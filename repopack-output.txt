================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-15T17:00:36.002Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    node.js.yml
controllers/
  partController.js
  sceneController.js
  scenePlayerController.js
  servoController.js
  soundController.js
data/
  characters.json
  parts.json
  scenes.json
  sounds.json
public/
  css/
    style.css
  stream/
    playlist.m3u8
    stream.m3u8
routes/
  activeModeRoutes.js
  characterRoutes.js
  ledRoutes.js
  lightRoutes.js
  linearActuatorRoutes.js
  partRoutes.js
  sceneRoutes.js
  sensorRoutes.js
  servoRoutes.js
  soundRoutes.js
scripts/
  active-mode.js
  audio_server.py
  audio.js
  camera.js
  led_control.py
  light_control.py
  linear_actuator_control.py
  motor_control.py
  scene-player.js
  sensor_control.py
  servo_control.py
  sound_player.py
  test_sensor.py
services/
  characterService.js
  partService.js
  sceneService.js
  soundService.js
views/
  part-forms/
    led.ejs
    light.ejs
    linear-actuator.ejs
    motor-control.ejs
    motor.ejs
    sensor.ejs
    servo.ejs
  active-mode.ejs
  character-form.ejs
  characters.ejs
  error.ejs
  index.ejs
  os-test.ejs
  part-form.ejs
  parts.ejs
  scene-form.ejs
  scene-player.ejs
  scenes.ejs
  sound-form.ejs
  sounds.ejs
.gitignore
app.js
package.json
README.md

================================================================
Repository Files
================================================================

================
File: .github/workflows/node.js.yml
================
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs

name: Node.js CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x, 22.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/

    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    - run: npm ci
    - run: npm run build --if-present
    - run: npm test

================
File: controllers/partController.js
================
// File: controllers/partController.js

const { spawn } = require('child_process');
const path = require('path');

let runningProcesses = [];

function executePartAction(step, sendEvent) {
    return new Promise(async (resolve, reject) => {
        try {
            const part = await getPartById(step.part_id);
            if (!part) {
                throw new Error(`Part not found for ID: ${step.part_id}`);
            }

            let scriptPath;
            let args;

            switch (part.type) {
                case 'motor':
                case 'linear-actuator':
                    scriptPath = path.resolve(__dirname, '..', 'scripts', 'motor_control.py');
                    args = [step.direction, step.speed.toString(), step.duration.toString(), part.directionPin.toString(), part.pwmPin.toString()];
                    break;
                case 'led':
                case 'light':
                    scriptPath = path.resolve(__dirname, '..', 'scripts', 'light_control.py');
                    args = [part.gpioPin.toString(), step.state, step.duration.toString()];
                    if (part.type === 'led' && step.brightness) {
                        args.push(step.brightness.toString());
                    }
                    break;
                case 'servo':
                    scriptPath = path.resolve(__dirname, '..', 'scripts', 'servo_control.py');
                    args = [
                        part.gpioPin.toString(),
                        step.angle.toString(),
                        step.speed.toString(),
                        step.duration.toString(),
                        part.pwmFrequency.toString(),
                        part.dutyCycle.toString()
                    ];
                    break;
                default:
                    throw new Error(`Unsupported part type: ${part.type}`);
            }

            const process = spawn('python3', [scriptPath, ...args]);
            runningProcesses.push(process);

            process.stdout.on('data', (data) => {
                sendEvent({ message: `${part.type} output: ${data}` });
            });

            process.stderr.on('data', (data) => {
                sendEvent({ error: `${part.type} error: ${data}` });
            });

            process.on('close', (code) => {
                const index = runningProcesses.indexOf(process);
                if (index > -1) {
                    runningProcesses.splice(index, 1);
                }
                if (code === 0) {
                    sendEvent({ message: `${part.type} action completed: ${step.name}` });
                    resolve();
                } else {
                    reject(new Error(`${part.type} process exited with code ${code}`));
                }
            });
        } catch (error) {
            reject(error);
        }
    });
}

function stopAllParts() {
    runningProcesses.forEach(process => {
        if (process.kill) {
            process.kill('SIGKILL');
        }
    });
    runningProcesses = [];
    spawn('pkill', ['-9', 'python3']);
}

async function getPartById(partId) {
    // This is a placeholder. You should implement the actual logic to fetch the part from your data source.
    // For now, we'll return a mock part object.
    return {
        id: partId,
        type: 'led',
        gpioPin: 17,
        // Add other necessary properties based on your part schema
    };
}

module.exports = {
    executePartAction,
    stopAllParts
};

================
File: controllers/sceneController.js
================
// File: controllers/sceneController.js

const sceneService = require('../services/sceneService');
const characterService = require('../services/characterService');
const partService = require('../services/partService');
const soundService = require('../services/soundService');

const sceneController = {
    getAllScenes: async (req, res) => {
        try {
            const scenes = await sceneService.getAllScenes();
            const characters = await characterService.getAllCharacters();
            console.log('Retrieved scenes:', scenes);
            res.render('scenes', { title: 'All Scenes', scenes, characters });
        } catch (error) {
            console.error('Error getting all scenes:', error);
            res.status(500).json({ error: 'Failed to retrieve scenes', details: error.message });
        }
    },

    getSceneById: async (req, res) => {
        try {
            const sceneId = req.params.id;
            const scene = await sceneService.getSceneById(sceneId);
            const characters = await characterService.getAllCharacters();
            const sounds = await soundService.getAllSounds();
            const parts = await partService.getAllParts();
            if (scene) {
                res.render('scene-form', { 
                    title: 'Edit Scene', 
                    scene, 
                    action: `/scenes/${scene.id}`,
                    characters,
                    sounds,
                    parts
                });
            } else {
                res.status(404).json({ error: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error getting scene by ID:', error);
            res.status(500).json({ error: 'Failed to retrieve scene', details: error.message });
        }
    },

    newScene: async (req, res) => {
        try {
            const characters = await characterService.getAllCharacters();
            const sounds = await soundService.getAllSounds();
            const parts = await partService.getAllParts();
            
            res.render('scene-form', {
                title: 'New Scene',
                scene: {},
                action: '/scenes',
                characters,
                sounds,
                parts
            });
        } catch (error) {
            console.error('Error rendering new scene form:', error);
            res.status(500).json({ error: 'Failed to render new scene form', details: error.message });
        }
    },

    createScene: async (req, res) => {
        try {
            const newScene = await sceneService.createScene(req.body);
            res.redirect('/scenes');
        } catch (error) {
            console.error('Error creating new scene:', error);
            res.status(500).json({ error: 'Failed to create new scene', details: error.message });
        }
    },

    updateScene: async (req, res) => {
        try {
            const updatedScene = await sceneService.updateScene(req.params.id, req.body);
            if (updatedScene) {
                res.json({ success: true, message: 'Scene updated successfully', scene: updatedScene });
            } else {
                res.status(404).json({ error: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error updating scene:', error);
            res.status(500).json({ error: 'Failed to update scene', details: error.message });
        }
    },

    deleteScene: async (req, res) => {
        try {
            const result = await sceneService.deleteScene(req.params.id);
            if (result) {
                res.json({ success: true, message: 'Scene deleted successfully' });
            } else {
                res.status(404).json({ error: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error deleting scene:', error);
            res.status(500).json({ error: 'Failed to delete scene', details: error.message });
        }
    }
};

module.exports = sceneController;

================
File: controllers/scenePlayerController.js
================
// File: controllers/scenePlayerController.js

const sceneService = require('../services/sceneService');
const partService = require('../services/partService');
const soundService = require('../services/soundService');
const soundController = require('./soundController');
const partController = require('./partController');
const path = require('path');
const { spawn } = require('child_process');

let isExecuting = false;

const scenePlayerController = {
    getScenePlayer: async (req, res) => {
        try {
            const sceneId = req.params.id;
            const scene = await sceneService.getSceneById(sceneId);
            if (scene) {
                res.render('scene-player', { title: 'Scene Player', scene });
            } else {
                res.status(404).render('error', { title: 'Not Found', message: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error getting scene by ID:', error);
            res.status(500).render('error', { title: 'Error', message: 'Failed to retrieve scene', error });
        }
    },

    playScene: async (req, res) => {
        const sceneId = req.params.id;
        const startStep = parseInt(req.query.startStep) || 0;
        console.log(`Attempting to play scene with ID: ${sceneId} from step ${startStep}`);
        
        let scene;
        try {
            scene = await sceneService.getSceneById(sceneId);
            if (!scene) {
                return res.status(404).json({ error: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error fetching scene:', error);
            return res.status(500).json({ error: 'Failed to fetch scene' });
        }

        res.writeHead(200, {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
        });

        const sendEvent = (data) => {
            res.write(`data: ${JSON.stringify(data)}\n\n`);
        };

        soundController.startSoundPlayer();
        isExecuting = true;

        let concurrentSteps = [];
        for (let i = startStep; i < scene.steps.length && isExecuting; i++) {
            const step = scene.steps[i];
            concurrentSteps.push(step);

            if (!step.concurrent || i === scene.steps.length - 1) {
                sendEvent({ message: `Executing concurrent steps`, currentStep: i });
                try {
                    await Promise.all(concurrentSteps.map(s => executeStep(s, sendEvent)));
                } catch (error) {
                    console.error(`Error executing concurrent steps:`, error);
                    sendEvent({ error: `Failed to execute concurrent steps: ${error.message}` });
                }
                concurrentSteps = [];
            }
        }

        sendEvent({ message: 'Scene execution completed' });
        isExecuting = false;
        res.end();
    },

    stopScene: async (req, res) => {
        console.log('Stopping all steps and terminating processes');
        isExecuting = false;
        try {
            await soundController.stopAllSounds();
            await partController.stopAllParts();
            res.json({ message: 'All steps stopped and processes terminated' });
        } catch (error) {
            console.error('Error stopping all steps:', error);
            res.status(500).json({ error: 'Failed to stop all steps', details: error.message });
        }
    },

    stopAllScenes: async (req, res) => {
        console.log('Stopping all scenes and terminating processes');
        isExecuting = false;
        try {
            await soundController.stopAllSounds();
            await partController.stopAllParts();
            res.json({ message: 'All scenes stopped and processes terminated' });
        } catch (error) {
            console.error('Error stopping all scenes:', error);
            res.status(500).json({ error: 'Failed to stop all scenes', details: error.message });
        }
    }
};

async function executeStep(step, sendEvent) {
    if (!isExecuting) return;
    console.log('Executing step:', step);
    sendEvent({ message: `Starting execution of ${step.type} step: ${step.name}` });

    try {
        switch (step.type) {
            case 'sound':
                await executeSound(step, sendEvent);
                break;
            case 'motor':
            case 'linear-actuator':
            case 'led':
            case 'light':
            case 'servo':
                await partController.executePartAction(step, sendEvent);
                break;
            case 'sensor':
                await executeSensor(step, sendEvent);
                break;
            case 'pause':
                await executePause(step, sendEvent);
                break;
            default:
                throw new Error(`Unknown step type: ${step.type}`);
        }
        sendEvent({ message: `Completed execution of ${step.type} step: ${step.name}` });
    } catch (error) {
        console.error(`Error executing step:`, error);
        sendEvent({ error: `Failed to execute ${step.type} step: ${error.message}` });
    }
}

async function executeSound(step, sendEvent) {
    const sound = await soundService.getSoundById(step.sound_id);
    if (!sound) {
        throw new Error(`Sound not found for ID: ${step.sound_id}`);
    }
    await soundController.playSound(sound, sendEvent);
}

async function executeSensor(step, sendEvent) {
    const part = await partService.getPartById(step.part_id);
    if (!part) {
        throw new Error(`Sensor not found for ID: ${step.part_id}`);
    }

    return new Promise((resolve, reject) => {
        const scriptPath = path.resolve(__dirname, '..', 'scripts', 'sensor_control.py');
        const args = [part.gpioPin.toString(), step.timeout.toString()];
        const process = spawn('python3', [scriptPath, ...args]);

        process.stdout.on('data', (data) => {
            sendEvent({ message: `Sensor output: ${data}` });
        });

        process.stderr.on('data', (data) => {
            sendEvent({ error: `Sensor error: ${data}` });
        });

        process.on('close', (code) => {
            if (code === 0) {
                sendEvent({ message: `Sensor step completed: ${step.name}`, result: { detected: true } });
                resolve({ detected: true });
            } else if (code === 1) {
                sendEvent({ message: `Sensor step completed: ${step.name}`, result: { detected: false } });
                resolve({ detected: false });
            } else {
                reject(new Error(`Sensor process exited with code ${code}`));
            }
        });
    });
}

async function executePause(step, sendEvent) {
    return new Promise((resolve) => {
        sendEvent({ message: `Starting pause: ${step.duration}ms` });
        setTimeout(() => {
            sendEvent({ message: `Pause completed: ${step.duration}ms` });
            resolve();
        }, step.duration);
    });
}

module.exports = scenePlayerController;

================
File: controllers/servoController.js
================
const i2cBus = require('i2c-bus');
const Pca9685Driver = require("pca9685").Pca9685Driver;

let pwm;

try {
    const options = {
        i2c: i2cBus.openSync(1),
        address: 0x40,
        frequency: 50,
        debug: false
    };

    pwm = new Pca9685Driver(options, function(err) {
        if (err) {
            console.error("Error initializing PCA9685");
            throw err;
        }
        console.log("PCA9685 initialization done");
    });
} catch (error) {
    console.error('Failed to initialize PCA9685:', error.message);
    pwm = null;
}

const servoTypes = {
    DS3240MG: { minPulse: 500, maxPulse: 2500 },
    FS90R: { minPulse: 700, maxPulse: 2300, stopPulse: 1500 },
    MG90S: { minPulse: 600, maxPulse: 2400 },
    BILDA: { minPulse: 500, maxPulse: 2500 },
};

function angleToPulse(angle, minPulse, maxPulse) {
    return minPulse + (angle / 180) * (maxPulse - minPulse);
}

function pulseToSteps(pulse) {
    return Math.round((pulse * 4096) / 20000);
}

function fs90rAngleToPulse(angle) {
    if (angle === 90) return 1500;  // Stop
    if (angle < 90) return 1000 + (angle * 500 / 90);  // Clockwise
    return 1500 + ((angle - 90) * 500 / 90);  // Counterclockwise
}

exports.testServo = async (req, res) => {
    console.log('Testing servo - Body:', req.body);
    if (!pwm) {
        return res.status(500).json({ success: false, message: 'PCA9685 is not initialized' });
    }

    try {
        const { angle, channel, servoType } = req.body;
        
        let pulse;
        if (servoType === 'FS90R') {
            pulse = fs90rAngleToPulse(parseInt(angle));
        } else {
            const servoConfig = servoTypes[servoType];
            pulse = angleToPulse(parseInt(angle), servoConfig.minPulse, servoConfig.maxPulse);
        }
        
        const steps = pulseToSteps(pulse);
        
        console.log(`Angle: ${angle}, Pulse: ${pulse}, Steps: ${steps}`);

        pwm.setPulseRange(parseInt(channel), 0, steps, function(err) {
            if (err) {
                console.error('Error setting pulse range:', err);
                return res.status(500).json({ success: false, message: 'Error setting servo position', error: err.message });
            }
            res.json({ success: true, message: 'Servo test completed successfully' });
        });
    } catch (error) {
        console.error('Error testing servo:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the servo', error: error.message });
    }
};

exports.stopServo = async (req, res) => {
    console.log('Stopping servo - Body:', req.body);
    if (!pwm) {
        return res.status(500).json({ success: false, message: 'PCA9685 is not initialized' });
    }

    try {
        const { channel, servoType } = req.body;
        
        let stopPulse;
        if (servoType === 'FS90R') {
            stopPulse = 1500;  // Center position for continuous rotation servo
        } else {
            const servoConfig = servoTypes[servoType];
            stopPulse = (servoConfig.minPulse + servoConfig.maxPulse) / 2;  // Middle position for standard servo
        }
        
        const steps = pulseToSteps(stopPulse);
        
        console.log(`Stopping servo - Channel: ${channel}, Pulse: ${stopPulse}, Steps: ${steps}`);

        pwm.setPulseRange(parseInt(channel), 0, steps, function(err) {
            if (err) {
                console.error('Error stopping servo:', err);
                return res.status(500).json({ success: false, message: 'Error stopping servo', error: err.message });
            }
            res.json({ success: true, message: 'Servo stopped successfully' });
        });
    } catch (error) {
        console.error('Error stopping servo:', error);
        res.status(500).json({ success: false, message: 'An error occurred while stopping the servo', error: error.message });
    }
};

================
File: controllers/soundController.js
================
// File: controllers/soundController.js

const { spawn } = require('child_process');
const path = require('path');

let soundPlayerProcess = null;
let soundPlayerRetries = 0;
const MAX_SOUND_PLAYER_RETRIES = 3;

function startSoundPlayer() {
    if (!soundPlayerProcess) {
        const scriptPath = path.resolve(__dirname, '..', 'scripts', 'sound_player.py');
        soundPlayerProcess = spawn('python3', [scriptPath]);

        soundPlayerProcess.stdout.on('data', (data) => {
            console.log(`Sound player output: ${data}`);
        });

        soundPlayerProcess.stderr.on('data', (data) => {
            console.error(`Sound player error: ${data}`);
        });

        soundPlayerProcess.on('close', (code) => {
            console.log(`Sound player exited with code ${code}`);
            soundPlayerProcess = null;
            if (soundPlayerRetries < MAX_SOUND_PLAYER_RETRIES) {
                soundPlayerRetries++;
                console.log(`Retrying to start sound player (Attempt ${soundPlayerRetries})`);
                startSoundPlayer();
            } else {
                console.error('Max retries reached. Unable to start sound player.');
            }
        });
    }
}

function playSound(sound, sendEvent) {
    return new Promise((resolve, reject) => {
        if (!soundPlayerProcess) {
            startSoundPlayer();
        }

        if (!soundPlayerProcess) {
            reject(new Error('Sound player not available'));
            return;
        }

        const filePath = path.resolve(__dirname, '..', 'public', 'sounds', sound.filename);
        const command = `PLAY|${sound.id}|${filePath}\n`;
        soundPlayerProcess.stdin.write(command);

        sendEvent({ message: `Sound started: ${sound.name}` });

        const listener = (data) => {
            const output = data.toString().trim();
            try {
                const jsonOutput = JSON.parse(output);
                if (jsonOutput.status === 'finished' && jsonOutput.sound_id === sound.id.toString()) {
                    soundPlayerProcess.stdout.removeListener('data', listener);
                    sendEvent({ message: `Sound completed: ${sound.name}` });
                    resolve();
                }
            } catch (e) {
                // Not JSON or not relevant, ignore
            }
        };

        soundPlayerProcess.stdout.on('data', listener);
    });
}

function stopAllSounds() {
    return new Promise((resolve, reject) => {
        if (soundPlayerProcess) {
            soundPlayerProcess.stdin.write("STOP_ALL\n");
            soundPlayerProcess.kill('SIGINT');
            soundPlayerProcess = null;
            resolve();
        } else {
            resolve(); // No sound player running, consider it stopped
        }
    });
}

module.exports = {
    startSoundPlayer,
    playSound,
    stopAllSounds
};

================
File: data/characters.json
================
[
  {
    "id": 1,
    "char_name": "Baphomet Lives",
    "char_description": "the dark lord finally rises",
    "parts": [
      2,
      3,
      4,
      5,
      6,
      8
    ],
    "sounds": [
      1,
      2,
      3
    ],
    "image": "c56cc12bfac10df2663b4c71ab53a801"
  }
]

================
File: data/parts.json
================
[
  {
    "id": 1,
    "name": "Hand of Azuras",
    "type": "light",
    "characterId": 1,
    "gpioPin": 26
  },
  {
    "id": 2,
    "name": "asdasd",
    "type": "linear-actuator",
    "characterId": 1,
    "directionPin": 23,
    "pwmPin": 12,
    "maxExtension": 10000,
    "maxRetraction": 10000
  },
  {
    "id": 3,
    "name": "Baphomet's Eye",
    "type": "sensor",
    "characterId": 1,
    "sensorType": "motion",
    "gpioPin": 16,
    "active": true
  },
  {
    "id": 4,
    "name": "GreenEye",
    "type": "led",
    "characterId": 1,
    "gpioPin": 17
  },
  {
    "id": 6,
    "name": "rwaraa",
    "type": "linear-actuator",
    "characterId": 1,
    "directionPin": 18,
    "pwmPin": 13,
    "maxExtension": null,
    "maxRetraction": null
  }
]

================
File: data/scenes.json
================
[
  {
    "id": 1,
    "character_id": 1,
    "scene_name": "Awaken",
    "steps": [
      {
        "type": "sensor",
        "name": "Watching you",
        "part_id": "5",
        "timeout": "30"
      },
      {
        "type": "led",
        "name": "Awaken Eyes",
        "part_id": "4",
        "duration": "4000",
        "state": "on",
        "brightness": "100"
      },
      {
        "type": "sound",
        "name": "Good evening buddy!",
        "sound_id": "1"
      }
    ]
  }
]

================
File: data/sounds.json
================
[
  {
    "id": 1,
    "name": "Good Evening2!",
    "filename": "1724882301591.mp3"
  },
  {
    "id": 2,
    "name": "Wind and Rain",
    "filename": "1724882315375.mp3"
  },
  {
    "id": 3,
    "name": "Santos Dominus ",
    "filename": "1724882328571.mp3"
  }
]

================
File: public/css/style.css
================
/* File: public/css/style.css */

body {
    font-family: 'Courier New', Courier, monospace;
    line-height: 1.6;
    margin: 0;
    padding: 20px;
    background-color: #000000;
    color: #00ff00;
}

h1, h2, h3, h4, h5, h6 {
    color: #00ff00;
    text-shadow: 0 0 5px #00ff00;
}

a {
    color: #00ffff;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
    text-shadow: 0 0 5px #00ffff;
}

.button {
    display: inline-block;
    background-color: #003300;
    color: #00ff00;
    padding: 10px 15px;
    border: 1px solid #00ff00;
    border-radius: 5px;
    cursor: pointer;
    text-decoration: none;
    margin: 10px 0;
}

.button:hover {
    background-color: #004400;
    text-decoration: none;
    box-shadow: 0 0 10px #00ff00;
}

form {
    background-color: #001100;
    padding: 20px;
    border-radius: 5px;
    border: 1px solid #00ff00;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
}

form div {
    margin-bottom: 15px;
}

label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

input[type="text"],
input[type="number"],
textarea,
select {
    width: 100%;
    padding: 8px;
    border: 1px solid #00ff00;
    border-radius: 4px;
    background-color: #000000;
    color: #00ff00;
    box-sizing: border-box;
}

button {
    background-color: #003300;
    color: #00ff00;
    padding: 10px 15px;
    border: 1px solid #00ff00;
    border-radius: 5px;
    cursor: pointer;
}

button:hover {
    background-color: #004400;
    box-shadow: 0 0 10px #00ff00;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    background-color: #001100;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
}

table, th, td {
    border: 1px solid #00ff00;
}

th, td {
    padding: 12px;
    text-align: left;
}

th {
    background-color: #002200;
    font-weight: bold;
}

tr:nth-child(even) {
    background-color: #001800;
}

#parts-container, #sounds-container {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
}

#available-parts, #selected-parts, #available-sounds, #selected-sounds {
    width: 40%;
}

#available-parts select, #selected-parts select, #available-sounds select, #selected-sounds select {
    width: 100%;
    height: 200px;
    background-color: #001100;
    color: #00ff00;
    border: 1px solid #00ff00;
}

#parts-container > div:nth-child(2), #sounds-container > div:nth-child(2) {
    display: flex;
    flex-direction: column;
    justify-content: center;
}

#parts-container button, #sounds-container button {
    margin: 5px;
}

input[type="file"] {
    background-color: #001100;
    color: #00ff00;
    border: 1px solid #00ff00;
    padding: 5px;
    border-radius: 4px;
}

option {
    background-color: #001100;
    color: #00ff00;
}

input:focus, textarea:focus, select:focus {
    outline: none;
    box-shadow: 0 0 5px #00ff00;
}

#cameraStream {
    width: 50%;
    max-width: 640px;
    aspect-ratio: 16 / 9;
    background-color: #000;
    margin-bottom: 20px;
}

.camera-controls {
    margin-top: 10px;
    margin-bottom: 20px;
}

.camera-controls button,
.camera-controls label,
.camera-controls select {
    margin-right: 10px;
}

.monitoring-section {
    margin-bottom: 20px;
}

#armStatus {
    font-weight: bold;
}

#armStatus.armed {
    color: #ff0000;
}

#armStatus.disarmed {
    color: #00ff00;
}

.character-section {
    display: flex;
    align-items: flex-start;
    margin-bottom: 20px;
}

.character-image {
    width: 250px;
    height: 250px;
    object-fit: cover;
    margin-right: 20px;
    border: 1px solid #0f0;
}

.character-info {
    flex-grow: 1;
}

.scene-container {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
}

.scene-box {
    width: 45%;
    border: 1px solid #0f0;
    padding: 10px;
}

.scene-controls {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

#availableScenes, #activatedScenes {
    width: 100%;
    height: 200px;
    overflow-y: auto;
    border: 1px solid #0f0;
    background-color: #001100;
    color: #0f0;
    padding: 5px;
}

#activatedScenes {
    list-style-type: none;
    margin: 0;
    padding: 5px;
}

.output-section {
    width: 100%;
    height: 300px;
    overflow-y: scroll;
    border: 1px solid #0f0;
    padding: 10px;
    background-color: #001100;
    margin-bottom: 20px;
}

================
File: public/stream/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:2
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:1.666667,
playlist0.ts
#EXT-X-ENDLIST

================
File: public/stream/stream.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:12
#EXT-X-MEDIA-SEQUENCE:28
#EXTINF:12.500000,
stream28.ts
#EXTINF:9.800000,
stream29.ts
#EXT-X-ENDLIST

================
File: routes/activeModeRoutes.js
================
const express = require('express');
const router = express.Router();
const characterService = require('../services/characterService');
const sceneService = require('../services/sceneService');

router.get('/', async (req, res) => {
    try {
        const characters = await characterService.getAllCharacters();
        res.render('active-mode', { 
            title: 'Active Mode',
            characters: characters
        });
    } catch (error) {
        console.error('Error fetching data for Active Mode:', error);
        res.status(500).send('An error occurred while loading Active Mode');
    }
});

router.get('/character/:id', async (req, res) => {
    try {
        const characterId = parseInt(req.params.id);
        const character = await characterService.getCharacterById(characterId);
        if (character) {
            res.json(character);
        } else {
            res.status(404).json({ error: 'Character not found' });
        }
    } catch (error) {
        console.error('Error fetching character:', error);
        res.status(500).json({ error: 'An error occurred while fetching the character' });
    }
});

router.get('/character/:id/scenes', async (req, res) => {
    try {
        const characterId = parseInt(req.params.id);
        const scenes = await sceneService.getScenesByCharacterId(characterId);
        res.json(scenes);
    } catch (error) {
        console.error('Error fetching scenes for character:', error);
        res.status(500).json({ error: 'An error occurred while fetching scenes' });
    }
});

module.exports = router;

================
File: routes/characterRoutes.js
================
const express = require('express');
const router = express.Router();
const characterService = require('../services/characterService');
const partService = require('../services/partService');
const soundService = require('../services/soundService');
const fs = require('fs').promises;
const path = require('path');
const multer = require('multer');

const upload = multer({
    dest: path.join(__dirname, '../public/images/characters')
});

router.get('/', async (req, res) => {
    try {
        const characters = await characterService.getAllCharacters();
        const parts = await partService.getAllParts();
        const sounds = await soundService.getAllSounds();
        res.render('characters', { title: 'Characters', characters, parts, sounds });
    } catch (error) {
        console.error('Error fetching characters:', error);
        res.status(500).send('An error occurred while fetching characters');
    }
});

router.get('/new', async (req, res) => {
    try {
        const parts = await partService.getAllParts();
        const sounds = await soundService.getAllSounds();
        res.render('character-form', { title: 'Add New Character', action: '/characters', character: {}, parts, sounds });
    } catch (error) {
        console.error('Error rendering new character form:', error);
        res.status(500).send('An error occurred while loading the new character form');
    }
});

router.get('/:id/edit', async (req, res) => {
    try {
        const character = await characterService.getCharacterById(parseInt(req.params.id));
        const parts = await partService.getAllParts();
        const sounds = await soundService.getAllSounds();
        if (character) {
            res.render('character-form', { title: 'Edit Character', action: `/characters/${character.id}`, character, parts, sounds });
        } else {
            res.status(404).send('Character not found');
        }
    } catch (error) {
        console.error('Error fetching character:', error);
        res.status(500).send('An error occurred while fetching the character');
    }
});

router.post('/', upload.single('character_image'), async (req, res) => {
    try {
        const newCharacter = {
            char_name: req.body.char_name,
            char_description: req.body.char_description,
            parts: req.body.parts ? req.body.parts.map(Number) : [],
            sounds: req.body.sounds ? req.body.sounds.map(Number) : [],
            image: req.file ? req.file.filename : null
        };
        await characterService.createCharacter(newCharacter);
        res.redirect('/characters');
    } catch (error) {
        console.error('Error creating character:', error);
        res.status(500).send('An error occurred while creating the character');
    }
});

router.post('/:id', upload.single('character_image'), async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const updatedCharacter = {
            char_name: req.body.char_name,
            char_description: req.body.char_description,
            parts: req.body.parts ? req.body.parts.map(Number) : [],
            sounds: req.body.sounds ? req.body.sounds.map(Number) : []
        };
        if (req.file) {
            const character = await characterService.getCharacterById(id);
            if (character.image) {
                const oldImagePath = path.join(__dirname, '../public/images/characters', character.image);
                await fs.unlink(oldImagePath).catch(console.error);
            }
            updatedCharacter.image = req.file.filename;
        }
        await characterService.updateCharacter(id, updatedCharacter);
        res.redirect('/characters');
    } catch (error) {
        console.error('Error updating character:', error);
        res.status(500).send('An error occurred while updating the character');
    }
});

router.post('/:id/delete', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const character = await characterService.getCharacterById(id);
        if (character.image) {
            const imagePath = path.join(__dirname, '../public/images/characters', character.image);
            await fs.unlink(imagePath).catch(console.error);
        }
        await characterService.deleteCharacter(id);
        res.sendStatus(200);
    } catch (error) {
        console.error('Error deleting character:', error);
        res.status(500).send('An error occurred while deleting the character');
    }
});

router.get('/:id/parts', async (req, res) => {
    try {
        const characterId = parseInt(req.params.id);
        const character = await characterService.getCharacterById(characterId);
        
        if (!character) {
            return res.status(404).json({ error: 'Character not found' });
        }

        const allParts = await partService.getAllParts();
        const characterParts = allParts.filter(part => character.parts.includes(part.id));

        res.json(characterParts);
    } catch (error) {
        console.error('Error in GET /characters/:id/parts route:', error);
        res.status(500).json({ error: 'An error occurred while fetching character parts' });
    }
});

module.exports = router;

================
File: routes/ledRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id, 10);
        console.log('Editing LED with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const part = await partService.getPartById(id);
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/led', { title: 'Edit LED', action: `/parts/led/${part.id}`, part, characters });
    } catch (error) {
        console.error('Error fetching LED:', error);
        res.status(500).send('An error occurred while fetching the LED: ' + error.message);
    }
});

router.post('/', async (req, res) => {
    try {
        const newLed = {
            name: req.body.name,
            type: 'led',
            characterId: parseInt(req.body.characterId, 10),
            gpioPin: parseInt(req.body.gpioPin, 10) || 26
        };
        const createdLed = await partService.createPart(newLed);
        console.log('Created LED:', createdLed);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating LED:', error);
        res.status(500).send('An error occurred while creating the LED: ' + error.message);
    }
});

router.post('/test', async (req, res) => {
    try {
        console.log('LED Test Route - Request body:', req.body);
        const { gpioPin, brightness, duration } = req.body;
        const scriptPath = path.join(__dirname, '..', 'scripts', 'led_control.py');
        console.log('LED test script path:', scriptPath);
        const process = spawn('python3', [
            scriptPath,
            gpioPin.toString(),
            'on',
            duration.toString(),
            brightness.toString()
        ]);

        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log(`Python script output: ${data}`);
        });

        process.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error(`Python script error: ${data}`);
        });

        process.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            if (code === 0) {
                res.json({ success: true, message: 'LED test completed successfully', output: stdout });
            } else {
                res.status(500).json({ success: false, message: 'LED test failed', error: stderr });
            }
        });
    } catch (error) {
        console.error('Error testing LED:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the LED', error: error.message });
    }
});

router.post('/:id', async (req, res) => {
    try {
        console.log('Update LED Route - Request params:', req.params);
        console.log('Update LED Route - Request body:', req.body);

        const id = parseInt(req.params.id, 10);
        console.log('Updating LED with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const updatedLed = {
            id: id,
            name: req.body.name,
            type: 'led',
            characterId: parseInt(req.body.characterId, 10),
            gpioPin: parseInt(req.body.gpioPin, 10) || 26
        };
        console.log('Updated LED data:', updatedLed);
        const result = await partService.updatePart(id, updatedLed);
        console.log('Updated LED:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating LED:', error);
        res.status(500).send('An error occurred while updating the LED: ' + error.message);
    }
});

module.exports = router;

================
File: routes/lightRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id, 10);
        console.log('Editing Light with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const part = await partService.getPartById(id);
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/light', { title: 'Edit Light', action: `/parts/light/${part.id}`, part, characters });
    } catch (error) {
        console.error('Error fetching light:', error);
        res.status(500).send('An error occurred while fetching the light: ' + error.message);
    }
});

router.post('/', async (req, res) => {
    try {
        const newLight = {
            name: req.body.name,
            type: 'light',
            characterId: parseInt(req.body.characterId, 10),
            gpioPin: parseInt(req.body.gpioPin, 10) || 26
        };
        const createdLight = await partService.createPart(newLight);
        console.log('Created light:', createdLight);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating light:', error);
        res.status(500).send('An error occurred while creating the light: ' + error.message);
    }
});

router.post('/test', async (req, res) => {
    try {
        console.log('Light Test Route - Request body:', req.body);
        const { gpioPin, state, duration } = req.body;
        const scriptPath = path.join(__dirname, '..', 'scripts', 'light_control.py');
        console.log('Light test script path:', scriptPath);
        const process = spawn('python3', [
            scriptPath,
            gpioPin.toString(),
            state,
            duration.toString()
        ]);

        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log(`Python script output: ${data}`);
        });

        process.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error(`Python script error: ${data}`);
        });

        process.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            if (code === 0) {
                res.json({ success: true, message: 'Light test completed successfully', output: stdout });
            } else {
                res.status(500).json({ success: false, message: 'Light test failed', error: stderr });
            }
        });
    } catch (error) {
        console.error('Error testing light:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the light', error: error.message });
    }
});

router.post('/:id', async (req, res) => {
    try {
        console.log('Update Light Route - Request params:', req.params);
        console.log('Update Light Route - Request body:', req.body);

        const id = parseInt(req.params.id, 10);
        console.log('Updating Light with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const updatedLight = {
            id: id,
            name: req.body.name,
            type: 'light',
            characterId: parseInt(req.body.characterId, 10),
            gpioPin: parseInt(req.body.gpioPin, 10) || 26
        };
        console.log('Updated Light data:', updatedLight);
        const result = await partService.updatePart(id, updatedLight);
        console.log('Updated light:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating light:', error);
        res.status(500).send('An error occurred while updating the light: ' + error.message);
    }
});

module.exports = router;

================
File: routes/linearActuatorRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/new', async (req, res) => {
    try {
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/linear-actuator', { 
            title: 'New Linear Actuator', 
            action: '/parts/linear-actuator', 
            part: {}, 
            characters 
        });
    } catch (error) {
        console.error('Error rendering new linear actuator form:', error);
        res.status(500).send('An error occurred while loading the new linear actuator form');
    }
});

router.post('/', async (req, res) => {
    try {
        const newActuator = {
            name: req.body.name,
            type: 'linear-actuator',
            characterId: parseInt(req.body.characterId),
            directionPin: parseInt(req.body.directionPin) || 18,
            pwmPin: parseInt(req.body.pwmPin) || 13,
            maxExtension: parseInt(req.body.maxExtension) || 10000,
            maxRetraction: parseInt(req.body.maxRetraction) || 10000
        };
        const createdActuator = await partService.createPart(newActuator);
        console.log('Created linear actuator:', createdActuator);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating linear actuator:', error);
        res.status(500).send('An error occurred while creating the linear actuator: ' + error.message);
    }
});

router.post('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        console.log('Updating linear actuator - Request body:', req.body);
        const updatedActuator = {
            id: id,
            name: req.body.name,
            type: 'linear-actuator',
            characterId: parseInt(req.body.characterId),
            directionPin: parseInt(req.body.directionPin),
            pwmPin: parseInt(req.body.pwmPin),
            maxExtension: parseInt(req.body.maxExtension),
            maxRetraction: parseInt(req.body.maxRetraction)
        };
        console.log('Updating linear actuator with data:', updatedActuator);
        const result = await partService.updatePart(id, updatedActuator);
        console.log('Updated linear actuator:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating linear actuator:', error);
        res.status(500).send('An error occurred while updating the linear actuator: ' + error.message);
    }
});

router.post('/test', async (req, res) => {
    try {
        console.log('Received test request:', req.body);
        const { direction, speed, duration, directionPin, pwmPin, maxExtension, maxRetraction } = req.body;
        const scriptPath = path.join(__dirname, '..', 'scripts', 'linear_actuator_control.py');
        
        console.log('Executing script with parameters:', { direction, speed, duration, directionPin, pwmPin, maxExtension, maxRetraction });
        
        const process = spawn('python3', [
            scriptPath,
            direction,
            speed.toString(),
            duration.toString(),
            directionPin.toString(),
            pwmPin.toString(),
            (maxExtension || '10000').toString(),
            (maxRetraction || '10000').toString()
        ]);

        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log(`Python script output: ${data}`);
        });

        process.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error(`Python script error: ${data}`);
        });

        process.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            if (code === 0) {
                res.json({ success: true, message: 'Linear actuator test completed successfully', output: stdout });
            } else {
                res.status(500).json({ success: false, message: 'Linear actuator test failed', error: stderr });
            }
        });
    } catch (error) {
        console.error('Error testing linear actuator:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the linear actuator', error: error.message });
    }
});

module.exports = router;

================
File: routes/partRoutes.js
================
// File: routes/partRoutes.js

const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/', async (req, res) => {
    try {
        const parts = await partService.getAllParts();
        const characters = await characterService.getAllCharacters();
        res.render('parts', { title: 'Parts', parts, characters });
    } catch (error) {
        console.error('Error fetching parts:', error);
        res.status(500).send('An error occurred while fetching parts');
    }
});

router.get('/new/:type', async (req, res) => {
    try {
        const { type } = req.params;
        const characters = await characterService.getAllCharacters();
        res.render(`part-forms/${type}`, { 
            title: `Add ${type.charAt(0).toUpperCase() + type.slice(1)}`, 
            action: `/parts/${type}`, 
            part: {}, 
            characters 
        });
    } catch (error) {
        console.error('Error rendering new part form:', error);
        res.status(500).send('An error occurred while loading the new part form');
    }
});

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const part = await partService.getPartById(id);
        const characters = await characterService.getAllCharacters();
        res.render(`part-forms/${part.type}`, {
            title: `Edit ${part.type.charAt(0).toUpperCase() + part.type.slice(1)}`,
            action: `/parts/${part.type}/${part.id}`,
            part,
            characters
        });
    } catch (error) {
        console.error('Error fetching part for edit:', error);
        res.status(500).send('An error occurred while fetching the part');
    }
});

router.get('/all', async (req, res) => {
    try {
        const parts = await partService.getAllParts();
        res.json(parts);
    } catch (error) {
        console.error('Error fetching all parts:', error);
        res.status(500).json({ error: 'An error occurred while fetching parts' });
    }
});

router.get('/os-test', async (req, res) => {
    res.render('os-test', { title: 'OS Test' });
});

router.post('/os-test', async (req, res) => {
    const { partId, command } = req.body;

    try {
        const part = await partService.getPartById(partId);
        let scriptPath;
        if (part.type === 'linear-actuator') {
            scriptPath = path.join(__dirname, '..', 'scripts', 'linear_actuator_control.py');
        } else {
            scriptPath = path.join(__dirname, '..', 'scripts', `${part.type}_control.py`);
        }
        
        const process = spawn('python3', [scriptPath, ...command.split(' ').slice(2)]);

        let output = '';
        let error = '';

        process.stdout.on('data', (data) => {
            output += data.toString();
        });

        process.stderr.on('data', (data) => {
            error += data.toString();
        });

        process.on('close', (code) => {
            res.json({ output: output || error, exitCode: code });
        });
    } catch (error) {
        console.error('Error running OS test:', error);
        res.status(500).json({ error: 'An error occurred while running the OS test' });
    }
});

router.get('/os-test-stream', (req, res) => {
    const { command } = req.query;
    
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive'
    });

    const process = spawn('python3', command.split(' ').slice(1));

    process.stdout.on('data', (data) => {
        res.write(`data: ${JSON.stringify({output: data.toString()})}\n\n`);
    });

    process.stderr.on('data', (data) => {
        res.write(`data: ${JSON.stringify({output: `Error: ${data.toString()}`})}\n\n`);
    });

    process.on('close', (code) => {
        res.write(`data: ${JSON.stringify({done: true})}\n\n`);
        res.end();
    });
});

router.post('/:id/delete', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        await partService.deletePart(id);
        res.status(200).json({ message: 'Part deleted successfully' });
    } catch (error) {
        console.error('Error deleting part:', error);
        res.status(500).json({ error: 'An error occurred while deleting the part' });
    }
});

router.post('/linear-actuator/test', async (req, res) => {
    try {
        const { direction, speed, duration, directionPin, pwmPin } = req.body;
        const scriptPath = path.join(__dirname, '..', 'scripts', 'linear_actuator_control.py');
        const process = spawn('python3', [
            scriptPath,
            direction,
            speed.toString(),
            duration.toString(),
            directionPin.toString(),
            pwmPin.toString()
        ]);

        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log(`Python script output: ${data}`);
        });

        process.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error(`Python script error: ${data}`);
        });

        process.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            if (code === 0) {
                res.json({ success: true, message: 'Linear actuator test completed successfully', output: stdout });
            } else {
                res.status(500).json({ success: false, message: 'Linear actuator test failed', error: stderr });
            }
        });
    } catch (error) {
        console.error('Error testing linear actuator:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the linear actuator', error: error.message });
    }
});

module.exports = router;

================
File: routes/sceneRoutes.js
================
// File: routes/sceneRoutes.js

const express = require('express');
const router = express.Router();
const sceneController = require('../controllers/sceneController');
const scenePlayerController = require('../controllers/scenePlayerController');

router.get('/', sceneController.getAllScenes);
router.get('/new', sceneController.newScene);
router.get('/:id', scenePlayerController.getScenePlayer);
router.get('/:id/edit', sceneController.getSceneById);
router.post('/', sceneController.createScene);
router.post('/:id', sceneController.updateScene);
router.delete('/:id', sceneController.deleteScene);
router.get('/:id/play', scenePlayerController.playScene);
router.post('/:id/stop', scenePlayerController.stopScene);
router.post('/stop-all', scenePlayerController.stopAllScenes);

module.exports = router;

================
File: routes/sensorRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const part = await partService.getPartById(id);
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/sensor', { title: 'Edit Sensor', action: `/parts/sensor/${part.id}`, part, characters });
    } catch (error) {
        console.error('Error fetching sensor:', error);
        res.status(500).send('An error occurred while fetching the sensor: ' + error.message);
    }
});

router.post('/', async (req, res) => {
    try {
        const newSensor = {
            name: req.body.name,
            type: 'sensor',
            characterId: parseInt(req.body.characterId),
            sensorType: req.body.sensorType,
            gpioPin: parseInt(req.body.gpioPin) || 16,
            active: req.body.active === 'on'
        };
        const createdSensor = await partService.createPart(newSensor);
        console.log('Created sensor:', createdSensor);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating sensor:', error);
        res.status(500).send('An error occurred while creating the sensor: ' + error.message);
    }
});

router.post('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const updatedSensor = {
            id: id,
            name: req.body.name,
            type: 'sensor',
            characterId: parseInt(req.body.characterId),
            sensorType: req.body.sensorType,
            gpioPin: parseInt(req.body.gpioPin) || 16,
            active: req.body.active === 'on'
        };
        const result = await partService.updatePart(id, updatedSensor);
        console.log('Updated sensor:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating sensor:', error);
        res.status(500).send('An error occurred while updating the sensor: ' + error.message);
    }
});

router.get('/test-sensor', async (req, res) => {
    try {
        const sensorId = parseInt(req.query.id);
        const gpioPin = parseInt(req.query.gpioPin);

        if (isNaN(sensorId) || isNaN(gpioPin)) {
            throw new Error('Invalid sensor ID or GPIO pin');
        }

        const scriptPath = path.join(__dirname, '..', 'scripts', 'test_sensor.py');

        res.writeHead(200, {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
        });

        const python = spawn('sudo', ['python3', scriptPath, gpioPin.toString()]);

        python.stdout.on('data', (data) => {
            res.write(`data: ${data}\n\n`);
        });

        python.stderr.on('data', (data) => {
            console.error(`Python script error: ${data}`);
            res.write(`data: ${JSON.stringify({ error: data.toString() })}\n\n`);
        });

        python.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
            res.end();
        });

        req.on('close', () => {
            python.kill();
        });
    } catch (error) {
        console.error('Error testing sensor:', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

module.exports = router;

================
File: routes/servoRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const servoController = require('../controllers/servoController');

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id, 10);
        console.log('Editing Servo with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const part = await partService.getPartById(id);
        if (!part) {
            throw new Error('Part not found');
        }
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/servo', { title: 'Edit Servo', action: `/parts/servo/${part.id}`, part, characters });
    } catch (error) {
        console.error('Error fetching servo:', error);
        res.status(500).send('An error occurred while fetching the servo: ' + error.message);
    }
});

router.post('/', async (req, res) => {
    try {
        const newServo = {
            name: req.body.name,
            type: 'servo',
            characterId: parseInt(req.body.characterId, 10),
            servoType: req.body.servoType,
            channel: parseInt(req.body.channel, 10),
            minPulse: parseInt(req.body.minPulse, 10),
            maxPulse: parseInt(req.body.maxPulse, 10),
            defaultAngle: parseInt(req.body.defaultAngle, 10)
        };
        const createdServo = await partService.createPart(newServo);
        console.log('Created servo:', createdServo);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating servo:', error);
        res.status(500).send('An error occurred while creating the servo: ' + error.message);
    }
});

router.post('/test', servoController.testServo);

router.post('/stop', servoController.stopServo);

router.post('/:id', async (req, res) => {
    try {
        console.log('Update Servo Route - Request params:', req.params);
        console.log('Update Servo Route - Request body:', req.body);

        const id = parseInt(req.params.id, 10);
        console.log('Updating Servo with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const updatedServo = {
            id: id,
            name: req.body.name,
            type: 'servo',
            characterId: parseInt(req.body.characterId, 10),
            servoType: req.body.servoType,
            channel: parseInt(req.body.channel, 10),
            minPulse: parseInt(req.body.minPulse, 10),
            maxPulse: parseInt(req.body.maxPulse, 10),
            defaultAngle: parseInt(req.body.defaultAngle, 10)
        };
        console.log('Updated Servo data:', updatedServo);
        const result = await partService.updatePart(id, updatedServo);
        console.log('Updated servo:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating servo:', error);
        res.status(500).send('An error occurred while updating the servo: ' + error.message);
    }
});

module.exports = router;

================
File: routes/soundRoutes.js
================
// File: routes/soundRoutes.js

const express = require('express');
const path = require('path');
const { spawn } = require('child_process');
const soundService = require('../services/soundService');
const multer = require('multer');
const fs = require('fs').promises;
const router = express.Router();

// Multer setup for file uploads
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, 'public/sounds/');
    },
    filename: function (req, file, cb) {
        cb(null, Date.now() + path.extname(file.originalname));
    }
});
const upload = multer({ storage: storage });

let soundPlayerProcess = null;

function startSoundPlayer() {
    if (!soundPlayerProcess) {
        const scriptPath = path.resolve(__dirname, '..', 'scripts', 'sound_player.py');
        soundPlayerProcess = spawn('python3', [scriptPath]);

        soundPlayerProcess.stdout.on('data', (data) => {
            console.log(`Sound player output: ${data}`);
        });

        soundPlayerProcess.stderr.on('data', (data) => {
            console.error(`Sound player error: ${data}`);
        });

        soundPlayerProcess.on('close', (code) => {
            console.log(`Sound player exited with code ${code}`);
            soundPlayerProcess = null;
        });
    }
}

router.get('/', async (req, res) => {
    try {
        const sounds = await soundService.getAllSounds();
        res.render('sounds', { title: 'Sounds', sounds });
    } catch (error) {
        console.error('Error fetching sounds:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.get('/new', (req, res) => {
    res.render('sound-form', { title: 'Add New Sound', action: '/sounds', sound: null });
});

router.get('/:id/edit', async (req, res) => {
    try {
        const sound = await soundService.getSoundById(parseInt(req.params.id));
        if (sound) {
            res.render('sound-form', { title: 'Edit Sound', action: `/sounds/${sound.id}`, sound });
        } else {
            res.status(404).json({ error: 'Sound not found', details: `No sound with id ${req.params.id}` });
        }
    } catch (error) {
        console.error('Error fetching sound:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.post('/', upload.single('sound_file'), async (req, res) => {
    try {
        const newSound = {
            name: req.body.name,
            filename: req.file.filename
        };
        await soundService.createSound(newSound);
        res.redirect('/sounds');
    } catch (error) {
        console.error('Error adding sound:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.post('/:id', upload.single('sound_file'), async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const updatedSound = {
            name: req.body.name
        };
        
        if (req.file) {
            const sound = await soundService.getSoundById(id);
            if (sound.filename) {
                const oldFilePath = path.join(__dirname, '../public/sounds', sound.filename);
                await fs.unlink(oldFilePath).catch(console.error);
            }
            updatedSound.filename = req.file.filename;
        }

        await soundService.updateSound(id, updatedSound);
        res.redirect('/sounds');
    } catch (error) {
        console.error('Error updating sound:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.post('/:id/play', async (req, res) => {
    try {
        const soundId = parseInt(req.params.id);
        console.log('Received request to play sound with ID:', soundId);

        const sound = await soundService.getSoundById(soundId);
        
        if (!sound) {
            console.error('Sound not found for ID:', soundId);
            return res.status(404).json({ error: 'Sound not found', details: `No sound with id ${soundId}`, soundId });
        }

        console.log('Found sound:', sound);

        const filePath = path.resolve(__dirname, '..', 'public', 'sounds', sound.filename);
        console.log('Absolute file path:', filePath);

        try {
            await fs.access(filePath, fs.constants.R_OK);
            console.log('File exists and is readable:', filePath);
        } catch (error) {
            console.error('File access error:', error);
            return res.status(404).json({ error: 'Sound file not accessible', details: error.message, filePath });
        }

        startSoundPlayer();

        if (!soundPlayerProcess) {
            return res.status(500).json({ error: 'Failed to start sound player' });
        }

        const command = `PLAY|${sound.id}|${filePath}\n`;
        soundPlayerProcess.stdin.write(command);

        res.status(200).json({ 
            message: 'Playing sound on character',
            sound: sound.name,
            file: sound.filename
        });

    } catch (error) {
        console.error('Error in /play route:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.post('/:id/delete', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const sound = await soundService.getSoundById(id);
        if (sound.filename) {
            const filePath = path.join(__dirname, '../public/sounds', sound.filename);
            await fs.unlink(filePath).catch(console.error);
        }
        await soundService.deleteSound(id);
        res.status(200).json({ message: 'Sound deleted successfully' });
    } catch (error) {
        console.error('Error deleting sound:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

module.exports = router;

================
File: scripts/active-mode.js
================
// File: scripts/active-mode.js

$(document).ready(function() {
    let isArmed = false;
    let currentEventSource = null;

    $('#characterSelect').change(fetchCharacterInfo);
    $('#addScenes').click(addScenes);
    $('#removeScenes').click(removeScenes);
    $('#activatedScenes').sortable().selectable();
    $('#armButton').click(armSystem);
    $('#disarmButton').click(disarmSystem);
    $('#stopAllSteps').click(stopAllSteps);

    // Load the first character by default
    loadFirstCharacter();

    function loadFirstCharacter() {
        const firstCharacter = $('#characterSelect option:first');
        if (firstCharacter.length > 0) {
            $('#characterSelect').val(firstCharacter.val()).trigger('change');
        }
    }

    function fetchCharacterInfo() {
        const characterId = $(this).val();
        if (characterId) {
            $.get(`/active-mode/character/${characterId}`, displayCharacterInfo)
                .fail(handleCharacterInfoError);
            fetchScenes(characterId);
        } else {
            clearCharacterInfo();
        }
    }

    function displayCharacterInfo(character) {
        let infoHtml = `<h3>${character.char_name}</h3><p>${character.char_description}</p>`;
        $('#characterInfo').html(infoHtml);
        
        if (character.image) {
            $('#characterImage').attr('src', `/images/characters/${character.image}`).attr('alt', character.char_name);
        } else {
            $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
        }
    }

    function handleCharacterInfoError(jqXHR, textStatus, errorThrown) {
        console.error("Error fetching character info:", textStatus, errorThrown);
        $('#characterInfo').html('<p>Failed to load character information. Please try again.</p>');
        $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
    }

    function clearCharacterInfo() {
        $('#characterInfo').empty();
        $('#availableScenes').empty();
        $('#activatedScenes').empty();
        $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
    }

    function fetchScenes(characterId) {
        $.get(`/active-mode/character/${characterId}/scenes`, displayScenes)
            .fail(handleSceneFetchError);
    }

    function displayScenes(scenes) {
        $('#availableScenes').empty();
        scenes.forEach(function(scene) {
            $('#availableScenes').append(`<option value="${scene.id}">${scene.scene_name}</option>`);
        });
    }

    function handleSceneFetchError(jqXHR, textStatus, errorThrown) {
        console.error("Error fetching scenes:", textStatus, errorThrown);
        $('#availableScenes').html('<option>Failed to load scenes</option>');
    }

    function addScenes() {
        $('#availableScenes option:selected').each(function() {
            const sceneId = $(this).val();
            const sceneName = $(this).text();
            $('#activatedScenes').append(`<li data-id="${sceneId}">${sceneName}</li>`);
            $(this).remove();
        });
    }

    function removeScenes() {
        $('#activatedScenes li.ui-selected').each(function() {
            const sceneId = $(this).data('id');
            const sceneName = $(this).text();
            $('#availableScenes').append(`<option value="${sceneId}">${sceneName}</option>`);
            $(this).remove();
        });
    }

    function armSystem() {
        if ($('#activatedScenes li').length === 0) {
            alert('Please select at least one scene to activate.');
            return;
        }
        isArmed = true;
        $(this).prop('disabled', true);
        $('#disarmButton').prop('disabled', false);
        $('#armStatus').text('ARMED').removeClass('disarmed').addClass('armed');
        logArmedModeOutput('System armed. Starting Active Mode.');
        startActiveModeLoop();
    }

    function disarmSystem() {
        isArmed = false;
        $(this).prop('disabled', true);
        $('#armButton').prop('disabled', false);
        $('#armStatus').text('DISARMED').removeClass('armed').addClass('disarmed');
        logArmedModeOutput('System disarmed. Active Mode stopped.');
        stopAllSteps();
    }

    function stopAllSteps() {
        if (currentEventSource) {
            currentEventSource.close();
        }
        $.post('/scenes/stop-all')
            .done(function(response) {
                logArmedModeOutput('All steps stopped: ' + response.message);
            })
            .fail(function(xhr, status, error) {
                console.error('Error stopping all steps:', error);
                logArmedModeOutput('Error stopping all steps: ' + error);
            });
    }

    function startActiveModeLoop() {
        const scenes = $('#activatedScenes li').map(function() {
            return $(this).data('id');
        }).get();

        function runNextScene(index) {
            if (!isArmed) return;
            if (index >= scenes.length) {
                index = 0; // Reset to the beginning of the list
            }
            const sceneId = scenes[index];
            logArmedModeOutput(`Starting execution of scene ${sceneId}`);
            runScene(sceneId).then(() => {
                logArmedModeOutput(`Completed execution of scene ${sceneId}`);
                setTimeout(() => runNextScene(index + 1), 5000); // 5 seconds between scenes
            }).catch((error) => {
                logArmedModeOutput(`Error executing scene ${sceneId}: ${error.message}`);
                setTimeout(() => runNextScene(index + 1), 5000); // Continue to next scene even if there's an error
            });
        }

        runNextScene(0);
    }

    function runScene(sceneId) {
        return new Promise((resolve, reject) => {
            if (currentEventSource) {
                currentEventSource.close();
            }
            currentEventSource = new EventSource(`/scenes/${sceneId}/play`);

            currentEventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleSceneExecutionUpdate(data);
            };

            currentEventSource.onerror = function(error) {
                console.error('EventSource failed:', error);
                currentEventSource.close();
                reject(new Error(`Failed to execute scene ${sceneId}`));
            };

            currentEventSource.addEventListener('close', function(event) {
                currentEventSource.close();
                resolve();
            });
        });
    }

    function handleSceneExecutionUpdate(data) {
        if (data.error) {
            logArmedModeOutput(`Error: ${data.error}`);
        } else if (data.message) {
            logArmedModeOutput(data.message);
        }
    }

    function logArmedModeOutput(message) {
        const timestamp = new Date().toLocaleTimeString();
        $('#armedModeOutput').append(`<p>[${timestamp}] ${message}</p>`);
        $('#armedModeOutput').scrollTop($('#armedModeOutput')[0].scrollHeight);
    }
});

================
File: scripts/audio_server.py
================
# File: scripts/audio_server.py

from flask import Flask, request, jsonify
import pygame
import threading
import os

app = Flask(__name__)
pygame.mixer.init()

playing_sounds = {}

@app.route('/play', methods=['POST'])
def play_sound():
    data = request.json
    sound_id = data['sound_id']
    file_path = data['file_path']

    if sound_id in playing_sounds:
        playing_sounds[sound_id].stop()

    try:
        sound = pygame.mixer.Sound(file_path)
        channel = sound.play()
        playing_sounds[sound_id] = channel

        def wait_for_finish():
            while channel.get_busy():
                pygame.time.wait(100)
            if sound_id in playing_sounds:
                del playing_sounds[sound_id]

        threading.Thread(target=wait_for_finish).start()

        return jsonify({"status": "playing", "sound_id": sound_id, "file": file_path})
    except Exception as e:
        return jsonify({"status": "error", "sound_id": sound_id, "file": file_path, "error": str(e)}), 500

@app.route('/stop', methods=['POST'])
def stop_sound():
    data = request.json
    sound_id = data['sound_id']

    if sound_id in playing_sounds:
        playing_sounds[sound_id].stop()
        del playing_sounds[sound_id]
        return jsonify({"status": "stopped", "sound_id": sound_id})
    else:
        return jsonify({"status": "not_found", "sound_id": sound_id}), 404

if __name__ == '__main__':
    app.run(host='localhost', port=5000)

================
File: scripts/audio.js
================
// File: scripts/audio.js

const { spawn } = require('child_process');
const WebSocket = require('ws');
const path = require('path');

class Audio {
    constructor() {
        this.audioProcess = null;
        this.wss = null;
        this.retryCount = 0;
        this.maxRetries = 3;
    }

    startStream(server) {
        this.wss = new WebSocket.Server({ server, path: '/audiostream' });

        this.wss.on('connection', (ws) => {
            console.log('New WebSocket connection for audio stream');
            if (!this.audioProcess) {
                this.startAudioProcess(ws);
            }

            ws.on('close', () => {
                console.log('WebSocket connection closed for audio stream');
            });
        });

        console.log('Audio stream server started');
    }

    startAudioProcess(ws) {
        const scriptPath = path.join(__dirname, 'sound_player.py');
        this.audioProcess = spawn('python3', [scriptPath]);

        this.audioProcess.stdout.on('data', (data) => {
            console.log(`Sound player output: ${data}`);
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(data);
            }
        });

        this.audioProcess.stderr.on('data', (data) => {
            console.error(`Sound player error: ${data}`);
        });

        this.audioProcess.on('close', (code) => {
            console.log(`Sound player exited with code ${code}`);
            this.audioProcess = null;
            if (this.retryCount < this.maxRetries) {
                this.retryCount++;
                console.log(`Retrying to start sound player (Attempt ${this.retryCount})`);
                this.startAudioProcess(ws);
            } else {
                console.error('Max retries reached. Unable to start sound player.');
            }
        });

        this.audioProcess.on('error', (error) => {
            console.error(`Error starting audio stream: ${error}`);
        });
    }

    stopAudioProcess() {
        if (this.audioProcess) {
            this.audioProcess.kill();
            this.audioProcess = null;
        }
    }

    playSound(soundId, filePath) {
        if (this.audioProcess) {
            const command = `PLAY|${soundId}|${filePath}\n`;
            this.audioProcess.stdin.write(command);
        } else {
            console.error('Audio process is not running');
            this.startAudioProcess(this.wss.clients.values().next().value);
        }
    }

    stopSound(soundId) {
        if (this.audioProcess) {
            const command = `STOP|${soundId}\n`;
            this.audioProcess.stdin.write(command);
        } else {
            console.error('Audio process is not running');
        }
    }

    stopAllSounds() {
        if (this.audioProcess) {
            const command = `STOP_ALL\n`;
            this.audioProcess.stdin.write(command);
        } else {
            console.error('Audio process is not running');
        }
    }
}

module.exports = new Audio();

================
File: scripts/camera.js
================
const { exec } = require('child_process');

class Camera {
    constructor() {
        this.streamProcess = null;
        this.nightMode = false;
        this.resolution = '640x480';
        this.framerate = '15';
    }

    startStream() {
        this.findAvailableVideoDevice((device) => {
            if (device) {
                this.startStreamWithDevice(device);
            } else {
                console.error('No available video devices found');
            }
        });
    }

    findAvailableVideoDevice(callback) {
        exec('ls /dev/video*', (error, stdout, stderr) => {
            if (error) {
                console.error('Error finding video devices:', error);
                callback(null);
                return;
            }
            const devices = stdout.trim().split('\n');
            console.log('Available video devices:', devices);
            if (devices.length > 0) {
                callback(devices[0]);
            } else {
                callback(null);
            }
        });
    }

    startStreamWithDevice(device) {
        const mjpegStreamerCommand = `mjpg_streamer -i "input_uvc.so -d ${device} -r ${this.resolution} -f ${this.framerate}" -o "output_http.so -p 8080"`;
        exec(mjpegStreamerCommand, (error, stdout, stderr) => {
            if (error) {
                console.error(`Error starting mjpg-streamer with device ${device}: ${error}`);
                console.error(`stderr: ${stderr}`);
                return;
            }
            console.log(`mjpg-streamer started successfully with device ${device}`);
            console.log(`stdout: ${stdout}`);
        });
    }

    stopStream() {
        exec('pkill mjpg_streamer', (error, stdout, stderr) => {
            if (error) {
                console.error(`Error stopping mjpg-streamer: ${error}`);
                return;
            }
            console.log('mjpg-streamer stopped successfully');
        });
    }

    toggleNightMode() {
        this.nightMode = !this.nightMode;
        console.log(`Night mode: ${this.nightMode ? 'ON' : 'OFF'}`);
        // Implement night mode logic here if your camera supports it
    }

    restartStream() {
        this.stopStream();
        setTimeout(() => {
            this.startStream();
        }, 1000); // Wait for 1 second before restarting the stream
    }
}

module.exports = new Camera();

================
File: scripts/led_control.py
================
import RPi.GPIO as GPIO
import time
import sys

def setup_gpio():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)

def cleanup_gpio():
    GPIO.cleanup()

def control_light(gpio_pin, state, duration, brightness=None):
    setup_gpio()
    GPIO.setup(gpio_pin, GPIO.OUT)

    try:
        if brightness is not None:
            pwm = GPIO.PWM(gpio_pin, 100)  # 100 Hz frequency
            pwm.start(0)
            if state.lower() == 'on':
                pwm.ChangeDutyCycle(int(brightness))
                print(f"LED on GPIO pin {gpio_pin} is ON with brightness {brightness}%")
            else:
                pwm.ChangeDutyCycle(0)
                print(f"LED on GPIO pin {gpio_pin} is OFF")
        else:
            if state.lower() == 'on':
                GPIO.output(gpio_pin, GPIO.HIGH)
                print(f"Light on GPIO pin {gpio_pin} is ON")
            elif state.lower() == 'off':
                GPIO.output(gpio_pin, GPIO.LOW)
                print(f"Light on GPIO pin {gpio_pin} is OFF")
            else:
                print("Invalid state. Use 'on' or 'off'.")
                return

        time.sleep(float(duration) / 1000)  # Convert duration to seconds
    finally:
        if brightness is not None:
            pwm.stop()
        cleanup_gpio()

if __name__ == "__main__":
    if len(sys.argv) < 4 or len(sys.argv) > 5:
        print("Usage: python light_control.py <gpio_pin> <state> <duration> [brightness]")
        sys.exit(1)

    gpio_pin = int(sys.argv[1])
    state = sys.argv[2]
    duration = int(sys.argv[3])
    brightness = int(sys.argv[4]) if len(sys.argv) == 5 else None

    try:
        control_light(gpio_pin, state, duration, brightness)
        print("Light control completed successfully")
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)
    finally:
        cleanup_gpio()

================
File: scripts/light_control.py
================
import RPi.GPIO as GPIO
import time
import sys

def setup_gpio():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)

def cleanup_gpio():
    GPIO.cleanup()

def control_light(gpio_pin, state, duration, brightness=None):
    setup_gpio()
    GPIO.setup(gpio_pin, GPIO.OUT)

    try:
        if brightness is not None:
            pwm = GPIO.PWM(gpio_pin, 100)  # 100 Hz frequency
            pwm.start(0)
            if state.lower() == 'on':
                pwm.ChangeDutyCycle(int(brightness))
                print(f"LED on GPIO pin {gpio_pin} is ON with brightness {brightness}%")
            else:
                pwm.ChangeDutyCycle(0)
                print(f"LED on GPIO pin {gpio_pin} is OFF")
        else:
            if state.lower() == 'on':
                GPIO.output(gpio_pin, GPIO.HIGH)
                print(f"Light on GPIO pin {gpio_pin} is ON")
            elif state.lower() == 'off':
                GPIO.output(gpio_pin, GPIO.LOW)
                print(f"Light on GPIO pin {gpio_pin} is OFF")
            else:
                print("Invalid state. Use 'on' or 'off'.")
                return

        time.sleep(float(duration) / 1000)  # Convert duration to seconds
    finally:
        if brightness is not None:
            pwm.stop()
        cleanup_gpio()

if __name__ == "__main__":
    if len(sys.argv) < 4 or len(sys.argv) > 5:
        print("Usage: python light_control.py <gpio_pin> <state> <duration> [brightness]")
        sys.exit(1)

    gpio_pin = int(sys.argv[1])
    state = sys.argv[2]
    duration = int(sys.argv[3])
    brightness = int(sys.argv[4]) if len(sys.argv) == 5 else None

    try:
        control_light(gpio_pin, state, duration, brightness)
        print("Light control completed successfully")
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)
    finally:
        cleanup_gpio()

================
File: scripts/linear_actuator_control.py
================
import RPi.GPIO as GPIO
import time
import sys

def setup_gpio(dir_pin, pwm_pin):
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(dir_pin, GPIO.OUT)
    GPIO.setup(pwm_pin, GPIO.OUT)
    return GPIO.PWM(pwm_pin, 100)  # 100Hz frequency

def control_actuator(direction, speed, duration, dir_pin, pwm_pin, max_extension, max_retraction):
    pwm = None
    try:
        pwm = setup_gpio(dir_pin, pwm_pin)
        
        GPIO.output(dir_pin, GPIO.LOW if direction == 'forward' else GPIO.HIGH)
        pwm.start(float(speed))
        
        # Calculate the actual duration based on direction and limits
        if direction == 'forward':
            actual_duration = min(int(duration), int(max_extension))
        else:
            actual_duration = min(int(duration), int(max_retraction))
        
        print(f"Moving actuator {direction} for {actual_duration}ms")
        time.sleep(actual_duration / 1000)  # Convert duration to seconds
    except Exception as e:
        print(f"Error during actuator control: {str(e)}")
    finally:
        if pwm:
            pwm.stop()
        GPIO.cleanup([dir_pin, pwm_pin])

if __name__ == "__main__":
    if len(sys.argv) < 8:
        print("Usage: python3 linear_actuator_control.py <direction> <speed> <duration> <dir_pin> <pwm_pin> <max_extension> <max_retraction>")
        sys.exit(1)

    try:
        direction = sys.argv[1]
        speed = sys.argv[2]
        duration = sys.argv[3]
        dir_pin = int(sys.argv[4])
        pwm_pin = int(sys.argv[5])
        max_extension = sys.argv[6]
        max_retraction = sys.argv[7]

        control_actuator(direction, speed, duration, dir_pin, pwm_pin, max_extension, max_retraction)
        print("Linear actuator control completed successfully")
        sys.exit(0)
    except Exception as e:
        print(f"Error controlling linear actuator: {str(e)}")
        sys.exit(1)

================
File: scripts/motor_control.py
================
import RPi.GPIO as GPIO
import sys
import time
import logging

# Set up logging
logging.basicConfig(filename='motor_control.log', level=logging.DEBUG, 
                    format='%(asctime)s - %(levelname)s - %(message)s')

def control_motor(direction, speed, duration, dir_pin, pwm_pin):
    logging.info(f"Controlling motor: direction={direction}, speed={speed}, duration={duration}, dir_pin={dir_pin}, pwm_pin={pwm_pin}")

    GPIO.setmode(GPIO.BCM)
    GPIO.setup(dir_pin, GPIO.OUT)
    GPIO.setup(pwm_pin, GPIO.OUT)

    pwm = GPIO.PWM(pwm_pin, 100)  # Use a default frequency of 100 Hz
    pwm.start(0)

    try:
        GPIO.output(dir_pin, GPIO.HIGH if direction == 'forward' else GPIO.LOW)
        pwm.ChangeDutyCycle(int(speed))
        time.sleep(int(duration) / 1000)  # Convert duration to seconds
        pwm.ChangeDutyCycle(0)
    except Exception as e:
        logging.error(f"Error controlling motor: {str(e)}")
        raise
    finally:
        pwm.stop()
        GPIO.cleanup([dir_pin, pwm_pin])

if __name__ == "__main__":
    if len(sys.argv) != 6:
        logging.error("Incorrect number of arguments")
        print("Usage: python motor_control.py <direction> <speed> <duration> <dir_pin> <pwm_pin>")
        sys.exit(1)

    direction = sys.argv[1]
    speed = sys.argv[2]
    duration = sys.argv[3]
    dir_pin = int(sys.argv[4])
    pwm_pin = int(sys.argv[5])

    try:
        control_motor(direction, speed, duration, dir_pin, pwm_pin)
        print("Motor control successful")
    except Exception as e:
        logging.error(f"Error: {str(e)}")
        print(f"Error: {str(e)}")
    finally:
        # Only clean up if GPIO was set up
        if GPIO.getmode() is not None:
            GPIO.cleanup()
            logging.info("GPIO cleanup completed")

================
File: scripts/scene-player.js
================
// File: scripts/scene-player.js

$(document).ready(function() {
    let currentStep = 0;
    let eventSource = null;
    const steps = sceneData.steps || [];

    function logMessage(message) {
        const logBox = $("#log-box");
        logBox.append(`<p>${new Date().toLocaleTimeString()} - ${message}</p>`);
        logBox.scrollTop(logBox[0].scrollHeight);
        console.log(message);
    }

    function updateCurrentStep(index) {
        $(".step").removeClass("current-step");
        if (index >= 0 && index < steps.length) {
            $(`#step-${index}`).addClass("current-step");
        }
    }

    $("#backward-btn").click(function() {
        if (currentStep > 0) {
            currentStep--;
            logMessage(`Moved to step ${currentStep + 1}: ${steps[currentStep].name}`);
            updateCurrentStep(currentStep);
        } else {
            logMessage("Already at the beginning of the scene");
        }
    });

    $("#forward-btn").click(function() {
        if (currentStep < steps.length - 1) {
            currentStep++;
            logMessage(`Moved to step ${currentStep + 1}: ${steps[currentStep].name}`);
            updateCurrentStep(currentStep);
        } else {
            logMessage("Reached the end of the scene");
        }
    });

    $("#run-btn").click(function() {
        $(this).prop('disabled', true);
        $("#backward-btn").prop('disabled', true);
        $("#forward-btn").prop('disabled', true);
        logMessage(`Running scene from step ${currentStep + 1}`);
        runScene();
    });

    $("#stop-btn").click(function() {
        stopAllSteps();
    });

    function runScene() {
        if (eventSource) {
            eventSource.close();
        }

        eventSource = new EventSource(`/scenes/${sceneData.id}/play?startStep=${currentStep}`);

        eventSource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            if (data.message) {
                logMessage(data.message);
            }
            if (data.currentStep !== undefined) {
                currentStep = data.currentStep;
                updateCurrentStep(currentStep);
            }
            if (data.error) {
                logMessage(`Error: ${data.error}`);
            }
        };

        eventSource.onerror = function(error) {
            console.error('EventSource failed:', error);
            eventSource.close();
            resetControlButtons();
            logMessage("Scene execution stopped due to an error");
        };

        eventSource.addEventListener('close', function(event) {
            eventSource.close();
            resetControlButtons();
            logMessage("Scene execution completed");
        });
    }

    function stopAllSteps() {
        if (eventSource) {
            eventSource.close();
        }

        $.ajax({
            url: `/scenes/${sceneData.id}/stop`,
            method: 'POST',
            success: function(response) {
                logMessage("All steps stopped");
                resetControlButtons();
            },
            error: function(xhr, status, error) {
                console.error('Error stopping steps:', error);
                logMessage(`Error stopping steps: ${error}`);
                resetControlButtons();
            }
        });
    }

    function resetControlButtons() {
        $("#run-btn").prop('disabled', false);
        $("#backward-btn").prop('disabled', false);
        $("#forward-btn").prop('disabled', false);
    }

    // Initial scene overview
    logMessage(`Scene Overview: "${sceneData.scene_name}"`);
    logMessage(`Total steps: ${steps.length}`);
    steps.forEach((step, index) => {
        logMessage(`Step ${index + 1}: ${step.name} (Type: ${step.type}${step.concurrent ? ', Concurrent' : ''})`);
    });
});

================
File: scripts/sensor_control.py
================
import RPi.GPIO as GPIO
import time
import sys

def setup_gpio():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)

def cleanup_gpio():
    GPIO.cleanup()

def control_sensor(gpio_pin, timeout):
    setup_gpio()
    GPIO.setup(gpio_pin, GPIO.IN)

    print(f"Monitoring sensor on GPIO pin {gpio_pin} for {timeout} seconds")

    end_time = time.time() + float(timeout)
    while time.time() < end_time:
        if GPIO.input(gpio_pin):
            print("Motion detected!")
            return True
        time.sleep(0.1)

    print("No motion detected within timeout period")
    return False

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python sensor_control.py <gpio_pin> <timeout>")
        sys.exit(1)

    gpio_pin = int(sys.argv[1])
    timeout = float(sys.argv[2])

    try:
        motion_detected = control_sensor(gpio_pin, timeout)
        print(f"Motion detected: {motion_detected}")
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)
    finally:
        cleanup_gpio()

    sys.exit(0 if motion_detected else 1)

================
File: scripts/servo_control.py
================
import RPi.GPIO as GPIO
import sys
import time

def setup_gpio(pin):
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(pin, GPIO.OUT)
    return GPIO.PWM(pin, 50)  # 50 Hz PWM frequency

def angle_to_duty_cycle(angle):
    return 2.5 + (angle / 18)  # Maps 0-180 degrees to 2.5-12.5% duty cycle

def control_servo(pin, angle, frequency, duty_cycle, duration):
    pwm = setup_gpio(pin)
    try:
        pwm.ChangeFrequency(frequency)
        pwm.start(duty_cycle)
        pwm.ChangeDutyCycle(angle_to_duty_cycle(angle))
        time.sleep(duration / 1000)  # Convert duration to seconds
    finally:
        pwm.stop()
        GPIO.cleanup(pin)

if __name__ == "__main__":
    if len(sys.argv) != 6:
        print("Usage: python servo_control.py <pin> <angle> <frequency> <duty_cycle> <duration>")
        sys.exit(1)

    pin = int(sys.argv[1])
    angle = float(sys.argv[2])
    frequency = float(sys.argv[3])
    duty_cycle = float(sys.argv[4])
    duration = int(sys.argv[5])

    try:
        control_servo(pin, angle, frequency, duty_cycle, duration)
        print("Servo control successful")
    except Exception as e:
        print(f"Error controlling servo: {str(e)}")
        sys.exit(1)

================
File: scripts/sound_player.py
================
# File: scripts/sound_player.py

import sys
import pygame
import time
import json
from threading import Thread
import os
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"

class SoundPlayer:
    def __init__(self):
        pygame.mixer.init()
        self.channels = {}

    def play_sound(self, sound_id, file_path):
        if sound_id in self.channels:
            self.channels[sound_id].stop()
        
        try:
            sound = pygame.mixer.Sound(file_path)
            channel = sound.play()
            self.channels[sound_id] = channel
            print(json.dumps({"status": "playing", "sound_id": sound_id, "file": file_path}))
            sys.stdout.flush()
            
            while channel.get_busy():
                time.sleep(0.1)
            
            print(json.dumps({"status": "finished", "sound_id": sound_id, "file": file_path}))
            sys.stdout.flush()
        except Exception as e:
            print(json.dumps({"status": "error", "sound_id": sound_id, "file": file_path, "error": str(e)}))
            sys.stdout.flush()

    def stop_sound(self, sound_id):
        if sound_id in self.channels:
            self.channels[sound_id].stop()
            print(json.dumps({"status": "stopped", "sound_id": sound_id}))
            sys.stdout.flush()

if __name__ == "__main__":
    player = SoundPlayer()

    while True:
        try:
            command = input().strip()
            if command == "EXIT":
                break

            cmd, sound_id, file_path = command.split("|")
            if cmd == "PLAY":
                Thread(target=player.play_sound, args=(sound_id, file_path)).start()
            elif cmd == "STOP":
                player.stop_sound(sound_id)
        except Exception as e:
            print(json.dumps({"status": "error", "error": str(e)}))
            sys.stdout.flush()

    pygame.mixer.quit()

================
File: scripts/test_sensor.py
================
from gpiozero import MotionSensor
import json
import sys
import time

def test_motion_sensor(pin, duration=30):
    pir = MotionSensor(pin)
    end_time = time.time() + duration

    while time.time() < end_time:
        if pir.motion_detected:
            print(json.dumps({"status": "Motion Detected"}), flush=True)
        else:
            print(json.dumps({"status": "No Motion"}), flush=True)
        time.sleep(0.5)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(json.dumps({"error": "Usage: python test_sensor.py <pin>"}), file=sys.stderr)
        sys.exit(1)
    
    try:
        pin = int(sys.argv[1])
        test_motion_sensor(pin)
    except ValueError:
        print(json.dumps({"error": "Invalid GPIO pin number"}), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(json.dumps({"error": str(e)}), file=sys.stderr)
        sys.exit(1)

================
File: services/characterService.js
================
const fs = require('fs').promises;
const path = require('path');

const dataPath = path.join(__dirname, '../data/characters.json');

const getAllCharacters = async () => {
    try {
        const data = await fs.readFile(dataPath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
};

const getCharacterById = async (id) => {
    const characters = await getAllCharacters();
    return characters.find(character => character.id === parseInt(id));
};

const createCharacter = async (characterData) => {
    const characters = await getAllCharacters();
    const newCharacter = {
        id: characters.length > 0 ? Math.max(...characters.map(c => c.id)) + 1 : 1,
        ...characterData
    };
    characters.push(newCharacter);
    await fs.writeFile(dataPath, JSON.stringify(characters, null, 2));
    return newCharacter;
};

const updateCharacter = async (id, characterData) => {
    const characters = await getAllCharacters();
    const index = characters.findIndex(character => character.id === parseInt(id));
    if (index !== -1) {
        characters[index] = { ...characters[index], ...characterData, id: parseInt(id) };
        await fs.writeFile(dataPath, JSON.stringify(characters, null, 2));
        return characters[index];
    }
    throw new Error('Character not found');
};

const deleteCharacter = async (id) => {
    const characters = await getAllCharacters();
    const filteredCharacters = characters.filter(character => character.id !== parseInt(id));
    if (filteredCharacters.length === characters.length) {
        throw new Error('Character not found');
    }
    await fs.writeFile(dataPath, JSON.stringify(filteredCharacters, null, 2));
};

module.exports = {
    getAllCharacters,
    getCharacterById,
    createCharacter,
    updateCharacter,
    deleteCharacter
};

================
File: services/partService.js
================
const fs = require('fs').promises;
const path = require('path');

const dataPath = path.join(__dirname, '../data/parts.json');

const getAllParts = async () => {
    try {
        const data = await fs.readFile(dataPath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
};

const getPartById = async (id) => {
    console.log('Getting part by ID:', id, 'Type:', typeof id);
    if (id === undefined || id === null) {
        throw new Error('Part ID is required');
    }
    const parts = await getAllParts();
    const part = parts.find(part => part.id === parseInt(id, 10));
    if (!part) {
        console.log(`Part not found with id: ${id}`);
        throw new Error(`Part not found with id: ${id}`);
    }
    console.log('Found part:', part);
    return part;
};

const createPart = async (partData) => {
    const parts = await getAllParts();
    const newPart = {
        id: parts.length > 0 ? Math.max(...parts.map(p => p.id)) + 1 : 1,
        ...partData
    };
    
    if (newPart.type === 'servo') {
        newPart.servoType = partData.servoType;
        newPart.channel = partData.channel;
        newPart.minPulse = partData.minPulse;
        newPart.maxPulse = partData.maxPulse;
        newPart.defaultAngle = partData.defaultAngle;
    }
    
    parts.push(newPart);
    await fs.writeFile(dataPath, JSON.stringify(parts, null, 2));
    return newPart;
};

const updatePart = async (id, partData) => {
    console.log('Updating part - ID:', id, 'Type:', typeof id);
    console.log('Updating part - Data:', partData);
    const parts = await getAllParts();
    const index = parts.findIndex(part => part.id === parseInt(id, 10));
    console.log('Found part index:', index);
    if (index === -1) {
        console.log(`Part not found with id: ${id}`);
        throw new Error(`Part not found with id: ${id}`);
    }
    parts[index] = { ...parts[index], ...partData, id: parseInt(id, 10) };
    
    if (parts[index].type === 'servo') {
        parts[index].servoType = partData.servoType;
        parts[index].channel = partData.channel;
        parts[index].minPulse = partData.minPulse;
        parts[index].maxPulse = partData.maxPulse;
        parts[index].defaultAngle = partData.defaultAngle;
    }
    
    await fs.writeFile(dataPath, JSON.stringify(parts, null, 2));
    console.log('Updated part:', parts[index]);
    return parts[index];
};

const deletePart = async (id) => {
    const parts = await getAllParts();
    const filteredParts = parts.filter(part => part.id !== parseInt(id, 10));
    if (filteredParts.length === parts.length) {
        throw new Error(`Part not found with id: ${id}`);
    }
    await fs.writeFile(dataPath, JSON.stringify(filteredParts, null, 2));
};

module.exports = {
    getAllParts,
    getPartById,
    createPart,
    updatePart,
    deletePart
};

================
File: services/sceneService.js
================
const fs = require('fs').promises;
const path = require('path');

const dataPath = path.join(__dirname, '../data/scenes.json');

const getAllScenes = async () => {
    try {
        const data = await fs.readFile(dataPath, 'utf8');
        let scenes = JSON.parse(data);
        scenes = scenes.map(scene => ({
            ...scene,
            id: parseInt(scene.id)
        }));
        return scenes;
    } catch (error) {
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
};

const getSceneById = async (id) => {
    const scenes = await getAllScenes();
    return scenes.find(scene => scene.id === parseInt(id));
};

const getScenesByCharacterId = async (characterId) => {
    const scenes = await getAllScenes();
    return scenes.filter(scene => scene.character_id === parseInt(characterId));
};

const getNextId = (scenes) => {
    return scenes.length > 0 ? Math.max(...scenes.map(s => parseInt(s.id) || 0)) + 1 : 1;
};

const createScene = async (sceneData) => {
    const scenes = await getAllScenes();
    const newScene = {
        id: getNextId(scenes),
        character_id: parseInt(sceneData.character_id),
        scene_name: sceneData.scene_name,
        steps: sceneData.steps || []
    };
    scenes.push(newScene);
    await fs.writeFile(dataPath, JSON.stringify(scenes, null, 2));
    return newScene;
};

const updateScene = async (id, sceneData) => {
    const scenes = await getAllScenes();
    const index = scenes.findIndex(scene => scene.id === parseInt(id));
    if (index !== -1) {
        scenes[index] = {
            ...scenes[index],
            ...sceneData,
            id: parseInt(id),
            character_id: parseInt(sceneData.character_id),
            steps: sceneData.steps || scenes[index].steps
        };
        await fs.writeFile(dataPath, JSON.stringify(scenes, null, 2));
        return scenes[index];
    }
    return null; // Return null instead of throwing an error
};

const deleteScene = async (id) => {
    const scenes = await getAllScenes();
    const filteredScenes = scenes.filter(scene => scene.id !== parseInt(id));
    if (filteredScenes.length === scenes.length) {
        return false; // Indicate that no scene was deleted
    }
    await fs.writeFile(dataPath, JSON.stringify(filteredScenes, null, 2));
    return true; // Indicate successful deletion
};

module.exports = {
    getAllScenes,
    getSceneById,
    getScenesByCharacterId,
    createScene,
    updateScene,
    deleteScene
};

================
File: services/soundService.js
================
// File: services/soundService.js

const fs = require('fs').promises;
const path = require('path');

const dataPath = path.join(__dirname, '../data/sounds.json');

const getAllSounds = async () => {
    try {
        const data = await fs.readFile(dataPath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
};

const getSoundById = async (id) => {
    const sounds = await getAllSounds();
    return sounds.find(sound => sound.id === parseInt(id));
};

const getNextId = (sounds) => {
    return sounds.length > 0 ? Math.max(...sounds.map(s => s.id)) + 1 : 1;
};

const createSound = async (soundData) => {
    const sounds = await getAllSounds();
    const newSound = {
        id: getNextId(sounds),
        ...soundData
    };
    sounds.push(newSound);
    await fs.writeFile(dataPath, JSON.stringify(sounds, null, 2));
    return newSound;
};

const updateSound = async (id, soundData) => {
    const sounds = await getAllSounds();
    const index = sounds.findIndex(sound => sound.id === parseInt(id));
    if (index !== -1) {
        sounds[index] = { ...sounds[index], ...soundData, id: parseInt(id) };
        await fs.writeFile(dataPath, JSON.stringify(sounds, null, 2));
        return sounds[index];
    }
    throw new Error('Sound not found');
};

const deleteSound = async (id) => {
    const sounds = await getAllSounds();
    const filteredSounds = sounds.filter(sound => sound.id !== parseInt(id));
    if (filteredSounds.length === sounds.length) {
        throw new Error('Sound not found');
    }
    await fs.writeFile(dataPath, JSON.stringify(filteredSounds, null, 2));
};

module.exports = {
    getAllSounds,
    getSoundById,
    createSound,
    updateSound,
    deleteSound
};

================
File: views/part-forms/led.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="light">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="gpioPin">GPIO Pin:</label>
            <input type="number" id="gpioPin" name="gpioPin" value="<%= part.gpioPin || 26 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>
    <div id="lightTest">
        <h2>Test LED - fo shizzle</h2>
        <div>
            <label for="state">State:</label>
            <select id="state">
                <option value="on">On</option>
                <option value="off">Off</option>
            </select>
        </div>
        <div>
            <label for="duration">Duration (ms):</label>
            <input type="number" id="duration" value="1000" min="100" max="10000">
        </div>
        <button onclick="testPart()">Test Light</button>
    </div>
    <a href="/parts" class="button">Back to Parts</a>

    <script>
        function testPart() {
            const partData = {
                part_id: <%= part.id || 'null' %>,
                type: 'light',
                state: document.getElementById('state').value,
                duration: parseInt(document.getElementById('duration').value),
                gpioPin: parseInt(document.getElementById('gpioPin').value)
            };

            fetch('/parts/light/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(partData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Light test successful:', data.message);
                } else {
                    console.error('Light test failed:', data.message);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
            });
        }
    </script>
</body>
</html>

================
File: views/part-forms/light.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="light">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="gpioPin">GPIO Pin:</label>
            <input type="number" id="gpioPin" name="gpioPin" value="<%= part.gpioPin || 26 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>
    <div id="lightTest">
        <h2>Test Light</h2>
        <div>
            <label for="state">State:</label>
            <select id="state">
                <option value="on">On</option>
                <option value="off">Off</option>
            </select>
        </div>
        <div>
            <label for="duration">Duration (ms):</label>
            <input type="number" id="duration" value="1000" min="100" max="10000">
        </div>
        <button onclick="testPart()">Test Light</button>
    </div>
    <a href="/parts" class="button">Back to Parts</a>

    <script>
        function testPart() {
            const partData = {
                part_id: <%= part.id || 'null' %>,
                type: 'light',
                state: document.getElementById('state').value,
                duration: parseInt(document.getElementById('duration').value),
                gpioPin: parseInt(document.getElementById('gpioPin').value)
            };

            fetch('/parts/light/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(partData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Light test successful:', data.message);
                  //  alert('Light test successful: ' + data.message);
                } else {
                    console.error('Light test failed:', data.message);
                  //  alert('Light test failed: ' + data.message);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
                alert('An error occurred while testing the light');
            });
        }
    </script>
</body>
</html>

================
File: views/part-forms/linear-actuator.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="linear-actuator">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="directionPin">Direction GPIO Pin:</label>
            <input type="number" id="directionPin" name="directionPin" value="<%= part.directionPin || 18 %>" required>
        </div>
        <div>
            <label for="pwmPin">PWM Pin:</label>
            <input type="number" id="pwmPin" name="pwmPin" value="<%= part.pwmPin || 13 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>

    <div id="actuatorTest">
        <h2>Test Linear Actuator</h2>
        <div>
            <label for="direction">Direction:</label>
            <select id="direction">
                <option value="forward">Forward</option>
                <option value="backward">Backward</option>
            </select>
        </div>
        <div>
            <label for="speed">Speed:</label>
            <input type="range" id="speed" min="0" max="100" value="50">
            <span id="speedValue">50</span>
        </div>
        <div>
            <label for="duration">Duration (ms):</label>
            <input type="range" id="duration" min="100" max="5000" value="1000" step="100">
            <span id="durationValue">1000</span>
        </div>
        <button onclick="testPart()">Test Linear Actuator</button>
    </div>

    <a href="/parts" class="button">Back to Parts</a>

    <script>
        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speedValue').textContent = this.value;
        });
        document.getElementById('duration').addEventListener('input', function() {
            document.getElementById('durationValue').textContent = this.value;
        });

        function testPart() {
            const partData = {
                direction: document.getElementById('direction').value,
                speed: parseInt(document.getElementById('speed').value),
                duration: parseInt(document.getElementById('duration').value),
                directionPin: parseInt(document.getElementById('directionPin').value),
                pwmPin: parseInt(document.getElementById('pwmPin').value)
            };

            fetch('/parts/linear-actuator/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(partData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Linear actuator test successful:', data.message);
                } else {
                    console.error('Linear actuator test failed:', data.message);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
            });
        }
    </script>
</body>
</html>

================
File: views/part-forms/motor-control.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="motor">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="directionPin">Direction GPIO Pin:</label>
            <input type="number" id="directionPin" name="directionPin" value="<%= part.directionPin || 18 %>" required>
        </div>
        <div>
            <label for="pwmPin">PWM Pin:</label>
            <input type="number" id="pwmPin" name="pwmPin" value="<%= part.pwmPin || 13 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>

    <div id="motorTest">
        <h2>Test Motor</h2>
        <div>
            <label for="direction">Direction:</label>
            <select id="direction">
                <option value="forward">Forward</option>
                <option value="backward">Backward</option>
            </select>
        </div>
        <div>
            <label for="speed">Speed:</label>
            <input type="range" id="speed" min="0" max="100" value="50">
            <span id="speedValue">50</span>
        </div>
        <div>
            <label for="duration">Duration (ms):</label>
            <input type="range" id="duration" min="100" max="5000" value="1000" step="100">
            <span id="durationValue">1000</span>
        </div>
        <button onclick="testPart()">Test Motor</button>
        <button onclick="openOSTestForm()">OS Test</button>
    </div>

    <div id="osTestForm" style="display: none;">
        <h2>OS Test</h2>
        <select id="osTestPart">
            <!-- Options will be populated dynamically -->
        </select>
        <textarea id="osTestCommand" rows="4" cols="50"></textarea>
        <button onclick="runOSTest()">Run</button>
        <div id="osTestResult"></div>
    </div>

    <a href="/parts" class="button">Back to Parts</a>

    <script>
        // Update speed and duration values
        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speedValue').textContent = this.value;
        });
        document.getElementById('duration').addEventListener('input', function() {
            document.getElementById('durationValue').textContent = this.value;
        });

        function testPart() {
            const partId = document.querySelector('input[name="id"]')?.value;
            const partData = {
                id: partId,
                type: 'motor',
                direction: document.getElementById('direction').value,
                speed: parseInt(document.getElementById('speed').value),
                duration: parseInt(document.getElementById('duration').value),
                directionPin: parseInt(document.getElementById('directionPin').value),
                pwmPin: parseInt(document.getElementById('pwmPin').value)
            };

            fetch('/parts/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(partData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Motor test successful');
                } else {
                    alert('Motor test failed: ' + data.message);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
                alert('An error occurred while testing the motor. Check console for details.');
            });
        }

        function openOSTestForm() {
            document.getElementById('osTestForm').style.display = 'block';
            fetchAllParts();
        }

        function fetchAllParts() {
            fetch('/parts/all')
                .then(response => response.json())
                .then(parts => {
                    const select = document.getElementById('osTestPart');
                    select.innerHTML = '';
                    parts.forEach(part => {
                        const option = document.createElement('option');
                        option.value = part.id;
                        option.textContent = `${part.name} (${part.type})`;
                        select.appendChild(option);
                    });
                })
                .catch(error => console.error('Error fetching parts:', error));
        }

        function runOSTest() {
            const partId = document.getElementById('osTestPart').value;
            const command = document.getElementById('osTestCommand').value;

            fetch('/parts/os-test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ partId, command })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('osTestResult').textContent = data.output;
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('osTestResult').textContent = 'An error occurred during the OS test.';
            });
        }
    </script>
</body>
</html>

================
File: views/part-forms/motor.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="motor">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="directionPin">Direction GPIO Pin:</label>
            <input type="number" id="directionPin" name="directionPin" value="<%= part.directionPin || 18 %>" required>
        </div>
        <div>
            <label for="pwmPin">PWM Pin:</label>
            <input type="number" id="pwmPin" name="pwmPin" value="<%= part.pwmPin || 13 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>

    <a href="/parts" class="button">Back to Parts</a>
</body>
</html>

================
File: views/part-forms/sensor.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&display=swap');

        .motion-detected {
            color: red;
            font-family: 'Creepster', cursive;
            font-size: 1.2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="sensor">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Sensor Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="sensorType">Type:</label>
            <select id="sensorType" name="sensorType" required>
                <option value="motion" <%= part.sensorType === 'motion' ? 'selected' : '' %>>Motion</option>
                <option value="sound" <%= part.sensorType === 'sound' ? 'selected' : '' %>>Sound</option>
            </select>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="gpioPin">GPIO Pin:</label>
            <input type="number" id="gpioPin" name="gpioPin" value="<%= part.gpioPin || '' %>" required>
        </div>
        <div>
            <label for="active">
                <input type="checkbox" id="active" name="active" <%= part.active ? 'checked' : '' %>>
                Active
            </label>
        </div>
        <button type="submit">Save Sensor</button>
    </form>

    <div id="testArea" style="margin-top: 20px;">
        <h2>Test Sensor</h2>
        <p id="statusText">Sensor status: Not testing</p>
        <button id="startTest">Start Test</button>
        <button id="stopTest" disabled>Stop Test</button>
        <div id="testResults" style="margin-top: 10px;"></div>
    </div>

    <a href="/parts" class="button">Back to Parts</a>

    <script>
        let eventSource;

        function updateSensorStatus(status) {
            const statusText = $('#statusText');
            statusText.text('Sensor status: ' + status);

            if (status === 'Motion Detected') {
                statusText.addClass('motion-detected');
            } else {
                statusText.removeClass('motion-detected');
            }
        }

        function startTest() {
            const sensorId = $('input[name="id"]').val();
            const gpioPin = $('#gpioPin').val();

            eventSource = new EventSource(`/parts/sensor/test-sensor?id=${sensorId}&gpioPin=${gpioPin}`);

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.status) {
                    updateSensorStatus(data.status);
                } else if (data.error) {
                    console.error('Error:', data.error);
                    updateSensorStatus('Error: ' + data.error);
                    stopTest();
                } else if (data.done) {
                    stopTest();
                }
            };

            eventSource.onerror = function(event) {
                console.error('EventSource failed:', event);
                stopTest();
            };

            $('#startTest').prop('disabled', true);
            $('#stopTest').prop('disabled', false);
        }

        function stopTest() {
            if (eventSource) {
                eventSource.close();
            }
            $('#startTest').prop('disabled', false);
            $('#stopTest').prop('disabled', true);
            updateSensorStatus('Not testing');
        }

        $('#startTest').click(startTest);
        $('#stopTest').click(stopTest);

        $('#sensorType').change(function() {
            if ($(this).val() === 'sound') {
                $('#gpioPin').prop('disabled', true);
            } else {
                $('#gpioPin').prop('disabled', false);
            }
        });

        // Trigger change event on page load
        $('#sensorType').change();
    </script>
</body>
</html>

================
File: views/part-forms/servo.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .channel-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .channel-button {
            padding: 10px;
            text-align: center;
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            cursor: pointer;
        }
        .channel-button.selected {
            background-color: #00ff00;
            color: #000000;
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="servo">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="servoType">Servo Type:</label>
            <select id="servoType" name="servoType" required onchange="updateServoDescription(document.getElementById('testAngle').value)">
                <option value="DS3240MG" <%= (part.servoType === 'DS3240MG') ? 'selected' : '' %>>DS3240MG (40KG Digital RC Servo)</option>
                <option value="FS90R" <%= (part.servoType === 'FS90R') ? 'selected' : '' %>>FITEC FS90R (Continuous Rotation)</option>
                <option value="MG90S" <%= (part.servoType === 'MG90S') ? 'selected' : '' %>>MG90S Servo</option>
                <option value="BILDA" <%= (part.servoType === 'BILDA') ? 'selected' : '' %>>BILDA Dual Mode Servo</option>
            </select>
        </div>
        <div>
            <label for="channel">PCA9685 Channel:</label>
            <input type="number" id="channel" name="channel" value="<%= part.channel || 0 %>" min="0" max="15" required readonly>
        </div>
        <div>
            <label>Channel Position:</label>
            <div class="channel-grid">
                <% for (let i = 0; i < 16; i++) { %>
                    <div class="channel-button" data-channel="<%= i %>">
                        <%= i %> (<%= ['Top', 'Top', 'Top', 'Top', 'Upper Mid', 'Upper Mid', 'Upper Mid', 'Upper Mid', 'Lower Mid', 'Lower Mid', 'Lower Mid', 'Lower Mid', 'Bottom', 'Bottom', 'Bottom', 'Bottom'][i] %>)
                    </div>
                <% } %>
            </div>
        </div>
        <div>
            <label for="minPulse">Min Pulse (s):</label>
            <input type="number" id="minPulse" name="minPulse" value="<%= part.minPulse || 500 %>" required>
        </div>
        <div>
            <label for="maxPulse">Max Pulse (s):</label>
            <input type="number" id="maxPulse" name="maxPulse" value="<%= part.maxPulse || 2500 %>" required>
        </div>
        <div>
            <label for="defaultAngle">Default Angle:</label>
            <input type="number" id="defaultAngle" name="defaultAngle" value="<%= part.defaultAngle || 90 %>" min="0" max="180" required>
        </div>
        <button type="submit">Save Part</button>
    </form>
    <div id="servoTest">
        <h2>Test Servo</h2>
        <div>
            <label for="testAngle">Angle (0-180) / Speed for FS90R:</label>
            <input type="range" id="testAngle" min="0" max="180" value="90">
            <span id="angleValue">90</span>
        </div>
        <p id="servoDescription"></p>
        <button onclick="testServo()">Test Servo</button>
        <button onclick="stopServo()">Stop Test</button>
    </div>
    <a href="/parts" class="button">Back to Parts</a>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const channelButtons = document.querySelectorAll('.channel-button');
            const channelInput = document.getElementById('channel');

            channelButtons.forEach(button => {
                button.addEventListener('click', function() {
                    channelButtons.forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    channelInput.value = this.dataset.channel;
                });
            });

            // Set initial selected channel
            const initialChannel = parseInt(channelInput.value);
            channelButtons[initialChannel].classList.add('selected');

            // Initialize servo description
            updateServoDescription(document.getElementById('testAngle').value);
        });

        document.getElementById('testAngle').addEventListener('input', function() {
            const angle = parseInt(this.value);
            document.getElementById('angleValue').textContent = angle;
            updateServoDescription(angle);
        });

        function updateServoDescription(angle) {
            const servoType = document.getElementById('servoType').value;
            let description = '';
            if (servoType === 'FS90R') {
                if (angle === 90) description = 'Stopped';
                else if (angle < 90) description = `Clockwise (${100 - Math.round(angle / 90 * 100)}% speed)`;
                else description = `Counterclockwise (${Math.round((angle - 90) / 90 * 100)}% speed)`;
            } else {
                description = `Angle: ${angle}`;
            }
            document.getElementById('servoDescription').textContent = description;
        }

        function testServo() {
            const angle = document.getElementById('testAngle').value;
            const channel = document.getElementById('channel').value;
            fetch('/parts/servo/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    angle: parseInt(angle),
                    channel: parseInt(channel),
                    servoType: document.getElementById('servoType').value,
                    minPulse: parseInt(document.getElementById('minPulse').value),
                    maxPulse: parseInt(document.getElementById('maxPulse').value)
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
//                    alert('Servo test successful');
						console.log('Servo Test Successful', data.message);
                } else {
                    alert('Servo test failed. Again. Of course you knew that already: ' + data.message);
						console.log('Servo Test FAAILURRREEE', data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred while testing the servo.damnit.');
            });
        }

        function stopServo() {
            const channel = document.getElementById('channel').value;
            fetch('/parts/servo/stop', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    channel: parseInt(channel),
                    servoType: document.getElementById('servoType').value
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Servo stopped successfully');
                } else {
                    alert('Failed to stop servo: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred while stopping the servo');
            });
        }
    </script>
</body>
</html>

================
File: views/active-mode.ejs
================
<!-- File: views/active-mode.ejs -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Mode</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        #errorMessage {
            color: red;
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Active Mode</h1>
    
    <div class="character-section">
        <img id="characterImage" class="character-image" src="/images/placeholder.jpg" alt="Character Image">
        <div class="character-info">
            <label for="characterSelect">Character:</label>
            <select id="characterSelect">
                <option value="">Select a character</option>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>"><%= character.char_name %></option>
                <% }); %>
            </select>
            <div id="characterInfo"></div>
        </div>
    </div>

    <div class="scene-container">
        <div class="scene-box">
            <h2>Available Scenes</h2>
            <select id="availableScenes" multiple></select>
        </div>
        <div class="scene-controls">
            <button id="addScenes">&gt;&gt;</button>
            <button id="removeScenes">&lt;&lt;</button>
        </div>
        <div class="scene-box">
            <h2>ACTIVE Scenes</h2>
            <ul id="activatedScenes"></ul>
        </div>
    </div>

    <div class="monitoring-section">
        <h2>Monitoring: <span id="armStatus">DISARMED</span></h2>
        <button id="armButton">Arm</button>
        <button id="disarmButton" disabled>Disarm</button>
        <button id="stopAllSteps">Stop All Steps</button>
    </div>

    <div id="armedModeOutput" class="output-section">
        <h3>Armed Mode Output</h3>
    </div>

    <div class="monitoring-section">
        <h2>Camera Stream</h2>
        <img id="cameraStream" src="/stream" alt="Camera Stream">
        <audio id="audioStream" controls></audio>
        <div class="camera-controls">
            <button id="toggleNightMode">Toggle Night Mode</button>
            <label>
                <input type="checkbox" id="audioToggle" checked> Enable Audio
            </label>
            <label>
                Mic Volume: <input type="range" id="micVolume" min="0" max="2" step="0.1" value="1">
            </label>
            </div>
        <div id="errorMessage"></div>
    </div>

    <a href="/" class="button">Back to Main Menu</a>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
    <script src="/scripts/active-mode.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            const toggleNightModeBtn = document.getElementById('toggleNightMode');
            const audioToggle = document.getElementById('audioToggle');
            const micVolumeSlider = document.getElementById('micVolume');
            const audioDeviceSelect = document.getElementById('audioDevice');
            const errorMessageDiv = document.getElementById('errorMessage');

            let audioWebSocket;

            function startAudioStream() {
                audioWebSocket = new WebSocket(`ws://${window.location.hostname}:${window.location.port}/audiostream`);
                audioWebSocket.binaryType = 'arraybuffer';
                audioWebSocket.onmessage = function(event) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioContext.decodeAudioData(event.data, function(buffer) {
                        const source = audioContext.createBufferSource();
                        source.buffer = buffer;
                        source.connect(audioContext.destination);
                        source.start(0);
                    });
                };
                audioWebSocket.onerror = function(error) {
                    console.error('WebSocket Error:', error);
                    errorMessageDiv.textContent = 'Error connecting to audio stream';
                };
            }

            toggleNightModeBtn.addEventListener('click', () => {
                fetch('/camera/toggle-night-mode', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        console.log('Night mode:', data.nightMode ? 'ON' : 'OFF');
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        errorMessageDiv.textContent = 'Error toggling night mode';
                    });
            });

            audioToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    startAudioStream();
                } else {
                    if (audioWebSocket) {
                        audioWebSocket.close();
                    }
                }
            });

            micVolumeSlider.addEventListener('input', (e) => {
                const volume = parseFloat(e.target.value);
                fetch('/audio/set-mic-volume', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ volume: volume }),
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Mic volume set to:', data.volume);
                })
                .catch(error => {
                    console.error('Error:', error);
                    errorMessageDiv.textContent = 'Error setting mic volume';
                });
            });

            // Populate audio devices
            fetch('/audio/devices')
                .then(response => response.json())
                .then(data => {
                    audioDeviceSelect.innerHTML = data.devices.map(device => 
                        `<option value="${device}">${device}</option>`
                    ).join('');
                })
                .catch(error => {
                    console.error('Error:', error);
                    errorMessageDiv.textContent = 'Error fetching audio devices';
                });

            audioDeviceSelect.addEventListener('change', (e) => {
                fetch('/audio/set-audio-device', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ device: e.target.value }),
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Audio device set to:', data.device);
                    if (audioWebSocket) {
                        audioWebSocket.close();
                    }
                    startAudioStream();
                })
                .catch(error => {
                    console.error('Error:', error);
                    errorMessageDiv.textContent = 'Error setting audio device';
                });
            });

            // Start audio stream initially if audio is enabled
            if (audioToggle.checked) {
                startAudioStream();
            }

            // Function to clear error messages after 5 seconds
            function clearErrorMessage() {
                setTimeout(() => {
                    errorMessageDiv.textContent = '';
                }, 5000);
            }

            // Add error handling for the video stream
            const cameraStream = document.getElementById('cameraStream');
            cameraStream.onerror = function() {
                errorMessageDiv.textContent = 'Error loading camera stream';
				clearErrorMessage();
            };

            // Restore previously removed functionality
            $('#characterSelect').change(fetchCharacterInfo);
            $('#addScenes').click(addScenes);
            $('#removeScenes').click(removeScenes);
            $('#activatedScenes').sortable().selectable();
            $('#armButton').click(armSystem);
            $('#disarmButton').click(disarmSystem);
            $('#stopAllSteps').click(stopAllSteps);

            // Load the first character by default
            loadFirstCharacter();

            function loadFirstCharacter() {
                const firstCharacter = $('#characterSelect option:first');
                if (firstCharacter.length > 0) {
                    $('#characterSelect').val(firstCharacter.val()).trigger('change');
                }
            }

            function fetchCharacterInfo() {
                const characterId = $(this).val();
                if (characterId) {
                    $.get(`/active-mode/character/${characterId}`, displayCharacterInfo)
                        .fail(handleCharacterInfoError);
                    fetchScenes(characterId);
                } else {
                    clearCharacterInfo();
                }
            }

            function displayCharacterInfo(character) {
                let infoHtml = `<h3>${character.char_name}</h3><p>${character.char_description}</p>`;
                $('#characterInfo').html(infoHtml);
                
                if (character.image) {
                    $('#characterImage').attr('src', `/images/characters/${character.image}`).attr('alt', character.char_name);
                } else {
                    $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
                }
            }

            function handleCharacterInfoError(jqXHR, textStatus, errorThrown) {
                console.error("Error fetching character info:", textStatus, errorThrown);
                $('#characterInfo').html('<p>Failed to load character information. Please try again.</p>');
                $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
            }

            function clearCharacterInfo() {
                $('#characterInfo').empty();
                $('#availableScenes').empty();
                $('#activatedScenes').empty();
                $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
            }

            function fetchScenes(characterId) {
                $.get(`/active-mode/character/${characterId}/scenes`, displayScenes)
                    .fail(handleSceneFetchError);
            }

            function displayScenes(scenes) {
                $('#availableScenes').empty();
                scenes.forEach(function(scene) {
                    $('#availableScenes').append(`<option value="${scene.id}">${scene.scene_name}</option>`);
                });
            }

            function handleSceneFetchError(jqXHR, textStatus, errorThrown) {
                console.error("Error fetching scenes:", textStatus, errorThrown);
                $('#availableScenes').html('<option>Failed to load scenes</option>');
            }

            function addScenes() {
                $('#availableScenes option:selected').each(function() {
                    const sceneId = $(this).val();
                    const sceneName = $(this).text();
                    $('#activatedScenes').append(`<li data-id="${sceneId}">${sceneName}</li>`);
                    $(this).remove();
                });
            }

            function removeScenes() {
                $('#activatedScenes li.ui-selected').each(function() {
                    const sceneId = $(this).data('id');
                    const sceneName = $(this).text();
                    $('#availableScenes').append(`<option value="${sceneId}">${sceneName}</option>`);
                    $(this).remove();
                });
            }

            function armSystem() {
                if ($('#activatedScenes li').length === 0) {
                    alert('Please select at least one scene to activate.');
                    return;
                }
                isArmed = true;
                $(this).prop('disabled', true);
                $('#disarmButton').prop('disabled', false);
                $('#armStatus').text('ARMED').removeClass('disarmed').addClass('armed');
                logArmedModeOutput('System armed. Starting Active Mode.');
                startActiveModeLoop();
            }

            function disarmSystem() {
                isArmed = false;
                $(this).prop('disabled', true);
                $('#armButton').prop('disabled', false);
                $('#armStatus').text('DISARMED').removeClass('armed').addClass('disarmed');
                logArmedModeOutput('System disarmed. Active Mode stopped.');
                stopAllSteps();
            }

            function stopAllSteps() {
                $.post('/scenes/stop-all')
                    .done(function(response) {
                        logArmedModeOutput('All steps stopped: ' + response.message);
                    })
                    .fail(function(xhr, status, error) {
                        console.error('Error stopping all steps:', error);
                        logArmedModeOutput('Error stopping all steps: ' + error);
                    });
            }

            function startActiveModeLoop() {
                const scenes = $('#activatedScenes li').map(function() {
                    return $(this).data('id');
                }).get();

                function runNextScene(index) {
                    if (!isArmed) return;
                    if (index >= scenes.length) {
                        index = 0; // Reset to the beginning of the list
                    }
                    const sceneId = scenes[index];
                    logArmedModeOutput(`Starting execution of scene ${sceneId}`);
                    runScene(sceneId).then(() => {
                        logArmedModeOutput(`Completed execution of scene ${sceneId}`);
                        setTimeout(() => runNextScene(index + 1), 5000); // 5 seconds between scenes
                    }).catch((error) => {
                        logArmedModeOutput(`Error executing scene ${sceneId}: ${error.message}`);
                        setTimeout(() => runNextScene(index + 1), 5000); // Continue to next scene even if there's an error
                    });
                }

                runNextScene(0);
            }

            function runScene(sceneId) {
                return new Promise((resolve, reject) => {
                    $.get(`/scenes/${sceneId}/play`)
                        .done(function(data) {
                            handleSceneExecutionUpdate(data);
                            resolve();
                        })
                        .fail(function(xhr, status, error) {
                            console.error('Error executing scene:', error);
                            reject(new Error(`Failed to execute scene ${sceneId}`));
                        });
                });
            }

            function handleSceneExecutionUpdate(data) {
                if (data.error) {
                    logArmedModeOutput(`Error: ${data.error}`);
                } else if (data.message) {
                    logArmedModeOutput(data.message);
                }
            }

            function logArmedModeOutput(message) {
                const timestamp = new Date().toLocaleTimeString();
                $('#armedModeOutput').append(`<p>[${timestamp}] ${message}</p>`);
                $('#armedModeOutput').scrollTop($('#armedModeOutput')[0].scrollHeight);
            }
        });
    </script>
</body>
</html>

================
File: views/character-form.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST" enctype="multipart/form-data">
        <% if (character.id) { %>
            <input type="hidden" name="id" value="<%= character.id %>">
        <% } %>
        <div>
            <label for="char_name">Name:</label>
            <input type="text" id="char_name" name="char_name" value="<%= character.char_name || '' %>" required>
        </div>
        <div>
            <label for="char_description">Description:</label>
            <textarea id="char_description" name="char_description" required><%= character.char_description || '' %></textarea>
        </div>
        <div>
            <label for="character_image">Character Image:</label>
            <input type="file" id="character_image" name="character_image" accept="image/*">
            <% if (character.image) { %>
                <img src="/images/characters/<%= character.image %>" alt="<%= character.char_name %>" style="max-width: 200px;">
            <% } %>
        </div>
        <div>
            <label>Parts:</label>
            <div id="parts-container">
                <div id="available-parts">
                    <h4>Available Parts:</h4>
                    <select id="available-parts-select" multiple>
                        <% parts.filter(part => !character.parts || !character.parts.includes(part.id)).forEach(function(part) { %>
                            <option value="<%= part.id %>"><%= part.name %> (<%= part.type %>)</option>
                        <% }); %>
                    </select>
                </div>
                <div>
                    <button type="button" onclick="addPart()">Add &gt;</button>
                    <button type="button" onclick="removePart()">&lt; Remove</button>
                </div>
                <div id="selected-parts">
                    <h4>Selected Parts:</h4>
                    <select id="selected-parts-select" name="parts" multiple>
                        <% if (character.parts) { %>
                            <% character.parts.forEach(function(partId) { %>
                                <% const part = parts.find(p => p.id === partId); %>
                                <% if (part) { %>
                                    <option value="<%= part.id %>"><%= part.name %> (<%= part.type %>)</option>
                                <% } %>
                            <% }); %>
                        <% } %>
                    </select>
                </div>
            </div>
        </div>
        <div>
            <label>Sounds:</label>
            <div id="sounds-container">
                <div id="available-sounds">
                    <h4>Available Sounds:</h4>
                    <select id="available-sounds-select" multiple>
                        <% sounds.filter(sound => !character.sounds || !character.sounds.includes(sound.id)).forEach(function(sound) { %>
                            <option value="<%= sound.id %>"><%= sound.name %></option>
                        <% }); %>
                    </select>
                </div>
                <div>
                    <button type="button" onclick="addSound()">Add &gt;</button>
                    <button type="button" onclick="removeSound()">&lt; Remove</button>
                </div>
                <div id="selected-sounds">
                    <h4>Selected Sounds:</h4>
                    <select id="selected-sounds-select" name="sounds" multiple>
                        <% if (character.sounds) { %>
                            <% character.sounds.forEach(function(soundId) { %>
                                <% const sound = sounds.find(s => s.id === soundId); %>
                                <% if (sound) { %>
                                    <option value="<%= sound.id %>"><%= sound.name %></option>
                                <% } %>
                            <% }); %>
                        <% } %>
                    </select>
                </div>
            </div>
        </div>
        <button type="submit">Save Character</button>
    </form>
    <a href="/characters" class="button">Back to Characters</a>

    <script>
        function addPart() {
            moveOptions('available-parts-select', 'selected-parts-select');
        }

        function removePart() {
            moveOptions('selected-parts-select', 'available-parts-select');
        }

        function addSound() {
            moveOptions('available-sounds-select', 'selected-sounds-select');
        }

        function removeSound() {
            moveOptions('selected-sounds-select', 'available-sounds-select');
        }

        function moveOptions(fromId, toId) {
            const fromSelect = document.getElementById(fromId);
            const toSelect = document.getElementById(toId);
            
            for (let option of Array.from(fromSelect.selectedOptions)) {
                toSelect.add(option);
                option.selected = false;
            }
            updateAvailableOptions();
        }

        function updateAvailableOptions() {
            const availableParts = document.getElementById('available-parts-select');
            const selectedParts = document.getElementById('selected-parts-select');
            const availableSounds = document.getElementById('available-sounds-select');
            const selectedSounds = document.getElementById('selected-sounds-select');

            for (let option of availableParts.options) {
                option.disabled = Array.from(selectedParts.options).some(o => o.value === option.value);
            }

            for (let option of availableSounds.options) {
                option.disabled = Array.from(selectedSounds.options).some(o => o.value === option.value);
            }
        }

        // Ensure all options are selected before form submission
        document.querySelector('form').onsubmit = function() {
            const selectedParts = document.getElementById('selected-parts-select');
            const selectedSounds = document.getElementById('selected-sounds-select');
            
            for (let option of selectedParts.options) {
                option.selected = true;
            }
            
            for (let option of selectedSounds.options) {
                option.selected = true;
            }
            
            return true;
        };

        // Initialize available options
        updateAvailableOptions();
    </script>
</body>
</html>

================
File: views/characters.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <h1><%= title %></h1>
    <a href="/characters/new" class="button">Add New Character</a>
    <table>
        <thead>
            <tr>
                <th>Image</th>
                <th>Name</th>
                <th>Description</th>
                <th>Parts</th>
                <th>Sounds</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <% characters.forEach(function(character) { %>
                <tr>
                    <td>
                        <% if (character.image) { %>
                            <img src="/images/characters/<%= character.image %>" alt="<%= character.char_name %>" style="max-width: 100px;">
                        <% } else { %>
                            No Image
                        <% } %>
                    </td>
                    <td><%= character.char_name %></td>
                    <td><%= character.char_description %></td>
                    <td>
                        <% character.parts.forEach(function(partId) { %>
                            <% const part = parts.find(p => p.id === partId); %>
                            <% if (part) { %>
                                <%= part.name %><br>
                            <% } %>
                        <% }); %>
                    </td>
                    <td>
                        <% character.sounds.forEach(function(soundId) { %>
                            <% const sound = sounds.find(s => s.id === soundId); %>
                            <% if (sound) { %>
                                <%= sound.name %><br>
                            <% } %>
                        <% }); %>
                    </td>
                    <td>
                        <a href="/characters/<%= character.id %>/edit" class="button">Edit</a>
                        <button onclick="deleteCharacter(<%= character.id %>)" class="button">Delete</button>
                    </td>
                </tr>
            <% }); %>
        </tbody>
    </table>
    <a href="/" class="button">Back to Main Menu</a>

    <script>
        function deleteCharacter(id) {
            if (confirm('Are you sure you want to delete this character?')) {
                $.post('/characters/' + id + '/delete')
                    .done(function() {
                        location.reload();
                    })
                    .fail(function(xhr, status, error) {
                        console.error('Error details:', xhr.responseText);
                        alert('Error deleting character: ' + xhr.status + ' ' + xhr.statusText);
                    });
            }
        }
    </script>
</body>
</html>

================
File: views/error.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <p><%= message %></p>
    <% if (error) { %>
        <pre><%= error.stack %></pre>
    <% } %>
    <a href="/" class="button">Back to Home</a>
</body>
</html>

================
File: views/index.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MonsterBox Control Panel</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Creepster&display=swap">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            font-family: 'Creepster', cursive;
            font-size: 3em;
            margin: 0;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        main {
            text-align: center;
            margin-bottom: 20px;
        }
        nav {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .button {
            display: inline-block;
            background-color: #003300;
            color: #00ff00;
            padding: 10px 15px;
            margin: 10px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            font-size: 1.2em;
            width: 200px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .button:hover {
            background-color: #004400;
            box-shadow: 0 0 10px #00ff00;
        }
        footer {
            margin-top: 20px;
            text-align: center;
            font-style: italic;
        }
    </style>
</head>
<body>
    <header>
        <h1>MonsterBox</h1>
    </header>
    <main>
        <h2>Welcome to the MonsterBox Control Panel</h2>
        <p>Choose an option from the menu to get started.</p>
    </main>

    <nav>
        <a href="/scenes" class="button">Scenes</a>
        <a href="/characters" class="button">Characters</a>
        <a href="/parts" class="button">Parts</a>
        <a href="/sounds" class="button">Sounds</a>
        <a href="/active-mode" class="button">Active Mode</a>
    </nav>
    
    <footer>
        <p>An animatronic automation package by ARW 8.15.2024.</p>
    </footer>
</body>
</html>

================
File: views/os-test.ejs
================
<!-- File: views/os-test.ejs -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Test</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #000000;
            color: #00ff00;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        #osTestForm {
            background-color: #001100;
            margin-top: 20px;
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 5px;
        }
        #osTestResult {
            font-family: 'Courier New', Courier, monospace;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #00ff00;
            background-color: #000;
            color: #e0b0ff;
            white-space: pre-wrap;
            word-wrap: break-word;
            height: 200px;
            overflow-y: auto;
        }
        #flagInfo {
            background-color: #001800;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            border: 1px solid #00ff00;
        }
        label {
            display: block;
            margin-top: 10px;
            color: #00ff00;
        }
        select, textarea {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            background-color: #001100;
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        button {
            background-color: #003300;
            color: #00ff00;
            padding: 10px 15px;
            border: 1px solid #00ff00;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #004400;
            box-shadow: 0 0 10px #00ff00;
        }
        a.button {
            display: inline-block;
            background-color: #003300;
            color: #00ff00;
            padding: 10px 15px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            margin-top: 10px;
        }
        a.button:hover {
            background-color: #004400;
            text-decoration: none;
            box-shadow: 0 0 10px #00ff00;
        }
    </style>
</head>
<body>
    <h1>OS Test</h1>

    <div id="osTestResult"></div>

    <div id="osTestForm">
        <div>
            <label for="osTestPart">Select Part:</label>
            <select id="osTestPart" onchange="updateCommand()">
                <!-- Options will be populated dynamically -->
            </select>
        </div>
        <div id="flagInfo"></div>
        <div>
            <label for="osTestCommand">Command:</label>
            <textarea id="osTestCommand" rows="4" cols="50"></textarea>
        </div>
        <button onclick="runOSTest()">Run OS Test</button>
    </div>

    <a href="/parts" class="button">Back to Parts</a>

    <script>
        document.addEventListener('DOMContentLoaded', fetchAllParts);
        const commandHistory = {};
        let eventSource;

        function fetchAllParts() {
            fetch('/parts/all')
                .then(response => response.json())
                .then(parts => {
                    const select = document.getElementById('osTestPart');
                    select.innerHTML = '';
                    parts.forEach(part => {
                        const option = document.createElement('option');
                        option.value = JSON.stringify(part);
                        option.textContent = `${part.name} (${part.type})`;
                        select.appendChild(option);
                    });
                    updateCommand();
                })
                .catch(error => console.error('Error fetching parts:', error));
        }

        function updateCommand() {
            const partSelect = document.getElementById('osTestPart');
            const commandTextarea = document.getElementById('osTestCommand');
            const flagInfo = document.getElementById('flagInfo');
            
            if (partSelect.value) {
                const part = JSON.parse(partSelect.value);
                let command = `python3 ${part.type === 'linear-actuator' ? 'linear_actuator_control.py' : part.type + '_control.py'}`;
                let flagInfoText = '';
                
                switch(part.type) {
                    case 'motor':
                    case 'linear-actuator':
                        command += ` <direction> <speed> <duration> ${part.directionPin} ${part.pwmPin}`;
                        flagInfoText = `direction: forward, backward || speed: 0 - 100 || duration: time in milliseconds || directionPin: ${part.directionPin} (Direction GPIO Pin) || pwmPin: ${part.pwmPin} (PWM Pin) ||`;
                        break;
                    case 'led':
                    case 'light':
                        command += ` ${part.gpioPin} <state> <duration>`;
                        flagInfoText = `gpioPin: ${part.gpioPin} (GPIO Pin) || state: on, off || duration: time in milliseconds ||`;
                        break;
                    case 'servo':
                        command += ` ${part.gpioPin} <angle> <frequency> <duty_cycle> <duration>`;
                        flagInfoText = `gpioPin: ${part.gpioPin} (GPIO Pin) || angle: 0 - 180 || frequency: typically 50Hz || duty_cycle: typically 2.5 - 12.5 || duration: time in milliseconds ||`;
                        break;
                    case 'sensor':
                        command += ` ${part.gpioPin} <timeout>`;
                        flagInfoText = `gpioPin: ${part.gpioPin} (GPIO Pin) || timeout: time in seconds ||`;
                        break;
                }
                
                commandTextarea.value = commandHistory[part.id] || command;
                flagInfo.textContent = flagInfoText;
            } else {
                commandTextarea.value = '';
                flagInfo.textContent = '';
            }
        }

        function runOSTest() {
            const command = document.getElementById('osTestCommand').value;
            const part = JSON.parse(document.getElementById('osTestPart').value);

            // Save the command to history
            commandHistory[part.id] = command;

            if (eventSource) {
                eventSource.close();
            }

            const resultDiv = document.getElementById('osTestResult');
            const timestamp = new Date().toLocaleTimeString();
            resultDiv.textContent += `\n[${timestamp}] Running command: ${command}\n`;

            if (part.type === 'sensor') {
                eventSource = new EventSource(`/parts/os-test-stream?command=${encodeURIComponent(command)}`);
                
                eventSource.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    if (data.done) {
                        eventSource.close();
                    } else {
                        resultDiv.textContent += data.output;
                        resultDiv.scrollTop = resultDiv.scrollHeight;
                    }
                };

                eventSource.onerror = function(event) {
                    console.error('EventSource failed:', event);
                    eventSource.close();
                };
            } else {
                fetch('/parts/os-test', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ partId: part.id, command })
                })
                .then(response => response.json())
                .then(data => {
                    resultDiv.textContent += `${data.output}\n`;
                    resultDiv.scrollTop = resultDiv.scrollHeight;
                })
                .catch(error => {
                    console.error('Error:', error);
                    resultDiv.textContent += `An error occurred during the OS test.\n`;
                    resultDiv.scrollTop = resultDiv.scrollHeight;
                });
            }
        }
    </script>
</body>
</html>

================
File: views/part-form.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="type">Type:</label>
            <select id="type" name="type" required onchange="toggleInputs()">
                <option value="motor" <%= part.type === 'motor' ? 'selected' : '' %>>Motor</option>
                <option value="light" <%= part.type === 'light' ? 'selected' : '' %>>Light</option>
                <option value="led" <%= part.type === 'led' ? 'selected' : '' %>>LED</option>
                <option value="servo" <%= part.type === 'servo' ? 'selected' : '' %>>Servo</option>
                <option value="sensor" <%= part.type === 'sensor' ? 'selected' : '' %>>Sensor</option>
            </select>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div id="motorInputs" style="display: none;">
            <div>
                <label for="directionPin">Direction Pin:</label>
                <input type="number" id="directionPin" name="directionPin" value="<%= part.directionPin || '' %>">
            </div>
            <div>
                <label for="pwmPin">PWM Pin:</label>
                <input type="number" id="pwmPin" name="pwmPin" value="<%= part.pwmPin || '' %>">
            </div>
        </div>
        <div id="singlePinInputs" style="display: none;">
            <div>
                <label for="pin">GPIO Pin:</label>
                <input type="number" id="pin" name="pin" value="<%= part.pin || '' %>">
            </div>
        </div>
        <div id="sensorInputs" style="display: none;">
            <div>
                <label for="sensorType">Sensor Type:</label>
                <select id="sensorType" name="sensorType">
                    <option value="motion" <%= part.sensorType === 'motion' ? 'selected' : '' %>>Motion</option>
                    <option value="sound" <%= part.sensorType === 'sound' ? 'selected' : '' %>>Sound</option>
                </select>
            </div>
        </div>
        <div id="ledInputs" style="display: none;">
            <div>
                <label for="ledPin">GPIO Pin:</label>
                <input type="number" id="ledPin" name="ledPin" value="<%= part.ledPin || '' %>" min="0" max="40">
            </div>
            <div>
                <label for="duration">Duration (ms):</label>
                <input type="number" id="duration" name="duration" value="<%= part.duration || '' %>" min="0">
            </div>
        </div>
        <button type="submit">Save Part</button>
        <button type="button" id="testPartButton" onclick="testPart()">Test Part</button>
    </form>
    <div id="testArea" style="display: none;">
        <h2>Test Results</h2>
        <p id="testStatus">Not testing</p>
    </div>
    <a href="/parts" class="button">Back to Parts</a>

    <script>
        function toggleInputs() {
            const type = document.getElementById('type').value;
            document.getElementById('motorInputs').style.display = type === 'motor' ? 'block' : 'none';
            document.getElementById('singlePinInputs').style.display = ['light', 'servo'].includes(type) ? 'block' : 'none';
            document.getElementById('sensorInputs').style.display = type === 'sensor' ? 'block' : 'none';
            document.getElementById('ledInputs').style.display = type === 'led' ? 'block' : 'none';
            document.getElementById('testArea').style.display = 'block';
        }

        // Call toggleInputs on page load to set initial state
        toggleInputs();

        function testPart() {
            const type = document.getElementById('type').value;
            const testStatus = document.getElementById('testStatus');
            testStatus.textContent = 'Testing...';

            let testData = { type: type };

            switch (type) {
                case 'motor':
                    testData.directionPin = document.getElementById('directionPin').value;
                    testData.pwmPin = document.getElementById('pwmPin').value;
                    testData.direction = 'forward';
                    testData.speed = 50;
                    testData.duration = 1000;
                    break;
                case 'light':
                case 'servo':
                    testData.pin = document.getElementById('pin').value;
                    testData.duration = 1000;
                    break;
                case 'led':
                    testData.ledPin = document.getElementById('ledPin').value;
                    testData.duration = document.getElementById('duration').value;
                    break;
                case 'sensor':
                    testData.pin = document.getElementById('pin').value;
                    testData.sensorType = document.getElementById('sensorType').value;
                    break;
            }

            axios.post('/parts/test', testData)
                .then(function (response) {
                    testStatus.textContent = 'Test completed: ' + response.data.message;
                })
                .catch(function (error) {
                    console.error('Error testing part:', error);
                    testStatus.textContent = 'Error testing part: ' + (error.response ? error.response.data : error.message);
                });
        }
    </script>
</body>
</html>

================
File: views/parts.ejs
================
<!-- File: views/parts.ejs -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        .button {
            display: inline-block;
            padding: 10px 20px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            font-size: 16px;
            border: none;
            cursor: pointer;
            width: 150px;
        }
        .button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    <div>
        <a href="/parts/new/motor" class="button">Add Motor</a>
        <a href="/parts/new/linear-actuator" class="button">Add Linear Actuator</a>
        <a href="/parts/new/light" class="button">Add Light</a>
        <a href="/parts/new/led" class="button">Add LED</a>
        <a href="/parts/new/servo" class="button">Add Servo</a>
        <a href="/parts/new/sensor" class="button">Add Sensor</a>
        <a href="/parts/os-test" class="button">OS Test</a>
    </div>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Character</th>
                <th>Details</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <% parts.forEach(function(part) { %>
                <tr>
                    <td><%= part.name %></td>
                    <td><%= part.type %></td>
                    <td><%= characters.find(c => c.id === parseInt(part.characterId))?.char_name || 'N/A' %></td>
                    <td>
                        <% if (part.type === 'motor' || part.type === 'linear-actuator') { %>
                            Dir Pin: <%= part.directionPin %>, PWM Pin: <%= part.pwmPin %>
                        <% } else if (part.type === 'light' || part.type === 'led') { %>
                            GPIO Pin: <%= part.gpioPin %>
                        <% } else if (part.type === 'servo') { %>
                            GPIO Pin: <%= part.gpioPin %>, Frequency: <%= part.pwmFrequency %>Hz, Duty Cycle: <%= part.dutyCycle %>%
                        <% } else if (part.type === 'sensor') { %>
                            Type: <%= part.sensorType %>, GPIO Pin: <%= part.gpioPin %>, Active: <%= part.active ? 'Yes' : 'No' %>
                        <% } %>
                    </td>
                    <td>
                        <a href="/parts/<%= part.id %>/edit" class="button">Edit</a>
                        <button onclick="deletePart(<%= part.id %>)" class="button">Delete</button>
                    </td>
                </tr>
            <% }); %>
        </tbody>
    </table>
    <a href="/" class="button">Back to Main Menu</a>

    <script>
        function deletePart(id) {
            if (confirm('Are you sure you want to delete this part?')) {
                $.post('/parts/' + id + '/delete')
                    .done(function() {
                        location.reload();
                    })
                    .fail(function(xhr, status, error) {
                        console.error('Error details:', xhr.responseText);
                        alert('Error deleting part: ' + xhr.status + ' ' + xhr.statusText);
                    });
            }
        }
    </script>
</body>
</html>

================
File: views/scene-form.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
</head>
<body>
    <h1><%= title %></h1>
    <form id="sceneForm" action="<%= action %>" method="POST">
        <input type="hidden" name="id" value="<%= scene.id %>">

        <div>
            <label for="character_id">Character:</label>
            <select id="character_id" name="character_id" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (scene.character_id === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>

        <div>
            <label for="scene_name">Scene Name:</label>
            <input type="text" id="scene_name" name="scene_name" value="<%= scene.scene_name || '' %>" required>
        </div>

        <h2>Steps</h2>
        <div id="steps" class="sortable">
            <% (scene.steps || []).forEach(function(step, index) { %>
                <div class="step" data-index="<%= index %>">
                    <h3>Step <%= index + 1 %>: <%= step.type.charAt(0).toUpperCase() + step.type.slice(1) %></h3>
                    <input type="hidden" name="steps[<%= index %>][type]" value="<%= step.type %>">
                    <input type="text" name="steps[<%= index %>][name]" value="<%= step.name %>" placeholder="Step Name" required>

                    <% if (step.type === 'sound') { %>
                        <select name="steps[<%= index %>][sound_id]" required>
                            <% sounds.forEach(function(sound) { %>
                                <option value="<%= sound.id %>" <%= (step.sound_id == sound.id) ? 'selected' : '' %>>
                                    <%= sound.name %>
                                </option>
                            <% }); %>
                        </select>
                        <label>
                            <input type="checkbox" name="steps[<%= index %>][concurrent]" <%= step.concurrent ? 'checked' : '' %>>
                            Play concurrently
                        </label>
                    <% } else if (['motor', 'linear-actuator', 'servo', 'led', 'light'].includes(step.type)) { %>
                        <select name="steps[<%= index %>][part_id]" required>
                            <% parts.filter(part => part.type === step.type).forEach(function(part) { %>
                                <option value="<%= part.id %>" <%= (step.part_id === part.id) ? 'selected' : '' %>>
                                    <%= part.name %>
                                </option>
                            <% }); %>
                        </select>
                        <input type="number" name="steps[<%= index %>][duration]" value="<%= step.duration || '' %>" placeholder="Duration (ms)" required>
                        
                        <% if (step.type === 'motor' || step.type === 'linear-actuator') { %>
                            <select name="steps[<%= index %>][direction]" required>
                                <option value="forward" <%= step.direction === 'forward' ? 'selected' : '' %>>Forward</option>
                                <option value="backward" <%= step.direction === 'backward' ? 'selected' : '' %>>Backward</option>
                            </select>
                            <input type="number" name="steps[<%= index %>][speed]" value="<%= step.speed || '' %>" placeholder="Speed (0-100)" min="0" max="100" required>
                        <% } else if (step.type === 'led' || step.type === 'light') { %>
                            <select name="steps[<%= index %>][state]" required>
                                <option value="on" <%= step.state === 'on' ? 'selected' : '' %>>On</option>
                                <option value="off" <%= step.state === 'off' ? 'selected' : '' %>>Off</option>
                            </select>
                            <% if (step.type === 'led') { %>
                                <input type="number" name="steps[<%= index %>][brightness]" value="<%= step.brightness || '' %>" placeholder="Brightness (0-100)" min="0" max="100" required>
                            <% } %>
                        <% } %>
                    <% } else if (step.type === 'sensor') { %>
                        <select name="steps[<%= index %>][part_id]" required>
                            <% parts.filter(part => part.type === 'sensor').forEach(function(part) { %>
                                <option value="<%= part.id %>" <%= (step.part_id === part.id) ? 'selected' : '' %>>
                                    <%= part.name %>
                                </option>
                            <% }); %>
                        </select>
                        <input type="number" name="steps[<%= index %>][timeout]" value="<%= step.timeout || 30 %>" placeholder="Timeout (seconds)" required>
                    <% } else if (step.type === 'pause') { %>
                        <input type="number" name="steps[<%= index %>][duration]" value="<%= step.duration || '' %>" placeholder="Duration (ms)" required>
                    <% } %>
                    <button type="button" onclick="removeStep(<%= index %>)">Remove Step</button>
                    <button type="button" onclick="copyStep(<%= index %>)">Copy Step</button>
                </div>
            <% }); %>
        </div>
        
        <button type="button" onclick="addStep('motor')">Add Motor</button>
        <button type="button" onclick="addStep('linear-actuator')">Add Linear Actuator</button>
        <button type="button" onclick="addStep('servo')">Add Servo</button>
        <button type="button" onclick="addStep('led')">Add LED</button>
        <button type="button" onclick="addStep('light')">Add Light</button>
        <button type="button" onclick="addStep('sensor')">Add Sensor</button>
        <button type="button" onclick="addStep('sound')">Add Sound</button>
        <button type="button" onclick="addStep('pause')">Add Pause</button>
        <button type="submit">Save Scene</button>
    </form>

    <a href="/scenes" class="button">Back to Scenes</a>

    <script>
        $(document).ready(function() {
            $('#character_id').change(function() {
                updatePartOptions();
            });

            $(".sortable").sortable({
                update: function(event, ui) {
                    updateStepNumbers();
                }
            });

            // Initial update of part options
            updatePartOptions();
        });

        function updatePartOptions() {
            const characterId = $('#character_id').val();
            $.ajax({
                url: '/characters/' + characterId + '/parts',
                method: 'GET',
                success: function(parts) {
                    window.availableParts = parts;
                    updateStepPartOptions();
                },
                error: function(error) {
                    console.error('Error fetching parts:', error);
                }
            });
        }

        function updateStepPartOptions() {
            $('.step').each(function() {
                const stepType = $(this).find('input[name$="[type]"]').val();
                const partSelect = $(this).find('select[name$="[part_id]"]');
                if (partSelect.length) {
                    const currentValue = partSelect.val();
                    partSelect.empty();
                    window.availableParts.filter(part => part.type === stepType).forEach(part => {
                        partSelect.append($('<option>', {
                            value: part.id,
                            text: part.name,
                            selected: part.id == currentValue
                        }));
                    });
                }
            });
        }

        function addStep(type) {
            const steps = document.getElementById('steps');
            const stepCount = steps.children.length;
            const newStep = document.createElement('div');
            newStep.className = 'step';
            newStep.dataset.index = stepCount;

            let stepContent = `
                <h3>Step ${stepCount + 1}: ${type.charAt(0).toUpperCase() + type.slice(1)}</h3>
                <input type="hidden" name="steps[${stepCount}][type]" value="${type}">
                <input type="text" name="steps[${stepCount}][name]" placeholder="Step Name" required>
            `;

            if (type === 'sound') {
                stepContent += `
                    <select name="steps[${stepCount}][sound_id]" required>
                        <% sounds.forEach(function(sound) { %>
                            <option value="<%= sound.id %>"><%= sound.name %></option>
                        <% }); %>
                    </select>
                    <label>
                        <input type="checkbox" name="steps[${stepCount}][concurrent]">
                        Play concurrently
                    </label>
                `;
            } else if (['motor', 'linear-actuator', 'servo', 'led', 'light'].includes(type)) {
                stepContent += `
                    <select name="steps[${stepCount}][part_id]" required>
                        ${getPartOptions(type)}
                    </select>
                    <input type="number" name="steps[${stepCount}][duration]" placeholder="Duration (ms)" required>
                `;
                if (type === 'motor' || type === 'linear-actuator') {
                    stepContent += `
                        <select name="steps[${stepCount}][direction]" required>
                            <option value="forward">Forward</option>
                            <option value="backward">Backward</option>
                        </select>
                        <input type="number" name="steps[${stepCount}][speed]" placeholder="Speed (0-100)" min="0" max="100" required>
                    `;
                } else if (type === 'led' || type === 'light') {
                    stepContent += `
                        <select name="steps[${stepCount}][state]" required>
                            <option value="on">On</option>
                            <option value="off">Off</option>
                        </select>
                    `;
                    if (type === 'led') {
                        stepContent += `
                            <input type="number" name="steps[${stepCount}][brightness]" placeholder="Brightness (0-100)" min="0" max="100" required>
                        `;
                    }
                }
            } else if (type === 'sensor') {
                stepContent += `
                    <select name="steps[${stepCount}][part_id]" required>
                        ${getPartOptions('sensor')}
                    </select>
                    <input type="number" name="steps[${stepCount}][timeout]" placeholder="Timeout (seconds)" value="30" required>
                `;
            } else if (type === 'pause') {
                stepContent += `
                    <input type="number" name="steps[${stepCount}][duration]" placeholder="Duration (ms)" required>
                `;
            }

            stepContent += `
                <button type="button" onclick="removeStep(${stepCount})">Remove Step</button>
                <button type="button" onclick="copyStep(${stepCount})">Copy Step</button>
            `;

            newStep.innerHTML = stepContent;
            steps.appendChild(newStep);
            updateStepNumbers();
        }

        function getPartOptions(type) {
            if (!window.availableParts) {
                return '<option value="">Please select a character first</option>';
            }
            return window.availableParts
                .filter(part => part.type === type)
                .map(part => `<option value="${part.id}">${part.name}</option>`)
                .join('');
        }

        function removeStep(index) {
            const steps = document.getElementById('steps');
            steps.removeChild(steps.children[index]);
            updateStepNumbers();
        }

        function copyStep(index) {
            const steps = document.getElementById('steps');
            const originalStep = steps.children[index];
            const newStep = originalStep.cloneNode(true);
            const newIndex = steps.children.length;

            // Update the step number and type
            const stepType = newStep.querySelector('input[name$="[type]"]').value;
            newStep.querySelector('h3').textContent = `Step ${newIndex + 1}: ${stepType.charAt(0).toUpperCase() + stepType.slice(1)}`;

            // Update the data-index attribute
            newStep.dataset.index = newIndex;

            // Update the name attribute of all inputs and selects
            newStep.querySelectorAll('input, select').forEach(element => {
                if (element.name) {
                    element.name = element.name.replace(`steps[${index}]`, `steps[${newIndex}]`);
                }
            });

            // Update the onclick attribute of the buttons
            newStep.querySelector('button[onclick^="removeStep"]').setAttribute('onclick', `removeStep(${newIndex})`);
            newStep.querySelector('button[onclick^="copyStep"]').setAttribute('onclick', `copyStep(${newIndex})`);

            // Append the new step to the steps container
            steps.appendChild(newStep);

            // Update the step name to indicate it's a copy
            const nameInput = newStep.querySelector('input[name$="[name]"]');
            nameInput.value = nameInput.value + ' (Copy)';

            updateStepNumbers();
        }

        function updateStepNumbers() {
            const steps = document.getElementById('steps').children;
            for (let i = 0; i < steps.length; i++) {
                const stepType = steps[i].querySelector('input[name$="[type]"]').value;
                steps[i].querySelector('h3').textContent = `Step ${i + 1}: ${stepType.charAt(0).toUpperCase() + stepType.slice(1)}`;
                steps[i].dataset.index = i;
                updateStepInputNames(steps[i], i);
            }
        }

        function updateStepInputNames(stepElement, newIndex) {
            const inputs = stepElement.querySelectorAll('input, select');
            inputs.forEach(input => {
                const name = input.getAttribute('name');
                if (name) {
                    input.setAttribute('name', name.replace(/steps\[\d+\]/, `steps[${newIndex}]`));
                }
            });
        }

        // Ensure all steps are included when submitting the form
        document.getElementById('sceneForm').onsubmit = function() {
            updateStepNumbers();
            return true;
        };
    </script>
</body>
</html>

================
File: views/scene-player.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        #log-box {
            border: 1px solid #00ff00;
            padding: 10px;
            height: 300px;
            overflow-y: scroll;
            background-color: #001100;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            margin-bottom: 20px;
        }
        #controls {
            margin-top: 20px;
        }
        #controls button {
            margin-right: 10px;
        }
        .step {
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #00ff00;
        }
        .current-step {
            background-color: #003300;
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    <h2><%= scene.scene_name %></h2>
    
    <div id="scene-overview">
        <h3>Scene Steps:</h3>
        <% scene.steps.forEach((step, index) => { %>
            <div class="step" id="step-<%= index %>">
                <strong>Step <%= index + 1 %>:</strong> <%= step.name %> (<%= step.type %>)
            </div>
        <% }); %>
    </div>
    
    <div id="log-box"></div>
    
    <div id="controls">
        <button id="backward-btn">Backward</button>
        <button id="run-btn">Run</button>
        <button id="forward-btn">Forward</button>
        <button id="stop-btn">Stop All Steps</button>
    </div>
    
    <a href="/scenes" class="button">Back to Scenes</a>

    <script>
        const sceneData = <%- JSON.stringify(scene) %>;
    </script>
    <script src="/scripts/scene-player.js"></script>
</body>
</html>

================
File: views/scenes.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <h1><%= title %></h1>
    <a href="/scenes/new" class="button">Add New Scene</a>
    <table>
        <thead>
            <tr>
                <th>Scene Name</th>
                <th>Character</th>
                <th>Steps</th>
                <th>Actions</th>
                <th>Operations</th>
            </tr>
        </thead>
        <tbody>
            <% scenes.forEach(function(scene) { %>
                <tr>
                    <td><%= scene.scene_name %></td>
                    <td><%= characters.find(c => c.id === scene.character_id)?.char_name || 'N/A' %></td>
                    <td><%= scene.steps ? scene.steps.length : 0 %></td>
                    <td>
                        <% if (scene.steps) { %>
                            <ul>
                                <% scene.steps.forEach(function(step) { %>
                                    <li><%= step.name %></li>
                                <% }); %>
                            </ul>
                        <% } %>
                    </td>
                    <td>
                        <a href="/scenes/<%= scene.id %>/edit" class="button edit-scene" data-id="<%= scene.id %>">Edit</a>
                        <button onclick="deleteScene('<%= scene.id %>')" class="button">Delete</button>
                        <a href="/scenes/<%= scene.id %>" class="button play-scene" data-id="<%= scene.id %>">Run</a>
                    </td>
                </tr>
            <% }); %>
        </tbody>
    </table>
    <a href="/" class="button">Back to Main Menu</a>

    <script>
        function deleteScene(id) {
            console.log('Attempting to delete scene:', id);
            if (confirm('Are you sure you want to delete this scene?')) {
                $.ajax({
                    url: '/scenes/' + id,
                    type: 'DELETE',
                    success: function(result) {
                        console.log('Scene deleted successfully');
                        location.reload();
                    },
                    error: function(xhr, status, error) {
                        console.error('Error deleting scene:', error);
                        console.error('Server response:', xhr.responseText);
                        alert('Error deleting scene: ' + error);
                    }
                });
            }
        }

        $(document).ready(function() {
            $('.edit-scene').on('click', function(e) {
                e.preventDefault();
                var id = $(this).data('id');
                var url = '/scenes/' + id + '/edit';
                console.log('Attempting to edit scene:', id);
                console.log('Edit URL:', url);
                window.location.href = url;
            });

            $('.play-scene').on('click', function(e) {
                e.preventDefault();
                var id = $(this).data('id');
                var url = '/scenes/' + id;
                console.log('Attempting to play scene:', id);
                console.log('Play URL:', url);
                window.location.href = url;
            });
        });
    </script>
</body>
</html>

================
File: views/sound-form.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
</head>
<body>
    <h1><%= title %></h1>
    <form id="sceneForm" action="<%= action %>" method="POST">
        <input type="hidden" name="id" value="<%= scene.id %>">
        
        <div>
            <label for="character_id">Character:</label>
            <select id="character_id" name="character_id" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (scene.character_id === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="scene_name">Scene Name:</label>
            <input type="text" id="scene_name" name="scene_name" value="<%= scene.scene_name || '' %>" required>
        </div>

        <h2>Steps</h2>
        <div id="steps" class="sortable">
            <% (scene.steps || []).forEach(function(step, index) { %>
                <div class="step" data-index="<%= index %>">
                    <h3>Step <%= index + 1 %>: <%= step.type.charAt(0).toUpperCase() + step.type.slice(1) %></h3>
                    <input type="hidden" name="steps[<%= index %>][type]" value="<%= step.type %>">
                    <input type="text" name="steps[<%= index %>][name]" value="<%= step.name %>" placeholder="Step Name" required>
                    <% if (step.type === 'sound') { %>
                        <select name="steps[<%= index %>][sound_id]" required>
                            <% sounds.forEach(function(sound) { %>
                                <option value="<%= sound.id %>" <%= (step.sound_id == sound.id) ? 'selected' : '' %>><%= sound.name %></option>
                            <% }); %>
                        </select>
                    <% } else if (['motor', 'linear-actuator', 'servo', 'led', 'light'].includes(step.type)) { %>
                        <select name="steps[<%= index %>][part_id]" required>
                            <% parts.filter(part => part.type === step.type).forEach(function(part) { %>
                                <option value="<%= part.id %>" <%= (step.part_id === part.id) ? 'selected' : '' %>><%= part.name %></option>
                            <% }); %>
                        </select>
                        <input type="number" name="steps[<%= index %>][duration]" value="<%= step.duration || '' %>" placeholder="Duration (ms)" required>
                        <% if (step.type === 'motor' || step.type === 'linear-actuator') { %>
                            <select name="steps[<%= index %>][direction]" required>
                                <option value="forward" <%= step.direction === 'forward' ? 'selected' : '' %>>Forward</option>
                                <option value="backward" <%= step.direction === 'backward' ? 'selected' : '' %>>Backward</option>
                            </select>
                            <input type="number" name="steps[<%= index %>][speed]" value="<%= step.speed || '' %>" placeholder="Speed (0-100)" min="0" max="100" required>
                        <% } else if (step.type === 'led' || step.type === 'light') { %>
                            <select name="steps[<%= index %>][state]" required>
                                <option value="on" <%= step.state === 'on' ? 'selected' : '' %>>On</option>
                                <option value="off" <%= step.state === 'off' ? 'selected' : '' %>>Off</option>
                            </select>
                            <% if (step.type === 'led') { %>
                                <input type="number" name="steps[<%= index %>][brightness]" value="<%= step.brightness || '' %>" placeholder="Brightness (0-100)" min="0" max="100" required>
                            <% } %>
                        <% } %>
                    <% } else if (step.type === 'sensor') { %>
                        <select name="steps[<%= index %>][part_id]" required>
                            <% parts.filter(part => part.type === 'sensor').forEach(function(part) { %>
                                <option value="<%= part.id %>" <%= (step.part_id === part.id) ? 'selected' : '' %>><%= part.name %></option>
                            <% }); %>
                        </select>
                        <input type="number" name="steps[<%= index %>][timeout]" value="<%= step.timeout || 30 %>" placeholder="Timeout (seconds)" required>
                    <% } else if (step.type === 'pause') { %>
                        <input type="number" name="steps[<%= index %>][duration]" value="<%= step.duration || '' %>" placeholder="Duration (ms)" required>
                    <% } %>
                    <label>
                        <input type="checkbox" name="steps[<%= index %>][concurrent]" <%= step.concurrent ? 'checked' : '' %>>
                        Run Concurrently
                    </label>
                    <button type="button" onclick="removeStep(<%= index %>)">Remove Step</button>
                    <button type="button" onclick="copyStep(<%= index %>)">Copy Step</button>
                </div>
            <% }); %>
        </div>
        
        <button type="button" onclick="addStep('motor')">Add Motor</button>
        <button type="button" onclick="addStep('linear-actuator')">Add Linear Actuator</button>
        <button type="button" onclick="addStep('servo')">Add Servo</button>
        <button type="button" onclick="addStep('led')">Add LED</button>
        <button type="button" onclick="addStep('light')">Add Light</button>
        <button type="button" onclick="addStep('sensor')">Add Sensor</button>
        <button type="button" onclick="addStep('sound')">Add Sound</button>
        <button type="button" onclick="addStep('pause')">Add Pause</button>
        <button type="submit">Save Scene</button>
    </form>

    <a href="/scenes" class="button">Back to Scenes</a>

    <script>
        $(document).ready(function() {
            $('#character_id').change(function() {
                updatePartOptions();
            });

            $(".sortable").sortable({
                update: function(event, ui) {
                    updateStepNumbers();
                }
            });

            // Initial update of part options
            updatePartOptions();
        });

        function updatePartOptions() {
            const characterId = $('#character_id').val();
            $.ajax({
                url: '/characters/' + characterId + '/parts',
                method: 'GET',
                success: function(parts) {
                    window.availableParts = parts;
                    updateStepPartOptions();
                },
                error: function(error) {
                    console.error('Error fetching parts:', error);
                }
            });
        }

        function updateStepPartOptions() {
            $('.step').each(function() {
                const stepType = $(this).find('input[name$="[type]"]').val();
                const partSelect = $(this).find('select[name$="[part_id]"]');
                if (partSelect.length) {
                    const currentValue = partSelect.val();
                    partSelect.empty();
                    window.availableParts.filter(part => part.type === stepType).forEach(part => {
                        partSelect.append($('<option>', {
                            value: part.id,
                            text: part.name,
                            selected: part.id == currentValue
                        }));
                    });
                }
            });
        }

        function addStep(type) {
            const steps = document.getElementById('steps');
            const stepCount = steps.children.length;
            const newStep = document.createElement('div');
            newStep.className = 'step';
            newStep.dataset.index = stepCount;

            let stepContent = `
                <h3>Step ${stepCount + 1}: ${type.charAt(0).toUpperCase() + type.slice(1)}</h3>
                <input type="hidden" name="steps[${stepCount}][type]" value="${type}">
                <input type="text" name="steps[${stepCount}][name]" placeholder="Step Name" required>
            `;

            if (type === 'sound') {
                stepContent += `
                    <select name="steps[${stepCount}][sound_id]" required>
                        <% sounds.forEach(function(sound) { %>
                            <option value="<%= sound.id %>"><%= sound.name %></option>
                        <% }); %>
                    </select>
                `;
            } else if (['motor', 'linear-actuator', 'servo', 'led', 'light'].includes(type)) {
                stepContent += `
                    <select name="steps[${stepCount}][part_id]" required>
                        ${getPartOptions(type)}
                    </select>
                    <input type="number" name="steps[${stepCount}][duration]" placeholder="Duration (ms)" required>
                `;
                if (type === 'motor' || type === 'linear-actuator') {
                    stepContent += `
                        <select name="steps[${stepCount}][direction]" required>
                            <option value="forward">Forward</option>
                            <option value="backward">Backward</option>
                        </select>
                        <input type="number" name="steps[${stepCount}][speed]" placeholder="Speed (0-100)" min="0" max="100" required>
                    `;
                } else if (type === 'led' || type === 'light') {
                    stepContent += `
                        <select name="steps[${stepCount}][state]" required>
                            <option value="on">On</option>
                            <option value="off">Off</option>
                        </select>
                    `;
                    if (type === 'led') {
                        stepContent += `
                            <input type="number" name="steps[${stepCount}][brightness]" placeholder="Brightness (0-100)" min="0" max="100" required>
                        `;
                    }
                }
            } else if (type === 'sensor') {
                stepContent += `
                    <select name="steps[${stepCount}][part_id]" required>
                        ${getPartOptions('sensor')}
                    </select>
                    <input type="number" name="steps[${stepCount}][timeout]" placeholder="Timeout (seconds)" value="30" required>
                `;
            } else if (type === 'pause') {
                stepContent += `
                    <input type="number" name="steps[${stepCount}][duration]" placeholder="Duration (ms)" required>
                `;
            }

            stepContent += `
                <label>
                    <input type="checkbox" name="steps[${stepCount}][concurrent]">
                    Run Concurrently
                </label>
                <button type="button" onclick="removeStep(${stepCount})">Remove Step</button>
                <button type="button" onclick="copyStep(${stepCount})">Copy Step</button>
            `;

            newStep.innerHTML = stepContent;
            steps.appendChild(newStep);
            updateStepNumbers();
        }

        function getPartOptions(type) {
            if (!window.availableParts) {
                return '<option value="">Please select a character first</option>';
            }
            return window.availableParts
                .filter(part => part.type === type)
                .map(part => `<option value="${part.id}">${part.name}</option>`)
                .join('');
        }

        function removeStep(index) {
            const steps = document.getElementById('steps');
            steps.removeChild(steps.children[index]);
            updateStepNumbers();
        }

        function copyStep(index) {
            const steps = document.getElementById('steps');
            const originalStep = steps.children[index];
            const newStep = originalStep.cloneNode(true);
            const newIndex = steps.children.length;

            // Update the step number and type
            const stepType = newStep.querySelector('input[name$="[type]"]').value;
            newStep.querySelector('h3').textContent = `Step ${newIndex + 1}: ${stepType.charAt(0).toUpperCase() + stepType.slice(1)}`;

            // Update the data-index attribute
            newStep.dataset.index = newIndex;

            // Update the name attribute of all inputs and selects
            newStep.querySelectorAll('input, select').forEach(element => {
                if (element.name) {
                    element.name = element.name.replace(`steps[${index}]`, `steps[${newIndex}]`);
                }
            });

            // Update the onclick attribute of the buttons
            newStep.querySelector('button[onclick^="removeStep"]').setAttribute('onclick', `removeStep(${newIndex})`);
            newStep.querySelector('button[onclick^="copyStep"]').setAttribute('onclick', `copyStep(${newIndex})`);

            // Append the new step to the steps container
            steps.appendChild(newStep);

            // Update the step name to indicate it's a copy
            const nameInput = newStep.querySelector('input[name$="[name]"]');
            nameInput.value = nameInput.value + ' (Copy)';

            updateStepNumbers();
        }

        function updateStepNumbers() {
            const steps = document.getElementById('steps').children;
            for (let i = 0; i < steps.length; i++) {
                const stepType = steps[i].querySelector('input[name$="[type]"]').value;
                steps[i].querySelector('h3').textContent = `Step ${i + 1}: ${stepType.charAt(0).toUpperCase() + stepType.slice(1)}`;
                steps[i].dataset.index = i;
                updateStepInputNames(steps[i], i);
            }
        }

        function updateStepInputNames(stepElement, newIndex) {
            const inputs = stepElement.querySelectorAll('input, select');
            inputs.forEach(input => {
                const name = input.getAttribute('name');
                if (name) {
                    input.setAttribute('name', name.replace(/steps\[\d+\]/, `steps[${newIndex}]`));
                }
            });
        }

        // Ensure all steps are included when submitting the form
        document.getElementById('sceneForm').onsubmit = function() {
            updateStepNumbers();
            return true;
        };
    </script>
</body>
</html>

================
File: views/sounds.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <h1><%= title %></h1>
    <a href="/sounds/new" class="button">Add New Sound</a>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Filename</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <% sounds.forEach(function(sound) { %>
                <tr>
                    <td><%= sound.name %></td>
                    <td><%= sound.filename %></td>
                    <td>
                        <button onclick="playOnCharacter(<%= sound.id %>)">Play (on Character)</button>
                        <button onclick="playLocal('<%= sound.filename %>')">Play (local)</button>
                        <a href="/sounds/<%= sound.id %>/edit" class="button">Edit</a>
                        <button onclick="deleteSound(<%= sound.id %>)">Delete</button>
                    </td>
                </tr>
            <% }); %>
        </tbody>
    </table>
    <a href="/" class="button">Back to Main Menu</a>

    <div id="soundInfo"></div>
    <div id="errorInfo" style="color: red;"></div>

    <script>
        function playLocal(filename) {
            const audio = new Audio(`/sounds/${filename}`);
            audio.play().catch(error => {
                console.error('Error playing sound locally:', error);
                displayError('Error playing sound locally: ' + error.message);
            });
        }

        function playOnCharacter(soundId) {
            console.log('Attempting to play sound with ID:', soundId);
            fetch(`/sounds/${soundId}/play`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => { throw err; });
                }
                return response.json();
            })
            .then(data => {
                console.log('Server response:', data);
                const soundInfo = `
                    <h3>Sound Details:</h3>
                    <p>Message: ${data.message}</p>
                    <p>Python Output: ${data.pythonOutput}</p>
                    <p>Executed Command: ${data.command}</p>
                `;
                document.getElementById('soundInfo').innerHTML = soundInfo;
                document.getElementById('errorInfo').innerHTML = '';
            })
            .catch(error => {
                console.error('Error playing sound on character:', error);
                let errorMessage = 'Error playing sound on character: ';
                if (error.error) {
                    errorMessage += error.error;
                    if (error.details) errorMessage += ' - ' + error.details;
                    if (error.output) errorMessage += ' (Output: ' + error.output + ')';
                    if (error.errorOutput) errorMessage += ' (Error Output: ' + error.errorOutput + ')';
                    if (error.command) errorMessage += ' (Command: ' + error.command + ')';
                } else {
                    errorMessage += error.toString();
                }
                displayError(errorMessage);
            });
        }

        function deleteSound(id) {
            if (confirm('Are you sure you want to delete this sound?')) {
                fetch('/sounds/' + id + '/delete', { method: 'POST' })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => { throw err; });
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Delete sound response:', data);
                    location.reload();
                })
                .catch(error => {
                    console.error('Error deleting sound:', error);
                    let errorMessage = 'Error deleting sound: ';
                    if (error.error) {
                        errorMessage += error.error;
                        if (error.details) errorMessage += ' - ' + error.details;
                    } else {
                        errorMessage += error.toString();
                    }
                    displayError(errorMessage);
                });
            }
        }

        function displayError(message) {
            document.getElementById('errorInfo').innerHTML = message;
            document.getElementById('soundInfo').innerHTML = '';
        }
    </script>
</body>
</html>

================
File: .gitignore
================
repopack-output.txt
motor_control.log
*.log
mjpg-streamer/
node_modules/

================
File: app.js
================
const express = require('express');
const path = require('path');
const http = require('http');
const { exec } = require('child_process');
const app = express();
const server = http.createServer(app);
const port = 3000;
const audio = require('./scripts/audio');
const fs = require('fs');
const os = require('os');

// Import routes
const ledRoutes = require('./routes/ledRoutes');
const lightRoutes = require('./routes/lightRoutes');
const servoRoutes = require('./routes/servoRoutes');
const sensorRoutes = require('./routes/sensorRoutes');
const partRoutes = require('./routes/partRoutes');
const sceneRoutes = require('./routes/sceneRoutes');
const characterRoutes = require('./routes/characterRoutes');
const soundRoutes = require('./routes/soundRoutes');
const linearActuatorRoutes = require('./routes/linearActuatorRoutes');
const activeModeRoutes = require('./routes/activeModeRoutes');

// Basic Express setup
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.set('view engine', 'ejs');
app.use(express.static('public'));
app.use('/scripts', express.static(path.join(__dirname, 'scripts')));

// Routes
app.use('/parts/led', ledRoutes);
app.use('/parts/light', lightRoutes);
app.use('/parts/servo', servoRoutes);
app.use('/parts/sensor', sensorRoutes);
app.use('/parts/linear-actuator', linearActuatorRoutes);
app.use('/parts', partRoutes);
app.use('/scenes', sceneRoutes);
app.use('/characters', characterRoutes);
app.use('/sounds', soundRoutes);
app.use('/active-mode', activeModeRoutes);

// Main menu route
app.get('/', (req, res) => {
    res.render('index', { title: 'MonsterBox Control Panel' });
});

// Audio routes
app.post('/audio/set-mic-volume', (req, res) => {
    res.status(200).json({ success: true, message: 'Mic volume control not implemented' });
});

// Function to start mjpg-streamer
function startMjpgStreamer() {
    exec('sudo mjpg_streamer -i "input_uvc.so" -o "output_http.so -w /usr/local/share/mjpg-streamer/www -p 8080"', (error, stdout, stderr) => {
        if (error) {
            console.error(`Error starting mjpg-streamer: ${error}`);
            return;
        }
        console.log(`mjpg-streamer started: ${stdout}`);
    });
}

// Try to start mjpg-streamer when the server starts
startMjpgStreamer();

// Function to get the local IP address
function getLocalIpAddress() {
    const interfaces = os.networkInterfaces();
    for (const devName in interfaces) {
        const iface = interfaces[devName];
        for (let i = 0; i < iface.length; i++) {
            const alias = iface[i];
            if (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.internal) {
                return alias.address;
            }
        }
    }
    return '127.0.0.1';  // Fallback to localhost if no other IP is found
}

// Proxy route for mjpeg-streamer with error handling and fallback
app.use('/stream', (req, res) => {
    const fallbackImagePath = path.join(__dirname, 'public', 'images', 'no-stream.jpg');
    const localIpAddress = getLocalIpAddress();
    
    const proxyRequest = http.request(
        {
            hostname: localIpAddress,
            port: 8080,
            path: '/?action=stream',
            method: req.method,
            headers: req.headers,
            timeout: 5000 // 5 seconds timeout
        },
        (proxyResponse) => {
            res.writeHead(proxyResponse.statusCode, proxyResponse.headers);
            proxyResponse.pipe(res);
        }
    );

    proxyRequest.on('error', (error) => {
        console.error('Proxy request error:', error);
        // Send fallback image
        if (!res.headersSent) {
            res.writeHead(200, { 'Content-Type': 'image/jpeg' });
            fs.createReadStream(fallbackImagePath).pipe(res);
        }
    });

    proxyRequest.on('timeout', () => {
        proxyRequest.destroy();
        console.error('Proxy request timeout');
        // Send fallback image
        if (!res.headersSent) {
            res.writeHead(200, { 'Content-Type': 'image/jpeg' });
            fs.createReadStream(fallbackImagePath).pipe(res);
        }
    });

    req.pipe(proxyRequest);
});

// Start the audio stream
audio.startStream(server);

// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    if (!res.headersSent) {
        res.status(500).send('Something broke!');
    }
});

// Start the server
server.listen(port, () => {
    console.log(`MonsterBox server running at http://localhost:${port}`);
    console.log(`Local IP address: ${getLocalIpAddress()}`);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

module.exports = app;

================
File: package.json
================
{
  "name": "monsterbox",
  "version": "1.0.0",
  "description": "A refactored scene builder application for managing scenes and steps.",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "test": "mocha --recursive || true"
  },
  "dependencies": {
    "axios": "^0.21.1",
    "body-parser": "^1.19.0",
    "ejs": "^3.1.10",
    "express": "^4.19.2",
    "hls.js": "^1.5.15",
    "i2c-bus": "^5.2.3",
    "multer": "^1.4.5-lts.1",
    "node-aplay": "^1.0.3",
    "node-mpg123": "^1.0.2-0023",
    "node-schedule": "^2.1.0",
    "onoff": "^6.0.3",
    "pca9685": "^5.0.0",
    "play-sound": "^1.1.6",
    "replit-auth": "^5.0.3",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "chai": "^4.5.0",
    "mocha": "^9.2.2",
    "supertest": "^6.1.6"
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/your-repo/monsterbox.git"
  },
  "keywords": [
    "scene",
    "builder",
    "express",
    "ejs",
    "nodejs"
  ],
  "author": "Your Name",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/your-repo/monsterbox/issues"
  },
  "homepage": "https://github.com/your-repo/monsterbox#readme"
}

================
File: README.md
================
Certainly! I'll update the README.md to include information about the hardware components. Here's the revised version:

```markdown
# MonsterBox

MonsterBox is an animatronic automation package designed to control and manage various components of interactive Halloween displays or haunted house attractions. It provides a web-based interface for creating, editing, and executing scenes that control different types of hardware components.

## Description

MonsterBox allows users to:
- Create and manage characters
- Add and configure various types of parts (motors, LEDs, lights, sensors, etc.)
- Design complex scenes with multiple steps
- Play sounds
- Execute scenes to control the animatronic components

The application is built with a Node.js backend using Express.js and EJS templates for the frontend. It's designed to run on a Raspberry Pi or similar device that can interface with GPIO pins to control physical hardware.

## Hardware Components

MonsterBox is designed to work with the following hardware:

1. **Raspberry Pi 4B**: The main controller running the MonsterBox software.
2. **Servos**: 
   - Standard servos (e.g., SG90, MG996R)
   - Continuous rotation servos
3. **Motors**:
   - DC motors with H-bridge drivers (e.g., L298N)
   - Stepper motors with appropriate drivers
4. **Linear Actuators**: 12V DC actuators for linear motion
5. **LEDs**: Both individual LEDs and LED strips (e.g., WS2812B)
6. **Lights**: Relay-controlled AC or DC lights
7. **Sensors**:
   - PIR motion sensors
   - Ultrasonic distance sensors (HC-SR04)
   - Sound sensors
8. **Audio**: 
   - USB audio adapter
   - Speakers or amplifier module

## Main Software Components

1. **Characters**: Represent the animatronic figures or props in your display.
2. **Parts**: Various types of controllable components (motors, LEDs, sensors, etc.) that can be attached to characters.
3. **Scenes**: Sequences of steps that define how parts should behave over time.
4. **Sounds**: Audio files that can be played as part of a scene.

## Project Structure

- `/routes`: Contains Express.js route handlers for different sections of the application.
- `/scripts`: Python scripts for controlling hardware components via GPIO.
- `/services`: JavaScript modules for data management and business logic.
- `/views`: EJS templates for rendering the web interface.
- `/public`: Static assets like CSS files.
- `/data`: JSON files for storing application data.

## Key Files

- `app.js`: The main Express.js application file.
- `package.json`: Defines project dependencies and scripts.
- `README.md`: This file, containing project documentation.

## Technology Stack

- Backend: Node.js with Express.js
- Frontend: EJS templates with custom CSS
- Database: JSON files (for simplicity and portability)
- Hardware Control: Python scripts using RPi.GPIO library

## Setup and Installation

1. Set up your Raspberry Pi 4B with the latest Raspberry Pi OS.
2. Install Node.js and npm on your Raspberry Pi.
3. Clone this repository to your Raspberry Pi.
4. Navigate to the project directory and run `npm install` to install dependencies.
5. Ensure Python 3 is installed and install the RPi.GPIO library: `pip3 install RPi.GPIO`.
6. Connect your hardware components to the appropriate GPIO pins on the Raspberry Pi.
7. Start the application by running `npm start`.

## Usage

1. Access the MonsterBox interface by opening a web browser and navigating to `http://<raspberry-pi-ip>:3000`.
2. Create characters to represent your animatronic figures.
3. Add parts to your characters, configuring them with the appropriate GPIO pins.
4. Create scenes by adding a series of steps that control your parts.
5. Use the scene player to test and run your scenes.

## Contributing

Contributions to MonsterBox are welcome! Please feel free to submit pull requests or create issues for bugs and feature requests.

## License

This project is licensed under the MIT License.

## Acknowledgments

Created by ARW (8.15.2024)

Special thanks to the Raspberry Pi Foundation and the open-source community for providing the tools and libraries that make this project possible.
```

This updated README now includes information about the specific hardware components that MonsterBox is designed to work with, as well as more detailed setup instructions. It provides a comprehensive overview of both the software and hardware aspects of the project.
