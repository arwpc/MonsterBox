================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-15T01:55:34.887Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    node.js.yml
controllers/
  partController.js
  sceneController.js
  scenePlayerController.js
  servoController.js
  soundController.js
data/
  characters.json
  parts.json
  scenes.json
  sounds.json
mjpg-streamer/
  .git/
    hooks/
      applypatch-msg.sample
      commit-msg.sample
      fsmonitor-watchman.sample
      post-update.sample
      pre-applypatch.sample
      pre-commit.sample
      pre-merge-commit.sample
      pre-push.sample
      pre-rebase.sample
      pre-receive.sample
      prepare-commit-msg.sample
      push-to-checkout.sample
      update.sample
    info/
      exclude
    logs/
      refs/
        heads/
          master
        remotes/
          origin/
            HEAD
      HEAD
    refs/
      heads/
        master
      remotes/
        origin/
          HEAD
    config
    description
    HEAD
    packed-refs
  mjpg-streamer-experimental/
    cmake/
      FindGphoto2.cmake
      FindProtobuf-c.cmake
      FindZeroMQ.cmake
      mjpg_streamer_utils.cmake
    plugins/
      input_control/
        dynctrl.c
        dynctrl.h
        input_uvc.c
        Makefile
        uvc_compat.h
        uvcvideo.h
      input_file/
        CMakeLists.txt
        input_file.c
        Makefile
      input_http/
        CMakeLists.txt
        input_http.c
        misc.c
        misc.h
        mjpg-proxy.c
        mjpg-proxy.h
        version.h
      input_opencv/
        filters/
          cvfilter_cpp/
            CMakeLists.txt
            filter_cpp.cpp
            README.md
          cvfilter_py/
            cmake/
              FindNumpy.cmake
            CMakeLists.txt
            conversion.cpp
            conversion.h
            example_filter.py
            filter_py.cpp
            README.md
        CMakeLists.txt
        input_opencv.cpp
        input_opencv.h
        README.md
      input_ptp2/
        CMakeLists.txt
        input_ptp2.c
        input_ptp2.h
      input_raspicam/
        mmal/
          core/
            CMakeLists.txt
            mmal_buffer_private.h
            mmal_buffer.c
            mmal_clock_private.h
            mmal_clock.c
            mmal_component_private.h
            mmal_component.c
            mmal_core_private.h
            mmal_events.c
            mmal_format.c
            mmal_logging.c
            mmal_pool.c
            mmal_port_clock.c
            mmal_port_private.h
            mmal_port.c
            mmal_queue.c
          util/
            CMakeLists.txt
            mmal_component_wrapper.c
            mmal_component_wrapper.h
            mmal_connection.c
            mmal_connection.h
            mmal_default_components.h
            mmal_graph.c
            mmal_graph.h
            mmal_il.c
            mmal_il.h
            mmal_list.c
            mmal_list.h
            mmal_param_convert.c
            mmal_param_convert.h
            mmal_util_params.c
            mmal_util_params.h
            mmal_util_rational.c
            mmal_util_rational.h
            mmal_util.c
            mmal_util.h
          vc/
            CMakeLists.txt
            mmal_vc_api_drm.c
            mmal_vc_api_drm.h
            mmal_vc_api.c
            mmal_vc_api.h
            mmal_vc_client_priv.h
            mmal_vc_client.c
            mmal_vc_msgnames.c
            mmal_vc_msgnames.h
            mmal_vc_msgs.h
            mmal_vc_opaque_alloc.c
            mmal_vc_opaque_alloc.h
            mmal_vc_shm.c
            mmal_vc_shm.h
          CMakeLists.txt
          mmal_buffer.h
          mmal_clock.h
          mmal_common.h
          mmal_component.h
          mmal_encodings.h
          mmal_events.h
          mmal_format.h
          mmal_logging.h
          mmal_metadata.h
          mmal_parameters_audio.h
          mmal_parameters_camera.h
          mmal_parameters_clock.h
          mmal_parameters_common.h
          mmal_parameters_video.h
          mmal_parameters.h
          mmal_pool.h
          mmal_port.h
          mmal_queue.h
          mmal_types.h
          mmal.h
        CMakeLists.txt
        input_raspicam.c
        RaspiCamControl.c
        RaspiCamControl.h
        README.md
      input_testpicture/
        input_testpicture.c
        Makefile
        testpictures.h
      input_uvc/
        CMakeLists.txt
        dynctrl.c
        dynctrl.h
        huffman.h
        input_uvc.c
        jpeg_utils.c
        jpeg_utils.h
        README.md
        uvc_compat.h
        uvcvideo.h
        v4l2uvc.c
        v4l2uvc.h
      output_autofocus/
        Makefile
        output_autofocus.c
        processJPEG_onlyCenter.c
        processJPEG_onlyCenter.h
      output_file/
        examples/
          change_filename.sh
          ftp_upload.sh
          show_filename.sh
        CMakeLists.txt
        output_file.c
        output_file.h
      output_http/
        CMakeLists.txt
        httpd.c
        httpd.h
        output_http.c
        README.md
      output_rtsp/
        CMakeLists.txt
        output_rtsp.c
      output_udp/
        CMakeLists.txt
        output_udp.c
      output_viewer/
        CMakeLists.txt
        output_viewer.c
        README.md
      output_zmqserver/
        CMakeLists.txt
        output_zmqserver.c
        output_zmqserver.h
        package.proto
        README.md
      input.h
      output.h
    scripts/
      make_deb.sh
      mjpg-streamer.default
      mjpg-streamer.init
      mjpg-streamer.service
      README.md
    www/
      control.htm
      fix.css
      functions.js
      index.html
      java_control.html
      java_simple.html
      java.html
      javascript_motiondetection.html
      javascript_simple.html
      javascript.html
      jquery.js
      jquery.rotate.js
      jquery.ui.core.min.js
      jquery.ui.custom.css
      jquery.ui.tabs.min.js
      jquery.ui.widget.min.js
      JQuerySpinBtn.css
      JQuerySpinBtn.js
      LICENSE.txt
      static_simple.html
      static.html
      stream_simple.html
      stream.html
      style.css
      videolan.html
    CMakeLists.txt
    docker-start.sh
    Dockerfile
    LICENSE
    makedeb.sh
    Makefile
    mjpg_streamer.c
    mjpg_streamer.h
    mjpg_streamer@.service
    postinstall.sh
    README.md
    start.sh
    TODO
    utils.c
    utils.h
  .gitignore
  README.md
public/
  css/
    style.css
  stream/
    playlist.m3u8
    stream.m3u8
routes/
  activeModeRoutes.js
  characterRoutes.js
  ledRoutes.js
  lightRoutes.js
  linearActuatorRoutes.js
  partRoutes.js
  sceneRoutes.js
  sensorRoutes.js
  servoRoutes.js
  soundRoutes.js
scripts/
  active-mode.js
  audio.js
  camera.js
  led_control.py
  light_control.py
  linear_actuator_control.py
  motor_control.py
  scene-player.js
  sensor_control.py
  servo_control.py
  sound_player.py
  test_sensor.py
services/
  characterService.js
  partService.js
  sceneService.js
  soundService.js
views/
  part-forms/
    led.ejs
    light.ejs
    linear-actuator.ejs
    motor-control.ejs
    motor.ejs
    sensor.ejs
    servo.ejs
  active-mode.ejs
  character-form.ejs
  characters.ejs
  error.ejs
  index.ejs
  os-test.ejs
  part-form.ejs
  parts.ejs
  scene-form.ejs
  scene-player.ejs
  scenes.ejs
  sound-form.ejs
  sounds.ejs
.gitignore
app.js
package.json
README.md

================================================================
Repository Files
================================================================

================
File: .github/workflows/node.js.yml
================
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs

name: Node.js CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x, 22.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/

    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    - run: npm ci
    - run: npm run build --if-present
    - run: npm test

================
File: controllers/partController.js
================
// File: controllers/partController.js

const { spawn } = require('child_process');
const path = require('path');

let runningProcesses = [];

function executePartAction(step, sendEvent) {
    return new Promise(async (resolve, reject) => {
        try {
            const part = await getPartById(step.part_id);
            if (!part) {
                throw new Error(`Part not found for ID: ${step.part_id}`);
            }

            let scriptPath;
            let args;

            switch (part.type) {
                case 'motor':
                case 'linear-actuator':
                    scriptPath = path.resolve(__dirname, '..', 'scripts', 'motor_control.py');
                    args = [step.direction, step.speed.toString(), step.duration.toString(), part.directionPin.toString(), part.pwmPin.toString()];
                    break;
                case 'led':
                case 'light':
                    scriptPath = path.resolve(__dirname, '..', 'scripts', 'light_control.py');
                    args = [part.gpioPin.toString(), step.state, step.duration.toString()];
                    if (part.type === 'led' && step.brightness) {
                        args.push(step.brightness.toString());
                    }
                    break;
                case 'servo':
                    scriptPath = path.resolve(__dirname, '..', 'scripts', 'servo_control.py');
                    args = [
                        part.gpioPin.toString(),
                        step.angle.toString(),
                        step.speed.toString(),
                        step.duration.toString(),
                        part.pwmFrequency.toString(),
                        part.dutyCycle.toString()
                    ];
                    break;
                default:
                    throw new Error(`Unsupported part type: ${part.type}`);
            }

            const process = spawn('python3', [scriptPath, ...args]);
            runningProcesses.push(process);

            process.stdout.on('data', (data) => {
                sendEvent({ message: `${part.type} output: ${data}` });
            });

            process.stderr.on('data', (data) => {
                sendEvent({ error: `${part.type} error: ${data}` });
            });

            process.on('close', (code) => {
                const index = runningProcesses.indexOf(process);
                if (index > -1) {
                    runningProcesses.splice(index, 1);
                }
                if (code === 0) {
                    sendEvent({ message: `${part.type} action completed: ${step.name}` });
                    resolve();
                } else {
                    reject(new Error(`${part.type} process exited with code ${code}`));
                }
            });
        } catch (error) {
            reject(error);
        }
    });
}

function stopAllParts() {
    runningProcesses.forEach(process => {
        if (process.kill) {
            process.kill('SIGKILL');
        }
    });
    runningProcesses = [];
    spawn('pkill', ['-9', 'python3']);
}

async function getPartById(partId) {
    // This is a placeholder. You should implement the actual logic to fetch the part from your data source.
    // For now, we'll return a mock part object.
    return {
        id: partId,
        type: 'led',
        gpioPin: 17,
        // Add other necessary properties based on your part schema
    };
}

module.exports = {
    executePartAction,
    stopAllParts
};

================
File: controllers/sceneController.js
================
// File: controllers/sceneController.js

const sceneService = require('../services/sceneService');
const characterService = require('../services/characterService');
const partService = require('../services/partService');
const soundService = require('../services/soundService');

const sceneController = {
    getAllScenes: async (req, res) => {
        try {
            const scenes = await sceneService.getAllScenes();
            const characters = await characterService.getAllCharacters();
            console.log('Retrieved scenes:', scenes);
            res.render('scenes', { title: 'All Scenes', scenes, characters });
        } catch (error) {
            console.error('Error getting all scenes:', error);
            res.status(500).json({ error: 'Failed to retrieve scenes', details: error.message });
        }
    },

    getSceneById: async (req, res) => {
        try {
            const sceneId = req.params.id;
            const scene = await sceneService.getSceneById(sceneId);
            const characters = await characterService.getAllCharacters();
            const sounds = await soundService.getAllSounds();
            const parts = await partService.getAllParts();
            if (scene) {
                res.render('scene-form', { 
                    title: 'Edit Scene', 
                    scene, 
                    action: `/scenes/${scene.id}`,
                    characters,
                    sounds,
                    parts
                });
            } else {
                res.status(404).json({ error: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error getting scene by ID:', error);
            res.status(500).json({ error: 'Failed to retrieve scene', details: error.message });
        }
    },

    newScene: async (req, res) => {
        try {
            const characters = await characterService.getAllCharacters();
            const sounds = await soundService.getAllSounds();
            const parts = await partService.getAllParts();
            
            res.render('scene-form', {
                title: 'New Scene',
                scene: {},
                action: '/scenes',
                characters,
                sounds,
                parts
            });
        } catch (error) {
            console.error('Error rendering new scene form:', error);
            res.status(500).json({ error: 'Failed to render new scene form', details: error.message });
        }
    },

    createScene: async (req, res) => {
        try {
            const newScene = await sceneService.createScene(req.body);
            res.redirect('/scenes');
        } catch (error) {
            console.error('Error creating new scene:', error);
            res.status(500).json({ error: 'Failed to create new scene', details: error.message });
        }
    },

    updateScene: async (req, res) => {
        try {
            const updatedScene = await sceneService.updateScene(req.params.id, req.body);
            if (updatedScene) {
                res.json({ success: true, message: 'Scene updated successfully', scene: updatedScene });
            } else {
                res.status(404).json({ error: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error updating scene:', error);
            res.status(500).json({ error: 'Failed to update scene', details: error.message });
        }
    },

    deleteScene: async (req, res) => {
        try {
            const result = await sceneService.deleteScene(req.params.id);
            if (result) {
                res.json({ success: true, message: 'Scene deleted successfully' });
            } else {
                res.status(404).json({ error: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error deleting scene:', error);
            res.status(500).json({ error: 'Failed to delete scene', details: error.message });
        }
    }
};

module.exports = sceneController;

================
File: controllers/scenePlayerController.js
================
// File: controllers/scenePlayerController.js

const sceneService = require('../services/sceneService');
const partService = require('../services/partService');
const soundService = require('../services/soundService');
const soundController = require('./soundController');
const partController = require('./partController');
const path = require('path');
const { spawn } = require('child_process');

let isExecuting = false;

const scenePlayerController = {
    getScenePlayer: async (req, res) => {
        try {
            const sceneId = req.params.id;
            const scene = await sceneService.getSceneById(sceneId);
            if (scene) {
                res.render('scene-player', { title: 'Scene Player', scene });
            } else {
                res.status(404).render('error', { title: 'Not Found', message: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error getting scene by ID:', error);
            res.status(500).render('error', { title: 'Error', message: 'Failed to retrieve scene', error });
        }
    },

    playScene: async (req, res) => {
        const sceneId = req.params.id;
        const startStep = parseInt(req.query.startStep) || 0;
        console.log(`Attempting to play scene with ID: ${sceneId} from step ${startStep}`);
        
        let scene;
        try {
            scene = await sceneService.getSceneById(sceneId);
            if (!scene) {
                return res.status(404).json({ error: 'Scene not found' });
            }
        } catch (error) {
            console.error('Error fetching scene:', error);
            return res.status(500).json({ error: 'Failed to fetch scene' });
        }

        res.writeHead(200, {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
        });

        const sendEvent = (data) => {
            res.write(`data: ${JSON.stringify(data)}\n\n`);
        };

        soundController.startSoundPlayer();
        isExecuting = true;

        let concurrentSteps = [];
        for (let i = startStep; i < scene.steps.length && isExecuting; i++) {
            const step = scene.steps[i];
            concurrentSteps.push(step);

            if (!step.concurrent || i === scene.steps.length - 1) {
                sendEvent({ message: `Executing concurrent steps`, currentStep: i });
                try {
                    await Promise.all(concurrentSteps.map(s => executeStep(s, sendEvent)));
                } catch (error) {
                    console.error(`Error executing concurrent steps:`, error);
                    sendEvent({ error: `Failed to execute concurrent steps: ${error.message}` });
                }
                concurrentSteps = [];
            }
        }

        sendEvent({ message: 'Scene execution completed' });
        isExecuting = false;
        res.end();
    },

    stopScene: async (req, res) => {
        console.log('Stopping all steps and terminating processes');
        isExecuting = false;
        try {
            await soundController.stopAllSounds();
            await partController.stopAllParts();
            res.json({ message: 'All steps stopped and processes terminated' });
        } catch (error) {
            console.error('Error stopping all steps:', error);
            res.status(500).json({ error: 'Failed to stop all steps', details: error.message });
        }
    },

    stopAllScenes: async (req, res) => {
        console.log('Stopping all scenes and terminating processes');
        isExecuting = false;
        try {
            await soundController.stopAllSounds();
            await partController.stopAllParts();
            res.json({ message: 'All scenes stopped and processes terminated' });
        } catch (error) {
            console.error('Error stopping all scenes:', error);
            res.status(500).json({ error: 'Failed to stop all scenes', details: error.message });
        }
    }
};

async function executeStep(step, sendEvent) {
    if (!isExecuting) return;
    console.log('Executing step:', step);
    sendEvent({ message: `Starting execution of ${step.type} step: ${step.name}` });

    try {
        switch (step.type) {
            case 'sound':
                await executeSound(step, sendEvent);
                break;
            case 'motor':
            case 'linear-actuator':
            case 'led':
            case 'light':
            case 'servo':
                await partController.executePartAction(step, sendEvent);
                break;
            case 'sensor':
                await executeSensor(step, sendEvent);
                break;
            case 'pause':
                await executePause(step, sendEvent);
                break;
            default:
                throw new Error(`Unknown step type: ${step.type}`);
        }
        sendEvent({ message: `Completed execution of ${step.type} step: ${step.name}` });
    } catch (error) {
        console.error(`Error executing step:`, error);
        sendEvent({ error: `Failed to execute ${step.type} step: ${error.message}` });
    }
}

async function executeSound(step, sendEvent) {
    const sound = await soundService.getSoundById(step.sound_id);
    if (!sound) {
        throw new Error(`Sound not found for ID: ${step.sound_id}`);
    }
    await soundController.playSound(sound, sendEvent);
}

async function executeSensor(step, sendEvent) {
    const part = await partService.getPartById(step.part_id);
    if (!part) {
        throw new Error(`Sensor not found for ID: ${step.part_id}`);
    }

    return new Promise((resolve, reject) => {
        const scriptPath = path.resolve(__dirname, '..', 'scripts', 'sensor_control.py');
        const args = [part.gpioPin.toString(), step.timeout.toString()];
        const process = spawn('python3', [scriptPath, ...args]);

        process.stdout.on('data', (data) => {
            sendEvent({ message: `Sensor output: ${data}` });
        });

        process.stderr.on('data', (data) => {
            sendEvent({ error: `Sensor error: ${data}` });
        });

        process.on('close', (code) => {
            if (code === 0) {
                sendEvent({ message: `Sensor step completed: ${step.name}`, result: { detected: true } });
                resolve({ detected: true });
            } else if (code === 1) {
                sendEvent({ message: `Sensor step completed: ${step.name}`, result: { detected: false } });
                resolve({ detected: false });
            } else {
                reject(new Error(`Sensor process exited with code ${code}`));
            }
        });
    });
}

async function executePause(step, sendEvent) {
    return new Promise((resolve) => {
        sendEvent({ message: `Starting pause: ${step.duration}ms` });
        setTimeout(() => {
            sendEvent({ message: `Pause completed: ${step.duration}ms` });
            resolve();
        }, step.duration);
    });
}

module.exports = scenePlayerController;

================
File: controllers/servoController.js
================
const i2cBus = require('i2c-bus');
const Pca9685Driver = require("pca9685").Pca9685Driver;

let pwm;

try {
    const options = {
        i2c: i2cBus.openSync(1),
        address: 0x40,
        frequency: 50,
        debug: false
    };

    pwm = new Pca9685Driver(options, function(err) {
        if (err) {
            console.error("Error initializing PCA9685");
            throw err;
        }
        console.log("PCA9685 initialization done");
    });
} catch (error) {
    console.error('Failed to initialize PCA9685:', error.message);
    pwm = null;
}

const servoTypes = {
    DS3240MG: { minPulse: 500, maxPulse: 2500 },
    FS90R: { minPulse: 700, maxPulse: 2300, stopPulse: 1500 },
    MG90S: { minPulse: 600, maxPulse: 2400 },
    BILDA: { minPulse: 500, maxPulse: 2500 },
};

function angleToPulse(angle, minPulse, maxPulse) {
    return minPulse + (angle / 180) * (maxPulse - minPulse);
}

function pulseToSteps(pulse) {
    return Math.round((pulse * 4096) / 20000);
}

function fs90rAngleToPulse(angle) {
    if (angle === 90) return 1500;  // Stop
    if (angle < 90) return 1000 + (angle * 500 / 90);  // Clockwise
    return 1500 + ((angle - 90) * 500 / 90);  // Counterclockwise
}

exports.testServo = async (req, res) => {
    console.log('Testing servo - Body:', req.body);
    if (!pwm) {
        return res.status(500).json({ success: false, message: 'PCA9685 is not initialized' });
    }

    try {
        const { angle, channel, servoType } = req.body;
        
        let pulse;
        if (servoType === 'FS90R') {
            pulse = fs90rAngleToPulse(parseInt(angle));
        } else {
            const servoConfig = servoTypes[servoType];
            pulse = angleToPulse(parseInt(angle), servoConfig.minPulse, servoConfig.maxPulse);
        }
        
        const steps = pulseToSteps(pulse);
        
        console.log(`Angle: ${angle}, Pulse: ${pulse}, Steps: ${steps}`);

        pwm.setPulseRange(parseInt(channel), 0, steps, function(err) {
            if (err) {
                console.error('Error setting pulse range:', err);
                return res.status(500).json({ success: false, message: 'Error setting servo position', error: err.message });
            }
            res.json({ success: true, message: 'Servo test completed successfully' });
        });
    } catch (error) {
        console.error('Error testing servo:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the servo', error: error.message });
    }
};

exports.stopServo = async (req, res) => {
    console.log('Stopping servo - Body:', req.body);
    if (!pwm) {
        return res.status(500).json({ success: false, message: 'PCA9685 is not initialized' });
    }

    try {
        const { channel, servoType } = req.body;
        
        let stopPulse;
        if (servoType === 'FS90R') {
            stopPulse = 1500;  // Center position for continuous rotation servo
        } else {
            const servoConfig = servoTypes[servoType];
            stopPulse = (servoConfig.minPulse + servoConfig.maxPulse) / 2;  // Middle position for standard servo
        }
        
        const steps = pulseToSteps(stopPulse);
        
        console.log(`Stopping servo - Channel: ${channel}, Pulse: ${stopPulse}, Steps: ${steps}`);

        pwm.setPulseRange(parseInt(channel), 0, steps, function(err) {
            if (err) {
                console.error('Error stopping servo:', err);
                return res.status(500).json({ success: false, message: 'Error stopping servo', error: err.message });
            }
            res.json({ success: true, message: 'Servo stopped successfully' });
        });
    } catch (error) {
        console.error('Error stopping servo:', error);
        res.status(500).json({ success: false, message: 'An error occurred while stopping the servo', error: error.message });
    }
};

================
File: controllers/soundController.js
================
// File: controllers/soundController.js

const { spawn } = require('child_process');
const path = require('path');

let soundPlayerProcess = null;
let soundPlayerRetries = 0;
const MAX_SOUND_PLAYER_RETRIES = 3;

function startSoundPlayer() {
    if (!soundPlayerProcess) {
        const scriptPath = path.resolve(__dirname, '..', 'scripts', 'sound_player.py');
        soundPlayerProcess = spawn('python3', [scriptPath]);

        soundPlayerProcess.stdout.on('data', (data) => {
            console.log(`Sound player output: ${data}`);
        });

        soundPlayerProcess.stderr.on('data', (data) => {
            console.error(`Sound player error: ${data}`);
        });

        soundPlayerProcess.on('close', (code) => {
            console.log(`Sound player exited with code ${code}`);
            soundPlayerProcess = null;
            if (soundPlayerRetries < MAX_SOUND_PLAYER_RETRIES) {
                soundPlayerRetries++;
                console.log(`Retrying to start sound player (Attempt ${soundPlayerRetries})`);
                startSoundPlayer();
            } else {
                console.error('Max retries reached. Unable to start sound player.');
            }
        });
    }
}

function playSound(sound, sendEvent) {
    return new Promise((resolve, reject) => {
        if (!soundPlayerProcess) {
            startSoundPlayer();
        }

        if (!soundPlayerProcess) {
            reject(new Error('Sound player not available'));
            return;
        }

        const filePath = path.resolve(__dirname, '..', 'public', 'sounds', sound.filename);
        const command = `PLAY|${sound.id}|${filePath}\n`;
        soundPlayerProcess.stdin.write(command);

        sendEvent({ message: `Sound started: ${sound.name}` });

        const listener = (data) => {
            const output = data.toString().trim();
            try {
                const jsonOutput = JSON.parse(output);
                if (jsonOutput.status === 'finished' && jsonOutput.sound_id === sound.id.toString()) {
                    soundPlayerProcess.stdout.removeListener('data', listener);
                    sendEvent({ message: `Sound completed: ${sound.name}` });
                    resolve();
                }
            } catch (e) {
                // Not JSON or not relevant, ignore
            }
        };

        soundPlayerProcess.stdout.on('data', listener);
    });
}

function stopAllSounds() {
    return new Promise((resolve, reject) => {
        if (soundPlayerProcess) {
            soundPlayerProcess.stdin.write("STOP_ALL\n");
            soundPlayerProcess.kill('SIGINT');
            soundPlayerProcess = null;
            resolve();
        } else {
            resolve(); // No sound player running, consider it stopped
        }
    });
}

module.exports = {
    startSoundPlayer,
    playSound,
    stopAllSounds
};

================
File: data/characters.json
================
[
  {
    "id": 1,
    "char_name": "Baphomet Lives",
    "char_description": "the dark lord finally rises",
    "parts": [
      2,
      3,
      4,
      5,
      6,
      8
    ],
    "sounds": [
      1,
      2,
      3
    ],
    "image": "c56cc12bfac10df2663b4c71ab53a801"
  }
]

================
File: data/parts.json
================
[
  {
    "id": 1,
    "name": "Hand of Azura",
    "type": "light",
    "characterId": 1,
    "gpioPin": 26
  }
]

================
File: data/scenes.json
================
[
  {
    "id": 1,
    "character_id": 1,
    "scene_name": "Awaken",
    "steps": [
      {
        "type": "sensor",
        "name": "Watching you",
        "part_id": "5",
        "timeout": "30"
      },
      {
        "type": "led",
        "name": "Awaken Eyes",
        "part_id": "4",
        "duration": "4000",
        "state": "on",
        "brightness": "100"
      },
      {
        "type": "sound",
        "name": "Good evening buddy!",
        "sound_id": "1"
      }
    ]
  },
  {
    "id": 2,
    "character_id": 1,
    "scene_name": "Attack",
    "steps": [
      {
        "type": "sound",
        "name": "Roar!!!",
        "sound_id": "2",
        "concurrent": "on"
      },
      {
        "type": "sound",
        "name": "santos",
        "sound_id": "3",
        "concurrent": "on"
      },
      {
        "type": "linear-actuator",
        "name": "Raise Right Arm Up",
        "part_id": "8",
        "duration": "5000",
        "direction": "backward",
        "speed": "25"
      },
      {
        "type": "light",
        "name": "Here's the money",
        "part_id": "3",
        "duration": "10000",
        "state": "on"
      },
      {
        "type": "pause",
        "name": "Waiting....5 seconds",
        "duration": "5000"
      },
      {
        "type": "linear-actuator",
        "name": "Lowrer Arm",
        "part_id": "8",
        "duration": "1250",
        "direction": "forward",
        "speed": "100"
      }
    ]
  }
]

================
File: data/sounds.json
================
[
  {
    "id": 1,
    "name": "Good Evening2!",
    "filename": "1724882301591.mp3"
  },
  {
    "id": 2,
    "name": "Wind and Rain",
    "filename": "1724882315375.mp3"
  },
  {
    "id": 3,
    "name": "Santos Dominus ",
    "filename": "1724882328571.mp3"
  }
]

================
File: mjpg-streamer/.git/hooks/applypatch-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

================
File: mjpg-streamer/.git/hooks/commit-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

================
File: mjpg-streamer/.git/hooks/fsmonitor-watchman.sample
================
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

================
File: mjpg-streamer/.git/hooks/post-update.sample
================
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

================
File: mjpg-streamer/.git/hooks/pre-applypatch.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

================
File: mjpg-streamer/.git/hooks/pre-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

================
File: mjpg-streamer/.git/hooks/pre-merge-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

================
File: mjpg-streamer/.git/hooks/pre-push.sample
================
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

================
File: mjpg-streamer/.git/hooks/pre-rebase.sample
================
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

================
File: mjpg-streamer/.git/hooks/pre-receive.sample
================
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

================
File: mjpg-streamer/.git/hooks/prepare-commit-msg.sample
================
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

================
File: mjpg-streamer/.git/hooks/push-to-checkout.sample
================
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

================
File: mjpg-streamer/.git/hooks/update.sample
================
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

================
File: mjpg-streamer/.git/info/exclude
================
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

================
File: mjpg-streamer/.git/logs/refs/heads/master
================
0000000000000000000000000000000000000000 310b29f4a94c46652b20c4b7b6e5cf24e532af39 Remote Developer <arwpersonal@gmail.com> 1726353851 -0500	clone: from https://github.com/jacksonliam/mjpg-streamer.git

================
File: mjpg-streamer/.git/logs/refs/remotes/origin/HEAD
================
0000000000000000000000000000000000000000 310b29f4a94c46652b20c4b7b6e5cf24e532af39 Remote Developer <arwpersonal@gmail.com> 1726353851 -0500	clone: from https://github.com/jacksonliam/mjpg-streamer.git

================
File: mjpg-streamer/.git/logs/HEAD
================
0000000000000000000000000000000000000000 310b29f4a94c46652b20c4b7b6e5cf24e532af39 Remote Developer <arwpersonal@gmail.com> 1726353851 -0500	clone: from https://github.com/jacksonliam/mjpg-streamer.git

================
File: mjpg-streamer/.git/refs/heads/master
================
310b29f4a94c46652b20c4b7b6e5cf24e532af39

================
File: mjpg-streamer/.git/refs/remotes/origin/HEAD
================
ref: refs/remotes/origin/master

================
File: mjpg-streamer/.git/config
================
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/jacksonliam/mjpg-streamer.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master

================
File: mjpg-streamer/.git/description
================
Unnamed repository; edit this file 'description' to name the repository.

================
File: mjpg-streamer/.git/HEAD
================
ref: refs/heads/master

================
File: mjpg-streamer/.git/packed-refs
================
# pack-refs with: peeled fully-peeled sorted 
310b29f4a94c46652b20c4b7b6e5cf24e532af39 refs/remotes/origin/master
5554f42c352ecfa7edaec6fc51e507afce605a34 refs/tags/v1.0.0

================
File: mjpg-streamer/mjpg-streamer-experimental/cmake/FindGphoto2.cmake
================
# - Find the native gphoto2 includes and library
#
# This module defines
#  GPHOTO2_INCLUDE_DIR, where to find libgphoto2 header files
#  GPHOTO2_LIBRARIES, the libraries to link against to use libgphoto2
#  GPHOTO2_FOUND, If false, do not try to use libgphoto2.
#  GPHOTO2_VERSION_STRING, e.g. 2.4.14
#  GPHOTO2_VERSION_MAJOR, e.g. 2
#  GPHOTO2_VERSION_MINOR, e.g. 4
#  GPHOTO2_VERSION_PATCH, e.g. 14
#
# also defined, but not for general use are
#  GPHOTO2_LIBRARY, where to find the gphoto2 library.


#=============================================================================
# Copyright 2010 henrik andersson
# From: https://github.com/darktable-org/darktable/blob/master/cmake/modules/FindGphoto2.cmake
#=============================================================================

include(FindPkgConfig)

SET(GPHOTO2_FIND_REQUIRED ${Gphoto2_FIND_REQUIRED})

find_path(GPHOTO2_INCLUDE_DIR gphoto2/gphoto2.h)
mark_as_advanced(GPHOTO2_INCLUDE_DIR)

set(GPHOTO2_NAMES ${GPHOTO2_NAMES} gphoto2 libgphoto2)
set(GPHOTO2_PORT_NAMES ${GPHOTO2_PORT_NAMES} gphoto2_port libgphoto2_port)
find_library(GPHOTO2_LIBRARY NAMES ${GPHOTO2_NAMES} )
find_library(GPHOTO2_PORT_LIBRARY NAMES ${GPHOTO2_PORT_NAMES} )
mark_as_advanced(GPHOTO2_LIBRARY)
mark_as_advanced(GPHOTO2_PORT_LIBRARY)

# Detect libgphoto2 version
pkg_check_modules(PC_GPHOTO2 libgphoto2)
if(PC_GPHOTO2_FOUND)
  set(GPHOTO2_VERSION_STRING "${PC_GPHOTO2_VERSION}")
endif()

# handle the QUIETLY and REQUIRED arguments and set GPHOTO2_FOUND to TRUE if
# all listed variables are TRUE
include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(GPHOTO2 DEFAULT_MSG GPHOTO2_LIBRARY GPHOTO2_INCLUDE_DIR)

IF(GPHOTO2_FOUND)
  SET(Gphoto2_LIBRARIES ${GPHOTO2_LIBRARY} ${GPHOTO2_PORT_LIBRARY})
  SET(Gphoto2_INCLUDE_DIRS ${GPHOTO2_INCLUDE_DIR})

  # libgphoto2 dynamically loads and unloads usb library
  # without calling any cleanup functions (since they are absent from libusb-0.1).
  # This leaves usb event handling threads running with invalid callback and return addresses,
  # which causes a crash after any usb event is generated, at least in Mac OS X. 
  # libusb1 backend does correctly call exit function, but ATM it crashes anyway.
  # Workaround is to link against libusb so that it wouldn't get unloaded.
  IF(APPLE)
    find_library(USB_LIBRARY NAMES usb-1.0 libusb-1.0)
    mark_as_advanced(USB_LIBRARY)
    IF(USB_LIBRARY)
      SET(Gphoto2_LIBRARIES ${Gphoto2_LIBRARIES} ${USB_LIBRARY})
    ENDIF(USB_LIBRARY)
  ENDIF(APPLE)

ENDIF(GPHOTO2_FOUND)

================
File: mjpg-streamer/mjpg-streamer-experimental/cmake/FindProtobuf-c.cmake
================
#  PROTOBUF_C_FOUND - System has libprotobuf-c
#  PROTOBUF_C_INCLUDE_DIRS - The libprotobuf-c include directories
#  PROTOBUF_C_LIBRARIES - The libraries needed to use libprotobuf-c
#  PROTOBUF_C_DEFINITIONS - Compiler switches required for using libprotobuf-c

function(PROTOBUF_C_GENERATE SRCS HDRS)
    if(NOT ARGN)
        message(SEND_ERROR "Error: PROTOBUFC_GENERATE() called without any proto files")
        return()
    endif()

    if(PROTOBUF_C_GENERATE_APPEND_PATH)
        # Create an include path for each file specified
        foreach(FIL ${ARGN})
            get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
            get_filename_component(ABS_PATH ${ABS_FIL} PATH)
            list(FIND _protobuf_include_path ${ABS_PATH} _contains_already)
            if(${_contains_already} EQUAL -1)
                list(APPEND _protobuf_include_path -I ${ABS_PATH})
            endif()
        endforeach()
    else()
        set(_protobuf_include_path -I ${CMAKE_CURRENT_SOURCE_DIR})
    endif()

    if(DEFINED PROTOBUFC_IMPORT_DIRS)
        foreach(DIR ${PROTOBUF_IMPORT_DIRS})
            get_filename_component(ABS_PATH ${DIR} ABSOLUTE)
            list(FIND _protobuf_include_path ${ABS_PATH} _contains_already)
            if(${_contains_already} EQUAL -1)
                list(APPEND _protobuf_include_path -I ${ABS_PATH})
            endif()
        endforeach()
    endif()

    set(${SRCS})
    set(${HDRS})
    foreach(FIL ${ARGN})
        get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
        get_filename_component(FIL_WE ${FIL} NAME_WE)

        list(APPEND ${SRCS} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb-c.c")
        list(APPEND ${HDRS} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb-c.h")

        add_custom_command(
                OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb-c.c"
                "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb-c.h"
                COMMAND  ${PROTOBUFC_PROTOC_EXECUTABLE}
                ARGS --c_out  ${CMAKE_CURRENT_BINARY_DIR} ${_protobuf_include_path} ${ABS_FIL}
                DEPENDS ${ABS_FIL}
                COMMENT "Running C protocol buffer compiler on ${FIL}"
                VERBATIM )
    endforeach()

    set_source_files_properties(${${SRCS}} ${${HDRS}} PROPERTIES GENERATED TRUE)
    set(${SRCS} ${${SRCS}} PARENT_SCOPE)
    set(${HDRS} ${${HDRS}} PARENT_SCOPE)
endfunction()

# Find the protoc Executable
find_program(PROTOBUFC_PROTOC_EXECUTABLE
        NAMES protoc-c
        DOC "protoc-c compiler"
        )

find_package(PkgConfig QUIET)
if(PKG_CONFIG_FOUND)
    pkg_check_modules(PC_PROTOBUF_C QUIET protobuf-c)
    set(PROTOBUF_C_DEFINITIONS ${PC_PROTOBUF_C_CFLAGS_OTHER})
endif()

find_path(PROTOBUF_C_INCLUDE_DIR protobuf-c/protobuf-c.h
        HINTS ${PC_PROTOBUF_C_INCLUDEDIR} ${PC_PROTOBUF_C_INCLUDE_DIRS}
        PATH_SUFFIXES protobuf-c)

find_library(PROTOBUF_C_LIBRARY NAMES protobuf-c
        HINTS ${PC_PROTOBUF_C_LIBDIR} ${PC_PROTOBUF_C_LIBRARY_DIRS})

set(PROTOBUF_C_LIBRARIES ${PROTOBUF_C_LIBRARY} )
set(PROTOBUF_C_INCLUDE_DIRS ${PROTOBUF_C_INCLUDE_DIR})

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(protobuf-c  DEFAULT_MSG
        PROTOBUF_C_LIBRARY PROTOBUF_C_INCLUDE_DIR)

mark_as_advanced(PROTOBUF_C_INCLUDE_DIR YANG_LIBRARY)

================
File: mjpg-streamer/mjpg-streamer-experimental/cmake/FindZeroMQ.cmake
================
## load in pkg-config support
find_package(PkgConfig QUIET)
if(PKG_CONFIG_FOUND)
    ## use pkg-config to get hints for 0mq locations
    pkg_check_modules(PC_ZeroMQ QUIET zmq)
    set(PROTOBUF_C_DEFINITIONS ${PC_PROTOBUF_C_CFLAGS_OTHER})
endif()

## use the hint from above to find where 'zmq.hpp' is located
find_path(ZeroMQ_INCLUDE_DIR
        NAMES zmq.h
        HINTS ${PC_ZeroMQ_INCLUDEDIR} ${PC_ZeroMQ_INCLUDE_DIRS}
        )

## use the hint from about to find the location of libzmq
find_library(ZeroMQ_LIBRARY
        NAMES zmq
        HINTS ${PC_ZeroMQ_C_LIBDIR} ${PC_ZeroMQ_C_LIBRARY_DIRS}
        )

================
File: mjpg-streamer/mjpg-streamer-experimental/cmake/mjpg_streamer_utils.cmake
================
include(CMakeDependentOption)
include(CMakeParseArguments)

#
# Adds an option to compile an mjpg-streamer plugin, but only enables if a set
# of requirements are met.
#
# First arg: module name
# Second arg: description
# Optional args: ONLYIF Condition1 [Condition2 ...]
#
macro(MJPG_STREAMER_PLUGIN_OPTION MODULE_NAME DESCRIPTION)

	cmake_parse_arguments(MSPOM
						  "" "" "ONLYIF" ${ARGN})
					  
	string(TOUPPER "PLUGIN_${MODULE_NAME}" OPT_ENABLE)
	string(TOUPPER "PLUGIN_${MODULE_NAME}_AVAILABLE" OPT_AVAILABLE)
	
	cmake_dependent_option(${OPT_ENABLE} "${DESCRIPTION}" ON "${MSPOM_ONLYIF}" OFF)
	
	if (${OPT_AVAILABLE})
		add_feature_info(${OPT_ENABLE} ${OPT_ENABLE} "${DESCRIPTION}")
	else()
		add_feature_info(${OPT_ENABLE} ${OPT_ENABLE} "${DESCRIPTION} (unmet dependencies)")
	endif()

endmacro()

#
# Conditionally compiles an mjpg-streamer plugin, must use
# MJPG_STREAMER_PLUGIN_OPTION first
# 
# First arg: module name,
# other args: source files
#
macro(MJPG_STREAMER_PLUGIN_COMPILE MODULE_NAME)
	
	string(TOUPPER "${MODULE_NAME}" ARGU)
	set(OPT_ENABLE "PLUGIN_${ARGU}")
	
	if (${OPT_ENABLE})
	
		set(MOD_SRC)
		foreach(arg ${ARGN})
			list(APPEND MOD_SRC "${arg}") 
		endforeach()
		
		add_library(${MODULE_NAME} SHARED ${MOD_SRC})
	    set_target_properties(${MODULE_NAME} PROPERTIES PREFIX "")
	    
		install(TARGETS ${MODULE_NAME} DESTINATION ${MJPG_STREAMER_PLUGIN_INSTALL_PATH})	
	endif()
	
endmacro()


macro(add_feature_option OPTVAR DESCRIPTION DEFAULT)
	option(${OPTVAR} "$DESCRIPTION" ${DEFAULT})
	add_feature_info(${OPTVAR} ${OPTVAR} "${DESCRIPTION}")
endmacro()

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_control/dynctrl.c
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C)      2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <sys/ioctl.h>
#include <sys/time.h>
#include <getopt.h>
#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include <linux/videodev2.h>

#include "../../utils.h"
#include "../../mjpg_streamer.h"
#include "dynctrl.h"

/* some Logitech webcams have pan/tilt/focus controls */
static struct uvc_xu_control_info xu_ctrls[] = {
    {
        .entity   = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector = XU_MOTORCONTROL_PANTILT_RELATIVE,
        .index    = 0,
        .size     = 4,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_DEF
    },
    {
        .entity   = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector = XU_MOTORCONTROL_PANTILT_RESET,
        .index    = 1,
        .size     = 1,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | UVC_CONTROL_GET_DEF
    },
    {
        .entity   = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector = XU_MOTORCONTROL_FOCUS,
        .index    = 2,
        .size     = 6,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_DEF
    },
    {
        .entity   = UVC_GUID_LOGITECH_USER_HW_CONTROL,
        .selector = XU_HW_CONTROL_LED1,
        .index    = 0,
        .size     = 3,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | UVC_CONTROL_GET_DEF
    }
};

/* mapping for Pan/Tilt/Focus */
static struct uvc_xu_control_mapping xu_mappings[] = {
    {
        .id        = V4L2_CID_PAN_RELATIVE_LOGITECH,
        .name      = "Pan (relative)",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_PANTILT_RELATIVE,
        .size      = 16,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_SIGNED
    },
    {
        .id        = V4L2_CID_TILT_RELATIVE_LOGITECH,
        .name      = "Tilt (relative)",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_PANTILT_RELATIVE,
        .size      = 16,
        .offset    = 16,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_SIGNED
    },
{
		.id        = V4L2_CID_PAN_RESET,
		.name      = N_("Pan Reset"),
		.entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
		.selector  = XU_MOTORCONTROL_PANTILT_RESET,
		.size      = 1,
		.offset    = 0,
		.v4l2_type = V4L2_CTRL_TYPE_BUTTON,
		.data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
	},
	{
		.id        = V4L2_CID_TILT_RESET,
		.name      = N_("Tilt Reset"),
		.entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
		.selector  = XU_MOTORCONTROL_PANTILT_RESET,
		.size      = 1,
		.offset    = 1,
		.v4l2_type = V4L2_CTRL_TYPE_BUTTON,
		.data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
	},
	{
		.id        = V4L2_CID_PANTILT_RESET_LOGITECH,
		.name      = N_("Pan/tilt Reset"),
		.entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
		.selector  = XU_MOTORCONTROL_PANTILT_RESET,
		.size      = 8,
		.offset    = 0,
		.v4l2_type = V4L2_CTRL_TYPE_BUTTON,
		.data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
	},
    {
        .id        = V4L2_CID_FOCUS_LOGITECH,
        .name      = "Focus (absolute)",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_FOCUS,
        .size      = 8,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },
    {
        .id        = V4L2_CID_LED1_MODE_LOGITECH,
        .name      = "LED1 Mode",
        .entity    = UVC_GUID_LOGITECH_USER_HW_CONTROL,
        .selector  = XU_HW_CONTROL_LED1,
        .size      = 8,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },
    {
        .id        = V4L2_CID_LED1_FREQUENCY_LOGITECH,
        .name      = "LED1 Frequency",
        .entity    = UVC_GUID_LOGITECH_USER_HW_CONTROL,
        .selector  = XU_HW_CONTROL_LED1,
        .size      = 8,
        .offset    = 16,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    }
};

void initDynCtrls(int dev)
{
    int i, err;

    /* try to add all controls listed above */
    for(i = 0; i < LENGTH_OF(xu_ctrls); i++) {
        DBG("adding control for %d\n", i);
        errno = 0;
        if((err = ioctl(dev, UVCIOC_CTRL_ADD, &xu_ctrls[i])) < 0) {
            if(errno != EEXIST) {
                DBG("uvcioc ctrl add error: errno=%d (retval=%d)\n", errno, err);
            } else {
                DBG("control %d already exists\n", i);
            }
        }
    }

    /* after adding the controls, add the mapping now */
    for(i = 0; i < LENGTH_OF(xu_mappings); i++) {
        DBG("mapping controls for %s\n", xu_mappings[i].name);
        errno = 0;
        if((err = ioctl(dev, UVCIOC_CTRL_MAP, &xu_mappings[i])) < 0) {
            if(errno != EEXIST) {
                DBG("uvcioc ctrl map error: errno=%d (retval=%d)\n", errno, err);
            } else {
                DBG("mapping %d already exists\n", i);
            }
        }
    }
}

/*
SRC: https://lists.berlios.de/pipermail/linux-uvc-devel/2007-July/001888.html

- dev: the device file descriptor
- pan: pan angle in 1/64th of degree
- tilt: tilt angle in 1/64th of degree
- reset: set to 1 to reset pan/tilt to the device origin, set to 0 otherwise
*/
int uvcPanTilt(int dev, int pan, int tilt, int reset)
{
    struct v4l2_ext_control xctrls[2];
    struct v4l2_ext_controls ctrls;

    if(reset) {
        xctrls[0].id = V4L2_CID_PANTILT_RESET_LOGITECH;
        xctrls[0].value = 3;

        ctrls.count = 1;
        ctrls.controls = xctrls;
    } else {
        xctrls[0].id = V4L2_CID_PAN_RELATIVE_LOGITECH;
        xctrls[0].value = pan;
        xctrls[1].id = V4L2_CID_TILT_RELATIVE_LOGITECH;
        xctrls[1].value = -tilt;

        ctrls.count = 2;
        ctrls.controls = xctrls;
    }

    if(ioctl(dev, VIDIOC_S_EXT_CTRLS, &ctrls) < 0) {
        DBG("Error in uvcPanTilt");
        return -1;
    }

    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_control/dynctrl.h
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C)      2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include "uvcvideo.h"

#define V4L2_CID_PAN_RELATIVE_LOGITECH   0x0A046D01
#define V4L2_CID_TILT_RELATIVE_LOGITECH  0x0A046D02
#define V4L2_CID_PANTILT_RESET_LOGITECH  0x0A046D03
#define V4L2_CID_FOCUS_LOGITECH          0x0A046D04
#define V4L2_CID_LED1_MODE_LOGITECH      0x0A046D05
#define V4L2_CID_LED1_FREQUENCY_LOGITECH 0x0A046D06

#define UVC_GUID_LOGITECH_MOTOR_CONTROL {0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x56}
#define UVC_GUID_LOGITECH_USER_HW_CONTROL {0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x1f}

#define XU_HW_CONTROL_LED1               1
#define XU_MOTORCONTROL_PANTILT_RELATIVE 1
#define XU_MOTORCONTROL_PANTILT_RESET    2
#define XU_MOTORCONTROL_FOCUS            3

#define ONE_DEGREE (64);
#define MAX_PAN  (70*64)
#define MIN_PAN  (-70*64)
#define MAX_TILT (30*64)
#define MIN_TILT (-30*64)
#define MIN_RES  (64*5)

void initDynCtrls(int dev);
int uvcPanTilt(int dev, int pan, int tilt, int reset);

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_control/input_uvc.c
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <linux/videodev.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <syslog.h>

#include "../../utils.h"
#include "../../mjpg_streamer.h"
#include "dynctrl.h"

#define INPUT_PLUGIN_NAME "UVC webcam control"

typedef struct input_uvc {
    int fd;
    char *videodevice;
    int min_res;
} input_uvc;

/* private functions and variables to this plugin */
pthread_t cam;
pthread_mutex_t controls_mutex;
input_uvc *this;
static globals *pglobal;

void *cam_thread(void *);
void cam_cleanup(void *);
void help(void);
int input_cmd(in_cmd_type, int);

/*** plugin interface functions ***/
/******************************************************************************
Description.: This function initializes the plugin. It parses the commandline-
              parameter and stores the default and parsed values in the
              appropriate variables.
Input Value.: param contains among others the command-line string
Return Value: 0 if everything is fine
              1 if "--help" was triggered, in this case the calling programm
              should stop running and leave.
******************************************************************************/
int input_init(input_parameter *param, int id)
{
    int i;
    char *dev = "/dev/video0";

    /* initialize the mutes variable */
    if(pthread_mutex_init(&controls_mutex, NULL) != 0) {
        IPRINT("could not initialize mutex variable\n");
        exit(EXIT_FAILURE);
    }

    /* keep a pointer to the global variables */
    pglobal = param->global;

    /* allocate webcam datastructure */
    this = calloc(sizeof(struct input_uvc));
    if(this == NULL) {
        IPRINT("not enough memory for videoIn\n");
        exit(EXIT_FAILURE);
    }
    this->min_res = MIN_RES;

    /* display the parsed values */
    IPRINT("Using V4L2 device.: %s\n", dev);

    param->argv[0] = INPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    /* parse the parameters */
    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = \ {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"d", required_argument, 0, 0},
            {"device", required_argument, 0, 0},
            {"m", required_argument, 0, 0},
            {"min", required_argument, 0, 0},
            {0, 0, 0, 0}
        };

        /* parsing all parameters according to the list above is sufficent */
        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        /* dispatch the given options */
        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

            /* d, device */
        case 2:
        case 3:
            DBG("case 2,3\n");
            dev = strdup(optarg);
            break;

        case 4:
        case 5: {
            DBG("case 4,5\n");
            float min_res  = strtof(optarg, 0);
            if(min_res > 0.0) {
                min_res *= ONE_DEGREE;
                this->min_res = (int)min_res;
            }
        }
        break;

        default:
            DBG("default case\n");
            help();
            return 1;
        }
    }

    this->videodevice = (char *) calloc(1, 16 * sizeof(char));
    snprintf(this->videodevice, 12, "%s", dev);

    if((this->fd = open(this->videodevice, O_RDWR)) == -1) {
        perror("ERROR opening V4L interface");
        return -1;
    }

    struct v4l2_capability cap;
    memset(&cap, 0, sizeof(struct v4l2_capability));
    int ret = ioctl(this->fd, VIDIOC_QUERYCAP, &cap);
    if(ret < 0) {
        fprintf(stderr, "Error opening device %s: unable to query device.\n", this->videodevice);
        return -1;
    }

    if(!(cap.capabilities & V4L2_CAP_STREAMING)) {
        fprintf(stderr, "%s does not support streaming, cap=%x\n", this->videodevice, cap.capabilities);
        return -1;
    }

    initDynCtrls(this->fd);

    return 0;
}

/******************************************************************************
Description.: Stops the execution of worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int input_stop(void)
{
    DBG("will cancel input thread\n");
    pthread_cancel(cam);

    return 0;
}

/******************************************************************************
Description.: spins of a worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int input_run(void)
{

    pthread_create(&cam, 0, cam_thread, NULL);
    pthread_detach(cam);

    return 0;
}

/******************************************************************************
Description.: process commands, allows to set certain runtime configurations
              and settings like pan/tilt, colors, saturation etc.
Input Value.: * cmd specifies the command, a complete list is maintained in
                the file "input.h"
              * value is used for commands that make use of a parameter.
Return Value: depends in the command, for most cases 0 means no errors and
              -1 signals an error. This is just rule of thumb, not more!
******************************************************************************/
int input_cmd(in_cmd_type cmd, int value)
{
    int res = 0;
    static int pan = 0, tilt = 0, pan_tilt_valid = -1;
    const int one_degree = ONE_DEGREE;

    /* certain commands do not need the mutex */
    if(cmd != IN_CMD_RESET_PAN_TILT_NO_MUTEX)
        pthread_mutex_lock(&controls_mutex);

    switch(cmd) {
    case IN_CMD_HELLO:
        fprintf(stderr, "Hello from input plugin\n");
        break;

    case IN_CMD_RESET_PAN_TILT:
    case IN_CMD_RESET_PAN_TILT_NO_MUTEX:
        DBG("about to set pan/tilt to default position\n");
        if(uvcPanTilt(this->fd, 0, 0, 3) != 0) {
            res = -1;
            break;
        }
        pan_tilt_valid = 1;
        pan = tilt = 0;
        sleep(4);
        break;

    case IN_CMD_PAN_SET:
        DBG("set pan to %d degrees\n", value);

        /* in order to calculate absolute positions we must check for initialized values */
        if(pan_tilt_valid != 1) {
            if(input_cmd(IN_CMD_RESET_PAN_TILT_NO_MUTEX, 0) == -1) {
                res = -1;
                break;
            }
        }

        /* limit pan-value to min and max, multiply it with constant "one_degree" */
        value = MIN(MAX(value * one_degree, MIN_PAN), MAX_PAN);

        /* calculate the relative degrees to move to the desired absolute pan-value */
        if((res = value - pan) == 0) {
            /* do not move if this would mean to move by 0 degrees */
            res = pan / one_degree;
            break;
        }

        /* move it */
        pan = value;
        uvcPanTilt(this->fd, res, 0, 0);
        res = pan / one_degree;

        DBG("pan: %d\n", pan);
        break;

    case IN_CMD_PAN_PLUS:
        DBG("pan +\n");

        if(pan_tilt_valid != 1) {
            if(input_cmd(IN_CMD_RESET_PAN_TILT_NO_MUTEX, 0) == -1) {
                res = -1;
                break;
            }
        }

        if((MAX_PAN) >= (pan + this->min_res)) {
            pan += this->min_res;
            uvcPanTilt(this->fd, this->min_res, 0, 0);
        }
        res = pan / one_degree;

        DBG("pan: %d\n", pan);
        break;

    case IN_CMD_PAN_MINUS:
        DBG("pan -\n");

        if(pan_tilt_valid != 1) {
            if(input_cmd(IN_CMD_RESET_PAN_TILT_NO_MUTEX, 0) == -1) {
                res = -1;
                break;
            }
        }

        if((MIN_PAN) <= (pan - this->min_res)) {
            pan -= this->min_res;
            uvcPanTilt(this->fd, -this->min_res, 0, 0);
        }
        res = pan / one_degree;

        DBG("pan: %d\n", pan);
        break;

    case IN_CMD_TILT_SET:
        DBG("set tilt to %d degrees\n", value);

        if(pan_tilt_valid != 1) {
            if(input_cmd(IN_CMD_RESET_PAN_TILT_NO_MUTEX, 0) == -1) {
                res = -1;
                break;
            }
        }

        /* limit pan-value to min and max, multiply it with constant "one_degree" */
        value = MIN(MAX(value * one_degree, MIN_TILT), MAX_TILT);

        /* calculate the relative degrees to move to the desired absolute pan-value */
        if((res = value - tilt) == 0) {
            /* do not move if this would mean to move by 0 degrees */
            res = tilt / one_degree;
            break;
        }

        /* move it */
        tilt = value;
        uvcPanTilt(this->fd, 0, res, 0);
        res = tilt / one_degree;

        DBG("tilt: %d\n", tilt);
        break;

    case IN_CMD_TILT_PLUS:
        DBG("tilt +\n");

        if(pan_tilt_valid != 1) {
            if(input_cmd(IN_CMD_RESET_PAN_TILT_NO_MUTEX, 0) == -1) {
                res = -1;
                break;
            }
        }

        if((MAX_TILT) >= (tilt + this->min_res)) {
            tilt += this->min_res;
            uvcPanTilt(this->fd, 0, this->min_res, 0);
        }
        res = tilt / one_degree;

        DBG("tilt: %d\n", tilt);
        break;

    case IN_CMD_TILT_MINUS:
        DBG("tilt -\n");

        if(pan_tilt_valid != 1) {
            if(input_cmd(IN_CMD_RESET_PAN_TILT_NO_MUTEX, 0) == -1) {
                res = -1;
                break;
            }
        }

        if((MIN_TILT) <= (tilt - this->min_res)) {
            tilt -= this->min_res;
            uvcPanTilt(this->fd, 0, -this->min_res, 0);
        }
        res = tilt / one_degree;

        DBG("tilt: %d\n", tilt);
        break;

    default:
        DBG("nothing matched\n");
        res = -1;
    }

    if(cmd != IN_CMD_RESET_PAN_TILT_NO_MUTEX)
        pthread_mutex_unlock(&controls_mutex);

    return res;
}

/*** private functions for this plugin below ***/
/******************************************************************************
Description.: print a help message to stderr
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
    " Help for input plugin..: "INPUT_PLUGIN_NAME"\n" \
    " ---------------------------------------------------------------\n" \
    " The following parameters can be passed to this plugin:\n\n" \
    " [-d | --device ]...: video device to open (your camera)\n" \
    " [-m | --min ]......: set the minimum step size in degrees (defalt 5)\n");
}

/******************************************************************************
Description.: this thread worker grabs a frame and copies it to the global buffer
Input Value.: unused
Return Value: unused, always NULL
******************************************************************************/
void *cam_thread(void *arg)
{
    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(cam_cleanup, NULL);

    while(!pglobal->stop) {

        sleep(1);
        pthread_cond_broadcast(&pglobal->db_update);  //this keeps the output stream alive
        DBG("spin loop\n");
    }

    DBG("leaving input thread, calling cleanup function now\n");
    pthread_cleanup_pop(1);

    return NULL;
}

/******************************************************************************
Description.:
Input Value.:
Return Value:
******************************************************************************/
void cam_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_control/Makefile
================
###############################################################
#
# Purpose: Makefile for "M-JPEG Streamer"
# Author.: Tom Stoeveken (TST)
# Version: 0.3
# License: GPL
#
###############################################################

CC = gcc

OTHER_HEADERS = ../../mjpg_streamer.h ../../utils.h ../output.h ../input.h

CFLAGS += -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC
#CFLAGS += -DDEBUG

all: input_control.so

clean:
	rm -f *.a *.o core *~ *.so *.lo

input_control.so: $(OTHER_HEADERS) input_uvc.c dynctrl.lo
	$(CC) $(CFLAGS) $(LFLAGS) -o $@ input_uvc.c dynctrl.lo

dynctrl.lo: dynctrl.c dynctrl.h uvcvideo.h
	$(CC) -c $(CFLAGS) -o $@ dynctrl.c

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_control/uvc_compat.h
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#ifndef _UVC_COMPAT_H
#define _UVC_COMPAT_H

#include <linux/version.h>
#ifndef __KERNEL__
#ifndef __user
#define __user
#endif
#endif

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
/*
 * Extended control API
 */
struct v4l2_ext_control {
    __u32 id;
    __u32 reserved2[2];
    union {
        __s32 value;
        __s64 value64;
        void *reserved;
    };
} __attribute__((packed));

struct v4l2_ext_controls {
    __u32 ctrl_class;
    __u32 count;
    __u32 error_idx;
    __u32 reserved[2];
    struct v4l2_ext_control *controls;
};

/* Values for ctrl_class field */
#define V4L2_CTRL_CLASS_USER        0x00980000  /* Old-style 'user' controls */
#define V4L2_CTRL_CLASS_MPEG        0x00990000  /* MPEG-compression controls */

#define V4L2_CTRL_ID_MASK       (0x0fffffff)
#define V4L2_CTRL_ID2CLASS(id)      ((id) & 0x0fff0000UL)
#define V4L2_CTRL_DRIVER_PRIV(id)   (((id) & 0xffff) >= 0x1000)
/* Control flags */
#define V4L2_CTRL_FLAG_READ_ONLY    0x0004
#define V4L2_CTRL_FLAG_UPDATE       0x0008
#define V4L2_CTRL_FLAG_INACTIVE     0x0010
#define V4L2_CTRL_FLAG_SLIDER       0x0020

/* Query flags, to be ORed with the control ID */
#define V4L2_CTRL_FLAG_NEXT_CTRL    0x80000000

/* User-class control IDs defined by V4L2 */
#undef  V4L2_CID_BASE
#define V4L2_CID_BASE           (V4L2_CTRL_CLASS_USER | 0x900)
#define V4L2_CID_USER_BASE      V4L2_CID_BASE
#define V4L2_CID_USER_CLASS     (V4L2_CTRL_CLASS_USER | 1)

#define VIDIOC_G_EXT_CTRLS      _IOWR ('V', 71, struct v4l2_ext_controls)
#define VIDIOC_S_EXT_CTRLS      _IOWR ('V', 72, struct v4l2_ext_controls)
#define VIDIOC_TRY_EXT_CTRLS        _IOWR ('V', 73, struct v4l2_ext_controls)

#endif

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
/*
 * Frame size and frame rate enumeration
 *
 * Included in Linux 2.6.19
 */
enum v4l2_frmsizetypes {
    V4L2_FRMSIZE_TYPE_DISCRETE  = 1,
    V4L2_FRMSIZE_TYPE_CONTINUOUS    = 2,
    V4L2_FRMSIZE_TYPE_STEPWISE  = 3
};

struct v4l2_frmsize_discrete {
    __u32           width;      /* Frame width [pixel] */
    __u32           height;     /* Frame height [pixel] */
};

struct v4l2_frmsize_stepwise {
    __u32           min_width;  /* Minimum frame width [pixel] */
    __u32           max_width;  /* Maximum frame width [pixel] */
    __u32           step_width; /* Frame width step size [pixel] */
    __u32           min_height; /* Minimum frame height [pixel] */
    __u32           max_height; /* Maximum frame height [pixel] */
    __u32           step_height;    /* Frame height step size [pixel] */
};

struct v4l2_frmsizeenum {
    __u32           index;      /* Frame size number */
    __u32           pixel_format;   /* Pixel format */
    __u32           type;       /* Frame size type the device supports. */

    union {                 /* Frame size */
        struct v4l2_frmsize_discrete    discrete;
        struct v4l2_frmsize_stepwise    stepwise;
    };

    __u32   reserved[2];            /* Reserved space for future use */
};

enum v4l2_frmivaltypes {
    V4L2_FRMIVAL_TYPE_DISCRETE  = 1,
    V4L2_FRMIVAL_TYPE_CONTINUOUS    = 2,
    V4L2_FRMIVAL_TYPE_STEPWISE  = 3
};

struct v4l2_frmival_stepwise {
    struct v4l2_fract   min;        /* Minimum frame interval [s] */
    struct v4l2_fract   max;        /* Maximum frame interval [s] */
    struct v4l2_fract   step;       /* Frame interval step size [s] */
};

struct v4l2_frmivalenum {
    __u32           index;      /* Frame format index */
    __u32           pixel_format;   /* Pixel format */
    __u32           width;      /* Frame width */
    __u32           height;     /* Frame height */
    __u32           type;       /* Frame interval type the device supports. */

    union {                 /* Frame interval */
        struct v4l2_fract       discrete;
        struct v4l2_frmival_stepwise    stepwise;
    };

    __u32   reserved[2];            /* Reserved space for future use */
};

#define VIDIOC_ENUM_FRAMESIZES      _IOWR ('V', 74, struct v4l2_frmsizeenum)
#define VIDIOC_ENUM_FRAMEINTERVALS  _IOWR ('V', 75, struct v4l2_frmivalenum)
#endif


#endif /* _UVC_COMPAT_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_control/uvcvideo.h
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#ifndef _USB_VIDEO_H_
#define _USB_VIDEO_H_

#include <linux/kernel.h>
#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

/* Compatibility */
#include "uvc_compat.h"

/*
 * Private V4L2 control identifiers.
 */

#ifndef V4L2_CID_BACKLIGHT_COMPENSATION
#define V4L2_CID_BACKLIGHT_COMPENSATION     (V4L2_CID_PRIVATE_BASE+0)
#endif

#ifndef V4L2_CID_POWER_LINE_FREQUENCY
#define V4L2_CID_POWER_LINE_FREQUENCY       (V4L2_CID_PRIVATE_BASE+1)
#endif

#ifndef V4L2_CID_SHARPNESS
#define V4L2_CID_SHARPNESS          (V4L2_CID_PRIVATE_BASE+2)
#endif

#ifndef V4L2_CID_HUE_AUTO
#define V4L2_CID_HUE_AUTO           (V4L2_CID_PRIVATE_BASE+3)
#endif

#ifndef V4L2_CID_FOCUS_AUTO
#define V4L2_CID_FOCUS_AUTO         (V4L2_CID_PRIVATE_BASE+4)
#endif

#ifndef V4L2_CID_FOCUS_ABSOLUTE
#define V4L2_CID_FOCUS_ABSOLUTE         (V4L2_CID_PRIVATE_BASE+5)
#endif

#ifndef V4L2_CID_FOCUS_RELATIVE
#define V4L2_CID_FOCUS_RELATIVE         (V4L2_CID_PRIVATE_BASE+6)
#endif

#ifndef V4L2_CID_PAN_RELATIVE
#define V4L2_CID_PAN_RELATIVE           (V4L2_CID_PRIVATE_BASE+7)
#endif

#ifndef V4L2_CID_TILT_RELATIVE
#define V4L2_CID_TILT_RELATIVE          (V4L2_CID_PRIVATE_BASE+8)
#endif

#ifndef V4L2_CID_PANTILT_RESET
#define V4L2_CID_PANTILT_RESET          (V4L2_CID_PRIVATE_BASE+9)
#endif

#ifndef V4L2_CID_EXPOSURE_AUTO
#define V4L2_CID_EXPOSURE_AUTO          (V4L2_CID_PRIVATE_BASE+10)
#endif

#ifndef V4L2_CID_EXPOSURE_ABSOLUTE
#define V4L2_CID_EXPOSURE_ABSOLUTE      (V4L2_CID_PRIVATE_BASE+11)
#endif

#ifndef V4L2_CID_EXPOSURE_AUTO_PRIORITY
#define V4L2_CID_EXPOSURE_AUTO_PRIORITY     (V4L2_CID_PRIVATE_BASE+14)
#endif

#ifndef V4L2_CID_WHITE_BALANCE_TEMPERATURE_AUTO
#define V4L2_CID_WHITE_BALANCE_TEMPERATURE_AUTO (V4L2_CID_PRIVATE_BASE+12)
#endif

#ifndef V4L2_CID_WHITE_BALANCE_TEMPERATURE
#define V4L2_CID_WHITE_BALANCE_TEMPERATURE  (V4L2_CID_PRIVATE_BASE+13)
#endif

#ifndef V4L2_CID_PRIVATE_LAST
#define V4L2_CID_PRIVATE_LAST           V4L2_CID_EXPOSURE_AUTO_PRIORITY
#endif
/*
 * Dynamic controls
 */
/* Data types for UVC control data */
enum uvc_control_data_type {
    UVC_CTRL_DATA_TYPE_RAW = 0,
    UVC_CTRL_DATA_TYPE_SIGNED,
    UVC_CTRL_DATA_TYPE_UNSIGNED,
    UVC_CTRL_DATA_TYPE_BOOLEAN,
    UVC_CTRL_DATA_TYPE_ENUM,
    UVC_CTRL_DATA_TYPE_BITMASK,
};

#define UVC_CONTROL_SET_CUR (1 << 0)
#define UVC_CONTROL_GET_CUR (1 << 1)
#define UVC_CONTROL_GET_MIN (1 << 2)
#define UVC_CONTROL_GET_MAX (1 << 3)
#define UVC_CONTROL_GET_RES (1 << 4)
#define UVC_CONTROL_GET_DEF (1 << 5)
/* Control should be saved at suspend and restored at resume. */
#define UVC_CONTROL_RESTORE (1 << 6)

#define UVC_CONTROL_GET_RANGE   (UVC_CONTROL_GET_CUR | UVC_CONTROL_GET_MIN | \
                                 UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | \
                                 UVC_CONTROL_GET_DEF)

struct uvc_xu_control_info {
    __u8 entity[16];
    __u8 index;
    __u8 selector;
    __u16 size;
    __u32 flags;
};

struct uvc_xu_control_mapping {
    __u32 id;
    __u8 name[32];
    __u8 entity[16];
    __u8 selector;

    __u8 size;
    __u8 offset;
    enum v4l2_ctrl_type v4l2_type;
    enum uvc_control_data_type data_type;
};

struct uvc_xu_control {
    __u8 unit;
    __u8 selector;
    __u16 size;
    __u8 __user *data;
};

#define UVCIOC_CTRL_ADD     _IOW  ('U', 1, struct uvc_xu_control_info)
#define UVCIOC_CTRL_MAP     _IOWR ('U', 2, struct uvc_xu_control_mapping)
#define UVCIOC_CTRL_GET     _IOWR ('U', 3, struct uvc_xu_control)
#define UVCIOC_CTRL_SET     _IOW  ('U', 4, struct uvc_xu_control)



#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_file/CMakeLists.txt
================
check_include_files(sys/inotify.h HAVE_SYS_INOTIFY_H)

MJPG_STREAMER_PLUGIN_OPTION(input_file "File input plugin" ONLYIF HAVE_SYS_INOTIFY_H)
MJPG_STREAMER_PLUGIN_COMPILE(input_file input_file.c)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_file/input_file.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/inotify.h>
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "../../mjpg_streamer.h"
#include "../../utils.h"

#define INPUT_PLUGIN_NAME "FILE input plugin"

typedef enum _read_mode {
    NewFilesOnly,
    ExistingFiles
} read_mode;

/* private functions and variables to this plugin */
static pthread_t   worker;
static globals     *pglobal;

void *worker_thread(void *);
void worker_cleanup(void *);
void help(void);

static double delay = 1.0;
static char *folder = NULL;
static char *filename = NULL;
static int rm = 0;
static int plugin_number;
static read_mode mode = NewFilesOnly;

/* global variables for this plugin */
static int fd, rc, wd, size;
static struct inotify_event *ev;

/*** plugin interface functions ***/
int input_init(input_parameter *param, int id)
{
    int i;
    plugin_number = id;

    param->argv[0] = INPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"d", required_argument, 0, 0},
            {"delay", required_argument, 0, 0},
            {"f", required_argument, 0, 0},
            {"folder", required_argument, 0, 0},
            {"r", no_argument, 0, 0},
            {"remove", no_argument, 0, 0},
            {"n", required_argument, 0, 0},
            {"name", required_argument, 0, 0},
            {"e", no_argument, 0, 0},
            {"existing", no_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

            /* d, delay */
        case 2:
        case 3:
            DBG("case 2,3\n");
            delay = atof(optarg);
            break;

            /* f, folder */
        case 4:
        case 5:
            DBG("case 4,5\n");
            folder = malloc(strlen(optarg) + 2);
            strcpy(folder, optarg);
            if(optarg[strlen(optarg)-1] != '/')
                strcat(folder, "/");
            break;

            /* r, remove */
        case 6:
        case 7:
            DBG("case 6,7\n");
            rm = 1;
            break;

            /* n, name */
        case 8:
        case 9:
            DBG("case 8,9\n");
            filename = malloc(strlen(optarg) + 1);
            strcpy(filename, optarg);
            break;
            /* e, existing */
        case 10:
        case 11:
            DBG("case 10,11\n");
            mode = ExistingFiles;
            break;
        default:
            DBG("default case\n");
            help();
            return 1;
        }
    }

    pglobal = param->global;

    /* check for required parameters */
    if(folder == NULL) {
        IPRINT("ERROR: no folder specified\n");
        return 1;
    }

    IPRINT("folder to watch...: %s\n", folder);
    IPRINT("forced delay......: %.4f\n", delay);
    IPRINT("delete file.......: %s\n", (rm) ? "yes, delete" : "no, do not delete");
    IPRINT("filename must be..: %s\n", (filename == NULL) ? "-no filter for certain filename set-" : filename);

    param->global->in[id].name = malloc((strlen(INPUT_PLUGIN_NAME) + 1) * sizeof(char));
    sprintf(param->global->in[id].name, INPUT_PLUGIN_NAME);

    return 0;
}

int input_stop(int id)
{
    DBG("will cancel input thread\n");
    pthread_cancel(worker);
    return 0;
}

int input_run(int id)
{
    pglobal->in[id].buf = NULL;

    if (mode == NewFilesOnly) {
        rc = fd = inotify_init();
        if(rc == -1) {
            perror("could not initilialize inotify");
            return 1;
        }

        rc = wd = inotify_add_watch(fd, folder, IN_CLOSE_WRITE | IN_MOVED_TO | IN_ONLYDIR);
        if(rc == -1) {
            perror("could not add watch");
            return 1;
        }

        size = sizeof(struct inotify_event) + (1 << 16);
        ev = malloc(size);
        if(ev == NULL) {
            perror("not enough memory");
            return 1;
        }
    }

    if(pthread_create(&worker, 0, worker_thread, NULL) != 0) {
        free(pglobal->in[id].buf);
        fprintf(stderr, "could not start worker thread\n");
        exit(EXIT_FAILURE);
    }

    pthread_detach(worker);

    return 0;
}

/*** private functions for this plugin below ***/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
    " Help for input plugin..: "INPUT_PLUGIN_NAME"\n" \
    " ---------------------------------------------------------------\n" \
    " The following parameters can be passed to this plugin:\n\n" \
    " [-d | --delay ]........: delay (in seconds) to pause between frames\n" \
    " [-f | --folder ].......: folder to watch for new JPEG files\n" \
    " [-r | --remove ].......: remove/delete JPEG file after reading\n" \
    " [-n | --name ].........: ignore changes unless filename matches\n" \
    " [-e | --existing ].....: serve the existing *.jpg files from the specified directory\n" \
    " ---------------------------------------------------------------\n");
}

/* the single writer thread */
void *worker_thread(void *arg)
{
    char buffer[1<<16];
    int file;
    size_t filesize = 0;
    struct stat stats;
    struct dirent **fileList;
    int fileCount = 0;
    int currentFileNumber = 0;
    char hasJpgFile = 0;
    struct timeval timestamp;

    if (mode == ExistingFiles) {
        fileCount = scandir(folder, &fileList, 0, alphasort);
        if (fileCount < 0) {
           perror("error during scandir\n");
           return NULL;
        }
    }

    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, NULL);

    while(!pglobal->stop) {
        if (mode == NewFilesOnly) {
            /* wait for new frame, read will block until something happens */
            rc = read(fd, ev, size);
            if(rc == -1) {
                perror("reading inotify events failed\n");
                break;
            }

            /* sanity check */
            if(wd != ev->wd) {
                fprintf(stderr, "This event is not for the watched directory (%d != %d)\n", wd, ev->wd);
                continue;
            }

            if(ev->mask & (IN_IGNORED | IN_Q_OVERFLOW | IN_UNMOUNT)) {
                fprintf(stderr, "event mask suggests to stop\n");
                break;
            }

            /* prepare filename */
            snprintf(buffer, sizeof(buffer), "%s%s", folder, ev->name);

            /* check if the filename matches specified parameter (if given) */
            if((filename != NULL) && (strcmp(filename, ev->name) != 0)) {
                DBG("ignoring this change (specified filename does not match)\n");
                continue;
            }
            DBG("new file detected: %s\n", buffer);
        } else {
            if ((strstr(fileList[currentFileNumber]->d_name, ".jpg") != NULL) ||
                (strstr(fileList[currentFileNumber]->d_name, ".JPG") != NULL)) {
                hasJpgFile = 1;
                DBG("serving file: %s\n", fileList[currentFileNumber]->d_name);
                snprintf(buffer, sizeof(buffer), "%s%s", folder, fileList[currentFileNumber]->d_name);
                currentFileNumber++;
                if (currentFileNumber == fileCount)
                    currentFileNumber = 0;
            } else {
                currentFileNumber++;
                if (currentFileNumber == fileCount) {
                    if(hasJpgFile == 0) {
                        perror("No files with jpg/JPG extension in the folder\n");
                        goto thread_quit;
                    } else {
                        // There are some jpeg files, the last one just happens not to be one
                        currentFileNumber = 0;
                    }
                }
                continue;
            }
        }

        /* open file for reading */
        rc = file = open(buffer, O_RDONLY);
        if(rc == -1) {
            perror("could not open file for reading");
            break;
        }

        /* approximate size of file */
        rc = fstat(file, &stats);
        if(rc == -1) {
            perror("could not read statistics of file");
            close(file);
            break;
        }

        filesize = stats.st_size;

        /* copy frame from file to global buffer */
        pthread_mutex_lock(&pglobal->in[plugin_number].db);

        /* allocate memory for frame */
        if(pglobal->in[plugin_number].buf != NULL)
            free(pglobal->in[plugin_number].buf);

        pglobal->in[plugin_number].buf = malloc(filesize + (1 << 16));

        if(pglobal->in[plugin_number].buf == NULL) {
            fprintf(stderr, "could not allocate memory\n");
            break;
        }

        if((pglobal->in[plugin_number].size = read(file, pglobal->in[plugin_number].buf, filesize)) == -1) {
            perror("could not read from file");
            free(pglobal->in[plugin_number].buf); pglobal->in[plugin_number].buf = NULL; pglobal->in[plugin_number].size = 0;
            pthread_mutex_unlock(&pglobal->in[plugin_number].db);
            close(file);
            break;
        }

        gettimeofday(&timestamp, NULL);
        pglobal->in[plugin_number].timestamp = timestamp;
        DBG("new frame copied (size: %d)\n", pglobal->in[plugin_number].size);
        /* signal fresh_frame */
        pthread_cond_broadcast(&pglobal->in[plugin_number].db_update);
        pthread_mutex_unlock(&pglobal->in[plugin_number].db);

        close(file);

        /* delete file if necessary */
        if(rm) {
            rc = unlink(buffer);
            if(rc == -1) {
                perror("could not remove/delete file");
            }
        }

        if(delay != 0)
            usleep(1000 * 1000 * delay);
    }

thread_quit:
    while (fileCount--) {
       free(fileList[fileCount]);
    }
    free(fileList);

    DBG("leaving input thread, calling cleanup function now\n");
    /* call cleanup handler, signal with the parameter */
    pthread_cleanup_pop(1);

    return NULL;
}

void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
    DBG("cleaning up resources allocated by input thread\n");

    if(pglobal->in[plugin_number].buf != NULL) free(pglobal->in[plugin_number].buf);

    free(ev);

    if (mode == NewFilesOnly) {
        rc = inotify_rm_watch(fd, wd);
        if(rc == -1) {
            perror("could not close watch descriptor");
        }

        rc = close(fd);
        if(rc == -1) {
            perror("could not close filedescriptor");
        }
    }
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_file/Makefile
================
###############################################################
#
# Purpose: Makefile for "M-JPEG Streamer"
# Author.: Tom Stoeveken (TST)
# Version: 0.3
# License: GPL
#
###############################################################

CC = gcc

OTHER_HEADERS = ../../mjpg_streamer.h ../../utils.h ../output.h ../input.h

CFLAGS += -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC
#CFLAGS += -DDEBUG
LFLAGS += 

all: input_file.so

clean:
	rm -f *.a *.o core *~ *.so *.lo

input_file.so: $(OTHER_HEADERS) input_file.c
	$(CC) $(CFLAGS) $(LFLAGS) -o $@ input_file.c

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_http/CMakeLists.txt
================
MJPG_STREAMER_PLUGIN_OPTION(input_http "HTTP input proxy plugin")
MJPG_STREAMER_PLUGIN_COMPILE(input_http input_http.c misc.c mjpg-proxy.c)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_http/input_http.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
# Modified by Eugene Katsevman, 2011                                           #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <syslog.h>

#include "../../mjpg_streamer.h"
#include "../../utils.h"

#include "mjpg-proxy.h"

/* private functions and variables to this plugin */
static pthread_t   worker;
static globals     *pglobal;
static pthread_mutex_t controls_mutex;
static int plugin_number;

void *worker_thread(void *);
void worker_cleanup(void *);

#define INPUT_PLUGIN_NAME "HTTP Input plugin"

struct extractor_state  proxy;

/*** plugin interface functions ***/

/******************************************************************************
Description.: parse input parameters
Input Value.: param contains the command line string and a pointer to globals
Return Value: 0 if everything is ok
******************************************************************************/


int input_init(input_parameter *param, int plugin_no)
{
    int i;

    if(pthread_mutex_init(&controls_mutex, NULL) != 0) {
        IPRINT("could not initialize mutex variable\n");
        exit(EXIT_FAILURE);
    }

    param->argv[0] = INPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }
    init_mjpg_proxy( &proxy );

    reset_getopt();
    if (parse_cmd_line(&proxy, param->argc, param->argv))
       return 1;

    pglobal = param->global;

    IPRINT("host.............: %s\n", proxy.hostname);
    IPRINT("port.............: %s\n", proxy.port);

    return 0;
}

/******************************************************************************
Description.: stops the execution of the worker thread
Input Value.: -
Return Value: 0
******************************************************************************/
int input_stop(int id)
{
    DBG("will cancel input thread\n");
    pthread_cancel(worker);
    return 0;
}

/******************************************************************************
Description.: starts the worker thread and allocates memory
Input Value.: -
Return Value: 0
******************************************************************************/
int input_run(int id)
{
    pglobal->in[id].buf = malloc(256 * 1024);
    if(pglobal->in[id].buf == NULL) {
        fprintf(stderr, "could not allocate memory\n");
        exit(EXIT_FAILURE);
    }

    if(pthread_create(&worker, 0, worker_thread, NULL) != 0) {
        free(pglobal->in[id].buf);
        fprintf(stderr, "could not start worker thread\n");
        exit(EXIT_FAILURE);
    }
    pthread_detach(worker);

    return 0;
}


void on_image_received(char * data, int length){
        /* copy JPG picture to global buffer */
        pthread_mutex_lock(&pglobal->in[plugin_number].db);

        pglobal->in[plugin_number].size = length;
        memcpy(pglobal->in[plugin_number].buf, data, pglobal->in[plugin_number].size);

        /* signal fresh_frame */
        pthread_cond_broadcast(&pglobal->in[plugin_number].db_update);
        pthread_mutex_unlock(&pglobal->in[plugin_number].db);

}

void *worker_thread(void *arg)
{

    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, NULL);

    proxy.on_image_received = on_image_received;
    proxy.should_stop =  & pglobal->stop;
    connect_and_stream(&proxy);

    IPRINT("leaving input thread, calling cleanup function now\n");
    pthread_cleanup_pop(1);

    return NULL;
}

/******************************************************************************
Description.: this functions cleans up allocated resources
Input Value.: arg is unused
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
    DBG("cleaning up resources allocated by input thread\n");
    close_mjpg_proxy(&proxy);
    if(pglobal->in[plugin_number].buf != NULL) free(pglobal->in[plugin_number].buf);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_http/misc.c
================
/*******************************************************************************
#                                                                              #
#      Copyright (C) 2011 Eugene Katsevman                                     #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include "misc.h"


// dumb 4 byte storing to detect double CRLF
int is_crlf(int bytes) {
    int result = (((13 << 8) | (10)) & bytes) == ((13 << 8) | (10));
    return result ;
}

int is_crlfcrlf(int bytes) {
    int result = is_crlf(bytes) && is_crlf(bytes >> 16);
    return result;

}
void push_byte(int * bytes, char byte) {
    * bytes = ((* bytes) << 8) | byte ;
}

int min(int a, int b) {
    if (a<b)
        return a;
    else
        return b;
}


void search_pattern_reset(struct search_pattern * pattern) {
    pattern->current_matched_char = pattern->string;
}

int search_pattern_compare(struct search_pattern * pattern, char c) {
    if (* (pattern->current_matched_char) == c)
    {
        pattern->current_matched_char ++;
        return 1;
    } else {
        search_pattern_reset(pattern);
        return 0;
    }
}

int search_pattern_matches(struct search_pattern * pattern) {
    return  *(pattern->current_matched_char)==0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_http/misc.h
================
/*******************************************************************************
#                                                                              #
#      Copyright (C) 2011 Eugene Katsevman                                     #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#ifndef HTTP_UTILS
#define HTTP_UTILS

int min(int a, int b);
void write_image(char * image, int length);

// dumb 4 byte storing to detect double CRLF
int is_crlf(int bytes);

int is_crlfcrlf(int bytes) ;
void push_byte(int * bytes, char byte);

struct search_pattern {
    const char * string;
    const char * current_matched_char;
};

void search_pattern_reset(struct search_pattern * pattern);


int search_pattern_compare(struct search_pattern * pattern, char c) ;

int search_pattern_matches(struct search_pattern * pattern);



#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_http/mjpg-proxy.c
================
/*******************************************************************************
#                                                                              #
#      Copyright (C) 2011 Eugene Katsevman                                     #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <getopt.h>


#include "version.h"

#include "mjpg-proxy.h"

#include "misc.h"



#define HEADER 1
#define CONTENT 0
#define NETBUFFER_SIZE 1024 * 4
#define TRUE 1
#define FALSE 0

const char * CONTENT_LENGTH = "Content-Length:";
// TODO: this must be decoupled from mjpeg-streamer
const char * BOUNDARY =     "--boundarydonotcross";

void init_extractor_state(struct extractor_state * state) {
    state->length = 0;
    state->part = HEADER;
    state->last_four_bytes = 0;
    state->contentlength.string = CONTENT_LENGTH;
    state->boundary.string = BOUNDARY;
    search_pattern_reset(&state->contentlength);
    search_pattern_reset(&state->boundary);
}

void init_mjpg_proxy(struct extractor_state * state){
    state->hostname = strdup("localhost");
    state->port = strdup("8080");

    init_extractor_state(state);
}

// main method
// we process all incoming buffer byte per byte and extract binary data from it to state->buffer
// if boundary is detected, then callback for image processing is run
// TODO; decouple from mjpeg streamer and ensure content-length processing
//       for that, we must properly work with headers, not just detect them
void extract_data(struct extractor_state * state, char * buffer, int length) {
    int i;
    for (i = 0; i < length && !*(state->should_stop); i++) {
        switch (state->part) {
        case HEADER:
            push_byte(&state->last_four_bytes, buffer[i]);
            if (is_crlfcrlf(state->last_four_bytes))
                state->part = CONTENT;
            else if (is_crlf(state->last_four_bytes))
                search_pattern_reset(&state->contentlength);
            else {
                search_pattern_compare(&state->contentlength, buffer[i]);
                if (search_pattern_matches(&state->contentlength)) {
                    DBG("Content length found\n");
                    search_pattern_reset(&state->contentlength);
                }
            }
            break;

        case CONTENT:
            if (state->length >= BUFFER_SIZE - 1) {
                perror("Buffer too small\n");
                break;
            }
            state->buffer[state->length++] = buffer[i];
            search_pattern_compare(&state->boundary, buffer[i]);
            if (search_pattern_matches(&state->boundary)) {
                state->length -= (strlen(state->boundary.string)+2); // magic happens here
                DBG("Image of length %d received\n", (int)state->length);
                if (state->on_image_received) // callback
                  state->on_image_received(state->buffer, state->length);
                init_extractor_state(state); // reset fsm
            }
            break;
        }

    }

}

char request [] = "GET /?action=stream HTTP/1.0\r\n\r\n";

void send_request_and_process_response(struct extractor_state * state) {
    int recv_length;
    char netbuffer[NETBUFFER_SIZE];

    init_extractor_state(state);
    
    // send request
    send(state->sockfd, request, sizeof(request), 0);

    // and listen for answer until sockerror or THEY stop us 
    // TODO: we must handle EINTR here, it really might occur
    while ( (recv_length = recv(state->sockfd, netbuffer, sizeof(netbuffer), 0)) > 0 && !*(state->should_stop))
        extract_data(state, netbuffer, recv_length);

}

// TODO:this must be reworked to decouple from mjpeg-streamer
void show_help(char * program_name) {

fprintf(stderr, " ---------------------------------------------------------------\n" \
                " Help for input plugin..: %s\n" \
                " ---------------------------------------------------------------\n" \
                " The following parameters can be passed to this plugin:\n\n" \
                " [-v | --version ]........: current SVN Revision\n" \
                " [-h | --help]............: show this message\n"
                " [-H | --host]............: select host to data from, localhost is default\n"
                " [-p | --port]............: port, defaults to 8080\n"
                " ---------------------------------------------------------------\n", program_name);
}
// TODO: this must be reworked, too. I don't know how
void show_version() {
    printf("Version - %s\n", VERSION);
}

int parse_cmd_line(struct extractor_state * state, int argc, char * argv []) {
    while (TRUE) {
        static struct option long_options [] = {
            {"help", no_argument, 0, 'h'},
            {"version", no_argument, 0, 'v'},
            {"host", required_argument, 0, 'H'},
            {"port", required_argument, 0, 'p'},
            {0,0,0,0}
        };

        int index = 0, c = 0;
        c = getopt_long_only(argc,argv, "hvH:p:", long_options, &index);

        if (c==-1) break;

        if (c=='?'){
            show_help(argv[0]);
            return 1;
            }
        else
            switch (c) {
            case 'h' :
                show_help(argv[0]);
                return 1;
                break;
            case 'v' :
                show_version();
                return 1;
                break;
            case 'H' :
                free(state->hostname);
                state->hostname = strdup(optarg);
                break;
            case 'p' :
                free(state->port);
                state->port = strdup(optarg);
                break;
            }
    }

  return 0;
}

// TODO: consider using hints for http

// TODO: consider moving delays to plugin command line arguments
void connect_and_stream(struct extractor_state * state){
    struct addrinfo * info, * rp;
    int errorcode;
    while (TRUE) {
        errorcode = getaddrinfo(state->hostname, state->port, NULL, &info);
        if (errorcode) {
            perror(gai_strerror(errorcode));
        };
        for (rp = info ; rp != NULL; rp = rp->ai_next) {
            state->sockfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
            if (state->sockfd <0) {
                perror("Can't allocate socket, will continue probing\n");
                continue;
            }

            DBG("socket value is %d\n", state->sockfd);
            if (connect(state->sockfd, (struct sockaddr *) rp->ai_addr, rp->ai_addrlen)>=0 ) {
                DBG("connected to host\n");
                break;
            }

            close(state->sockfd);

        }

        freeaddrinfo(info);

        if (rp==NULL) {
            perror("Can't connect to server, will retry in 5 sec");
            sleep(5);
        }
        else
        {
            send_request_and_process_response(state);
            
            DBG ("Closing socket\n");
            close (state->sockfd);
            if (*state->should_stop)
              break;
            sleep(1);
        };
    }

}

void close_mjpg_proxy(struct extractor_state * state){
    free(state->hostname);
    free(state->port);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_http/mjpg-proxy.h
================
/*******************************************************************************
#                                                                              #
#      Copyright (C) 2011 Eugene Katsevman                                     #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#ifndef MJPG_PROXY_H
#define MJPG_PROXY_H

#include "misc.h"


#ifndef DBG
#ifdef DEBUG
#define DBG(...) fprintf(stderr, " DBG(%s, %s(), %d): ", __FILE__, __FUNCTION__, __LINE__); fprintf(stderr, __VA_ARGS__)
#else
#define DBG(...)
#endif
#endif

#define BUFFER_SIZE 1024 * 256

struct extractor_state {
    
    char * port;
    char * hostname;

    // this is current result
    char buffer [BUFFER_SIZE];
    int length;

    // this is inner state of a parser

    int sockfd;
    int part;
    int last_four_bytes;
    struct search_pattern contentlength;
    struct search_pattern boundary;

    int * should_stop;
    void (*on_image_received)(char * data, int length);
        
};

void init_mjpg_proxy(struct extractor_state  * state);

int parse_cmd_line(struct extractor_state * out_state, int argc, char * argv []);

void connect_and_stream(struct extractor_state * state);

void close_mjpg_proxy(struct extractor_state * state);

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_http/version.h
================
#define VERSION "No version"

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_cpp/CMakeLists.txt
================
MJPG_STREAMER_PLUGIN_OPTION(cvfilter_cpp "OpenCV example filter")
MJPG_STREAMER_PLUGIN_COMPILE(cvfilter_cpp filter_cpp.cpp)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_cpp/filter_cpp.cpp
================
/**
    Example C++ OpenCV filter plugin that doesn't do anything. Copy/paste this
    to create your own awesome filter plugins for mjpg-streamer.
    
    At the moment, only the input_opencv.so plugin supports filter plugins.
*/

#include "opencv2/opencv.hpp"

using namespace cv;
using namespace std;

// exports for the filter
extern "C" {
    bool filter_init(const char * args, void** filter_ctx);
    void filter_process(void* filter_ctx, Mat &src, Mat &dst);
    void filter_free(void* filter_ctx);
}


/**
    Initializes the filter. If you return something, it will be passed to the
    filter_process function, and should be freed by the filter_free function
*/
bool filter_init(const char * args, void** filter_ctx) {
    return true;
}

/**
    Called by the OpenCV plugin upon each frame
*/
void filter_process(void* filter_ctx, Mat &src, Mat &dst) {
    // TODO insert your filter code here
    dst = src;
}

/**
    Called when the input plugin is cleaning up
*/
void filter_free(void* filter_ctx) {
    // empty
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_cpp/README.md
================
input_opencv filter plugin: cvfilter_cpp
========================================

This is just a demonstration plugin that shows how to create a bare minimum
filter plugin for use with the mjpg-streamer input_opencv plugin.

To create your own filter plugin, just copy filter_cpp.cpp to your own project,
and compile/link it with the same build of OpenCV that mjpg-streamer is linked
to.

CMakeLists.txt is specific to the mjpg-streamer build tree, and won't be useful
outside of it.

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_py/cmake/FindNumpy.cmake
================
#-------------------------------------------------------------------------------
# Copyright (c) 2013, Lars Baehren <lbaehren@gmail.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#-------------------------------------------------------------------------------

# - Check for the presence of NumPy
#
# The following variables are set when NumPy is found:
#  NUMPY_FOUND      = Set to true, if all components of NUMPY have been found.
#  NUMPY_INCLUDES   = Include path for the header files of NUMPY
#  NUMPY_LIBRARIES  = Link these to use NUMPY
#  NUMPY_LFLAGS     = Linker flags (optional)

if (NOT NUMPY_FOUND)

    if (NOT NUMPY_ROOT_DIR)
        set (NUMPY_ROOT_DIR ${CMAKE_INSTALL_PREFIX})
    endif (NOT NUMPY_ROOT_DIR)

    if (NOT PYTHON_FOUND)
        find_package (PythonInterp)
    endif (NOT PYTHON_FOUND)

    ##__________________________________________________________________________
    ## Check for the header files

    ## Use Python to determine the include directory
    execute_process (
        COMMAND ${PYTHON_EXECUTABLE} -c import\ sys,\ numpy\;\ sys.stdout.write\(numpy.get_include\(\)\)\;
        ERROR_VARIABLE NUMPY_FIND_ERROR
        RESULT_VARIABLE NUMPY_FIND_RESULT
        OUTPUT_VARIABLE NUMPY_FIND_OUTPUT
        OUTPUT_STRIP_TRAILING_WHITESPACE
        )
    ## process the output from the execution of the command
    if (NOT NUMPY_FIND_RESULT)
        set (NUMPY_INCLUDES ${NUMPY_FIND_OUTPUT})
    endif (NOT NUMPY_FIND_RESULT)

    ##__________________________________________________________________________
    ## Check for the library

    unset (NUMPY_LIBRARIES)

    if (PYTHON_SITE_PACKAGES)
        find_library (NUMPY_NPYMATH_LIBRARY npymath
            HINTS ${PYTHON_SITE_PACKAGES}/numpy/core
            PATH_SUFFIXES lib
            )
        if (NUMPY_NPYMATH_LIBRARY)
            list (APPEND NUMPY_LIBRARIES ${NUMPY_NPYMATH_LIBRARY})
        endif (NUMPY_NPYMATH_LIBRARY)
    endif (PYTHON_SITE_PACKAGES)

    ##__________________________________________________________________________
    ## Get API version of NumPy from 'numpy/numpyconfig.h'

    if (PYTHON_EXECUTABLE)
        execute_process (
            COMMAND ${PYTHON_EXECUTABLE} -c import\ sys,\ numpy\;\ sys.stdout.write\(numpy.__version__\)\;
            ERROR_VARIABLE NUMPY_API_VERSION_ERROR
            RESULT_VARIABLE NUMPY_API_VERSION_RESULT
            OUTPUT_VARIABLE NUMPY_API_VERSION
            OUTPUT_STRIP_TRAILING_WHITESPACE
            )
    else ()
        ## Backup procedure: extract version number directly from the header file
        if (NUMPY_INCLUDES)
            find_file (HAVE_NUMPYCONFIG_H numpy/numpyconfig.h
                HINTS ${NUMPY_INCLUDES}
                )
        endif (NUMPY_INCLUDES)
    endif ()

    ## Dissect full version number into major, minor and patch version
    if (NUMPY_API_VERSION)
        string (REGEX REPLACE "\\." ";" _tmp ${NUMPY_API_VERSION})
        list (GET _tmp 0 NUMPY_API_VERSION_MAJOR)
        list (GET _tmp 1 NUMPY_API_VERSION_MINOR)
        list (GET _tmp 2 NUMPY_API_VERSION_PATCH)
    endif (NUMPY_API_VERSION)

    ##__________________________________________________________________________
    ## Actions taken when all components have been found

    find_package_handle_standard_args (NUMPY DEFAULT_MSG NUMPY_INCLUDES)

    if (NUMPY_FOUND)
        if (NOT NUMPY_FIND_QUIETLY)
            message (STATUS "Found components for NumPy")
            message (STATUS "NUMPY_ROOT_DIR    = ${NUMPY_ROOT_DIR}")
            message (STATUS "NUMPY_INCLUDES    = ${NUMPY_INCLUDES}")
            message (STATUS "NUMPY_LIBRARIES   = ${NUMPY_LIBRARIES}")
            message (STATUS "NUMPY_API_VERSION = ${NUMPY_API_VERSION}")
        endif (NOT NUMPY_FIND_QUIETLY)
    else (NUMPY_FOUND)
        if (NUMPY_FIND_REQUIRED)
            message (FATAL_ERROR "Could not find NUMPY!")
        endif (NUMPY_FIND_REQUIRED)
    endif (NUMPY_FOUND)

    ##__________________________________________________________________________
    ## Mark advanced variables

  mark_as_advanced (
    NUMPY_ROOT_DIR
    NUMPY_INCLUDES
    NUMPY_LIBRARIES
    )

endif (NOT NUMPY_FOUND)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_py/CMakeLists.txt
================
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

# Required for old versions of cmake
set(Python_ADDITIONAL_VERSIONS 3.4 3.5)

# find python and numpy
find_package(PythonLibs)
find_package(Numpy)

MJPG_STREAMER_PLUGIN_OPTION(cvfilter_py "OpenCV python filter"
                            ONLYIF PYTHONLIBS_FOUND NUMPY_FOUND ${PYTHON_VERSION_MAJOR} EQUAL 3)
                            
if (PLUGIN_CVFILTER_PY)
    include_directories(${PYTHON_INCLUDE_DIRS})
    include_directories(${NUMPY_INCLUDES})
    

    MJPG_STREAMER_PLUGIN_COMPILE(cvfilter_py filter_py.cpp conversion.cpp)
    
    target_link_libraries(cvfilter_py ${OpenCV_LIBS})
    target_link_libraries(cvfilter_py ${PYTHON_LIBRARIES})
endif()

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_py/conversion.cpp
================
// borrowed in spirit from https://github.com/yati-sagade/opencv-ndarray-conversion
// MIT License

#include "conversion.h"

#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <numpy/ndarrayobject.h>

#if PY_VERSION_HEX >= 0x03000000
    #define PyInt_Check PyLong_Check
    #define PyInt_AsLong PyLong_AsLong
#endif

struct Tmp {
    const char * name;

    Tmp(const char * name ) : name(name) {}
};

Tmp info("return value");

bool NDArrayConverter::init_numpy() {
    // bug: import_array will hide the inner exception if something fails, so 
    //      go ahead and import the numpy module first
    PyObject * np_module = PyImport_ImportModule("numpy.core.multiarray");
    if (np_module == NULL) {
        PyErr_Print();
        return false;
    }
    
    Py_DECREF(np_module);
    
    // this has to be in this file, since PyArray_API is defined as static
    import_array1(false);
    return true;
}

/*
 * The following conversion functions are taken/adapted from OpenCV's cv2.cpp file
 * inside modules/python/src2 folder (OpenCV 3.1.0)
 */

static PyObject* opencv_error = 0;

static int failmsg(const char *fmt, ...)
{
    char str[1000];

    va_list ap;
    va_start(ap, fmt);
    vsnprintf(str, sizeof(str), fmt, ap);
    va_end(ap);

    PyErr_SetString(PyExc_TypeError, str);
    return 0;
}

class PyAllowThreads
{
public:
    PyAllowThreads() : _state(PyEval_SaveThread()) {}
    ~PyAllowThreads()
    {
        PyEval_RestoreThread(_state);
    }
private:
    PyThreadState* _state;
};

class PyEnsureGIL
{
public:
    PyEnsureGIL() : _state(PyGILState_Ensure()) {}
    ~PyEnsureGIL()
    {
        PyGILState_Release(_state);
    }
private:
    PyGILState_STATE _state;
};

#define ERRWRAP2(expr) \
try \
{ \
    PyAllowThreads allowThreads; \
    expr; \
} \
catch (const cv::Exception &e) \
{ \
    PyErr_SetString(opencv_error, e.what()); \
    return 0; \
}

using namespace cv;

class NumpyAllocator : public MatAllocator
{
public:
    NumpyAllocator() { stdAllocator = Mat::getStdAllocator(); }
    ~NumpyAllocator() {}

    UMatData* allocate(PyObject* o, int dims, const int* sizes, int type, size_t* step) const
    {
        UMatData* u = new UMatData(this);
        u->data = u->origdata = (uchar*)PyArray_DATA((PyArrayObject*) o);
        npy_intp* _strides = PyArray_STRIDES((PyArrayObject*) o);
        for( int i = 0; i < dims - 1; i++ )
            step[i] = (size_t)_strides[i];
        step[dims-1] = CV_ELEM_SIZE(type);
        u->size = sizes[0]*step[0];
        u->userdata = o;
        return u;
    }

    UMatData* allocate(int dims0, const int* sizes, int type, void* data, size_t* step, int flags, UMatUsageFlags usageFlags) const
    {
        if( data != 0 )
        {
            CV_Error(Error::StsAssert, "The data should normally be NULL!");
            // probably this is safe to do in such extreme case
            return stdAllocator->allocate(dims0, sizes, type, data, step, flags, usageFlags);
        }
        PyEnsureGIL gil;

        int depth = CV_MAT_DEPTH(type);
        int cn = CV_MAT_CN(type);
        const int f = (int)(sizeof(size_t)/8);
        int typenum = depth == CV_8U ? NPY_UBYTE : depth == CV_8S ? NPY_BYTE :
        depth == CV_16U ? NPY_USHORT : depth == CV_16S ? NPY_SHORT :
        depth == CV_32S ? NPY_INT : depth == CV_32F ? NPY_FLOAT :
        depth == CV_64F ? NPY_DOUBLE : f*NPY_ULONGLONG + (f^1)*NPY_UINT;
        int i, dims = dims0;
        cv::AutoBuffer<npy_intp> _sizes(dims + 1);
        for( i = 0; i < dims; i++ )
            _sizes[i] = sizes[i];
        if( cn > 1 )
            _sizes[dims++] = cn;
        PyObject* o = PyArray_SimpleNew(dims, _sizes, typenum);
        if(!o)
            CV_Error_(Error::StsError, ("The numpy array of typenum=%d, ndims=%d can not be created", typenum, dims));
        return allocate(o, dims0, sizes, type, step);
    }

    bool allocate(UMatData* u, int accessFlags, UMatUsageFlags usageFlags) const
    {
        return stdAllocator->allocate(u, accessFlags, usageFlags);
    }

    void deallocate(UMatData* u) const
    {
        if(!u)
            return;
        PyEnsureGIL gil;
        CV_Assert(u->urefcount >= 0);
        CV_Assert(u->refcount >= 0);
        if(u->refcount == 0)
        {
            PyObject* o = (PyObject*)u->userdata;
            Py_XDECREF(o);
            delete u;
        }
    }

    const MatAllocator* stdAllocator;
};

NumpyAllocator g_numpyAllocator;

bool NDArrayConverter::toMat(PyObject *o, Mat &m)
{
    bool allowND = true;
    if(!o || o == Py_None)
    {
        if( !m.data )
            m.allocator = &g_numpyAllocator;
        return true;
    }

    if( PyInt_Check(o) )
    {
        double v[] = {static_cast<double>(PyInt_AsLong((PyObject*)o)), 0., 0., 0.};
        m = Mat(4, 1, CV_64F, v).clone();
        return true;
    }
    if( PyFloat_Check(o) )
    {
        double v[] = {PyFloat_AsDouble((PyObject*)o), 0., 0., 0.};
        m = Mat(4, 1, CV_64F, v).clone();
        return true;
    }
    if( PyTuple_Check(o) )
    {
        int i, sz = (int)PyTuple_Size((PyObject*)o);
        m = Mat(sz, 1, CV_64F);
        for( i = 0; i < sz; i++ )
        {
            PyObject* oi = PyTuple_GET_ITEM(o, i);
            if( PyInt_Check(oi) )
                m.at<double>(i) = (double)PyInt_AsLong(oi);
            else if( PyFloat_Check(oi) )
                m.at<double>(i) = (double)PyFloat_AsDouble(oi);
            else
            {
                failmsg("%s is not a numerical tuple", info.name);
                m.release();
                return false;
            }
        }
        return true;
    }

    if( !PyArray_Check(o) )
    {
        failmsg("%s is not a numpy array, neither a scalar", info.name);
        return false;
    }

    PyArrayObject* oarr = (PyArrayObject*) o;

    bool needcopy = false, needcast = false;
    int typenum = PyArray_TYPE(oarr), new_typenum = typenum;
    int type = typenum == NPY_UBYTE ? CV_8U :
               typenum == NPY_BYTE ? CV_8S :
               typenum == NPY_USHORT ? CV_16U :
               typenum == NPY_SHORT ? CV_16S :
               typenum == NPY_INT ? CV_32S :
               typenum == NPY_INT32 ? CV_32S :
               typenum == NPY_FLOAT ? CV_32F :
               typenum == NPY_DOUBLE ? CV_64F : -1;

    if( type < 0 )
    {
        if( typenum == NPY_INT64 || typenum == NPY_UINT64 || typenum == NPY_LONG )
        {
            needcopy = needcast = true;
            new_typenum = NPY_INT;
            type = CV_32S;
        }
        else
        {
            failmsg("%s data type = %d is not supported", info.name, typenum);
            return false;
        }
    }

#ifndef CV_MAX_DIM
    const int CV_MAX_DIM = 32;
#endif

    int ndims = PyArray_NDIM(oarr);
    if(ndims >= CV_MAX_DIM)
    {
        failmsg("%s dimensionality (=%d) is too high", info.name, ndims);
        return false;
    }

    int size[CV_MAX_DIM+1];
    size_t step[CV_MAX_DIM+1];
    size_t elemsize = CV_ELEM_SIZE1(type);
    const npy_intp* _sizes = PyArray_DIMS(oarr);
    const npy_intp* _strides = PyArray_STRIDES(oarr);
    bool ismultichannel = ndims == 3 && _sizes[2] <= CV_CN_MAX;

    for( int i = ndims-1; i >= 0 && !needcopy; i-- )
    {
        // these checks handle cases of
        //  a) multi-dimensional (ndims > 2) arrays, as well as simpler 1- and 2-dimensional cases
        //  b) transposed arrays, where _strides[] elements go in non-descending order
        //  c) flipped arrays, where some of _strides[] elements are negative
        // the _sizes[i] > 1 is needed to avoid spurious copies when NPY_RELAXED_STRIDES is set
        if( (i == ndims-1 && _sizes[i] > 1 && (size_t)_strides[i] != elemsize) ||
            (i < ndims-1 && _sizes[i] > 1 && _strides[i] < _strides[i+1]) )
            needcopy = true;
    }

    if( ismultichannel && _strides[1] != (npy_intp)elemsize*_sizes[2] )
        needcopy = true;

    if (needcopy)
    {
        //if (info.outputarg)
        //{
        //    failmsg("Layout of the output array %s is incompatible with cv::Mat (step[ndims-1] != elemsize or step[1] != elemsize*nchannels)", info.name);
        //    return false;
        //}

        if( needcast ) {
            o = PyArray_Cast(oarr, new_typenum);
            oarr = (PyArrayObject*) o;
        }
        else {
            oarr = PyArray_GETCONTIGUOUS(oarr);
            o = (PyObject*) oarr;
        }

        _strides = PyArray_STRIDES(oarr);
    }

    // Normalize strides in case NPY_RELAXED_STRIDES is set
    size_t default_step = elemsize;
    for ( int i = ndims - 1; i >= 0; --i )
    {
        size[i] = (int)_sizes[i];
        if ( size[i] > 1 )
        {
            step[i] = (size_t)_strides[i];
            default_step = step[i] * size[i];
        }
        else
        {
            step[i] = default_step;
            default_step *= size[i];
        }
    }

    // handle degenerate case
    if( ndims == 0) {
        size[ndims] = 1;
        step[ndims] = elemsize;
        ndims++;
    }

    if( ismultichannel )
    {
        ndims--;
        type |= CV_MAKETYPE(0, size[2]);
    }

    if( ndims > 2 && !allowND )
    {
        failmsg("%s has more than 2 dimensions", info.name);
        return false;
    }

    m = Mat(ndims, size, type, PyArray_DATA(oarr), step);
    m.u = g_numpyAllocator.allocate(o, ndims, size, type, step);
    m.addref();

    if( !needcopy )
    {
        Py_INCREF(o);
    }
    m.allocator = &g_numpyAllocator;

    return true;
}

PyObject* NDArrayConverter::toNDArray(const cv::Mat& m)
{
    if( !m.data )
        Py_RETURN_NONE;
    Mat temp, *p = (Mat*)&m;
    if(!p->u || p->allocator != &g_numpyAllocator)
    {
        temp.allocator = &g_numpyAllocator;
        ERRWRAP2(m.copyTo(temp));
        p = &temp;
    }
    PyObject* o = (PyObject*)p->u->userdata;
    Py_INCREF(o);
    return o;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_py/conversion.h
================
# ifndef __COVERSION_OPENCV_H__
# define __COVERSION_OPENCV_H__

#include <Python.h>
#include <opencv2/core/core.hpp>

class NDArrayConverter {
public:
    static bool init_numpy();
    
    bool toMat(PyObject* o, cv::Mat &m);
    PyObject* toNDArray(const cv::Mat& mat);
};

# endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_py/example_filter.py
================
import cv2
import numpy as np

class MyFilter:
    
    def process(self, img):
        '''
            :param img: A numpy array representing the input image
            :returns: A numpy array to send to the mjpg-streamer output plugin
        '''
        
        # silly routine that overlays a really large crosshair over the image
        h = img.shape[0]
        w = img.shape[1]
        
        w2 = int(w/2)
        h2 = int(h/2)
        
        cv2.line(img, (int(w/4), h2), (int(3*(w/4)), h2), (0xff, 0, 0), thickness=3)
        cv2.line(img, (w2, int(h/4)), (w2, int(3*(h/4))), (0xff, 0, 0), thickness=3)
        
        return img
        
def init_filter():
    '''
        This function is called after the filter module is imported. It MUST
        return a callable object (such as a function or bound method). 
    '''
    f = MyFilter()
    return f.process

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_py/filter_py.cpp
================
/**
    OpenCV filter plugin for mjpg-streamer that loads a python script and calls
    it directly. The python script must... TODO
    
    At the moment, only the input_opencv.so plugin supports filter plugins.
*/

#include <libgen.h>
#include <string.h>

#include "opencv2/opencv.hpp"
#include <Python.h>
#include "conversion.h"

using namespace cv;
using namespace std;

// exports for the filter
extern "C" {
    bool filter_init(const char * args, void** filter_ctx);
    Mat filter_init_frame(void* filter_ctx);
    void filter_process(void* filter_ctx, Mat &src, Mat &dst);
    void filter_free(void* filter_ctx);
}

static int python_loaded = 0;

struct Context {
    NDArrayConverter converter;
    
    PyObject *pModule;
    PyObject *filter_fn;
    PyObject *lastRetval;
    
    PyThreadState *pMainThread;
};


// exists because dirname modifies its args
static PyObject* get_dirname(const char * args) {
    char * dupargs = strdup(args);
    PyObject* obj = PyUnicode_DecodeFSDefault(dirname(dupargs));
    free(dupargs);
    return obj;
}

// exists because basename modifies its args
static PyObject* get_import(const char * args) {
    char * dupargs = strdup(args);
    char * base = basename(dupargs);
    char * ext = strrchr(base, '.');
    if (ext)
        *ext = '\0';
    PyObject* obj = PyUnicode_DecodeFSDefault(base);
    free(dupargs);
    return obj;
}

/**
    Initializes the filter. If you return something, it will be passed to the
    filter_process function, and should be freed by the filter_free function
*/
bool filter_init(const char * args, void** filter_ctx) {
    
    PyObject *sys, *sys_path = NULL;
    PyObject *pModuleDir, *pModuleName, *pFunc;
    Context * ctx;
    char * dupargs, *mod_name, *mod_dir;
    
    if (strlen(args) < 3) {
        fprintf(stderr, "Need to specify python filter module via --fargs\n");
        return false;
    }
    
    // don't initialize python more than once
    if (python_loaded == 0) {
        Py_Initialize();
        PyEval_InitThreads();
    }
    
    ctx = new Context();
    *filter_ctx = ctx;
    
    python_loaded += 1;
    
    if (!NDArrayConverter::init_numpy()) {
        fprintf(stderr, "Error loading numpy!\n");
        return false;
    }
    
    // import the module by path
    // -> add the module's path to sys.path, in case it decides to import
    //    something, and import it directly
    
    pModuleDir = get_dirname(args);
    pModuleName = get_import(args);
    
    sys = PyImport_ImportModule("sys");
    if (sys != NULL) {
        sys_path = PyObject_GetAttrString(sys, "path");
    }
    
    if (sys_path != NULL && pModuleDir != NULL && pModuleName != NULL) {            
        if (PyList_Insert(sys_path, 0, pModuleDir) == 0) {
            ctx->pModule = PyImport_Import(pModuleName);
        }
    }
    
    Py_XDECREF(pModuleName);
    Py_XDECREF(pModuleDir);
    Py_XDECREF(sys_path);
    Py_XDECREF(sys);
    
    if (ctx->pModule == NULL) {
        PyErr_Print();
        fprintf(stderr, "Failed to load \"%s\"\n", args);
        return false;
    }
    
    // load the initialize function, call it
    pFunc = PyObject_GetAttrString(ctx->pModule, "init_filter");
    if (pFunc == NULL || !PyCallable_Check(pFunc)) {
        if (PyErr_Occurred())
            PyErr_Print();
        
        fprintf(stderr, "Could not load init_filter function: %p\n", pFunc);
        return false;
    }
    
    // load the processing function
    ctx->filter_fn = PyObject_CallObject(pFunc, NULL);
    Py_DECREF(pFunc);
    
    if (ctx->filter_fn == NULL) {
        PyErr_Print();
        return false;
    }
    
    if (!PyCallable_Check(ctx->filter_fn)) {
        fprintf(stderr, "init_filter did not return a callable object\n");
        return false;
    }
    
    // done with initialization, let go of the GIL
    ctx->pMainThread = PyEval_SaveThread();
    return true;
}


void dbgMat(const char * wat, Mat &m) {
    fprintf(stderr, "%s: ref %d, alloc @ %p; ptr %p %p\n", wat, m.u ? m.u->refcount : 0, m.allocator,
            m.u ? m.u->data : NULL, m.u ? m.u->origdata : NULL);
}


Mat filter_init_frame(void *filter_ctx) {
    Context *ctx = (Context*)filter_ctx;
    
    // this function ensures that the initial mat is using the numpy allocator,
    // which avoids copies each time the source image is captured
    Mat mat;
    PyObject *mm = ctx->converter.toNDArray(mat);
    ctx->converter.toMat(mm, mat);
    Py_DECREF(mm);
    return mat;
}

/**
    Called by the OpenCV plugin upon each frame
*/
void filter_process(void* filter_ctx, Mat &src, Mat &dst) {
    
    Context *ctx = (Context*)filter_ctx;
    PyObject *ndArray, *pArgs;
    
    PyGILState_STATE gil_state = PyGILState_Ensure();
    
    ndArray = ctx->converter.toNDArray(src);
    if (ndArray == NULL) {
        PyErr_Print();
        PyGILState_Release(gil_state);
        dst = src;
        return;
    }
        
    pArgs = PyTuple_New(1);
    PyTuple_SetItem(pArgs, 0, ndArray); // takes ownership of ndarray
    
    // see below for rationale
    Py_XDECREF(ctx->lastRetval);
    
    // call the python function, store the object until next time, that way the
    // underlying Mat object doesn't get deallocated
    ctx->lastRetval = PyObject_CallObject(ctx->filter_fn, pArgs);
    if (ctx->lastRetval == NULL) {
        PyErr_Print();
        dst = src;
    } else {
        if (ctx->lastRetval != Py_None) {
            if (!ctx->converter.toMat(ctx->lastRetval, dst)) {
                PyErr_Print();
                dst = src;
            }
        }    
    }
    
    Py_DECREF(pArgs);
    
    // done with GIL
    PyGILState_Release(gil_state);
}


/**
    Called when the input plugin is cleaning up (will get called during
    initialization if initialization fails).
*/
void filter_free(void* filter_ctx) {
    
    Context * ctx = (Context*)filter_ctx;
    
    if (ctx->pMainThread != NULL) {
        PyEval_RestoreThread(ctx->pMainThread);
    }
    
    Py_XDECREF(ctx->lastRetval);
    Py_XDECREF(ctx->filter_fn);
    Py_XDECREF(ctx->pModule);
    
    delete ctx;
    
    python_loaded -= 1;
    
    if (python_loaded == 0) {
        // TODO: weird threading KeyError... probably because this is not called
        //       from the same thread as filter_init
        Py_Finalize();
    }
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/filters/cvfilter_py/README.md
================
input_opencv filter plugin: cvfilter_py
=======================================

This plugin allows you to use a Python 3.x script to process images received by
mjpg-streamer. This has been tested with Python 3.4.

To run a Python 3.x script, you can do the following:

    mjpg_streamer -i "input_opencv.so --filter cvfilter_py.so --fargs path/to/filter.py"

Filter script
-------------

Your script MUST define a function called 'init_filter', that takes zero
arguments and returns a single callable. This returned callable must take
a single argument (a numpy array), and returns a single object (a numpy array).
A simple example follows:

```

def filter_fn(img):
    '''
        :param img: A numpy array representing the input image
        :returns: A numpy array to send to the mjpg-streamer output plugin
    '''
    return img
    
def init_filter():
    return filter_fn

```

For a more complex example, see the included example_filter.py

Known Issues
------------

When mjpg-streamer is terminated, a `KeyError` is raised in the threading
module. While annoying, it's harmless. Most likely it happens because the
python interpreter is destroyed on the wrong thread.

TODO
----

After going through all of this effort to create the code for this module, I
bet it can be done a lot simpler via cython.

Authors
-------

Dustin Spicuzza (dustin@virtualroadside.com)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/CMakeLists.txt
================
# TODO: which components do I need?
# To fix the error: "undefined symbol: _ZN2cv12VideoCaptureC1Ev"
find_package(OpenCV COMPONENTS core imgproc highgui videoio)

MJPG_STREAMER_PLUGIN_OPTION(input_opencv "OpenCV input plugin"
                            ONLYIF OpenCV_FOUND ${OpenCV_VERSION_MAJOR} EQUAL 3)

if (PLUGIN_INPUT_OPENCV)
    enable_language(CXX)
    include_directories(${OpenCV_INCLUDE_DIRS})

    MJPG_STREAMER_PLUGIN_COMPILE(input_opencv input_opencv.cpp)
    
    target_link_libraries(input_opencv ${OpenCV_LIBS})
    
    add_subdirectory(filters/cvfilter_cpp)
    add_subdirectory(filters/cvfilter_py)
    
endif()

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/input_opencv.cpp
================
/*******************************************************************************
#                                                                              #
# OpenCV input plugin                                                          #
# Copyright (C) 2016 Dustin Spicuzza                                           #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <dlfcn.h>
#include <pthread.h>

#include "input_opencv.h"

#include "opencv2/opencv.hpp"

using namespace cv;
using namespace std;

/* private functions and variables to this plugin */
static globals     *pglobal;

typedef struct {
    char *filter_args;
    int fps_set, fps,
        quality_set, quality,
        co_set, co,
        br_set, br,
        sa_set, sa,
        gain_set, gain,
        ex_set, ex;
} context_settings;

// filter functions
typedef bool (*filter_init_fn)(const char * args, void** filter_ctx);
typedef Mat (*filter_init_frame_fn)(void* filter_ctx);
typedef void (*filter_process_fn)(void* filter_ctx, Mat &src, Mat &dst);
typedef void (*filter_free_fn)(void* filter_ctx);


typedef struct {
    pthread_t   worker;
    VideoCapture capture;
    
    context_settings *init_settings;
    
    void* filter_handle;
    void* filter_ctx;
    
    filter_init_fn filter_init;
    filter_init_frame_fn filter_init_frame;
    filter_process_fn filter_process;
    filter_free_fn filter_free;
    
} context;


void *worker_thread(void *);
void worker_cleanup(void *);

#define INPUT_PLUGIN_NAME "OpenCV Input plugin"
static char plugin_name[] = INPUT_PLUGIN_NAME;

static void null_filter(void* filter_ctx, Mat &src, Mat &dst) {
    dst = src;
}

static void help() {
    
    fprintf(stderr,
    " ---------------------------------------------------------------\n" \
    " Help for input plugin..: "INPUT_PLUGIN_NAME"\n" \
    " ---------------------------------------------------------------\n" \
    " The following parameters can be passed to this plugin:\n\n" \
    " [-d | --device ].......: video device to open (your camera)\n" \
    " [-r | --resolution ]...: the resolution of the video device,\n" \
    "                          can be one of the following strings:\n" \
    "                          ");
    
    resolutions_help("                          ");
    
    fprintf(stderr,
    " [-f | --fps ]..........: frames per second\n" \
    " [-q | --quality ] .....: set quality of JPEG encoding\n" \
    " ---------------------------------------------------------------\n" \
    " Optional parameters (may not be supported by all cameras):\n\n"
    " [-br ].................: Set image brightness (integer)\n"\
    " [-co ].................: Set image contrast (integer)\n"\
    " [-sh ].................: Set image sharpness (integer)\n"\
    " [-sa ].................: Set image saturation (integer)\n"\
    " [-ex ].................: Set exposure (off, or integer)\n"\
    " [-gain ]...............: Set gain (integer)\n"
    " ---------------------------------------------------------------\n" \
    " Optional filter plugin:\n" \
    " [ -filter ]............: filter plugin .so\n" \
    " [ -fargs ].............: filter plugin arguments\n" \
    " ---------------------------------------------------------------\n\n"\
    );
}

static context_settings* init_settings() {
    context_settings *settings;
    
    settings = (context_settings*)calloc(1, sizeof(context_settings));
    if (settings == NULL) {
        IPRINT("error allocating context");
        exit(EXIT_FAILURE);
    }
    
    settings->quality = 80;
    return settings;
}

/*** plugin interface functions ***/

/******************************************************************************
Description.: parse input parameters
Input Value.: param contains the command line string and a pointer to globals
Return Value: 0 if everything is ok
******************************************************************************/


int input_init(input_parameter *param, int plugin_no)
{
    const char * device = "default";
    const char *filter = NULL, *filter_args = "";
    int width = 640, height = 480, i, device_idx;
    
    input * in;
    context *pctx;
    context_settings *settings;
    
    pctx = new context();
    
    settings = pctx->init_settings = init_settings();
    pglobal = param->global;
    in = &pglobal->in[plugin_no];
    in->context = pctx;

    param->argv[0] = plugin_name;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    /* parse the parameters */
    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0},
            {"help", no_argument, 0, 0},
            {"d", required_argument, 0, 0},
            {"device", required_argument, 0, 0},
            {"r", required_argument, 0, 0},
            {"resolution", required_argument, 0, 0},
            {"f", required_argument, 0, 0},
            {"fps", required_argument, 0, 0},
            {"q", required_argument, 0, 0},
            {"quality", required_argument, 0, 0},
            {"co", required_argument, 0, 0},
            {"br", required_argument, 0, 0},
            {"sa", required_argument, 0, 0},
            {"gain", required_argument, 0, 0},
            {"ex", required_argument, 0, 0},
            {"filter", required_argument, 0, 0},
            {"fargs", required_argument, 0, 0},
            {0, 0, 0, 0}
        };
    
        /* parsing all parameters according to the list above is sufficent */
        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        /* dispatch the given options */
        switch(option_index) {
        /* h, help */
        case 0:
        case 1:
            help();
            return 1;
        /* d, device */
        case 2:
        case 3:
            device = optarg;
            break;
        /* r, resolution */
        case 4:
        case 5:
            DBG("case 4,5\n");
            parse_resolution_opt(optarg, &width, &height);
            break;
        /* f, fps */
        case 6:
        OPTION_INT(7, fps)
            break;
        /* q, quality */
        case 8:
        OPTION_INT(9, quality)
            settings->quality = MIN(MAX(settings->quality, 0), 100);
            break;
        OPTION_INT(10, co)
            break;
        OPTION_INT(11, br)
            break;
        OPTION_INT(12, sa)
            break;
        OPTION_INT(13, gain)
            break;
        OPTION_INT(14, ex)
            break;
            
        /* filter */
        case 15:
            filter = optarg;
            break;
            
        /* fargs */
        case 16:
            filter_args = optarg;
            break;
            
        default:
            help();
            return 1;
        }
    }

    IPRINT("device........... : %s\n", device);
    IPRINT("Desired Resolution: %i x %i\n", width, height);
    
    // need to allocate a VideoCapture object: default device is 0
    try {
        if (!strcasecmp(device, "default")) {
            pctx->capture.open(0);
        } else if (sscanf(device, "%d", &device_idx) == 1) {
            pctx->capture.open(device_idx);
        } else {
            pctx->capture.open(device);
        }
    } catch (Exception e) {
        IPRINT("VideoCapture::open() failed: %s\n", e.what());
        goto fatal_error;
    }
    
    // validate that isOpened is true
    if (!pctx->capture.isOpened()) {
        IPRINT("VideoCapture::open() failed\n");
        goto fatal_error;
    }
    
    pctx->capture.set(CAP_PROP_FRAME_WIDTH, width);
    pctx->capture.set(CAP_PROP_FRAME_HEIGHT, height);
    
    if (settings->fps_set)
        pctx->capture.set(CAP_PROP_FPS, settings->fps);
    
    /* filter stuff goes here */
    if (filter != NULL) {
        
        IPRINT("filter........... : %s\n", filter);
        IPRINT("filter args ..... : %s\n", filter_args);
        
        pctx->filter_handle = dlopen(filter, RTLD_LAZY | RTLD_GLOBAL);
        if(!pctx->filter_handle) {
            LOG("ERROR: could not find input plugin\n");
            LOG("       Perhaps you want to adjust the search path with:\n");
            LOG("       # export LD_LIBRARY_PATH=/path/to/plugin/folder\n");
            LOG("       dlopen: %s\n", dlerror());
            goto fatal_error;
        }
        
        pctx->filter_init = (filter_init_fn)dlsym(pctx->filter_handle, "filter_init");
        if (pctx->filter_init == NULL) {
            LOG("ERROR: %s\n", dlerror());
            goto fatal_error;
        }
        
        pctx->filter_process = (filter_process_fn)dlsym(pctx->filter_handle, "filter_process");
        if (pctx->filter_process == NULL) {
            LOG("ERROR: %s\n", dlerror());
            goto fatal_error;
        }
        
        pctx->filter_free = (filter_free_fn)dlsym(pctx->filter_handle, "filter_free");
        if (pctx->filter_free == NULL) {
            LOG("ERROR: %s\n", dlerror());
            goto fatal_error;
        }
        
        // optional functions
        pctx->filter_init_frame = (filter_init_frame_fn)dlsym(pctx->filter_handle, "filter_init_frame");
        
        // initialize it
        if (!pctx->filter_init(filter_args, &pctx->filter_ctx)) {
            goto fatal_error;
        }
        
    } else {
        pctx->filter_handle = NULL;
        pctx->filter_ctx = NULL;
        pctx->filter_process = null_filter;
        pctx->filter_free = NULL;
    }
    
    return 0;
    
fatal_error:
    worker_cleanup(in);
    closelog();
    exit(EXIT_FAILURE);
}

/******************************************************************************
Description.: stops the execution of the worker thread
Input Value.: -
Return Value: 0
******************************************************************************/
int input_stop(int id)
{
    input * in = &pglobal->in[id];
    context *pctx = (context*)in->context;
    
    if (pctx != NULL) {
        DBG("will cancel input thread\n");
        pthread_cancel(pctx->worker);
    }
    return 0;
}

/******************************************************************************
Description.: starts the worker thread and allocates memory
Input Value.: -
Return Value: 0
******************************************************************************/
int input_run(int id)
{
    input * in = &pglobal->in[id];
    context *pctx = (context*)in->context;
    
    in->buf = NULL;
    in->size = 0;
    
    if(pthread_create(&pctx->worker, 0, worker_thread, in) != 0) {
        worker_cleanup(in);
        fprintf(stderr, "could not start worker thread\n");
        exit(EXIT_FAILURE);
    }
    pthread_detach(pctx->worker);

    return 0;
}

void *worker_thread(void *arg)
{
    input * in = (input*)arg;
    context *pctx = (context*)in->context;
    context_settings *settings = (context_settings*)pctx->init_settings;
    
    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, arg);

    /* set VideoCapture options */
    #define CVOPT_OPT(prop, var, desc) \
        if (!pctx->capture.set(prop, settings->var)) {\
            IPRINT("%-18s: %d\n", desc, settings->var); \
        } else {\
            fprintf(stderr, "Failed to set " desc "\n"); \
        }
    
    #define CVOPT_SET(prop, var, desc) \
        if (settings->var##_set) { \
            CVOPT_OPT(prop, var,desc) \
        }
    
    CVOPT_SET(CAP_PROP_FPS, fps, "frames per second")
    CVOPT_SET(CAP_PROP_BRIGHTNESS, co, "contrast")
    CVOPT_SET(CAP_PROP_CONTRAST, br, "brightness")
    CVOPT_SET(CAP_PROP_SATURATION, sa, "saturation")
    CVOPT_SET(CAP_PROP_GAIN, gain, "gain")
    CVOPT_SET(CAP_PROP_EXPOSURE, ex, "exposure")
    
    /* setup imencode options */
    vector<int> compression_params;
    compression_params.push_back(CV_IMWRITE_JPEG_QUALITY);
    compression_params.push_back(settings->quality); // 1-100
    
    free(settings);
    pctx->init_settings = NULL;
    settings = NULL;
    
    Mat src, dst;
    vector<uchar> jpeg_buffer;
    
    // this exists so that the numpy allocator can assign a custom allocator to
    // the mat, so that it doesn't need to copy the data each time
    if (pctx->filter_init_frame != NULL)
        src = pctx->filter_init_frame(pctx->filter_ctx);
    
    while (!pglobal->stop) {
        if (!pctx->capture.read(src))
            break; // TODO
            
        // call the filter function
        pctx->filter_process(pctx->filter_ctx, src, dst);
            
        /* copy JPG picture to global buffer */
        pthread_mutex_lock(&in->db);
        
        // take whatever Mat it returns, and write it to jpeg buffer
        imencode(".jpg", dst, jpeg_buffer, compression_params);
        
        // TODO: what to do if imencode returns an error?
        
        // std::vector is guaranteed to be contiguous
        in->buf = &jpeg_buffer[0];
        in->size = jpeg_buffer.size();
        
        /* signal fresh_frame */
        pthread_cond_broadcast(&in->db_update);
        pthread_mutex_unlock(&in->db);
    }
    
    IPRINT("leaving input thread, calling cleanup function now\n");
    pthread_cleanup_pop(1);

    return NULL;
}

/******************************************************************************
Description.: this functions cleans up allocated resources
Input Value.: arg is unused
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    input * in = (input*)arg;
    if (in->context != NULL) {
        context *pctx = (context*)in->context;
        
        if (pctx->filter_free != NULL && pctx->filter_ctx != NULL) {
            pctx->filter_free(pctx->filter_ctx);
            pctx->filter_free = NULL;
        }
        
        if (pctx->filter_handle != NULL) {
            dlclose(pctx->filter_handle);
            pctx->filter_handle = NULL;
        }
        
        delete pctx;
        in->context = NULL;
    }
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/input_opencv.h
================
#ifndef INPUT_OPENCV_H_
#define INPUT_OPENCV_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "../../mjpg_streamer.h"
#include "../../utils.h"

int input_init(input_parameter* param, int id);
int input_stop(int id);
int input_run(int id);
int input_cmd(int plugin, unsigned int control_id, unsigned int typecode, int value);

#ifdef __cplusplus
}
#endif

#endif /* INPUT_OPENCV_H_ */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_opencv/README.md
================
mjpg-streamer input plugin: input_opencv
========================================

This input plugin uses OpenCV to read from supported video sources, optionally
running the image through a filter plugin that can be specified on the command
line.

If you're not using the image filtering functionality of this plugin, you're
probably better off using some other input plugin as this plugin will probably
consume more CPU resources.

This plugin has only been tested with OpenCV 3.1.0, will probably not work with
OpenCV 2.x without some adjustments.

Usage
=====

```
---------------------------------------------------------------
Help for input plugin..: OpenCV Input plugin
---------------------------------------------------------------
The following parameters can be passed to this plugin:

[-d | --device ].......: video device to open (your camera)
[-r | --resolution ]...: the resolution of the video device,
                         can be one of the following strings:
                         QQVGA QCIF CGA QVGA CIF VGA 
                         SVGA XGA HD SXGA UXGA FHD 
                         
                         or a custom value like the following
                         example: 640x480
[-f | --fps ]..........: frames per second
[-q | --quality ] .....: set quality of JPEG encoding
---------------------------------------------------------------
Optional parameters (may not be supported by all cameras):

[-br ].................: Set image brightness (integer)
[-co ].................: Set image contrast (integer)
[-sh ].................: Set image sharpness (integer)
[-sa ].................: Set image saturation (integer)
[-ex ].................: Set exposure (off, or integer)
[-gain ]...............: Set gain (integer)
---------------------------------------------------------------
Optional filter plugin:
[ -filter ]............: filter plugin .so
[ -fargs ].............: filter plugin arguments
---------------------------------------------------------------
```


Filter plugins
==============

You can specify a filter plugin to load via the "--filter" argument:

    mjpg_streamer -i "input_opencv.so --filter cvfilter_cpp.so" .. 
    
The following plugins are included:

* [cvfilter_cpp](filters/cvfilter_cpp/README.md): barebones example
* [cvfilter_py](filters/cvfilter_py/README.md): Embeds a python interpreter to
  allow you to create a filter script in Python
  
Authors
-------

Dustin Spicuzza (dustin@virtualroadside.com)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_ptp2/CMakeLists.txt
================
find_package(Gphoto2)

MJPG_STREAMER_PLUGIN_OPTION(input_ptp2 "PTP2 input plugin"
                            ONLYIF GPHOTO2_FOUND)

if (PLUGIN_INPUT_PTP2)
    include_directories(${GPHOTO2_INCLUDE_DIR})

    MJPG_STREAMER_PLUGIN_COMPILE(input_ptp2 input_ptp2.c)
    
    target_link_libraries(input_ptp2 ${Gphoto2_LIBRARIES})
    
endif()

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_ptp2/input_ptp2.c
================
/* input_ptp2.c -- MJPG-streamer input plugin to stream JPG frames
 from digital cameras supporting PTP2 capture

 Copyright (C) 2010, Alessio Sangalli (alesan@manoweb.com)

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3, or (at your option)
 any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software Foundation,
 Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */

#define CAMERA_CHECK_GP(res, msg){if(res != GP_OK){IPRINT(INPUT_PLUGIN_NAME " - Gphoto error, on '%s': %d - %s\n", msg, res, gp_result_as_string(res)); return 0;}}

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <gphoto2/gphoto2-camera.h>
#include "input_ptp2.h"

#define INPUT_PLUGIN_NAME "PTP2 input plugin"

static int plugin_id;
static pthread_t thread;
static pthread_mutex_t control_mutex;
static globals* global;

GPContext* context;
Camera* camera;
char* selected_port;
int delay;

int input_init(input_parameter *param, int id)
{
	int i;
	int opt;

	global = param->global;

	if(pthread_mutex_init(&control_mutex, NULL) != 0)
	{
		IPRINT(INPUT_PLUGIN_NAME "- Could not initialize mutex variable\n");
		exit(EXIT_FAILURE);
	}

	control zoom_ctrl;
	zoom_ctrl.group = IN_CMD_GENERIC;
	zoom_ctrl.menuitems = NULL;
	zoom_ctrl.value = 0.0;
	zoom_ctrl.class_id = 0;

	zoom_ctrl.ctrl.id = 1;
	zoom_ctrl.ctrl.type = V4L2_CTRL_TYPE_INTEGER;
	strcpy((char*) zoom_ctrl.ctrl.name, "Zoom");
	zoom_ctrl.ctrl.minimum = 0;
	zoom_ctrl.ctrl.maximum = 10;
	zoom_ctrl.ctrl.step = 1;
	zoom_ctrl.ctrl.default_value = 0;
	zoom_ctrl.ctrl.flags = V4L2_CTRL_FLAG_SLIDER;

	param->global->in[id].in_parameters = (control*) malloc((param->global->in[id].parametercount + 1) * sizeof(control));

	param->global->in[id].in_parameters[param->global->in[id].parametercount] = zoom_ctrl;
	param->global->in[id].parametercount++;

	selected_port = NULL;
	delay = 0;

	param->argv[0] = INPUT_PLUGIN_NAME;

	/* show all parameters for DBG purposes */
	for(i = 0; i < param->argc; i++)
	{
		DBG("argv[%d]=%s\n", i, param->argv[i]);
	}

	optind = 1;
	while((opt = getopt(param->argc, param->argv, "hu:d:")) != -1)
	{
		switch(opt)
		{
			case 'h':
				help();
				return 1;
			case 'u':
				delay = atoi(optarg);
				break;
			case 'd':
				selected_port = strdup(optarg);
				break;
		}
	}

	DBG("usleep: %d\n", delay); DBG("device: %s\n", selected_port);

	return 0;
}

int input_stop(int id)
{
	DBG("will cancel input thread\n");
	pthread_cancel(thread);

	return 0;
}

void help()
{
	printf(" ---------------------------------------------------------------\n"
		" Help for input plugin..: "INPUT_PLUGIN_NAME"\n"
	" ---------------------------------------------------------------\n"
	" The following parameters can be passed to this plugin:\n\n"
	" [-h ]..........: print this help\n"
	" [-u X ]........: delay between frames in us (default 0)\n"
	" [-d X ]........: camera address in [usb:xxx,yyy] form; use\n"
	"                  gphoto2 --auto-detect to get a list of\n"
	"                  available cameras\n"
	" ---------------------------------------------------------------\n");
}

int input_run(int id)
{
	int res, i;

	plugin_id = id;

	// auto-detect algorithm
	CameraAbilitiesList* al;
	GPPortInfoList* il;
	CameraList* list;
	const char* model;
	const char* port;
	context = gp_context_new();
	gp_abilities_list_new(&al);
	gp_abilities_list_load(al, context);
	gp_port_info_list_new(&il);
	gp_port_info_list_load(il);
	gp_list_new(&list);
	gp_abilities_list_detect(al, il, list, context);
	int count = gp_list_count(list);
	IPRINT(INPUT_PLUGIN_NAME " - Detected %d camera(s)\n", count);
	if(count == 0)
	{
		IPRINT(INPUT_PLUGIN_NAME " - No cameras detected.\n");
		return 0;
	}
	GPPortInfo info;
	CameraAbilities a;
	int m, p;
	camera = NULL;
	for(i = 0; i < count; i++)
	{
		res = gp_list_get_name(list, i, &model);
		CAMERA_CHECK_GP(res, "gp_list_get_name");
		m = gp_abilities_list_lookup_model(al, model);
		if(m < 0)
		{
			IPRINT(INPUT_PLUGIN_NAME " - Gphoto abilities_list_lookup_model Code: %d - %s\n", m, gp_result_as_string(m));
			return 0;
		}
		res = gp_abilities_list_get_abilities(al, m, &a);
		CAMERA_CHECK_GP(res, "gp_abilities_list_get_abilities");
		res = gp_list_get_value(list, i, &port);
		CAMERA_CHECK_GP(res, "gp_list_get_value"); DBG("Model: %s; port: %s.\n", model, port);
		if(selected_port != NULL && strcmp(selected_port, port) != 0)
			continue;
		p = gp_port_info_list_lookup_path(il, port);
		if(p < 0)
		{
			IPRINT(INPUT_PLUGIN_NAME " - Gphoto port_info_list_lookup_path Code: %d - %s\n", m, gp_result_as_string(m));
			return 0;
		}
		res = gp_port_info_list_get_info(il, p, &info);
		CAMERA_CHECK_GP(res, "gp_port_info_list_get_info");

		res = gp_camera_new(&camera);
		CAMERA_CHECK_GP(res, "gp_camera_new");
		res = gp_camera_set_abilities(camera, a);
		CAMERA_CHECK_GP(res, "gp_camera_set_abilities");
		res = gp_camera_set_port_info(camera, info);
		CAMERA_CHECK_GP(res, "gp_camera_set_port_info");
	}
	if(camera == NULL)
	{
		IPRINT("Camera %s not found, exiting.\n", selected_port);
		exit(EXIT_FAILURE);
	}
	// cleanup
	gp_list_unref(list);
	gp_port_info_list_free(il);
	gp_abilities_list_free(al);

	// open camera and set capture on
	int value = 1;
	res = gp_camera_init(camera, context);
	CAMERA_CHECK_GP(res, "gp_camera_init");
	camera_set("capture", &value);

	// starting thread
	if(pthread_create(&thread, 0, capture, NULL) != 0)
	{
		free(global->in[id].buf);
		IPRINT("could not start worker thread\n");
		exit(EXIT_FAILURE);
	}
	pthread_detach(thread);

	return 0;
}

void* capture(void* arg)
{
	int res;
	int i = 0;
	CameraFile* file;

	int jpeg_buffer_size = 256 * 1024;
	global->in[plugin_id].buf = malloc(jpeg_buffer_size);
	if(global->in[plugin_id].buf == NULL)
	{
		IPRINT(INPUT_PLUGIN_NAME " - could not allocate memory\n");
		return NULL;
	}

	pthread_cleanup_push(cleanup, NULL);
	while(!global->stop)
	{
		unsigned long int xsize;
		const char* xdata;
		pthread_mutex_lock(&control_mutex);
		res = gp_file_new(&file);
		CAMERA_CHECK_GP(res, "gp_file_new");
		res = gp_camera_capture_preview(camera, file, context);
		CAMERA_CHECK_GP(res, "gp_camera_capture_preview");
		pthread_mutex_lock(&global->in[plugin_id].db);
		res = gp_file_get_data_and_size(file, &xdata, &xsize);
		if(xsize == 0)
		{
			if(i++ > 3)
			{
				IPRINT("Restarted too many times; giving up\n");
				return NULL;
			}
			int value = 0;
			IPRINT("Read 0 bytes from camera; restarting it\n");
			camera_set("capture", &value);
			sleep(3);
			value = 1;
			camera_set("capture", &value);
		}
		else
			i = 0;
		CAMERA_CHECK_GP(res, "gp_file_get_data_and_size");

		if(jpeg_buffer_size <= xsize) {
			jpeg_buffer_size = xsize + xsize * 10/100;
			unsigned char *tmp_buff = realloc(global->in[plugin_id].buf,jpeg_buffer_size);
			if(tmp_buff == NULL)
			{
				IPRINT(INPUT_PLUGIN_NAME " - could not allocate memory\n");
				return NULL;
			}
			global->in[plugin_id].buf = tmp_buff;
		}


		memcpy(global->in[plugin_id].buf, xdata, xsize);
		res = gp_file_unref(file);
		pthread_mutex_unlock(&control_mutex);
		CAMERA_CHECK_GP(res, "gp_file_unref");
		global->in[plugin_id].size = xsize;
		DBG("Read %d bytes from camera.\n", global->in[plugin_id].size);
		pthread_cond_broadcast(&global->in[plugin_id].db_update);
		pthread_mutex_unlock(&global->in[plugin_id].db);
		usleep(delay);
	}
	pthread_cleanup_pop(1);

	return NULL;
}

int camera_set(char* name, void* value)
{
	int res;

	CameraWidget* config_root;
	CameraWidget* widget;
	res = gp_camera_get_config(camera, &config_root, context);
	CAMERA_CHECK_GP(res, "gp_camera_get_config");
	res = gp_widget_get_child_by_name(config_root, name, &widget);
	CAMERA_CHECK_GP(res, "gp_widget_get_child_by_name");
	res = gp_widget_set_value(widget, value);
	CAMERA_CHECK_GP(res, "gp_widget_set_value");
	res = gp_camera_set_config(camera, config_root, context);
	CAMERA_CHECK_GP(res, "gp_camera_set_config");
	gp_widget_unref(config_root);
	return 1;
}

void cleanup(void *arg)
{
	int value = 0;

	// TODO check to see if we have already cleaned up?

	IPRINT("PTP2 capture - Cleaning up\n");
	camera_set("capture", &value);
	gp_camera_exit(camera, context);
	gp_camera_unref(camera);
	gp_context_unref(context);
	free(global->in[plugin_id].buf);
}

int input_cmd(int plugin, unsigned int control_id, unsigned int group, int value)
{
	int res;
	int i;
	DBG("Requested cmd (id: %d) for the %d plugin. Group: %d value: %d\n", control_id, plugin_id, group, value);
	switch(group)
	{
		case IN_CMD_GENERIC:
			for(i = 0; i < global->in[plugin_id].parametercount; i++)
			{
				if((global->in[plugin_id].in_parameters[i].ctrl.id == control_id) && (global->in[plugin_id].in_parameters[i].group == IN_CMD_GENERIC))
				{
					DBG("Generic control found (id: %d): %s\n", control_id, global->in[plugin_id].in_parameters[i].ctrl.name);
					if(control_id == 1)
					{
						float z = value;
						pthread_mutex_lock(&control_mutex);
						res = camera_set("zoom", &z);
						pthread_mutex_unlock(&control_mutex);
					} DBG("New %s value: %d\n", global->in[plugin_id].in_parameters[i].ctrl.name, value);
					return 0;
				}
			}
			DBG("Requested generic control (%d) did not found\n", control_id);
			return -1;
			break;
	}
	return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_ptp2/input_ptp2.h
================
#ifndef INPUT_PTP2_H_
#define INPUT_PTP2_H_

#include "../../mjpg_streamer.h"

int input_init(input_parameter* param, int id);
int input_stop(int id);
int input_run(int id);
int input_cmd(int plugin, unsigned int control_id, unsigned int typecode, int value);

void help();
int camera_set(char* name, void* value);
void* capture(void* arg);
void cleanup(void *arg);

#endif /* INPUT_PTP2_H_ */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/CMakeLists.txt
================
add_library (mmal_core SHARED
   mmal_format.c
   mmal_port.c
   mmal_port_clock.c
   mmal_component.c
   mmal_buffer.c
   mmal_queue.c
   mmal_pool.c
   mmal_events.c
   mmal_logging.c
   mmal_clock.c
)

target_link_libraries (mmal_core vcos)

install(TARGETS mmal_core DESTINATION lib)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_buffer_private.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_BUFFER_PRIVATE_H
#define MMAL_BUFFER_PRIVATE_H

/** Typedef for the private area the framework reserves for the driver / communication layer */
typedef struct MMAL_DRIVER_BUFFER_T MMAL_DRIVER_BUFFER_T;

/** Size of the private area the framework reserves for the driver / communication layer */
#define MMAL_DRIVER_BUFFER_SIZE 32

/** Typedef for the framework's private area in the buffer header */
typedef struct MMAL_BUFFER_HEADER_PRIVATE_T
{
   /** Callback invoked just prior to actually releasing the buffer header. Returns TRUE if
    * release should be delayed. */
   MMAL_BH_PRE_RELEASE_CB_T pf_pre_release;
   void *pre_release_userdata;

   /** Callback used to release / recycle the buffer header. This needs to be set by
    * whoever allocates the buffer header. */
   void (*pf_release)(struct MMAL_BUFFER_HEADER_T *header);
   void *owner;               /**< Context set by the allocator of the buffer header and passed
                                   during the release callback */

   int32_t refcount;          /**< Reference count of the buffer header. When it reaches 0,
                                   the release callback will be called. */

   MMAL_BUFFER_HEADER_T *reference; /**< Reference to another acquired buffer header. */

   /** Callback used to free the payload associated with this buffer header. This is only
    * used if the buffer header was created by MMAL with a payload associated with it. */
   void   (*pf_payload_free)(void *payload_context, void *payload);
   void    *payload;          /**< Pointer / handle to the allocated payload buffer */
   void    *payload_context;  /**< Pointer to the context of the payload allocator */
   uint32_t payload_size;     /**< Allocated size in bytes of payload buffer */

   void *component_data;      /**< Field reserved for use by the component */
   void *payload_handle;      /**< Field reserved for mmal_buffer_header_mem_lock */

   uint8_t driver_area[MMAL_DRIVER_BUFFER_SIZE];

} MMAL_BUFFER_HEADER_PRIVATE_T;

/** Get the size in bytes of a fully initialised MMAL_BUFFER_HEADER_T */
unsigned int mmal_buffer_header_size(MMAL_BUFFER_HEADER_T *header);

/** Initialise a MMAL_BUFFER_HEADER_T */
MMAL_BUFFER_HEADER_T *mmal_buffer_header_initialise(void *mem, unsigned int length);

/** Return a pointer to the area reserved for the driver.
  */
MMAL_DRIVER_BUFFER_T *mmal_buffer_header_driver_data(MMAL_BUFFER_HEADER_T *);

/** Return a pointer to a referenced buffer header.
 * It is the caller's responsibility to ensure that the reference is still
 * valid when using it.
 */
MMAL_BUFFER_HEADER_T *mmal_buffer_header_reference(MMAL_BUFFER_HEADER_T *header);

#endif /* MMAL_BUFFER_PRIVATE_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_buffer.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "mmal_buffer.h"
#include "core/mmal_buffer_private.h"
#include "mmal_logging.h"

#define ROUND_UP(s,align) ((((unsigned long)(s)) & ~((align)-1)) + (align))
#define DEFAULT_COMMAND_SIZE 256 /**< 256 bytes of space for commands */
#define ALIGN  8

/** Acquire a buffer header */
void mmal_buffer_header_acquire(MMAL_BUFFER_HEADER_T *header)
{
#ifdef ENABLE_MMAL_EXTRA_LOGGING
   LOG_TRACE("%p (%i)", header, (int)header->priv->refcount+1);
#endif
   header->priv->refcount++;
}

/** Reset a buffer header */
void mmal_buffer_header_reset(MMAL_BUFFER_HEADER_T *header)
{
   header->length = 0;
   header->offset = 0;
   header->flags = 0;
   header->pts = MMAL_TIME_UNKNOWN;
   header->dts = MMAL_TIME_UNKNOWN;
}

/** Release a buffer header */
void mmal_buffer_header_release(MMAL_BUFFER_HEADER_T *header)
{
#ifdef ENABLE_MMAL_EXTRA_LOGGING
   LOG_TRACE("%p (%i)", header, (int)header->priv->refcount-1);
#endif

   if(--header->priv->refcount != 0)
      return;

   if (header->priv->pf_pre_release)
   {
      if (header->priv->pf_pre_release(header, header->priv->pre_release_userdata))
         return; /* delay releasing the buffer */
   }
   mmal_buffer_header_release_continue(header);
}

/** Finalise buffer release following a pre-release event */
void mmal_buffer_header_release_continue(MMAL_BUFFER_HEADER_T *header)
{
   mmal_buffer_header_reset(header);
   if (header->priv->reference)
      mmal_buffer_header_release(header->priv->reference);
   header->priv->reference = 0;
   header->priv->pf_release(header);
}

/** Replicate a buffer header */
MMAL_STATUS_T mmal_buffer_header_replicate(MMAL_BUFFER_HEADER_T *dest,
   MMAL_BUFFER_HEADER_T *src)
{
#ifdef ENABLE_MMAL_EXTRA_LOGGING
   LOG_TRACE("dest: %p src: %p", dest, src);
#endif

   if (!dest || !src || dest->priv->reference)
      return MMAL_EINVAL;

   mmal_buffer_header_acquire(src);
   dest->priv->reference = src;

   /* Copy all the relevant fields */
   dest->cmd        = src->cmd;
   dest->alloc_size = src->alloc_size;
   dest->data       = src->data;
   dest->offset     = src->offset;
   dest->length     = src->length;
   dest->flags      = src->flags;
   dest->pts        = src->pts;
   dest->dts        = src->dts;
   *dest->type      = *src->type;
   return MMAL_SUCCESS;
}

/** Get the size in bytes of a fully initialised MMAL_BUFFER_HEADER_T */
unsigned int mmal_buffer_header_size(MMAL_BUFFER_HEADER_T *header)
{
   unsigned int header_size;

   header_size = ROUND_UP(sizeof(*header), ALIGN);
   header_size += ROUND_UP(sizeof(*header->type), ALIGN);
   header_size += ROUND_UP(DEFAULT_COMMAND_SIZE, ALIGN);
   header_size += ROUND_UP(sizeof(*header->priv), ALIGN);
   return header_size;
}

/** Initialise a MMAL_BUFFER_HEADER_T */
MMAL_BUFFER_HEADER_T *mmal_buffer_header_initialise(void *mem, unsigned int length)
{
   MMAL_BUFFER_HEADER_T *header;
   unsigned int header_size = mmal_buffer_header_size(0);

   if(length < header_size)
      return 0;

   memset(mem, 0, header_size);

   header = (MMAL_BUFFER_HEADER_T *)mem;
   header->type = (void *)&header[1];
   header->priv = (MMAL_BUFFER_HEADER_PRIVATE_T *)&header->type[1];
   return header;
}

/** Return a pointer to the area reserved for the driver */
MMAL_DRIVER_BUFFER_T *mmal_buffer_header_driver_data(MMAL_BUFFER_HEADER_T *header)
{
   return (MMAL_DRIVER_BUFFER_T *)header->priv->driver_area;
}

/** Return a pointer to a referenced buffer header */
MMAL_BUFFER_HEADER_T *mmal_buffer_header_reference(MMAL_BUFFER_HEADER_T *header)
{
   return header->priv->reference;
}

#ifdef __VIDEOCORE__
# include "vcfw/rtos/common/rtos_common_mem.h"
#endif

/** Lock the data buffer contained in the buffer header */
MMAL_STATUS_T mmal_buffer_header_mem_lock(MMAL_BUFFER_HEADER_T *header)
{
#ifdef __VIDEOCORE__
   uint8_t *data = mem_lock((MEM_HANDLE_T)header->data);
   if (!data)
      return MMAL_EINVAL;
   header->priv->payload_handle = (void *)header->data;
   header->data = data;
#else
   MMAL_PARAM_UNUSED(header);
#endif

   return MMAL_SUCCESS;
}

/** Unlock the data buffer contained in the buffer header */
void mmal_buffer_header_mem_unlock(MMAL_BUFFER_HEADER_T *header)
{
#ifdef __VIDEOCORE__
   mem_unlock((MEM_HANDLE_T)header->priv->payload_handle);
   header->data = header->priv->payload_handle;
#else
   MMAL_PARAM_UNUSED(header);
#endif
}

/** Set a pre-release callback for a buffer header */
void mmal_buffer_header_pre_release_cb_set(MMAL_BUFFER_HEADER_T *header, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata)
{
   header->priv->pf_pre_release = cb;
   header->priv->pre_release_userdata = userdata;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock_private.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_CLOCK_PRIVATE_H
#define MMAL_CLOCK_PRIVATE_H

#include "interface/mmal/mmal.h"
#include "interface/mmal/mmal_clock.h"

#ifdef __cplusplus
extern "C" {
#endif


/** Handle to a clock. */
typedef struct MMAL_CLOCK_T
{
   void *user_data;   /**< Client-supplied data (not used by the clock). */
} MMAL_CLOCK_T;

/** Create a new instance of a clock.
 *
 * @param clock Returned clock
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_create(MMAL_CLOCK_T **clock);

/** Destroy a previously created clock.
 *
 * @param clock The clock to destroy
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_destroy(MMAL_CLOCK_T *clock);

/** Definition of a clock request callback.
 * This is invoked when the media-time requested by the client is reached.
 *
 * @param clock      The clock which serviced the request
 * @param media_time The current media-time
 * @param cb_data    Client-supplied data
 * @param priv       Function pointer used by the framework
 */
typedef void (*MMAL_CLOCK_VOID_FP)(void);
typedef void (*MMAL_CLOCK_REQUEST_CB)(MMAL_CLOCK_T *clock, int64_t media_time, void *cb_data, MMAL_CLOCK_VOID_FP priv);

/** Register a request with the clock.
 * When the specified media-time is reached, the clock will invoke the supplied callback.
 *
 * @param clock      The clock
 * @param media_time The media-time at which the callback should be invoked (microseconds)
 * @param offset     Time offset (in microseconds) applied to the media-time. This can be used
 *                   to schedule the request slightly in advance of the media-time.
 * @param cb         Callback to invoke
 * @param cb_data    Client-supplied callback data
 * @param priv       Function pointer used by the framework
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time, int64_t offset,
                                     MMAL_CLOCK_REQUEST_CB cb, void *cb_data, MMAL_CLOCK_VOID_FP priv);

/** Remove all previously registered clock requests.
 *
 * @param clock      The clock
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_request_flush(MMAL_CLOCK_T *clock);

/** Update the clock's media-time.
 *
 * @param clock      The clock to update
 * @param media_time New media-time to be applied (microseconds)
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_media_time_set(MMAL_CLOCK_T *clock, int64_t media_time);

/** Update the clock's media-time offset.
 *
 * @param clock      The clock to update
 * @param media_time New media-time offset to be applied (microseconds)
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_media_time_offset_set(MMAL_CLOCK_T *clock, int64_t offset);

/** Set the clock's scale.
 *
 * @param clock      The clock
 * @param scale      Scale factor
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_scale_set(MMAL_CLOCK_T *clock, MMAL_RATIONAL_T scale);

/** Set the clock state.
 *
 * @param clock      The clock
 * @param active     TRUE -> clock is active and media-time is advancing
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_active_set(MMAL_CLOCK_T *clock, MMAL_BOOL_T active);

/** Get the clock's scale.
 *
 * @param clock      The clock
 *
 * @return Current clock scale
 */
MMAL_RATIONAL_T mmal_clock_scale_get(MMAL_CLOCK_T *clock);

/** Get the clock's current media-time.
 * This takes the clock scale and media-time offset into account.
 *
 * @param clock      The clock to query
 *
 * @return Current media-time in microseconds
 */
int64_t mmal_clock_media_time_get(MMAL_CLOCK_T *clock);

/** Get the clock's media-time offset.
 *
 * @param clock      The clock to query
 *
 * @return Current media-time offset in microseconds
 */
int64_t mmal_clock_media_time_offset_get(MMAL_CLOCK_T *clock);

/** Get the clock's state.
 *
 * @param clock      The clock to query
 *
 * @return TRUE if clock is running (i.e. local media-time is advancing)
 */
MMAL_BOOL_T mmal_clock_is_active(MMAL_CLOCK_T *clock);

/** Get the clock's media-time update threshold values.
 *
 * @param clock             The clock
 * @param update_threshold  Pointer to clock update threshold values to fill
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold);

/** Set the clock's media-time update threshold values.
 *
 * @param clock             The clock
 * @param update_threshold  Pointer to new clock update threshold values
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold);

/** Get the clock's discontinuity threshold values.
 *
 * @param clock      The clock
 * @param discont    Pointer to clock discontinuity threshold values to fill
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont);

/** Set the clock's discontinuity threshold values.
 *
 * @param clock      The clock
 * @param discont    Pointer to new clock discontinuity threshold values
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont);

/** Get the clock's request threshold values.
 *
 * @param clock      The clock
 * @param future     Pointer to clock request threshold values to fill
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req);

/** Set the clock's request threshold values.
 *
 * @param clock      The clock
 * @param discont    Pointer to new clock request threshold values
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req);

#ifdef __cplusplus
}
#endif

#endif /* MMAL_CLOCK_PRIVATE_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "interface/vcos/vcos.h"
#include "interface/mmal/mmal_logging.h"
#include "interface/mmal/util/mmal_list.h"
#include "interface/mmal/util/mmal_util_rational.h"
#include "interface/mmal/core/mmal_clock_private.h"

#ifdef __VIDEOCORE__
/* Use RTOS timer for improved accuracy */
# include "vcfw/rtos/rtos.h"
# define USE_RTOS_TIMER
#endif


/*****************************************************************************/
#ifdef USE_RTOS_TIMER
# define MIN_TIMER_DELAY  1     /* microseconds */
#else
# define MIN_TIMER_DELAY  10000 /* microseconds */
#endif

/* 1.0 in Q16 format */
#define Q16_ONE  (1 << 16)

/* Maximum number of pending requests */
#define CLOCK_REQUEST_SLOTS  32

/* Number of microseconds the clock tries to service requests early
 * to account for processing overhead */
#define CLOCK_TARGET_OFFSET  20

/* Default wait time (in microseconds) when the clock is paused. */
#define CLOCK_WAIT_TIME  200000LL

/* In order to prevent unnecessary clock jitter when updating the local media-time of the
 * clock, an upper and lower threshold is used. If the difference between the reference
 * media-time and local media-time is greater than the upper threshold, local media-time
 * is set to the reference time. Below this threshold, a weighted moving average is applied
 * to the difference. If this is greater than the lower threshold, the local media-time is
 * adjusted by the average. Anything below the lower threshold is ignored. */
#define CLOCK_UPDATE_THRESHOLD_LOWER  8000   /* microseconds */
#define CLOCK_UPDATE_THRESHOLD_UPPER  50000  /* microseconds */

/* Default threshold after which backward jumps in media time are treated as a discontinuity. */
#define CLOCK_DISCONT_THRESHOLD  1000000  /* microseconds */

/* Default duration for which a discontinuity applies. Used for wall time duration for which
 * a discontinuity continues to cause affected requests to fire immediately, and as the media
 * time span for detecting discontinuous requests. */
#define CLOCK_DISCONT_DURATION   1000000  /* microseconds */

/* Absolute value macro */
#define ABS_VALUE(v)  (((v) < 0) ? -(v) : (v))

/* Macros used to make clock access thread-safe */
#define LOCK(p)    vcos_mutex_lock(&(p)->lock);
#define UNLOCK(p)  vcos_mutex_unlock(&(p)->lock);


/*****************************************************************************/
#ifdef USE_RTOS_TIMER
typedef RTOS_TIMER_T MMAL_TIMER_T;
#else
typedef VCOS_TIMER_T MMAL_TIMER_T;
#endif

typedef struct MMAL_CLOCK_REQUEST_T
{
   MMAL_LIST_ELEMENT_T link; /**< must be first */
   MMAL_CLOCK_VOID_FP priv;  /**< client-supplied function pointer */
   MMAL_CLOCK_REQUEST_CB cb; /**< client-supplied callback to invoke */
   void *cb_data;            /**< client-supplied callback data */
   int64_t offset;           /**< time offset requested by the client (microseconds) */
   int64_t media_time;       /**< media-time requested by the client (microseconds) */
   int64_t media_time_adj;   /**< adjusted media-time at which the request will be
                                  serviced in microseconds (this takes the client-supplied
                                  offset and CLOCK_TARGET_OFFSET into account) */
} MMAL_CLOCK_REQUEST_T;

typedef struct MMAL_CLOCK_PRIVATE_T
{
   MMAL_CLOCK_T clock;        /**< must be first */

   MMAL_BOOL_T is_active;     /**< TRUE -> media-time is advancing */

   MMAL_BOOL_T stop_thread;
   VCOS_SEMAPHORE_T event;
   VCOS_THREAD_T thread;

   VCOS_MUTEX_T lock;         /**< lock access to the request lists */

   MMAL_TIMER_T timer;        /**< used for scheduling client requests */

   int32_t scale;             /**< media-time scale factor (Q16 format) */
   int32_t scale_inv;         /**< 1/scale (Q16 format) */
   MMAL_RATIONAL_T scale_rational;
                              /**< clock scale as a rational number; keep a copy since
                                   converting from Q16 will result in precision errors */

   int64_t  average_ref_diff; /**< media-time moving average adjustment */
   int64_t  media_time;       /**< current local media-time in microseconds */
   int64_t  media_time_offset;/**< media-time offset in microseconds */
   uint32_t media_time_frac;  /**< media-time fraction in microseconds (Q24 format) */
   int64_t  wall_time;        /**< current local wall-time (microseconds) */
   uint32_t rtc_at_update;    /**< real-time clock value at local time update (microseconds) */
   int64_t  media_time_at_timer;
                              /**< media-time when the timer was last set */

   int64_t  discont_expiry;   /**< wall-time when discontinuity expires; 0 = no discontinuity
                                   in effect */
   int64_t  discont_start;    /**< media-time at start of discontinuity
                                   (n/a if discont_expiry = 0) */
   int64_t  discont_end;      /**< media-time at end of discontinuity
                                   (n/a if discont_expiry = 0) */
   int64_t  discont_threshold;/**< Threshold after which backward jumps in media time are treated
                                   as a discontinuity  (microseconds) */
   int64_t  discont_duration; /**< Duration (wall-time) for which a discontinuity applies */

   int64_t  request_threshold;/**< Threshold after which frames exceeding the media-time are
                                   dropped (microseconds) */
   MMAL_BOOL_T request_threshold_enable;/**< Enable the request threshold */
   int64_t  update_threshold_lower;
                              /**< Time differences below this threshold are ignored */
   int64_t  update_threshold_upper;
                              /**< Time differences above this threshold reset media time */

   /* Client requests */
   struct
   {
      MMAL_LIST_T* list_free;
      MMAL_LIST_T* list_pending;
      MMAL_CLOCK_REQUEST_T pool[CLOCK_REQUEST_SLOTS];
   } request;

} MMAL_CLOCK_PRIVATE_T;


/*****************************************************************************/
static void mmal_clock_wake_thread(MMAL_CLOCK_PRIVATE_T *private);

/*****************************************************************************
 * Timer-specific functions
 *****************************************************************************/
/* Callback invoked when timer expires */
#ifdef USE_RTOS_TIMER
static void mmal_clock_timer_cb(MMAL_TIMER_T *timer, void *ctx)
{
   MMAL_PARAM_UNUSED(timer);
   /* Notify the worker thread */
   mmal_clock_wake_thread((MMAL_CLOCK_PRIVATE_T*)ctx);
}
#else
static void mmal_clock_timer_cb(void *ctx)
{
   /* Notify the worker thread */
   mmal_clock_wake_thread((MMAL_CLOCK_PRIVATE_T*)ctx);
}
#endif

/* Create a timer */
static inline MMAL_BOOL_T mmal_clock_timer_create(MMAL_TIMER_T *timer, void *ctx)
{
#ifdef USE_RTOS_TIMER
   return (rtos_timer_init(timer, mmal_clock_timer_cb, ctx) == 0);
#else
   return (vcos_timer_create(timer, "mmal-clock timer", mmal_clock_timer_cb, ctx) == VCOS_SUCCESS);
#endif
}

/* Destroy a timer */
static inline void mmal_clock_timer_destroy(MMAL_TIMER_T *timer)
{
#ifdef USE_RTOS_TIMER
   /* Nothing to do */
#else
   vcos_timer_delete(timer);
#endif
}

/* Set the timer. Delay is in microseconds. */
static inline void mmal_clock_timer_set(MMAL_TIMER_T *timer, int64_t delay_us)
{
#ifdef USE_RTOS_TIMER
   rtos_timer_set(timer, (RTOS_TIMER_TIME_T)delay_us);
#else
   /* VCOS timer only provides millisecond accuracy */
   vcos_timer_set(timer, (VCOS_UNSIGNED)(delay_us / 1000));
#endif
}

/* Stop the timer. */
static inline void mmal_clock_timer_cancel(MMAL_TIMER_T *timer)
{
#ifdef USE_RTOS_TIMER
   rtos_timer_cancel(timer);
#else
   vcos_timer_cancel(timer);
#endif
}


/*****************************************************************************
 * Clock module private functions
 *****************************************************************************/
/* Update the internal wall-time and media-time */
static void mmal_clock_update_local_time(MMAL_CLOCK_PRIVATE_T *private)
{
   uint32_t time_now = vcos_getmicrosecs();
   uint32_t time_diff = (time_now > private->rtc_at_update) ? (time_now - private->rtc_at_update) : 0;

   private->wall_time += time_diff;

   /* Only update the media-time if the clock is active */
   if (private->is_active)
   {
      /* For small clock scale values (i.e. slow motion), the media-time increment
       * could potentially be rounded down when doing lots of updates, so also keep
       * track of the fractional increment. */
      int64_t media_diff = ((int64_t)time_diff) * (int64_t)(private->scale << 8) + private->media_time_frac;

      private->media_time += media_diff >> 24;
      private->media_time_frac = media_diff & ((1<<24)-1);
   }

   private->rtc_at_update = time_now;
}

/* Comparison function used for inserting a request into
 * the list of pending requests when clock scale is positive. */
static int mmal_clock_request_compare_pos(MMAL_LIST_ELEMENT_T *lhs, MMAL_LIST_ELEMENT_T *rhs)
{
   return ((MMAL_CLOCK_REQUEST_T*)lhs)->media_time_adj < ((MMAL_CLOCK_REQUEST_T*)rhs)->media_time_adj;
}

/* Comparison function used for inserting a request into
 * the list of pending requests when clock scale is negative. */
static int mmal_clock_request_compare_neg(MMAL_LIST_ELEMENT_T *lhs, MMAL_LIST_ELEMENT_T *rhs)
{
   return ((MMAL_CLOCK_REQUEST_T*)lhs)->media_time_adj > ((MMAL_CLOCK_REQUEST_T*)rhs)->media_time_adj;
}

/* Insert a new request into the list of pending requests */
static MMAL_BOOL_T mmal_clock_request_insert(MMAL_CLOCK_PRIVATE_T *private, MMAL_CLOCK_REQUEST_T *request)
{
   MMAL_LIST_T *list = private->request.list_pending;
   MMAL_CLOCK_REQUEST_T *pending;

   if (private->stop_thread)
      return MMAL_FALSE; /* the clock is being destroyed */

   if (list->length == 0)
   {
      mmal_list_push_front(list, &request->link);
      return MMAL_TRUE;
   }

   /* It is more likely for requests to be received in sequence,
    * so try adding to the back of the list first before doing
    * a more expensive list insert. */
   pending = (MMAL_CLOCK_REQUEST_T*)list->last;
   if ((private->scale >= 0 && (request->media_time_adj >= pending->media_time_adj)) ||
       (private->scale <  0 && (request->media_time_adj <= pending->media_time_adj)))
   {
      mmal_list_push_back(list, &request->link);
   }
   else
   {
      mmal_list_insert(list, &request->link,
            (private->scale >= 0) ? mmal_clock_request_compare_pos : mmal_clock_request_compare_neg);
   }
   return MMAL_TRUE;
}

/* Flush all pending requests */
static MMAL_STATUS_T mmal_clock_request_flush_locked(MMAL_CLOCK_PRIVATE_T *private,
                                                     int64_t media_time)
{
   MMAL_LIST_T *pending = private->request.list_pending;
   MMAL_LIST_T *list_free = private->request.list_free;
   MMAL_CLOCK_REQUEST_T *request;

   while ((request = (MMAL_CLOCK_REQUEST_T *)mmal_list_pop_front(pending)) != NULL)
   {
      /* Inform the client */
      request->cb(&private->clock, media_time, request->cb_data, request->priv);
      /* Recycle request slot */
      mmal_list_push_back(list_free, &request->link);
   }

   private->media_time_at_timer = 0;

   return MMAL_SUCCESS;
}

/* Process all pending requests */
static void mmal_clock_process_requests(MMAL_CLOCK_PRIVATE_T *private)
{
   int64_t media_time_now;
   MMAL_LIST_T* free = private->request.list_free;
   MMAL_LIST_T* pending = private->request.list_pending;
   MMAL_CLOCK_REQUEST_T *next;

   if (pending->length == 0 || !private->is_active)
      return;

   LOCK(private);

   /* Detect discontinuity */
   if (private->media_time_at_timer != 0)
   {
      media_time_now = mmal_clock_media_time_get(&private->clock);
      /* Currently only applied to forward speeds */
      if (private->scale > 0 &&
          media_time_now + private->discont_threshold < private->media_time_at_timer)
      {
         LOG_INFO("discontinuity: was=%" PRIi64 " now=%" PRIi64 " pending=%d",
                  private->media_time_at_timer, media_time_now, pending->length);

         /* It's likely that packets from before the discontinuity will continue to arrive for
          * a short time. Ensure these are detected and the requests fired immediately. */
         private->discont_start = private->media_time_at_timer;
         private->discont_end = private->discont_start + private->discont_duration;
         private->discont_expiry = private->wall_time + private->discont_duration;

         /* Fire all pending requests */
         mmal_clock_request_flush_locked(private, media_time_now);
      }
   }

   /* Earliest request is always at the front */
   next = (MMAL_CLOCK_REQUEST_T*)mmal_list_pop_front(pending);
   while (next)
   {
      media_time_now = mmal_clock_media_time_get(&private->clock);

      if (private->discont_expiry != 0 && private->wall_time > private->discont_expiry)
      {
         private->discont_expiry = 0;
      }

      /* Fire the request if it matches the pending discontinuity or if its requested media time
       * has been reached. */
      if ((private->discont_expiry != 0 &&
           next->media_time_adj >= private->discont_start &&
           next->media_time_adj < private->discont_end) ||
          (private->scale > 0 && ((media_time_now + MIN_TIMER_DELAY) >= next->media_time_adj)) ||
          (private->scale < 0 && ((media_time_now - MIN_TIMER_DELAY) <= next->media_time_adj)))
      {
         LOG_TRACE("servicing request: next %"PRIi64" now %"PRIi64, next->media_time_adj, media_time_now);
         /* Inform the client */
         next->cb(&private->clock, media_time_now, next->cb_data, next->priv);
         /* Recycle the request slot */
         mmal_list_push_back(free, &next->link);
         /* Move onto next pending request */
         next = (MMAL_CLOCK_REQUEST_T*)mmal_list_pop_front(pending);
      }
      else
      {
         /* The next request is in the future, so re-schedule the
          * timer based on the current clock scale and media-time diff */
         int64_t media_time_delay = ABS_VALUE(media_time_now - next->media_time_adj);
         int64_t wall_time_delay = ABS_VALUE(((int64_t)private->scale_inv * media_time_delay) >> 16);

         if (private->scale == 0)
            wall_time_delay = CLOCK_WAIT_TIME; /* Clock is paused */

         /* Put next request back into pending list */
         mmal_list_push_front(pending, &next->link);
         next = NULL;

         /* Set the timer */
         private->media_time_at_timer = media_time_now;
         mmal_clock_timer_set(&private->timer, wall_time_delay);

         LOG_TRACE("re-schedule timer: now %"PRIi64" delay %"PRIi64, media_time_now, wall_time_delay);
      }
   }

   UNLOCK(private);
}

/* Trigger the worker thread */
static void mmal_clock_wake_thread(MMAL_CLOCK_PRIVATE_T *private)
{
   vcos_semaphore_post(&private->event);
}

/* Stop the worker thread */
static void mmal_clock_stop_thread(MMAL_CLOCK_PRIVATE_T *private)
{
   private->stop_thread = MMAL_TRUE;
   mmal_clock_wake_thread(private);
   vcos_thread_join(&private->thread, NULL);
}

/* Main processing thread */
static void* mmal_clock_worker_thread(void *ctx)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)ctx;

   while (1)
   {
      vcos_semaphore_wait(&private->event);

      /* Either the timer has expired or a new request is pending */
      mmal_clock_timer_cancel(&private->timer);

      if (private->stop_thread)
         break;

      mmal_clock_process_requests(private);
   }
   return NULL;
}

/* Start the media-time */
static void mmal_clock_start(MMAL_CLOCK_T *clock)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;

   private->is_active = MMAL_TRUE;
   mmal_clock_wake_thread(private);
}

/* Stop the media-time */
static void mmal_clock_stop(MMAL_CLOCK_T *clock)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;

   private->is_active = MMAL_FALSE;
}

/*****************************************************************************
 * Clock module public functions
 *****************************************************************************/
/* Create new clock instance */
MMAL_STATUS_T mmal_clock_create(MMAL_CLOCK_T **clock)
{
   unsigned int i, size = sizeof(MMAL_CLOCK_PRIVATE_T);
   MMAL_BOOL_T timer_status = MMAL_FALSE;
   VCOS_STATUS_T lock_status = VCOS_EINVAL;
   VCOS_STATUS_T event_status = VCOS_EINVAL;
   MMAL_RATIONAL_T scale = { 1, 0 };
   VCOS_UNSIGNED priority;
   MMAL_CLOCK_PRIVATE_T *private;

   /* Sanity checking */
   if (clock == NULL)
      return MMAL_EINVAL;

   private = vcos_calloc(1, size, "mmal-clock");
   if (!private)
   {
      LOG_ERROR("failed to allocate memory");
      return MMAL_ENOMEM;
   }

   timer_status = mmal_clock_timer_create(&private->timer, private);
   if (!timer_status)
   {
      LOG_ERROR("failed to create timer %p", private);
      goto error;
   }

   event_status = vcos_semaphore_create(&private->event, "mmal-clock sema", 0);
   if (event_status != VCOS_SUCCESS)
   {
      LOG_ERROR("failed to create event semaphore %d", event_status);
      goto error;
   }

   lock_status = vcos_mutex_create(&private->lock, "mmal-clock lock");
   if (lock_status != VCOS_SUCCESS)
   {
      LOG_ERROR("failed to create lock mutex %d", lock_status);
      goto error;
   }

   private->request.list_free = mmal_list_create();
   private->request.list_pending = mmal_list_create();
   if (!private->request.list_free || !private->request.list_pending)
   {
      LOG_ERROR("failed to create list %p %p", private->request.list_free, private->request.list_pending);
      goto error;
   }

   /* Set the default threshold values */
   private->update_threshold_lower = CLOCK_UPDATE_THRESHOLD_LOWER;
   private->update_threshold_upper = CLOCK_UPDATE_THRESHOLD_UPPER;
   private->discont_threshold      = CLOCK_DISCONT_THRESHOLD;
   private->discont_duration       = CLOCK_DISCONT_DURATION;
   private->request_threshold      = 0;
   private->request_threshold_enable = MMAL_FALSE;

   if (vcos_thread_create(&private->thread, "mmal-clock thread", NULL,
                          mmal_clock_worker_thread, private) != VCOS_SUCCESS)
   {
      LOG_ERROR("failed to create worker thread");
      goto error;
   }
   priority = vcos_thread_get_priority(&private->thread);
   vcos_thread_set_priority(&private->thread, 1 | (priority & VCOS_AFFINITY_MASK));

   /* Populate the list of available request slots */
   for (i = 0; i < CLOCK_REQUEST_SLOTS; ++i)
      mmal_list_push_back(private->request.list_free, &private->request.pool[i].link);

   /* Default scale = 1.0, i.e. normal playback speed */
   mmal_clock_scale_set(&private->clock, scale);

   *clock = &private->clock;
   return MMAL_SUCCESS;

error:
   if (lock_status == VCOS_SUCCESS) vcos_mutex_delete(&private->lock);
   if (event_status == VCOS_SUCCESS) vcos_semaphore_delete(&private->event);
   if (timer_status) mmal_clock_timer_destroy(&private->timer);
   if (private->request.list_free) mmal_list_destroy(private->request.list_free);
   if (private->request.list_pending) mmal_list_destroy(private->request.list_pending);
   vcos_free(private);
   return MMAL_ENOSPC;
}

/* Destroy a clock instance */
MMAL_STATUS_T mmal_clock_destroy(MMAL_CLOCK_T *clock)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;

   mmal_clock_stop_thread(private);

   mmal_clock_request_flush(clock);

   mmal_list_destroy(private->request.list_free);
   mmal_list_destroy(private->request.list_pending);

   mmal_clock_timer_destroy(&private->timer);

   vcos_mutex_delete(&private->lock);

   vcos_semaphore_delete(&private->event);

   vcos_free(private);

   return MMAL_SUCCESS;
}

/* Add new client request to list of pending requests */
MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time, int64_t offset,
      MMAL_CLOCK_REQUEST_CB cb, void *cb_data, MMAL_CLOCK_VOID_FP priv)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
   MMAL_CLOCK_REQUEST_T *request;
   MMAL_BOOL_T success;
   int64_t media_time_now;

   LOG_TRACE("media time %"PRIi64" offset %"PRIi64, media_time, offset);

   /* Drop the request if request_threshold_enable and the frame exceeds the request threshold */
   media_time_now = mmal_clock_media_time_get(&private->clock);
   LOCK(private);
   if(private->request_threshold_enable && (media_time > (media_time_now + private->request_threshold))) {
      LOG_TRACE("dropping request: media time %"PRIi64" now %"PRIi64, media_time, media_time_now);
      UNLOCK(private);
      return MMAL_ECORRUPT;
   }
   UNLOCK(private);
   request = (MMAL_CLOCK_REQUEST_T*)mmal_list_pop_front(private->request.list_free);
   if (request == NULL)
   {
      LOG_ERROR("no more free clock request slots");
      return MMAL_ENOSPC;
   }

   request->cb = cb;
   request->cb_data = cb_data;
   request->priv = priv;
   request->offset = offset;
   request->media_time = media_time;
   request->media_time_adj = media_time - (int64_t)(private->scale * (request->offset + CLOCK_TARGET_OFFSET) >> 16);

   LOCK(private);
   success = mmal_clock_request_insert(private, request);
   UNLOCK(private);

   /* Notify the worker thread */
   if (success)
      mmal_clock_wake_thread(private);

   return success ? MMAL_SUCCESS : MMAL_EINVAL;
}

/* Flush all pending requests */
MMAL_STATUS_T mmal_clock_request_flush(MMAL_CLOCK_T *clock)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;

   LOCK(private);
   mmal_clock_request_flush_locked(private, MMAL_TIME_UNKNOWN);
   UNLOCK(private);

   return MMAL_SUCCESS;
}

/* Update the local media-time with the given reference */
MMAL_STATUS_T mmal_clock_media_time_set(MMAL_CLOCK_T *clock, int64_t media_time)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
   MMAL_BOOL_T wake_thread = MMAL_TRUE;
   int64_t time_diff;

   /* Reset the local media-time with the given time reference */
   mmal_clock_update_local_time(private);

   time_diff = private->media_time - media_time;
   if (time_diff >  private->update_threshold_upper ||
       time_diff < -private->update_threshold_upper)
   {
      LOG_TRACE("cur:%"PRIi64" new:%"PRIi64" diff:%"PRIi64, private->media_time, media_time, time_diff);
      private->media_time = media_time;
      private->average_ref_diff = 0;
   }
   else
   {
      private->average_ref_diff = ((private->average_ref_diff << 6) - private->average_ref_diff + time_diff) >> 6;
      if(private->average_ref_diff >  private->update_threshold_lower ||
         private->average_ref_diff < -private->update_threshold_lower)
      {
         LOG_TRACE("cur:%"PRIi64" new:%"PRIi64" ave:%"PRIi64, private->media_time,
               private->media_time - private->average_ref_diff, private->average_ref_diff);
         private->media_time -= private->average_ref_diff;
         private->average_ref_diff = 0;
      }
      else
      {
         /* Don't update the media-time */
         wake_thread = MMAL_FALSE;
         LOG_TRACE("cur:%"PRIi64" new:%"PRIi64" diff:%"PRIi64" ave:%"PRIi64" ignored", private->media_time,
               media_time, private->media_time - media_time, private->average_ref_diff);
      }
   }

   if (wake_thread)
      mmal_clock_wake_thread(private);

   return wake_thread ? MMAL_SUCCESS : MMAL_EINVAL;
}

/* Set a media-time offset */
MMAL_STATUS_T mmal_clock_media_time_offset_set(MMAL_CLOCK_T *clock, int64_t offset)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;

   LOG_TRACE("new offset %"PRIi64, offset);

   private->media_time_offset = offset;

   mmal_clock_wake_thread(private);

   return MMAL_SUCCESS;
}

/* Change the clock scale */
MMAL_STATUS_T mmal_clock_scale_set(MMAL_CLOCK_T *clock, MMAL_RATIONAL_T scale)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;

   LOG_TRACE("new scale %d/%d", scale.num, scale.den);

   mmal_clock_update_local_time(private);

   LOCK(private);

   private->scale_rational = scale;
   private->scale = mmal_rational_to_fixed_16_16(scale);

   if (private->scale)
      private->scale_inv = (int32_t)((1LL << 32) / (int64_t)private->scale);
   else
      private->scale_inv = Q16_ONE; /* clock is paused */

   UNLOCK(private);

   mmal_clock_wake_thread(private);

   return MMAL_SUCCESS;
}

/* Set the clock state */
MMAL_STATUS_T mmal_clock_active_set(MMAL_CLOCK_T *clock, MMAL_BOOL_T active)
{
   if (active)
      mmal_clock_start(clock);
   else
      mmal_clock_stop(clock);

   return MMAL_SUCCESS;
}

/* Get the clock's scale */
MMAL_RATIONAL_T mmal_clock_scale_get(MMAL_CLOCK_T *clock)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
   MMAL_RATIONAL_T scale;

   LOCK(private);
   scale = private->scale_rational;
   UNLOCK(private);

   return scale;
}

/* Return the current local media-time */
int64_t mmal_clock_media_time_get(MMAL_CLOCK_T *clock)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;

   mmal_clock_update_local_time(private);

   return private->media_time + (private->scale * private->media_time_offset >> 16);
}

/* Return the media-time offset */
int64_t mmal_clock_media_time_offset_get(MMAL_CLOCK_T *clock)
{
   return ((MMAL_CLOCK_PRIVATE_T*)clock)->media_time_offset;
}

/* Get the clock's state */
MMAL_BOOL_T mmal_clock_is_active(MMAL_CLOCK_T *clock)
{
   return ((MMAL_CLOCK_PRIVATE_T*)clock)->is_active;
}

/* Get the clock's media-time update threshold values */
MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;

   LOCK(private);
   update_threshold->threshold_lower = private->update_threshold_lower;
   update_threshold->threshold_upper = private->update_threshold_upper;
   UNLOCK(private);

   return MMAL_SUCCESS;
}

/* Set the clock's media-time update threshold values */
MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;

   LOG_TRACE("new clock update thresholds: upper %"PRIi64", lower %"PRIi64,
         update_threshold->threshold_lower, update_threshold->threshold_upper);

   LOCK(private);
   private->update_threshold_lower = update_threshold->threshold_lower;
   private->update_threshold_upper = update_threshold->threshold_upper;
   UNLOCK(private);

   return MMAL_SUCCESS;
}

/* Get the clock's discontinuity threshold values */
MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;

   LOCK(private);
   discont->threshold = private->discont_threshold;
   discont->duration  = private->discont_duration;
   UNLOCK(private);

   return MMAL_SUCCESS;
}

/* Set the clock's discontinuity threshold values */
MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;

   LOG_TRACE("new clock discontinuity values: threshold %"PRIi64", duration %"PRIi64,
         discont->threshold, discont->duration);

   LOCK(private);
   private->discont_threshold = discont->threshold;
   private->discont_duration  = discont->duration;
   UNLOCK(private);

   return MMAL_SUCCESS;
}

/* Get the clock's request threshold values */
MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;

   LOCK(private);
   req->threshold = private->request_threshold;
   req->threshold_enable = private->request_threshold_enable;
   UNLOCK(private);

   return MMAL_SUCCESS;
}

/* Set the clock's request threshold values */
MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req)
{
   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;

   LOG_TRACE("new clock request values: threshold %"PRIi64,
         req->threshold);

   LOCK(private);
   private->request_threshold = req->threshold;
   private->request_threshold_enable = req->threshold_enable;
   UNLOCK(private);

   return MMAL_SUCCESS;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component_private.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_COMPONENT_PRIVATE_H
#define MMAL_COMPONENT_PRIVATE_H

#define MMAL_VIDEO_DECODE  "video_decode"
#define MMAL_VIDEO_ENCODE  "video_encode"
#define MMAL_VIDEO_RENDER  "video_render"
#define MMAL_AUDIO_DECODE  "audio_decode"
#define MMAL_AUDIO_ENCODE  "audio_encode"
#define MMAL_AUDIO_RENDER  "audio_render"
#define MMAL_CAMERA        "camera"

#if defined(__GNUC__) && (__GNUC__ > 2)
# define MMAL_CONSTRUCTOR(func) void __attribute__((constructor,used)) func(void)
# define MMAL_DESTRUCTOR(func) void __attribute__((destructor,used)) func(void)
#else
# define MMAL_CONSTRUCTOR(func) void func(void)
# define MMAL_DESTRUCTOR(func) void func(void)
#endif

#include "mmal.h"
#include "mmal_component.h"

/** Definition of a component. */
struct MMAL_COMPONENT_PRIVATE_T
{
   /** Pointer to the private data of the component module in use */
   struct MMAL_COMPONENT_MODULE_T *module;

   MMAL_STATUS_T (*pf_enable)(MMAL_COMPONENT_T *component);
   MMAL_STATUS_T (*pf_disable)(MMAL_COMPONENT_T *component);
   MMAL_STATUS_T (*pf_destroy)(MMAL_COMPONENT_T *component);

   /** Pool of event buffer headers, for sending events from component to client. */
   MMAL_POOL_T *event_pool;

   /** Reference counting of the component */
   int refcount;
   /** Reference counting of the ports. Component won't be destroyed until this
    * goes to 0 */
   int refcount_ports;

   /** Priority associated with the 'action thread' for this component, when
    * such action thread is applicable. */
   int priority;
};

/** Set a generic component control parameter.
  *
  * @param control_port control port of component on which to set the parameter.
  * @param param        parameter to be set.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_parameter_set(MMAL_PORT_T *control_port,
                                           const MMAL_PARAMETER_HEADER_T *param);

/** Get a generic component control parameter.
  *
  * @param contorl_port control port of component from which to get the parameter.
  * @param param        parameter to be retrieved.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_parameter_get(MMAL_PORT_T *control_port,
                                           MMAL_PARAMETER_HEADER_T *param);

/** Registers an action with the core.
  * The MMAL core allows components to register an action which will be run
  * from a separate thread context when the action is explicitly triggered by
  * the component.
  *
  * @param component    component registering the action.
  * @param action       action to register.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_register(MMAL_COMPONENT_T *component,
                                             void (*pf_action)(MMAL_COMPONENT_T *));

/** De-registers the current action registered with the core.
  *
  * @param component    component de-registering the action.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_deregister(MMAL_COMPONENT_T *component);

/** Triggers a registered action.
  * Explicitly triggers an action registered by a component.
  *
  * @param component    component on which to trigger the action.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_trigger(MMAL_COMPONENT_T *component);

/** Lock an action to prevent it from running.
  * Allows a component to make sure no action is running while the lock is taken.
  *
  * @param component    component.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_lock(MMAL_COMPONENT_T *component);

/** Unlock an action to allow it to run again.
  *
  * @param component    component.
  * @return MMAL_SUCCESS or another status on error.
  */
MMAL_STATUS_T mmal_component_action_unlock(MMAL_COMPONENT_T *component);

/** Prototype used by components to register themselves to the supplier. */
typedef MMAL_STATUS_T (*MMAL_COMPONENT_SUPPLIER_FUNCTION_T)(const char *name,
                                                            MMAL_COMPONENT_T *component);

/** Create an instance of a component given a constructor for the component.
 * This allows the creation of client-side components which haven't been registered with the core.
 * See \ref mmal_component_create for the public interface used to create components.
 *
 * @param name name assigned to the component by the client
 * @param constructor constructor function for the component
 * @param constructor_private private data for the constructor
 * @param component returned component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_create_with_constructor(const char *name,
   MMAL_STATUS_T (*constructor)(const char *name, MMAL_COMPONENT_T *),
   struct MMAL_COMPONENT_MODULE_T *constructor_private,
   MMAL_COMPONENT_T **component);

/** Register a component with the mmal component supplier.
  *
  * @param prefix     prefix for this supplier, e.g. "VC"
  * @param create_fn  function which will instantiate a component given a name.
  */
void mmal_component_supplier_register(const char *prefix,
                                      MMAL_COMPONENT_SUPPLIER_FUNCTION_T create_fn);

#endif /* MMAL_COMPONENT_PRIVATE_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "core/mmal_component_private.h"
#include "core/mmal_port_private.h"
#include "core/mmal_core_private.h"
#include "mmal_logging.h"

/* Minimum number of buffers that will be available on the control port */
#define MMAL_CONTROL_PORT_BUFFERS_MIN 4

/** Definition of the core private context. */
typedef struct
{
   MMAL_COMPONENT_PRIVATE_T private;

   /** Action registered by component and run when buffers are received by any of the ports */
   void (*pf_action)(MMAL_COMPONENT_T *component);

   /** Action thread */
   VCOS_THREAD_T action_thread;
   VCOS_SEMAPHORE_T action_sema;
   VCOS_MUTEX_T action_mutex;
   MMAL_BOOL_T action_quit;

   VCOS_MUTEX_T lock; /**< Used to lock access to the component */
   MMAL_BOOL_T destruction_pending;

} MMAL_COMPONENT_CORE_PRIVATE_T;

/*****************************************************************************/
static void mmal_core_init(void);
static void mmal_core_deinit(void);

static MMAL_STATUS_T mmal_component_supplier_create(const char *name, MMAL_COMPONENT_T *component);
static void mmal_component_init_control_port(MMAL_PORT_T *port);

static MMAL_STATUS_T mmal_component_destroy_internal(MMAL_COMPONENT_T *component);
static MMAL_STATUS_T mmal_component_release_internal(MMAL_COMPONENT_T *component);

/*****************************************************************************/
static VCOS_MUTEX_T mmal_core_lock;
/** Used to generate a unique id for each MMAL component in this context.    */
static unsigned int mmal_core_instance_count;
static unsigned int mmal_core_refcount;
/*****************************************************************************/

/** Create an instance of a component */
static MMAL_STATUS_T mmal_component_create_core(const char *name,
   MMAL_STATUS_T (*constructor)(const char *name, MMAL_COMPONENT_T *),
   struct MMAL_COMPONENT_MODULE_T *constructor_private,
   MMAL_COMPONENT_T **component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private;
   MMAL_STATUS_T status = MMAL_ENOMEM;
   unsigned int size = sizeof(MMAL_COMPONENT_T) + sizeof(MMAL_COMPONENT_CORE_PRIVATE_T);
   unsigned int i, name_length = strlen(name) + 1;
   unsigned int port_index;
   char *component_name;

   if(!component)
      return MMAL_EINVAL;

   mmal_core_init();

   *component = vcos_calloc(1, size + name_length, "mmal component");
   if(!*component)
      return MMAL_ENOMEM;

   private = (MMAL_COMPONENT_CORE_PRIVATE_T *)&(*component)[1];
   (*component)->priv = (MMAL_COMPONENT_PRIVATE_T *)private;
   (*component)->name = component_name= (char *)&((MMAL_COMPONENT_CORE_PRIVATE_T *)(*component)->priv)[1];
   memcpy(component_name, name, name_length);
   (*component)->priv->refcount = 1;
   (*component)->priv->priority = VCOS_THREAD_PRI_NORMAL;

   if(vcos_mutex_create(&private->lock, "mmal component lock") != VCOS_SUCCESS)
   {
      vcos_free(*component);
      return MMAL_ENOMEM;
   }

   vcos_mutex_lock(&mmal_core_lock);
   (*component)->id=mmal_core_instance_count++;
   vcos_mutex_unlock(&mmal_core_lock);

   /* Create the control port */
   (*component)->control = mmal_port_alloc(*component, MMAL_PORT_TYPE_CONTROL, 0);
   if(!(*component)->control)
      goto error;
   mmal_component_init_control_port((*component)->control);

   /* Create the actual component */
   (*component)->priv->module = constructor_private;
   if (!constructor)
      constructor = mmal_component_supplier_create;
   status = constructor(name, *component);
   if (status != MMAL_SUCCESS)
   {
      if (status == MMAL_ENOSYS)
         LOG_ERROR("could not find component '%s'", name);
      else
         LOG_ERROR("could not create component '%s' (%i)", name, status);
      goto error;
   }

   /* Make sure we have enough space for at least a MMAL_EVENT_FORMAT_CHANGED */
   if ((*component)->control->buffer_size_min <
       sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T) + sizeof(MMAL_EVENT_FORMAT_CHANGED_T))
      (*component)->control->buffer_size_min = sizeof(MMAL_ES_FORMAT_T) +
         sizeof(MMAL_ES_SPECIFIC_FORMAT_T) + sizeof(MMAL_EVENT_FORMAT_CHANGED_T);
   /* Make sure we have enough events */
   if ((*component)->control->buffer_num_min < MMAL_CONTROL_PORT_BUFFERS_MIN)
      (*component)->control->buffer_num_min = MMAL_CONTROL_PORT_BUFFERS_MIN;

   /* Create the event pool */
   (*component)->priv->event_pool = mmal_pool_create((*component)->control->buffer_num_min,
         (*component)->control->buffer_size_min);
   if (!(*component)->priv->event_pool)
   {
      status = MMAL_ENOMEM;
      LOG_ERROR("could not create event pool (%d, %d)", (*component)->control->buffer_num_min,
            (*component)->control->buffer_size_min);
      goto error;
   }

   /* Build the list of all the ports */
   (*component)->port_num = (*component)->input_num + (*component)->output_num + (*component)->clock_num + 1;
   (*component)->port = vcos_malloc((*component)->port_num * sizeof(MMAL_PORT_T *), "mmal ports");
   if (!(*component)->port)
   {
      status = MMAL_ENOMEM;
      LOG_ERROR("could not create list of ports");
      goto error;
   }
   port_index = 0;
   (*component)->port[port_index++] = (*component)->control;
   for (i = 0; i < (*component)->input_num; i++)
      (*component)->port[port_index++] = (*component)->input[i];
   for (i = 0; i < (*component)->output_num; i++)
      (*component)->port[port_index++] = (*component)->output[i];
   for (i = 0; i < (*component)->clock_num; i++)
      (*component)->port[port_index++] = (*component)->clock[i];
   for (i = 0; i < (*component)->port_num; i++)
      (*component)->port[i]->index_all = i;

   LOG_INFO("created '%s' %d %p", name, (*component)->id, *component);

   /* Make sure the port types, indexes and buffer sizes are set correctly */
   (*component)->control->type = MMAL_PORT_TYPE_CONTROL;
   (*component)->control->index = 0;
   for (i = 0; i < (*component)->input_num; i++)
   {
      MMAL_PORT_T *port = (*component)->input[i];
      port->type = MMAL_PORT_TYPE_INPUT;
      port->index = i;
   }
   for (i = 0; i < (*component)->output_num; i++)
   {
      MMAL_PORT_T *port = (*component)->output[i];
      port->type = MMAL_PORT_TYPE_OUTPUT;
      port->index = i;
   }
   for (i = 0; i < (*component)->clock_num; i++)
   {
      MMAL_PORT_T *port = (*component)->clock[i];
      port->type = MMAL_PORT_TYPE_CLOCK;
      port->index = i;
   }
   for (i = 0; i < (*component)->port_num; i++)
   {
      MMAL_PORT_T *port = (*component)->port[i];
      if (port->buffer_size < port->buffer_size_min)
         port->buffer_size = port->buffer_size_min;
      if (port->buffer_num < port->buffer_num_min)
         port->buffer_num = port->buffer_num_min;
   }

   return MMAL_SUCCESS;

 error:
   mmal_component_destroy_internal(*component);
   *component = 0;
   return status;
}

/** Create an instance of a component */
MMAL_STATUS_T mmal_component_create(const char *name,
   MMAL_COMPONENT_T **component)
{
   LOG_TRACE("%s", name);
   return mmal_component_create_core(name, 0, 0, component);
}

/** Create an instance of a component */
MMAL_STATUS_T mmal_component_create_with_constructor(const char *name,
   MMAL_STATUS_T (*constructor)(const char *name, MMAL_COMPONENT_T *),
   struct MMAL_COMPONENT_MODULE_T *constructor_private,
   MMAL_COMPONENT_T **component)
{
   LOG_TRACE("%s", name);
   return mmal_component_create_core(name, constructor, constructor_private, component);
}

/** Destroy a previously created component */
static MMAL_STATUS_T mmal_component_destroy_internal(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
   MMAL_STATUS_T status;

   LOG_TRACE("%s %d", component->name, component->id);

   mmal_component_action_deregister(component);

   /* Should pf_destroy be allowed to fail ?
    * If so, what do we do if it fails ?
    */
   if (component->priv->pf_destroy)
   {
      status = component->priv->pf_destroy(component);
      if(!vcos_verify(status == MMAL_SUCCESS))
         return status;
   }

   if (component->priv->event_pool)
      mmal_pool_destroy(component->priv->event_pool);

   if (component->control)
      mmal_port_free(component->control);

   if (component->port)
      vcos_free(component->port);

   vcos_mutex_delete(&private->lock);
   vcos_free(component);
   mmal_core_deinit();
   return MMAL_SUCCESS;
}

/** Release a reference to a component */
static MMAL_STATUS_T mmal_component_release_internal(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
   unsigned int i;

   if (!vcos_verify(component->priv->refcount > 0))
      return MMAL_EINVAL;

   vcos_mutex_lock(&private->lock);
   if (--component->priv->refcount)
   {
      vcos_mutex_unlock(&private->lock);
      return MMAL_SUCCESS;
   }
   private->destruction_pending = 1;
   vcos_mutex_unlock(&private->lock);

   LOG_TRACE("%s %d preparing for destruction", component->name, component->id);

   /* Make sure the ports are all disabled */
   for(i = 0; i < component->input_num; i++)
      if(component->input[i]->is_enabled)
         mmal_port_disable(component->input[i]);
   for(i = 0; i < component->output_num; i++)
      if(component->output[i]->is_enabled)
         mmal_port_disable(component->output[i]);
   for(i = 0; i < component->clock_num; i++)
      if(component->clock[i]->is_enabled)
         mmal_port_disable(component->clock[i]);
   if(component->control->is_enabled)
      mmal_port_disable(component->control);

   /* Make sure all the ports are disconnected. This is necessary to prevent
    * connected ports from referencing destroyed components */
   for(i = 0; i < component->input_num; i++)
      mmal_port_disconnect(component->input[i]);
   for(i = 0; i < component->output_num; i++)
      mmal_port_disconnect(component->output[i]);
   for(i = 0; i < component->clock_num; i++)
      mmal_port_disconnect(component->clock[i]);

   /* If there is any reference pending on the ports we will delay the actual destruction */
   vcos_mutex_lock(&private->lock);
   if (component->priv->refcount_ports)
   {
      private->destruction_pending = 0;
      vcos_mutex_unlock(&private->lock);
      LOG_TRACE("%s %d delaying destruction", component->name, component->id);
      return MMAL_SUCCESS;
   }
   vcos_mutex_unlock(&private->lock);

   return mmal_component_destroy_internal(component);
}

/** Destroy a component */
MMAL_STATUS_T mmal_component_destroy(MMAL_COMPONENT_T *component)
{
   if(!component)
      return MMAL_EINVAL;

   LOG_TRACE("%s %d", component->name, component->id);

   return mmal_component_release_internal(component);
}

/** Acquire a reference to a component */
void mmal_component_acquire(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   LOG_TRACE("component %s(%d), refcount %i", component->name, component->id,
             component->priv->refcount);

   vcos_mutex_lock(&private->lock);
   component->priv->refcount++;
   vcos_mutex_unlock(&private->lock);
}

/** Release a reference to a component */
MMAL_STATUS_T mmal_component_release(MMAL_COMPONENT_T *component)
{
   if(!component)
      return MMAL_EINVAL;

   LOG_TRACE("component %s(%d), refcount %i", component->name, component->id,
             component->priv->refcount);

   return mmal_component_release_internal(component);
}

/** Enable processing on a component */
MMAL_STATUS_T mmal_component_enable(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private;
   MMAL_STATUS_T status;
   unsigned int i;

   if(!component)
      return MMAL_EINVAL;

   private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   LOG_TRACE("%s %d", component->name, component->id);

   vcos_mutex_lock(&private->lock);

   /* Check we have anything to do */
   if (component->is_enabled)
   {
      vcos_mutex_unlock(&private->lock);
      return MMAL_SUCCESS;
   }

   status = component->priv->pf_enable(component);

   /* Resume all input / output ports */
   for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
      status = mmal_port_pause(component->input[i], MMAL_FALSE);
   for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
      status = mmal_port_pause(component->output[i], MMAL_FALSE);

   if (status == MMAL_SUCCESS)
      component->is_enabled = 1;

   vcos_mutex_unlock(&private->lock);

   return status;
}

/** Disable processing on a component */
MMAL_STATUS_T mmal_component_disable(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private;
   MMAL_STATUS_T status;
   unsigned int i;

   if (!component)
      return MMAL_EINVAL;

   private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   LOG_TRACE("%s %d", component->name, component->id);

   vcos_mutex_lock(&private->lock);

   /* Check we have anything to do */
   if (!component->is_enabled)
   {
      vcos_mutex_unlock(&private->lock);
      return MMAL_SUCCESS;
   }

   status = component->priv->pf_disable(component);

   /* Pause all input / output ports */
   for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
      status = mmal_port_pause(component->input[i], MMAL_TRUE);
   for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
      status = mmal_port_pause(component->output[i], MMAL_TRUE);

   if (status == MMAL_SUCCESS)
      component->is_enabled = 0;

   vcos_mutex_unlock(&private->lock);

   return status;
}

static MMAL_STATUS_T mmal_component_enable_control_port(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
{
   (void)port;
   (void)cb;
   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_component_disable_control_port(MMAL_PORT_T *port)
{
   (void)port;
   return MMAL_SUCCESS;
}

MMAL_STATUS_T mmal_component_parameter_set(MMAL_PORT_T *control_port,
                                           const MMAL_PARAMETER_HEADER_T *param)
{
   (void)control_port;
   (void)param;
   /* No generic component control parameters */
   LOG_ERROR("parameter id 0x%08x not supported", param->id);
   return MMAL_ENOSYS;
}

MMAL_STATUS_T mmal_component_parameter_get(MMAL_PORT_T *control_port,
                                           MMAL_PARAMETER_HEADER_T *param)
{
   (void)control_port;
   (void)param;
   /* No generic component control parameters */
   LOG_ERROR("parameter id 0x%08x not supported", param->id);
   return MMAL_ENOSYS;
}

static void mmal_component_init_control_port(MMAL_PORT_T *port)
{
   port->format->type = MMAL_ES_TYPE_CONTROL;
   port->buffer_num_min = MMAL_CONTROL_PORT_BUFFERS_MIN;
   port->buffer_num = port->buffer_num_min;
   port->buffer_size_min = sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T);
   port->buffer_size = port->buffer_size_min;

   /* Default to generic handling */
   port->priv->pf_enable = mmal_component_enable_control_port;
   port->priv->pf_disable = mmal_component_disable_control_port;
   port->priv->pf_parameter_set = mmal_component_parameter_set;
   port->priv->pf_parameter_get = mmal_component_parameter_get;
   /* No pf_set_format - format of control port cannot be changed */
   /* No pf_send - buffers cannot be sent to control port */
}

/** Acquire a reference on a port */
void mmal_port_acquire(MMAL_PORT_T *port)
{
   MMAL_COMPONENT_T *component = port->component;
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   LOG_TRACE("port %s(%p), refcount %i", port->name, port,
             component->priv->refcount_ports);

   vcos_mutex_lock(&private->lock);
   component->priv->refcount_ports++;
   vcos_mutex_unlock(&private->lock);
}

/** Release a reference on a port */
MMAL_STATUS_T mmal_port_release(MMAL_PORT_T *port)
{
   MMAL_COMPONENT_T *component = port->component;
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   LOG_TRACE("port %s(%p), refcount %i", port->name, port,
             component->priv->refcount_ports);

   /* Sanity check the refcount */
   if (!vcos_verify(component->priv->refcount_ports > 0))
      return MMAL_EINVAL;

   vcos_mutex_lock(&private->lock);
   if (--component->priv->refcount_ports ||
       component->priv->refcount || private->destruction_pending)
   {
      vcos_mutex_unlock(&private->lock);
      return MMAL_SUCCESS;
   }
   vcos_mutex_unlock(&private->lock);

   return mmal_component_destroy_internal(component);
}

/*****************************************************************************
 * Actions support
 *****************************************************************************/

/** Registers an action with the core */
static void *mmal_component_action_thread_func(void *arg)
{
   MMAL_COMPONENT_T *component = (MMAL_COMPONENT_T *)arg;
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
   VCOS_STATUS_T status;

   while (1)
   {
      status = vcos_semaphore_wait(&private->action_sema);

      if (status == VCOS_EAGAIN)
         continue;
      if (private->action_quit)
         break;
      if (!vcos_verify(status == VCOS_SUCCESS))
         break;

      vcos_mutex_lock(&private->action_mutex);
      private->pf_action(component);
      vcos_mutex_unlock(&private->action_mutex);
   }
   return 0;
}

/** Registers an action with the core */
MMAL_STATUS_T mmal_component_action_register(MMAL_COMPONENT_T *component,
                                             void (*pf_action)(MMAL_COMPONENT_T *) )
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
   VCOS_THREAD_ATTR_T attrs;
   VCOS_STATUS_T status;

   if (private->pf_action)
      return MMAL_EINVAL;

   status = vcos_semaphore_create(&private->action_sema, component->name, 0);
   if (status != VCOS_SUCCESS)
      return MMAL_ENOMEM;

   status = vcos_mutex_create(&private->action_mutex, component->name);
   if (status != VCOS_SUCCESS)
   {
      vcos_semaphore_delete(&private->action_sema);
      return MMAL_ENOMEM;
   }

   vcos_thread_attr_init(&attrs);
   vcos_thread_attr_setpriority(&attrs,
                                private->private.priority);
   status = vcos_thread_create(&private->action_thread, component->name, &attrs,
                               mmal_component_action_thread_func, component);
   if (status != VCOS_SUCCESS)
   {
      vcos_mutex_delete(&private->action_mutex);
      vcos_semaphore_delete(&private->action_sema);
      return MMAL_ENOMEM;
   }

   private->pf_action = pf_action;
   return MMAL_SUCCESS;
}

/** De-registers the current action with the core */
MMAL_STATUS_T mmal_component_action_deregister(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   if (!private->pf_action)
      return MMAL_EINVAL;

   private->action_quit = 1;
   vcos_semaphore_post(&private->action_sema);
   vcos_thread_join(&private->action_thread, NULL);
   vcos_semaphore_delete(&private->action_sema);
   vcos_mutex_delete(&private->action_mutex);
   private->pf_action = NULL;
   private->action_quit = 0;
   return MMAL_SUCCESS;
}

/** Triggers a registered action */
MMAL_STATUS_T mmal_component_action_trigger(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   if (!private->pf_action)
      return MMAL_EINVAL;

   vcos_semaphore_post(&private->action_sema);
   return MMAL_SUCCESS;
}

/** Lock an action to prevent it from running */
MMAL_STATUS_T mmal_component_action_lock(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   if (!private->pf_action)
      return MMAL_EINVAL;

   vcos_mutex_lock(&private->action_mutex);
   return MMAL_SUCCESS;
}

/** Unlock an action to allow it to run again */
MMAL_STATUS_T mmal_component_action_unlock(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;

   if (!private->pf_action)
      return MMAL_EINVAL;

   vcos_mutex_unlock(&private->action_mutex);
   return MMAL_SUCCESS;
}

/*****************************************************************************
 * Initialisation / Deinitialisation of the MMAL core
 *****************************************************************************/
static void mmal_core_init_once(void)
{
   vcos_mutex_create(&mmal_core_lock, VCOS_FUNCTION);
}

static void mmal_core_init(void)
{
   static VCOS_ONCE_T once = VCOS_ONCE_INIT;
   vcos_init();
   vcos_once(&once, mmal_core_init_once);

   vcos_mutex_lock(&mmal_core_lock);
   if (mmal_core_refcount++)
   {
      vcos_mutex_unlock(&mmal_core_lock);
      return;
   }

   mmal_logging_init();
   vcos_mutex_unlock(&mmal_core_lock);
}

static void mmal_core_deinit(void)
{
   vcos_mutex_lock(&mmal_core_lock);
   if (!mmal_core_refcount || --mmal_core_refcount)
   {
      vcos_mutex_unlock(&mmal_core_lock);
      return;
   }

   mmal_logging_deinit();
   vcos_mutex_unlock(&mmal_core_lock);
   vcos_deinit();
}

/*****************************************************************************
 * Supplier support
 *****************************************************************************/

/** a component supplier gets passed a string and returns a
  * component (if it can) based on that string.
  */

#define SUPPLIER_PREFIX_LEN 32
typedef struct MMAL_COMPONENT_SUPPLIER_T
{
   struct MMAL_COMPONENT_SUPPLIER_T *next;
   MMAL_COMPONENT_SUPPLIER_FUNCTION_T create;
   char prefix[SUPPLIER_PREFIX_LEN];
} MMAL_COMPONENT_SUPPLIER_T;

/** List of component suppliers.
  *
  * Does not need to be thread-safe if we assume that suppliers
  * can never be removed.
  */
static MMAL_COMPONENT_SUPPLIER_T *suppliers;

/** Create an instance of a component  */
static MMAL_STATUS_T mmal_component_supplier_create(const char *name, MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_SUPPLIER_T *supplier = suppliers;
   MMAL_STATUS_T status = MMAL_ENOSYS;
   const char *dot = strchr(name, '.');
   size_t dot_size = dot ? dot - name : (int)strlen(name);

   /* walk list of suppliers to see if any can create this component */
   while (supplier)
   {
      if (strlen(supplier->prefix) == dot_size && !memcmp(supplier->prefix, name, dot_size))
      {
         status = supplier->create(name, component);
         if (status == MMAL_SUCCESS)
            break;
      }
      supplier = supplier->next;
   }
   return status;
}

void mmal_component_supplier_register(const char *prefix,
   MMAL_COMPONENT_SUPPLIER_FUNCTION_T create_fn)
{
   MMAL_COMPONENT_SUPPLIER_T *supplier = vcos_calloc(1,sizeof(*supplier),NULL);

   LOG_TRACE("prefix %s fn %p", (prefix ? prefix : "NULL"), create_fn);

   if (vcos_verify(supplier))
   {
      supplier->create = create_fn;
      strncpy(supplier->prefix, prefix, SUPPLIER_PREFIX_LEN);
      supplier->prefix[SUPPLIER_PREFIX_LEN-1] = '\0';

      supplier->next = suppliers;
      suppliers = supplier;
   }
   else
   {
      LOG_ERROR("no memory for supplier registry entry");
   }
}

MMAL_DESTRUCTOR(mmal_component_supplier_destructor);
void mmal_component_supplier_destructor(void)
{
   MMAL_COMPONENT_SUPPLIER_T *supplier = suppliers;

   /* walk list of suppliers and free associated memory */
   while (supplier)
   {
      MMAL_COMPONENT_SUPPLIER_T *current = supplier;
      supplier = supplier->next;
      vcos_free(current);
   }
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_core_private.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_CORE_PRIVATE_H
#define MMAL_CORE_PRIVATE_H

/** Initialise the logging system.
  */
void mmal_logging_init(void);

/** Deinitialise the logging system.
  */
void mmal_logging_deinit(void);

#endif /* MMAL_CORE_PRIVATE_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_events.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "mmal_port_private.h"
#include "mmal_buffer.h"
#include "mmal_logging.h"

MMAL_EVENT_FORMAT_CHANGED_T *mmal_event_format_changed_get(MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_EVENT_FORMAT_CHANGED_T *event;
   MMAL_ES_FORMAT_T *format;
   uint32_t size;

   size = sizeof(MMAL_EVENT_FORMAT_CHANGED_T);
   size += sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T);

   if (buffer->cmd != MMAL_EVENT_FORMAT_CHANGED || !buffer || buffer->length < size)
      return 0;

   event = (MMAL_EVENT_FORMAT_CHANGED_T *)buffer->data;
   format = event->format = (MMAL_ES_FORMAT_T *)&event[1];
   format->es = (MMAL_ES_SPECIFIC_FORMAT_T *)&format[1];
   format->extradata = (uint8_t *)&format->es[1];
   format->extradata_size = buffer->length - size;
   return event;
}

MMAL_STATUS_T mmal_event_error_send(MMAL_COMPONENT_T *component, MMAL_STATUS_T error_status)
{
   MMAL_BUFFER_HEADER_T* event;
   MMAL_STATUS_T status;

   if(!component)
   {
      LOG_ERROR("invalid component");
      return MMAL_EINVAL;
   }

   status = mmal_port_event_get(component->control, &event, MMAL_EVENT_ERROR);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("event not available for component %s %p, result %d", component->name, component, status);
      return status;
   }

   event->length = sizeof(MMAL_STATUS_T);
   *(MMAL_STATUS_T *)event->data = error_status;
   mmal_port_event_send(component->control, event);

   return MMAL_SUCCESS;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_format.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal_types.h"
#include "mmal_format.h"

#define MMAL_ES_FORMAT_MAGIC MMAL_FOURCC('m','a','g','f')
#define EXTRADATA_SIZE_DEFAULT 32
#define EXTRADATA_SIZE_MAX (10*1024)

typedef struct MMAL_ES_FORMAT_PRIVATE_T
{
   MMAL_ES_FORMAT_T format;
   MMAL_ES_SPECIFIC_FORMAT_T es;

   uint32_t magic;

   unsigned int extradata_size;
   uint8_t *extradata;

   uint8_t buffer[EXTRADATA_SIZE_DEFAULT];

} MMAL_ES_FORMAT_PRIVATE_T;

/** Allocate a format structure */
MMAL_ES_FORMAT_T *mmal_format_alloc(void)
{
   MMAL_ES_FORMAT_PRIVATE_T *private;

   private = vcos_malloc(sizeof(*private), "mmal format");
   if(!private) return 0;
   memset(private, 0, sizeof(*private));

   private->magic = MMAL_ES_FORMAT_MAGIC;
   private->format.es = (void *)&private->es;
   private->extradata_size = EXTRADATA_SIZE_DEFAULT;

   return &private->format;
}

/** Free a format structure */
void mmal_format_free(MMAL_ES_FORMAT_T *format)
{
   MMAL_ES_FORMAT_PRIVATE_T *private = (MMAL_ES_FORMAT_PRIVATE_T *)format;
   vcos_assert(private->magic == MMAL_ES_FORMAT_MAGIC);
   if(private->extradata) vcos_free(private->extradata);
   vcos_free(private);
}

/** Copy a format structure */
void mmal_format_copy(MMAL_ES_FORMAT_T *fmt_dst, MMAL_ES_FORMAT_T *fmt_src)
{
   void *backup = fmt_dst->es;
   *fmt_dst->es = *fmt_src->es;
   *fmt_dst = *fmt_src;
   fmt_dst->es = backup;
   fmt_dst->extradata = 0;
   fmt_dst->extradata_size = 0;
}

/** Full copy of a format structure (including extradata) */
MMAL_STATUS_T mmal_format_full_copy(MMAL_ES_FORMAT_T *fmt_dst, MMAL_ES_FORMAT_T *fmt_src)
{
   mmal_format_copy(fmt_dst, fmt_src);

   if (fmt_src->extradata_size)
   {
      MMAL_STATUS_T status = mmal_format_extradata_alloc(fmt_dst, fmt_src->extradata_size);
      if (status != MMAL_SUCCESS)
         return status;
      fmt_dst->extradata_size = fmt_src->extradata_size;
      memcpy(fmt_dst->extradata, fmt_src->extradata, fmt_src->extradata_size);
   }
   return MMAL_SUCCESS;
}

/** Compare 2 format structures */
uint32_t mmal_format_compare(MMAL_ES_FORMAT_T *fmt1, MMAL_ES_FORMAT_T *fmt2)
{
   MMAL_VIDEO_FORMAT_T *video1, *video2;
   uint32_t result = 0;

   if (fmt1->type != fmt2->type)
      return MMAL_ES_FORMAT_COMPARE_FLAG_TYPE;

   if (fmt1->encoding != fmt2->encoding)
      result |= MMAL_ES_FORMAT_COMPARE_FLAG_ENCODING;
   if (fmt1->bitrate != fmt2->bitrate)
      result |= MMAL_ES_FORMAT_COMPARE_FLAG_BITRATE;
   if (fmt1->flags != fmt2->flags)
      result |= MMAL_ES_FORMAT_COMPARE_FLAG_FLAGS;
   if (fmt1->extradata_size != fmt2->extradata_size ||
       (fmt1->extradata_size && (!fmt1->extradata || !fmt2->extradata)) ||
       memcmp(fmt1->extradata, fmt2->extradata, fmt1->extradata_size))
      result |= MMAL_ES_FORMAT_COMPARE_FLAG_EXTRADATA;

   /* Compare the ES specific information */
   switch (fmt1->type)
   {
   case MMAL_ES_TYPE_VIDEO:
      video1 = &fmt1->es->video;
      video2 = &fmt2->es->video;
      if (video1->width != video2->width || video1->height != video2->height)
         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION;
      if (memcmp(&video1->crop, &video2->crop, sizeof(video1->crop)))
         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING;
      if (memcmp(&video1->par, &video2->par, sizeof(video1->par)))
         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO;
      if (memcmp(&video1->frame_rate, &video2->frame_rate, sizeof(video1->frame_rate)))
         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE;
      if (video1->color_space != video2->color_space)
         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE;
      /* coverity[overrun-buffer-arg] We're comparing the rest of the video format structure */
      if (memcmp(((char*)&video1->color_space) + sizeof(video1->color_space),
                 ((char*)&video2->color_space) + sizeof(video2->color_space),
                 sizeof(*video1) - offsetof(MMAL_VIDEO_FORMAT_T, color_space) - sizeof(video1->color_space)))
         result |= MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER;
      break;
   case MMAL_ES_TYPE_AUDIO:
      if (memcmp(fmt1->es, fmt2->es, sizeof(MMAL_AUDIO_FORMAT_T)))
         result |= MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER;
      break;
   case MMAL_ES_TYPE_SUBPICTURE:
      if (memcmp(fmt1->es, fmt2->es, sizeof(MMAL_SUBPICTURE_FORMAT_T)))
         result |= MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER;
      break;
   default:
      break;
   }

   return result;
}

/** */
MMAL_STATUS_T mmal_format_extradata_alloc(MMAL_ES_FORMAT_T *format, unsigned int size)
{
   MMAL_ES_FORMAT_PRIVATE_T *private = (MMAL_ES_FORMAT_PRIVATE_T *)format;

   /* Sanity check the size requested */
   if(size > EXTRADATA_SIZE_MAX)
      return MMAL_EINVAL;

   /* Allocate memory if needed */
   if(private->extradata_size < size)
   {
      if(private->extradata) vcos_free(private->extradata);
      private->extradata = vcos_malloc(size, "mmal format extradata");
      if(!private->extradata)
         return MMAL_ENOMEM;
      private->extradata_size = size;
   }

   /* Set the fields in the actual format structure */
   if(private->extradata) private->format.extradata = private->extradata;
   else private->format.extradata = private->buffer;

   return MMAL_SUCCESS;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_logging.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include "mmal_logging.h"
#include "core/mmal_core_private.h"

VCOS_LOG_CAT_T mmal_log_category;
static VCOS_LOG_LEVEL_T mmal_log_level = VCOS_LOG_ERROR;

void mmal_logging_init(void)
{
   vcos_log_set_level(VCOS_LOG_CATEGORY, mmal_log_level);
   vcos_log_register("mmal", VCOS_LOG_CATEGORY);
}

void mmal_logging_deinit(void)
{
   mmal_log_level = mmal_log_category.level;
   vcos_log_unregister(VCOS_LOG_CATEGORY);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_pool.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "mmal_pool.h"
#include "core/mmal_buffer_private.h"
#include "mmal_logging.h"

/** Definition of a pool */
typedef struct MMAL_POOL_PRIVATE_T
{
   MMAL_POOL_T pool; /**< Actual pool */

   MMAL_POOL_BH_CB_T cb; /**< Buffer header release callback */
   void *userdata;       /**< User provided data to pass with callback */

   mmal_pool_allocator_alloc_t allocator_alloc; /**< Allocator for the payload buffers */
   mmal_pool_allocator_free_t allocator_free;   /**< Allocator for the payload buffers */
   void *allocator_context;                     /**< Context for the allocator */

   unsigned int header_size; /**< Size of an initialised buffer header structure */
   unsigned int payload_size;

   unsigned int headers_alloc_num; /**< Number of buffer headers allocated as part of the private structure */

} MMAL_POOL_PRIVATE_T;

#define ROUND_UP(s,align) ((((unsigned long)(s)) & ~((align)-1)) + (align))
#define ALIGN  8

static void mmal_pool_buffer_header_release(MMAL_BUFFER_HEADER_T *header);

static void *mmal_pool_allocator_default_alloc(void *context, uint32_t size)
{
   MMAL_PARAM_UNUSED(context);
   return vcos_malloc(size, "mmal_pool payload");
}

static void mmal_pool_allocator_default_free(void *context, void *mem)
{
   MMAL_PARAM_UNUSED(context);
   vcos_free(mem);
}

static MMAL_STATUS_T mmal_pool_initialise_buffer_headers(MMAL_POOL_T *pool, unsigned int headers,
                                                         MMAL_BOOL_T reinitialise)
{
   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
   MMAL_BUFFER_HEADER_T *header;
   uint8_t *payload = NULL;
   unsigned int i;

   header = (MMAL_BUFFER_HEADER_T *)((uint8_t *)pool->header + ROUND_UP(sizeof(void *)*headers,ALIGN));

   for (i = 0; i < headers; i++)
   {
      if (reinitialise)
         header = mmal_buffer_header_initialise(header, private->header_size);

      if (private->payload_size && private->allocator_alloc)
      {
         LOG_TRACE("allocating %u bytes for payload %u/%u", private->payload_size, i, headers);
         payload = (uint8_t*)private->allocator_alloc(private->allocator_context, private->payload_size);
         if (! payload)
         {
            LOG_ERROR("failed to allocate payload %u/%u", i, headers);
            return MMAL_ENOMEM;
         }
      }
      else
      {
         if (header->priv->pf_payload_free && header->priv->payload && header->priv->payload_size)
         {
            LOG_TRACE("freeing %u bytes for payload %u/%u", header->priv->payload_size, i, headers);
            header->priv->pf_payload_free(header->priv->payload_context, header->priv->payload);
         }
      }
      header->data = payload;
      header->alloc_size = private->payload_size;
      header->priv->pf_release = mmal_pool_buffer_header_release;
      header->priv->owner = (void *)pool;
      header->priv->refcount = 1;
      header->priv->payload = payload;
      header->priv->payload_context = private->allocator_context;
      header->priv->pf_payload_free = private->allocator_free;
      header->priv->payload_size = private->payload_size;
      pool->header[i] = header;
      pool->headers_num = i+1;
      header = (MMAL_BUFFER_HEADER_T *)((uint8_t*)header + private->header_size);
   }

   return MMAL_SUCCESS;
}

/** Create a pool of MMAL_BUFFER_HEADER_T */
MMAL_POOL_T *mmal_pool_create(unsigned int headers, uint32_t payload_size)
{
   return mmal_pool_create_with_allocator(headers, payload_size, NULL,
             mmal_pool_allocator_default_alloc, mmal_pool_allocator_default_free);
}

/** Create a pool of MMAL_BUFFER_HEADER_T */
MMAL_POOL_T *mmal_pool_create_with_allocator(unsigned int headers, uint32_t payload_size,
                              void *allocator_context, mmal_pool_allocator_alloc_t allocator_alloc,
                              mmal_pool_allocator_free_t allocator_free)
{
   unsigned int i, headers_array_size, header_size, pool_size;
   MMAL_POOL_PRIVATE_T *private;
   MMAL_BUFFER_HEADER_T **array;
   MMAL_POOL_T *pool;
   MMAL_QUEUE_T *queue;

   queue = mmal_queue_create();
   if (!queue)
   {
      LOG_ERROR("failed to create queue");
      return NULL;
   }

   /* Calculate how much memory we need */
   pool_size = ROUND_UP(sizeof(MMAL_POOL_PRIVATE_T),ALIGN);
   headers_array_size = ROUND_UP(sizeof(void *)*headers,ALIGN);
   header_size = ROUND_UP(mmal_buffer_header_size(0),ALIGN);

   LOG_TRACE("allocating %u + %u + %u * %u bytes for pool",
             pool_size, headers_array_size, header_size, headers);
   private = vcos_calloc(pool_size, 1, "MMAL pool");
   array = vcos_calloc(headers_array_size + header_size * headers, 1, "MMAL buffer headers");
   if (!private || !array)
   {
      LOG_ERROR("failed to allocate pool");
      if (private) vcos_free(private);
      if (array) vcos_free(array);
      mmal_queue_destroy(queue);
      return NULL;
   }
   pool = &private->pool;
   pool->queue = queue;
   pool->header = (MMAL_BUFFER_HEADER_T **)array;
   private->header_size = header_size;
   private->payload_size = payload_size;
   private->headers_alloc_num = headers;

   /* Use default allocators if none has been specified by client */
   if (!allocator_alloc || !allocator_free)
   {
      allocator_alloc = mmal_pool_allocator_default_alloc;
      allocator_free = mmal_pool_allocator_default_free;
      allocator_context = NULL;
   }

   /* Keep reference to the allocator to allow resizing the payloads at a later point */
   private->allocator_alloc = allocator_alloc;
   private->allocator_free = allocator_free;
   private->allocator_context = allocator_context;

   if (mmal_pool_initialise_buffer_headers(pool, headers, 1) != MMAL_SUCCESS)
   {
      mmal_pool_destroy(pool);
      return NULL;
   }

   /* Add all the headers to the queue */
   for (i = 0; i < pool->headers_num; i++)
      mmal_queue_put(queue, pool->header[i]);

   return pool;
}

/** Destroy a pool of MMAL_BUFFER_HEADER_T */
void mmal_pool_destroy(MMAL_POOL_T *pool)
{
   unsigned int i;

   if (!pool)
      return;

   /* If the payload_size is non-zero then the buffer header payload
    * must be freed. Otherwise it is the caller's responsibility. */
   for (i = 0; i < pool->headers_num; ++i)
   {
      MMAL_BUFFER_HEADER_PRIVATE_T* priv = pool->header[i]->priv;

      if (priv->pf_payload_free && priv->payload && priv->payload_size)
         priv->pf_payload_free(priv->payload_context, priv->payload);
   }

   if (pool->header)
      vcos_free(pool->header);

   if(pool->queue) mmal_queue_destroy(pool->queue);
   vcos_free(pool);
}

/** Resize a pool of MMAL_BUFFER_HEADER_T */
MMAL_STATUS_T mmal_pool_resize(MMAL_POOL_T *pool, unsigned int headers, uint32_t payload_size)
{
   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
   unsigned int i;

   if (!private || !headers)
      return MMAL_EINVAL;

   /* Check if anything needs to be done */
   if (headers == pool->headers_num && payload_size == private->payload_size)
      return MMAL_SUCCESS;

   /* Remove all the headers from the queue */
   for (i = 0; i < pool->headers_num; i++)
      mmal_queue_get(pool->queue);

   /* Start by freeing the current payloads */
   private->payload_size = 0;
   mmal_pool_initialise_buffer_headers(pool, pool->headers_num, 0);
   pool->headers_num = 0;

   /* Check if we need to reallocate the buffer headers themselves */
   if (headers > private->headers_alloc_num)
   {
      private->headers_alloc_num = 0;
      if (pool->header)
         vcos_free(pool->header);
      pool->header =
         vcos_calloc(private->header_size * headers + ROUND_UP(sizeof(void *)*headers,ALIGN),
                     1, "MMAL buffer headers");
      if (!pool->header)
         return MMAL_ENOMEM;
      private->headers_alloc_num = headers;
   }

   /* Allocate the new payloads */
   private->payload_size = payload_size;
   mmal_pool_initialise_buffer_headers(pool, headers, 1);

   /* Add all the headers to the queue */
   for (i = 0; i < pool->headers_num; i++)
      mmal_queue_put(pool->queue, pool->header[i]);

   return MMAL_SUCCESS;
}

/** Buffer header release callback.
 * Call out to a further client callback and put the buffer back in the queue
 * so it can be reused, unless the client callback prevents it. */
static void mmal_pool_buffer_header_release(MMAL_BUFFER_HEADER_T *header)
{
   MMAL_POOL_T *pool = (MMAL_POOL_T *)header->priv->owner;
   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
   MMAL_BOOL_T queue_buffer = 1;

   header->priv->refcount = 1;
   if(private->cb)
      queue_buffer = private->cb(pool, header, private->userdata);
   if (queue_buffer)
      mmal_queue_put(pool->queue, header);
}

/** Set a buffer header release callback to the pool */
void mmal_pool_callback_set(MMAL_POOL_T *pool, MMAL_POOL_BH_CB_T cb, void *userdata)
{
   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
   private->cb = cb;
   private->userdata = userdata;
}

/* Set a pre-release callback for all buffer headers in the pool */
void mmal_pool_pre_release_callback_set(MMAL_POOL_T *pool, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata)
{
   unsigned int i;
   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
   MMAL_BUFFER_HEADER_T *header =
         (MMAL_BUFFER_HEADER_T*)((uint8_t*)pool->header + ROUND_UP(sizeof(void*)*pool->headers_num,ALIGN));

   for (i = 0; i < pool->headers_num; ++i)
   {
      mmal_buffer_header_pre_release_cb_set(header, cb, userdata);
      header = (MMAL_BUFFER_HEADER_T *)((uint8_t*)header + private->header_size);
   }
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_clock.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal_clock.h"
#include "mmal_logging.h"
#include "core/mmal_clock_private.h"
#include "core/mmal_port_private.h"
#include "util/mmal_util.h"

#ifdef __VIDEOCORE__
# include "vcfw/rtos/common/rtos_common_mem.h"
#endif

/** Minimum number of buffers required on a clock port */
#define MMAL_PORT_CLOCK_BUFFERS_MIN  8

/** Private clock port context */
typedef struct MMAL_PORT_MODULE_T
{
   MMAL_PORT_CLOCK_EVENT_CB event_cb; /**< callback for notifying the component of clock events */
   MMAL_QUEUE_T *queue;               /**< queue for empty buffers sent to the port */
   MMAL_CLOCK_T *clock;               /**< clock module for scheduling requests */
   MMAL_BOOL_T is_reference;          /**< TRUE -> clock port is a reference, therefore
                                           will forward time updates */
} MMAL_PORT_MODULE_T;

/*****************************************************************************
 * Private functions
 *****************************************************************************/
#ifdef __VIDEOCORE__
/* FIXME: mmal_buffer_header_mem_lock() assumes that payload memory is on the
 * relocatable heap when on VC. However that is not always the case. The MMAL
 * framework will allocate memory from the normal heap when ports are connected.
 * To work around this, override the default behaviour by providing a payload
 * allocator for clock ports which always allocates from the relocatable heap. */
static uint8_t* mmal_port_clock_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size)
{
   int alignment = port->buffer_alignment_min;
   uint8_t *mem;

   if (!alignment)
      alignment = 32;
   vcos_assert((alignment & (alignment-1)) == 0);

   mem = (uint8_t*)mem_alloc(payload_size, alignment, MEM_FLAG_DIRECT, port->name);
   if (!mem)
   {
      LOG_ERROR("could not allocate %u bytes", payload_size);
      return NULL;
   }
   return mem;
}

static void mmal_port_clock_payload_free(MMAL_PORT_T *port, uint8_t *payload)
{
   MMAL_PARAM_UNUSED(port);
   mem_release((MEM_HANDLE_T)payload);
}
#endif


/* Callback invoked by the clock module in response to a client request */
static void mmal_port_clock_request_cb(MMAL_CLOCK_T* clock, int64_t media_time, void *cb_data, MMAL_CLOCK_VOID_FP cb)
{
   MMAL_PORT_CLOCK_REQUEST_CB cb_client = (MMAL_PORT_CLOCK_REQUEST_CB)cb;

   /* Forward to the client */
   cb_client((MMAL_PORT_T*)clock->user_data, media_time, cb_data);
}

/* Process buffers received from other clock ports */
static MMAL_STATUS_T mmal_port_clock_process_buffer(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_STATUS_T status = MMAL_SUCCESS;
   MMAL_CLOCK_PAYLOAD_T payload;

   if (buffer->length != sizeof(MMAL_CLOCK_PAYLOAD_T))
   {
      LOG_ERROR("invalid buffer length %d", buffer->length);
      return MMAL_EINVAL;
   }

   mmal_buffer_header_mem_lock(buffer);
   memcpy(&payload, buffer->data, sizeof(MMAL_CLOCK_PAYLOAD_T));
   mmal_buffer_header_mem_unlock(buffer);

   if (payload.magic != MMAL_CLOCK_PAYLOAD_MAGIC)
   {
      LOG_ERROR("buffer corrupt (magic %4.4s)", (char*)&payload.magic);
      return MMAL_EINVAL;
   }

   LOG_TRACE("port %s length %d id %4.4s time %"PRIi64,
         port->name, buffer->length, (char*)&payload.id, payload.time);

   switch (payload.id)
   {
   case MMAL_CLOCK_PAYLOAD_TIME:
      mmal_clock_media_time_set(port->priv->module->clock, payload.time);
      break;
   case MMAL_CLOCK_PAYLOAD_SCALE:
      mmal_clock_scale_set(port->priv->module->clock, payload.data.scale);
      break;
   default:
      LOG_ERROR("invalid id %4.4s", (char*)&payload.id);
      status = MMAL_EINVAL;
      break;
   }

   /* Finished with the buffer, so return it */
   buffer->length = 0;
   mmal_port_buffer_header_callback(port, buffer);

   return status;
}

static MMAL_STATUS_T mmal_port_clock_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;

   if (buffer->length)
      return mmal_port_clock_process_buffer(port, buffer);

   /* Queue empty buffers to be used later when forwarding clock updates */
   mmal_queue_put(module->queue, buffer);

   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_port_clock_flush(MMAL_PORT_T *port)
{
   MMAL_BUFFER_HEADER_T *buffer;

   /* Flush empty buffers */
   buffer = mmal_queue_get(port->priv->module->queue);
   while (buffer)
   {
      mmal_port_buffer_header_callback(port, buffer);
      buffer = mmal_queue_get(port->priv->module->queue);
   }

   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_port_clock_parameter_set(MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_STATUS_T status = MMAL_SUCCESS;
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_CLOCK_PAYLOAD_T event;

   switch (param->id)
   {
      case MMAL_PARAMETER_CLOCK_REFERENCE:
      {
         const MMAL_PARAMETER_BOOLEAN_T *p = (const MMAL_PARAMETER_BOOLEAN_T*)param;
         module->is_reference = p->enable;
         event.id = MMAL_CLOCK_PAYLOAD_REFERENCE;
         event.time = mmal_clock_media_time_get(module->clock);
         event.data.enable = p->enable;
      }
      break;
      case MMAL_PARAMETER_CLOCK_ACTIVE:
      {
         const MMAL_PARAMETER_BOOLEAN_T *p = (const MMAL_PARAMETER_BOOLEAN_T*)param;
         status = mmal_clock_active_set(module->clock, p->enable);
         event.id = MMAL_CLOCK_PAYLOAD_ACTIVE;
         event.time = mmal_clock_media_time_get(module->clock);
         event.data.enable = p->enable;
      }
      break;
      case MMAL_PARAMETER_CLOCK_SCALE:
      {
         const MMAL_PARAMETER_RATIONAL_T *p = (const MMAL_PARAMETER_RATIONAL_T*)param;
         status = mmal_port_clock_scale_set(port, p->value);
         event.id = MMAL_CLOCK_PAYLOAD_SCALE;
         event.time = mmal_clock_media_time_get(module->clock);
         event.data.scale = p->value;
      }
      break;
      case MMAL_PARAMETER_CLOCK_TIME:
      {
         const MMAL_PARAMETER_INT64_T *p = (const MMAL_PARAMETER_INT64_T*)param;
         status = mmal_port_clock_media_time_set(port, p->value);
         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
      }
      break;
      case MMAL_PARAMETER_CLOCK_TIME_OFFSET:
      {
         const MMAL_PARAMETER_INT64_T *p = (const MMAL_PARAMETER_INT64_T*)param;
         status = mmal_port_clock_media_time_offset_set(port, p->value);
         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
      }
      break;
      case MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD:
      {
         const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *)param;
         status = mmal_clock_update_threshold_set(module->clock, p);
         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
      }
      break;
      case MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD:
      {
         const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *)param;
         status = mmal_clock_discont_threshold_set(module->clock, p);
         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
      }
      break;
      case MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD:
      {
         const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *)param;
         status = mmal_clock_request_threshold_set(module->clock, p);
         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
      }
      break;
      default:
         return MMAL_ENOSYS;
   }

   /* Notify the component */
   if (module->event_cb && status == MMAL_SUCCESS && event.id != MMAL_CLOCK_PAYLOAD_INVALID)
      module->event_cb(port, &event);

   return status;
}

static MMAL_STATUS_T mmal_port_clock_parameter_get(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;

   switch (param->id)
   {
      case MMAL_PARAMETER_CLOCK_REFERENCE:
      {
         MMAL_PARAMETER_BOOLEAN_T *p = (MMAL_PARAMETER_BOOLEAN_T*)param;
         p->enable = module->is_reference;
      }
      break;
      case MMAL_PARAMETER_CLOCK_ACTIVE:
      {
         MMAL_PARAMETER_BOOLEAN_T *p = (MMAL_PARAMETER_BOOLEAN_T*)param;
         p->enable = mmal_clock_is_active(module->clock);
      }
      break;
      case MMAL_PARAMETER_CLOCK_SCALE:
      {
         MMAL_PARAMETER_RATIONAL_T *p = (MMAL_PARAMETER_RATIONAL_T*)param;
         p->value = mmal_clock_scale_get(module->clock);
      }
      break;
      case MMAL_PARAMETER_CLOCK_TIME:
      {
         MMAL_PARAMETER_INT64_T *p = (MMAL_PARAMETER_INT64_T*)param;
         p->value = mmal_clock_media_time_get(module->clock);
      }
      break;
      case MMAL_PARAMETER_CLOCK_TIME_OFFSET:
      {
         MMAL_PARAMETER_INT64_T *p = (MMAL_PARAMETER_INT64_T*)param;
         p->value = mmal_clock_media_time_offset_get(module->clock);
      }
      break;
      case MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD:
      {
         MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *)param;
         mmal_clock_update_threshold_get(module->clock, p);
      }
      break;
      case MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD:
      {
         MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *)param;
         mmal_clock_discont_threshold_get(module->clock, p);
      }
      break;
      case MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD:
      {
         MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *)param;
         mmal_clock_request_threshold_get(module->clock, p);
      }
      break;
      default:
         return MMAL_ENOSYS;
   }
   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_port_clock_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
{
   MMAL_PARAM_UNUSED(port);
   MMAL_PARAM_UNUSED(cb);
   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_port_clock_disable(MMAL_PORT_T *port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;

   if (mmal_clock_is_active(module->clock))
      mmal_clock_active_set(module->clock, MMAL_FALSE);

   mmal_port_clock_flush(port);

   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_port_clock_set_format(MMAL_PORT_T *port)
{
   MMAL_PARAM_UNUSED(port);
   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_port_clock_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port)
{
   MMAL_PARAM_UNUSED(port);
   MMAL_PARAM_UNUSED(other_port);
   return MMAL_ENOSYS;
}

/* Send a payload buffer to a connected port/client */
static MMAL_STATUS_T mmal_port_clock_forward_payload(MMAL_PORT_T *port, const MMAL_CLOCK_PAYLOAD_T *payload)
{
   MMAL_STATUS_T status;
   MMAL_BUFFER_HEADER_T *buffer;

   buffer = mmal_queue_get(port->priv->module->queue);
   if (!buffer)
   {
      LOG_ERROR("no free buffers available");
      return MMAL_ENOSPC;
   }

   status = mmal_buffer_header_mem_lock(buffer);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to lock buffer %s", mmal_status_to_string(status));
      mmal_queue_put_back(port->priv->module->queue, buffer);
      goto end;
   }
   buffer->length = sizeof(MMAL_CLOCK_PAYLOAD_T);
   memcpy(buffer->data, payload, buffer->length);
   mmal_buffer_header_mem_unlock(buffer);

   mmal_port_buffer_header_callback(port, buffer);

end:
   return status;
}

/* Send a clock time update to a connected port/client */
static MMAL_STATUS_T mmal_port_clock_forward_media_time(MMAL_PORT_T *port, int64_t media_time)
{
   MMAL_CLOCK_PAYLOAD_T payload;

   payload.id = MMAL_CLOCK_PAYLOAD_TIME;
   payload.magic = MMAL_CLOCK_PAYLOAD_MAGIC;
   payload.time = media_time;

   return mmal_port_clock_forward_payload(port, &payload);
}

/* Send a clock scale update to a connected port/client */
static MMAL_STATUS_T mmal_port_clock_forward_scale(MMAL_PORT_T *port, MMAL_RATIONAL_T scale)
{
   MMAL_CLOCK_PAYLOAD_T payload;

   payload.id = MMAL_CLOCK_PAYLOAD_SCALE;
   payload.magic = MMAL_CLOCK_PAYLOAD_MAGIC;
   payload.time = mmal_clock_media_time_get(port->priv->module->clock);
   payload.data.scale = scale;

   return mmal_port_clock_forward_payload(port, &payload);
}

/* Initialise all callbacks and setup internal resources */
static MMAL_STATUS_T mmal_port_clock_setup(MMAL_PORT_T *port, MMAL_PORT_CLOCK_EVENT_CB event_cb)
{
   MMAL_STATUS_T status;

   status = mmal_clock_create(&port->priv->module->clock);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to create clock module on port %s (%s)", port->name, mmal_status_to_string(status));
      return status;
   }
   port->priv->module->clock->user_data = port;

   port->buffer_size = sizeof(MMAL_CLOCK_PAYLOAD_T);
   port->buffer_size_min = sizeof(MMAL_CLOCK_PAYLOAD_T);
   port->buffer_num_min = MMAL_PORT_CLOCK_BUFFERS_MIN;
   port->buffer_num_recommended = MMAL_PORT_CLOCK_BUFFERS_MIN;

   port->priv->module->event_cb = event_cb;
   port->priv->module->queue = mmal_queue_create();
   if (!port->priv->module->queue)
   {
      mmal_clock_destroy(port->priv->module->clock);
      return MMAL_ENOMEM;
   }

   port->priv->pf_set_format = mmal_port_clock_set_format;
   port->priv->pf_enable = mmal_port_clock_enable;
   port->priv->pf_disable = mmal_port_clock_disable;
   port->priv->pf_send = mmal_port_clock_send;
   port->priv->pf_flush = mmal_port_clock_flush;
   port->priv->pf_parameter_set = mmal_port_clock_parameter_set;
   port->priv->pf_parameter_get = mmal_port_clock_parameter_get;
   port->priv->pf_connect = mmal_port_clock_connect;
#ifdef __VIDEOCORE__
   port->priv->pf_payload_alloc = mmal_port_clock_payload_alloc;
   port->priv->pf_payload_free = mmal_port_clock_payload_free;
   port->capabilities = MMAL_PORT_CAPABILITY_ALLOCATION;
#endif

   return status;
}

/* Release all internal resources */
static void mmal_port_clock_teardown(MMAL_PORT_T *port)
{
   if (!port)
      return;
   mmal_queue_destroy(port->priv->module->queue);
   mmal_clock_destroy(port->priv->module->clock);
}

/*****************************************************************************
 * Public functions
 *****************************************************************************/
/* Allocate a clock port */
MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, MMAL_PORT_CLOCK_EVENT_CB event_cb)
{
   MMAL_PORT_T *port;

   port = mmal_port_alloc(component, MMAL_PORT_TYPE_CLOCK, sizeof(MMAL_PORT_MODULE_T));
   if (!port)
      return NULL;

   if (mmal_port_clock_setup(port, event_cb) != MMAL_SUCCESS)
   {
      mmal_port_free(port);
      return NULL;
   }

   return port;
}

/* Free a clock port */
void mmal_port_clock_free(MMAL_PORT_T *port)
{
   mmal_port_clock_teardown(port);
   mmal_port_free(port);
}

/* Allocate an array of clock ports */
MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num, MMAL_PORT_CLOCK_EVENT_CB event_cb)
{
   unsigned int i;
   MMAL_PORT_T **ports;

   ports = mmal_ports_alloc(component, ports_num, MMAL_PORT_TYPE_CLOCK, sizeof(MMAL_PORT_MODULE_T));
   if (!ports)
      return NULL;

   for (i = 0; i < ports_num; i++)
   {
      if (mmal_port_clock_setup(ports[i], event_cb) != MMAL_SUCCESS)
         break;
   }

   if (i != ports_num)
   {
      for (ports_num = i, i = 0; i < ports_num; i++)
         mmal_port_clock_free(ports[i]);
      vcos_free(ports);
      return NULL;
   }

   return ports;
}

/* Free an array of clock ports */
void mmal_ports_clock_free(MMAL_PORT_T **ports, unsigned int ports_num)
{
   unsigned int i;

   for (i = 0; i < ports_num; i++)
      mmal_port_clock_free(ports[i]);
   vcos_free(ports);
}

/* Register a callback request */
MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time, int64_t offset,
      MMAL_PORT_CLOCK_REQUEST_CB cb, void *cb_data)
{
   return mmal_clock_request_add(port->priv->module->clock, media_time, offset,
                                 mmal_port_clock_request_cb, cb_data, (MMAL_CLOCK_VOID_FP)cb);
}

/* Flush all pending clock requests */
MMAL_STATUS_T mmal_port_clock_request_flush(MMAL_PORT_T *port)
{
   return mmal_clock_request_flush(port->priv->module->clock);
}

/* Set the media-time on the clock port */
MMAL_STATUS_T mmal_port_clock_media_time_set(MMAL_PORT_T *port, int64_t media_time)
{
   MMAL_STATUS_T status;

   status = mmal_clock_media_time_set(port->priv->module->clock, media_time);
   if (status != MMAL_SUCCESS)
   {
      LOG_DEBUG("clock update ignored");
      return status;
   }

   /* Only forward time updates if this port is set as a reference clock port */
   if (port->priv->module->is_reference)
      mmal_port_clock_forward_media_time(port, mmal_clock_media_time_get(port->priv->module->clock));

   return status;
}

/* Set the media-time offset on the clock port */
MMAL_STATUS_T mmal_port_clock_media_time_offset_set(MMAL_PORT_T *port, int64_t offset)
{
   MMAL_STATUS_T status;

   status = mmal_clock_media_time_offset_set(port->priv->module->clock, offset);

   /* The media-time has effectively changed, so need to inform connected clock ports */
   if (port->priv->module->is_reference)
      mmal_port_clock_forward_media_time(port, mmal_clock_media_time_get(port->priv->module->clock));

   return status;
}

/* Return the current media-time */
int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port)
{
   return mmal_clock_media_time_get(port->priv->module->clock);
}

/* Return the media-time offset */
int64_t mmal_port_clock_media_time_offset_get(MMAL_PORT_T *port)
{
   return mmal_clock_media_time_offset_get(port->priv->module->clock);
}

/* Set the clock scale factor */
MMAL_STATUS_T mmal_port_clock_scale_set(MMAL_PORT_T *port, MMAL_RATIONAL_T scale)
{
   MMAL_STATUS_T status;

   status = mmal_clock_scale_set(port->priv->module->clock, scale);

   if (port->priv->module->is_reference)
      mmal_port_clock_forward_scale(port, scale);

   return status;
}

/* Return the clock scale factor */
MMAL_RATIONAL_T mmal_port_clock_scale_get(MMAL_PORT_T *port)
{
   return mmal_clock_scale_get(port->priv->module->clock);
}

/* Return TRUE if clock is running (media-time is advancing) */
MMAL_BOOL_T mmal_port_clock_is_active(MMAL_PORT_T *port)
{
   return mmal_clock_is_active(port->priv->module->clock);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_private.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PORT_PRIVATE_H
#define MMAL_PORT_PRIVATE_H

#include "interface/mmal/mmal.h"
#include "interface/mmal/mmal_clock.h"

/** Definition of a port. */
typedef struct MMAL_PORT_PRIVATE_T
{
   /** Pointer to the private data of the core */
   struct MMAL_PORT_PRIVATE_CORE_T *core;
   /** Pointer to the private data of the module in use */
   struct MMAL_PORT_MODULE_T *module;

   MMAL_STATUS_T (*pf_set_format)(MMAL_PORT_T *port);
   MMAL_STATUS_T (*pf_enable)(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T);
   MMAL_STATUS_T (*pf_disable)(MMAL_PORT_T *port);
   MMAL_STATUS_T (*pf_send)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *);
   MMAL_STATUS_T (*pf_flush)(MMAL_PORT_T *port);
   MMAL_STATUS_T (*pf_parameter_set)(MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param);
   MMAL_STATUS_T (*pf_parameter_get)(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param);
   MMAL_STATUS_T (*pf_connect)(MMAL_PORT_T *port, MMAL_PORT_T *other_port);

   uint8_t *(*pf_payload_alloc)(MMAL_PORT_T *port, uint32_t payload_size);
   void     (*pf_payload_free)(MMAL_PORT_T *port, uint8_t *payload);

} MMAL_PORT_PRIVATE_T;

/** Callback called by components when a \ref MMAL_BUFFER_HEADER_T needs to be sent back to the
 * user */
void mmal_port_buffer_header_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);

/** Callback called by components when an event \ref MMAL_BUFFER_HEADER_T needs to be sent to the
 * user. Events differ from ordinary buffer headers because they originate from the component
 * and do not return data from the client to the component. */
void mmal_port_event_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);

/** Allocate a port structure */
MMAL_PORT_T *mmal_port_alloc(MMAL_COMPONENT_T *, MMAL_PORT_TYPE_T type, unsigned int extra_size);
/** Free a port structure */
void mmal_port_free(MMAL_PORT_T *port);
/** Allocate an array of ports */
MMAL_PORT_T **mmal_ports_alloc(MMAL_COMPONENT_T *, unsigned int ports_num, MMAL_PORT_TYPE_T type,
                               unsigned int extra_size);
/** Free an array of ports */
void mmal_ports_free(MMAL_PORT_T **ports, unsigned int ports_num);

/** Acquire a reference on a port */
void mmal_port_acquire(MMAL_PORT_T *port);

/** Release a reference on a port */
MMAL_STATUS_T mmal_port_release(MMAL_PORT_T *port);

/** Pause processing on a port */
MMAL_STATUS_T mmal_port_pause(MMAL_PORT_T *port, MMAL_BOOL_T pause);

/*****************************************************************************
 * Clock Port API
 *****************************************************************************/
/** Definition of a clock port event callback.
 * Used to inform the client of a clock event that has occurred.
 *
 * @param port       The clock port where the event occurred
 * @param event      The event that has occurred
 */
typedef void (*MMAL_PORT_CLOCK_EVENT_CB)(MMAL_PORT_T *port, const MMAL_CLOCK_PAYLOAD_T *event);

/** Allocate a clock port.
 *
 * @param component  The component requesting the alloc
 * @param event_cb   Clock event callback
 *
 * @return Pointer to new clock port or NULL on failure.
 */
MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, MMAL_PORT_CLOCK_EVENT_CB event_cb);

/** Free a clock port.
 *
 * @param port       The clock port to free
 */
void mmal_port_clock_free(MMAL_PORT_T *port);

/** Allocate an array of clock ports.
 *
 * @param component  The component requesting the alloc
 * @param ports_num  Number of ports to allocate
 * @param event_cb   Clock event callback
 *
 * @return Pointer to a new array of clock ports or NULL on failure.
 */
MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num, MMAL_PORT_CLOCK_EVENT_CB event_cb);

/** Free an array of clock ports.
 *
 * @param ports      The clock ports to free
 * @param ports_num  Number of ports to free
 */
void mmal_ports_clock_free(MMAL_PORT_T **ports, unsigned int ports_num);

/** Definition of a clock port request callback.
 * This is invoked when the media-time requested by the client is reached.
 *
 * @param port       The clock port which serviced the request
 * @param media_time The current media-time
 * @param cb_data    Client-supplied data
 */
typedef void (*MMAL_PORT_CLOCK_REQUEST_CB)(MMAL_PORT_T *port, int64_t media_time, void *cb_data);

/** Register a request with the clock port.
 * When the specified media-time is reached, the clock port will invoke the supplied callback.
 *
 * @param port       The clock port
 * @param media_time The media-time at which the callback should be invoked (microseconds)
 * @param offset     Time offset (in microseconds) applied to the media-time. This can be used
 *                   to schedule the request slightly in advance of the media-time.
 * @param cb         Callback to invoke
 * @param cb_data    Client-supplied callback data
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time, int64_t offset,
                                          MMAL_PORT_CLOCK_REQUEST_CB cb, void *cb_data);

/** Remove all previously registered clock port requests.
 *
 * @param port       The clock port
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_clock_request_flush(MMAL_PORT_T *port);

/** Update the clock port's media-time.
 *
 * @param port       The clock port to update
 * @param media_time New media-time to be applied (microseconds)
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_clock_media_time_set(MMAL_PORT_T *port, int64_t media_time);

/** Set an offset for the port's media-time.
 *
 * @param port       The clock port to update
 * @param offset     Media-time offset (microseconds)
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_clock_media_time_offset_set(MMAL_PORT_T *port, int64_t offset);

/** Get the clock port's current media-time.
 * This takes the clock port's scale and media-time offset into account.
 *
 * @param port       The clock port to query
 *
 * @return Current media-time in microseconds
 */
int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port);

/** Get the clock port's media-time offset.
 *
 * @param port       The clock port to query
 *
 * @return Media-time offset in microseconds
 */
int64_t mmal_port_clock_media_time_offset_get(MMAL_PORT_T *port);

/** Set the clock port's scale.
 *
 * @param port       The clock port
 * @param scale      Scale factor in Q16 format
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_clock_scale_set(MMAL_PORT_T *port, MMAL_RATIONAL_T scale);

/** Get the clock port's scale.
 *
 * @param port       The clock port
 *
 * @return Current clock port scale factor
 */
MMAL_RATIONAL_T mmal_port_clock_scale_get(MMAL_PORT_T *port);

/** Get the clock port's state.
 *
 * @param port       The clock port to query
 *
 * @return TRUE if clock port is active (i.e. local media-time is advancing)
 */
MMAL_BOOL_T mmal_port_clock_is_active(MMAL_PORT_T *port);

#endif /* MMAL_PORT_PRIVATE_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "util/mmal_util.h"
#include "core/mmal_component_private.h"
#include "core/mmal_port_private.h"
#include "interface/vcos/vcos.h"
#include "mmal_logging.h"
#include "interface/mmal/util/mmal_util.h"
#include "interface/mmal/mmal_parameters.h"
#include <stdio.h>

#ifdef _VIDEOCORE
#include "vcfw/rtos/common/rtos_common_mem.h" /* mem_alloc */
#endif

/** Only collect port stats if enabled in build. Performance could be
 * affected on an ARM since gettimeofday() involves a system call.
 */
#if defined(MMAL_COLLECT_PORT_STATS)
# define MMAL_COLLECT_PORT_STATS_ENABLED 1
#else
# define MMAL_COLLECT_PORT_STATS_ENABLED 0
#endif

static MMAL_STATUS_T mmal_port_private_parameter_get(MMAL_PORT_T *port,
                                                     MMAL_PARAMETER_HEADER_T *param);

static MMAL_STATUS_T mmal_port_private_parameter_set(MMAL_PORT_T *port,
                                                     const MMAL_PARAMETER_HEADER_T *param);

/* Define this if you want to log all buffer transfers */
//#define ENABLE_MMAL_EXTRA_LOGGING

/** Definition of the core's private structure for a port. */
typedef struct MMAL_PORT_PRIVATE_CORE_T
{
   VCOS_MUTEX_T lock; /**< Used to lock access to the port */
   VCOS_MUTEX_T send_lock; /**< Used to lock access while sending buffer to the port */
   VCOS_MUTEX_T stats_lock; /**< Used to lock access to the stats */
   VCOS_MUTEX_T connection_lock; /**< Used to lock access to a connection */

   /** Callback set by client to call when buffer headers need to be returned */
   MMAL_PORT_BH_CB_T buffer_header_callback;

   /** Keeps track of the number of buffer headers currently in transit in this port */
   int32_t transit_buffer_headers;
   VCOS_MUTEX_T transit_lock;
   VCOS_SEMAPHORE_T transit_sema;

   /** Copy of the public port format pointer, to detect accidental overwrites */
   MMAL_ES_FORMAT_T* format_ptr_copy;

   /** Port to which this port is connected, or NULL if disconnected */
   MMAL_PORT_T* connected_port;

   MMAL_BOOL_T core_owns_connection; /**< Connection is handled by the core */

   /** Pool of buffers used between connected ports - output port only */
   MMAL_POOL_T* pool_for_connection;

   /** Indicates whether the port is paused or not. Buffers received on
    * a paused port will be queued instead of being sent to the component. */
   MMAL_BOOL_T is_paused;
   /** Queue for buffers received from the client when in paused state */
   MMAL_BUFFER_HEADER_T* queue_first;
   /** Queue for buffers received from the client when in paused state */
   MMAL_BUFFER_HEADER_T** queue_last;

   /** Per-port statistics collected directly by the MMAL core */
   MMAL_CORE_PORT_STATISTICS_T stats;

   char *name; /**< Port name */
   unsigned int name_size; /** Size of the memory area reserved for the name string */
} MMAL_PORT_PRIVATE_CORE_T;

/*****************************************************************************
 * Static declarations
 *****************************************************************************/
static MMAL_STATUS_T mmal_port_enable_internal(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb);
static MMAL_STATUS_T mmal_port_disable_internal(MMAL_PORT_T *port);

static MMAL_STATUS_T mmal_port_connection_enable(MMAL_PORT_T *port, MMAL_PORT_T *connected_port);
static MMAL_STATUS_T mmal_port_connection_disable(MMAL_PORT_T *port, MMAL_PORT_T *connected_port);
static MMAL_STATUS_T mmal_port_connection_start(MMAL_PORT_T *port, MMAL_PORT_T *connected_port);
static MMAL_STATUS_T mmal_port_populate_from_pool(MMAL_PORT_T* port, MMAL_POOL_T* pool);
static MMAL_STATUS_T mmal_port_populate_clock_ports(MMAL_PORT_T* output, MMAL_PORT_T* input, MMAL_POOL_T* pool);
static MMAL_STATUS_T mmal_port_connect_default(MMAL_PORT_T *port, MMAL_PORT_T *other_port);
static void mmal_port_connected_input_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
static void mmal_port_connected_output_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
static MMAL_BOOL_T mmal_port_connected_pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata);

static void mmal_port_name_update(MMAL_PORT_T *port);
static void mmal_port_update_port_stats(MMAL_PORT_T *port, MMAL_CORE_STATS_DIR direction);

/*****************************************************************************/

/* Macros used to make the port API thread safe */
#define LOCK_PORT(a) vcos_mutex_lock(&(a)->priv->core->lock);
#define UNLOCK_PORT(a) vcos_mutex_unlock(&(a)->priv->core->lock);

/* Macros used to make the buffer sending / flushing thread safe */
#define LOCK_SENDING(a) vcos_mutex_lock(&(a)->priv->core->send_lock);
#define UNLOCK_SENDING(a) vcos_mutex_unlock(&(a)->priv->core->send_lock);

/* Macros used to make the port connection API thread safe */
#define LOCK_CONNECTION(a) vcos_mutex_lock(&(a)->priv->core->connection_lock);
#define UNLOCK_CONNECTION(a) vcos_mutex_unlock(&(a)->priv->core->connection_lock);

/* Macros used to make mmal_port_disable() blocking until all
 * the buffers have been sent back to the client */
#define IN_TRANSIT_INCREMENT(a) \
   vcos_mutex_lock(&(a)->priv->core->transit_lock); \
   if (!(a)->priv->core->transit_buffer_headers++) \
      vcos_semaphore_wait(&(a)->priv->core->transit_sema); \
   vcos_mutex_unlock(&(a)->priv->core->transit_lock)
#define IN_TRANSIT_DECREMENT(a) \
   vcos_mutex_lock(&(a)->priv->core->transit_lock); \
   if (!--(a)->priv->core->transit_buffer_headers) \
      vcos_semaphore_post(&(a)->priv->core->transit_sema); \
   vcos_mutex_unlock(&(a)->priv->core->transit_lock)
#define IN_TRANSIT_WAIT(a) \
   vcos_semaphore_wait(&(a)->priv->core->transit_sema); \
   vcos_semaphore_post(&(a)->priv->core->transit_sema)
#define IN_TRANSIT_COUNT(a) \
   (a)->priv->core->transit_buffer_headers

#define PORT_NAME_FORMAT "%s:%.2222s:%i%c%4.4s)"

/*****************************************************************************/

/** Allocate a port structure */
MMAL_PORT_T *mmal_port_alloc(MMAL_COMPONENT_T *component, MMAL_PORT_TYPE_T type, unsigned int extra_size)
{
   MMAL_PORT_T *port;
   MMAL_PORT_PRIVATE_CORE_T *core;
   unsigned int name_size = strlen(component->name) + sizeof(PORT_NAME_FORMAT);
   unsigned int size = sizeof(*port) + sizeof(MMAL_PORT_PRIVATE_T) +
      sizeof(MMAL_PORT_PRIVATE_CORE_T) + name_size + extra_size;
   MMAL_BOOL_T lock = 0, lock_send = 0, lock_transit = 0, sema_transit = 0;
   MMAL_BOOL_T lock_stats = 0, lock_connection = 0;

   LOG_TRACE("component:%s type:%u extra:%u", component->name, type, extra_size);

   port = vcos_calloc(1, size, "mmal port");
   if (!port)
   {
      LOG_ERROR("failed to allocate port, size %u", size);
      return 0;
   }
   port->type = type;

   port->priv = (MMAL_PORT_PRIVATE_T *)(port+1);
   port->priv->core = core = (MMAL_PORT_PRIVATE_CORE_T *)(port->priv+1);
   if (extra_size)
      port->priv->module = (struct MMAL_PORT_MODULE_T *)(port->priv->core+1);
   port->component = component;
   port->name = core->name = ((char *)(port->priv->core+1)) + extra_size;
   core->name_size = name_size;
   mmal_port_name_update(port);
   core->queue_last = &core->queue_first;

   port->priv->pf_connect = mmal_port_connect_default;

   lock = vcos_mutex_create(&port->priv->core->lock, "mmal port lock") == VCOS_SUCCESS;
   lock_send = vcos_mutex_create(&port->priv->core->send_lock, "mmal port send lock") == VCOS_SUCCESS;
   lock_transit = vcos_mutex_create(&port->priv->core->transit_lock, "mmal port transit lock") == VCOS_SUCCESS;
   sema_transit = vcos_semaphore_create(&port->priv->core->transit_sema, "mmal port transit sema", 1) == VCOS_SUCCESS;
   lock_stats = vcos_mutex_create(&port->priv->core->stats_lock, "mmal stats lock") == VCOS_SUCCESS;
   lock_connection = vcos_mutex_create(&port->priv->core->connection_lock, "mmal connection lock") == VCOS_SUCCESS;

   if (!lock || !lock_send || !lock_transit || !sema_transit || !lock_stats || !lock_connection)
   {
      LOG_ERROR("%s: failed to create sync objects (%u,%u,%u,%u,%u,%u)",
            port->name, lock, lock_send, lock_transit, sema_transit, lock_stats, lock_connection);
      goto error;
   }

   port->format = mmal_format_alloc();
   if (!port->format)
   {
      LOG_ERROR("%s: failed to allocate format object", port->name);
      goto error;
   }
   port->priv->core->format_ptr_copy = port->format;

   LOG_TRACE("%s: created at %p", port->name, port);
   return port;

 error:
   if (lock) vcos_mutex_delete(&port->priv->core->lock);
   if (lock_send) vcos_mutex_delete(&port->priv->core->send_lock);
   if (lock_transit) vcos_mutex_delete(&port->priv->core->transit_lock);
   if (sema_transit) vcos_semaphore_delete(&port->priv->core->transit_sema);
   if (lock_stats) vcos_mutex_delete(&port->priv->core->stats_lock);
   if (lock_connection) vcos_mutex_delete(&port->priv->core->connection_lock);
   if (port->format) mmal_format_free(port->format);
   vcos_free(port);
   return 0;
}

/** Free a port structure */
void mmal_port_free(MMAL_PORT_T *port)
{
   LOG_TRACE("%s at %p", port ? port->name : "<invalid>", port);

   if (!port)
      return;

   vcos_assert(port->format == port->priv->core->format_ptr_copy);
   mmal_format_free(port->priv->core->format_ptr_copy);
   vcos_mutex_delete(&port->priv->core->connection_lock);
   vcos_mutex_delete(&port->priv->core->stats_lock);
   vcos_semaphore_delete(&port->priv->core->transit_sema);
   vcos_mutex_delete(&port->priv->core->transit_lock);
   vcos_mutex_delete(&port->priv->core->send_lock);
   vcos_mutex_delete(&port->priv->core->lock);
   vcos_free(port);
}

/** Allocate an array of ports */
MMAL_PORT_T **mmal_ports_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num,
   MMAL_PORT_TYPE_T type, unsigned int extra_size)
{
   MMAL_PORT_T **ports;
   unsigned int i;

   ports = vcos_malloc(sizeof(MMAL_PORT_T *) * ports_num, "mmal ports");
   if (!ports)
      return 0;

   for (i = 0; i < ports_num; i++)
   {
      ports[i] = mmal_port_alloc(component, type, extra_size);
      if (!ports[i])
         break;
      ports[i]->index = i;
      mmal_port_name_update(ports[i]);
   }

   if (i != ports_num)
   {
      for (ports_num = i, i = 0; i < ports_num; i++)
         mmal_port_free(ports[i]);
      vcos_free(ports);
      return 0;
   }

   return ports;
}

/** Free an array of ports */
void mmal_ports_free(MMAL_PORT_T **ports, unsigned int ports_num)
{
   unsigned int i;

   for (i = 0; i < ports_num; i++)
      mmal_port_free(ports[i]);
   vcos_free(ports);
}

/** Set format of a port */
MMAL_STATUS_T mmal_port_format_commit(MMAL_PORT_T *port)
{
   MMAL_STATUS_T status;
   char encoding_string[16];

   if (!port || !port->priv)
   {
      LOG_ERROR("invalid port (%p/%p)", port, port ? port->priv : NULL);
      return MMAL_EINVAL;
   }

   if (port->format != port->priv->core->format_ptr_copy)
   {
      LOG_ERROR("%s: port format has been overwritten, resetting %p to %p",
            port->name, port->format, port->priv->core->format_ptr_copy);
      port->format = port->priv->core->format_ptr_copy;
      return MMAL_EFAULT;
   }

   if (port->format->encoding == 0)
      snprintf(encoding_string, sizeof(encoding_string), "<NO-FORMAT>");
   else
      snprintf(encoding_string, sizeof(encoding_string), "%4.4s", (char*)&port->format->encoding);

   LOG_TRACE("%s(%i:%i) port %p format %i:%s",
             port->component->name, (int)port->type, (int)port->index, port,
             (int)port->format->type, encoding_string);

   if (!port->priv->pf_set_format)
   {
      LOG_ERROR("%s: no component implementation", port->name);
      return MMAL_ENOSYS;
   }

   LOCK_PORT(port);
   status = port->priv->pf_set_format(port);
   mmal_port_name_update(port);

   /* Make sure the buffer size / num are sensible */
   if (port->buffer_size < port->buffer_size_min)
      port->buffer_size = port->buffer_size_min;
   if (port->buffer_num < port->buffer_num_min)
      port->buffer_num = port->buffer_num_min;
   /* The output port settings might have changed */
   if (port->type == MMAL_PORT_TYPE_INPUT)
   {
      MMAL_PORT_T **ports = port->component->output;
      unsigned int i;

      for (i = 0; i < port->component->output_num; i++)
      {
         if (ports[i]->buffer_size < ports[i]->buffer_size_min)
            ports[i]->buffer_size = ports[i]->buffer_size_min;
         if (ports[i]->buffer_num < ports[i]->buffer_num_min)
            ports[i]->buffer_num = ports[i]->buffer_num_min;
      }
   }

   UNLOCK_PORT(port);
   return status;
}

/** Enable processing on a port */
MMAL_STATUS_T mmal_port_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
{
   MMAL_STATUS_T status;
   MMAL_PORT_T *connected_port;
   MMAL_PORT_PRIVATE_CORE_T *core;

   if (!port || !port->priv)
      return MMAL_EINVAL;

   LOG_TRACE("%s port %p, cb %p, buffers (%i/%i/%i,%i/%i/%i)",
             port->name, port, cb,
             (int)port->buffer_num, (int)port->buffer_num_recommended, (int)port->buffer_num_min,
             (int)port->buffer_size, (int)port->buffer_size_recommended, (int)port->buffer_size_min);

   if (!port->priv->pf_enable)
      return MMAL_ENOSYS;

   core = port->priv->core;
   LOCK_CONNECTION(port);
   connected_port = core->connected_port;

   /* Sanity checking */
   if (port->is_enabled)
   {
      UNLOCK_CONNECTION(port);
      LOG_ERROR("%s(%p) already enabled", port->name, port);
      return MMAL_EINVAL;
   }
   if (connected_port && cb) /* Callback must be NULL for connected ports */
   {
      UNLOCK_CONNECTION(port);
      LOG_ERROR("callback (%p) not allowed for connected port (%s)%p",
         cb, port->name, connected_port);
      return MMAL_EINVAL;
   }

   /* Start by preparing the port connection so that everything is ready for when
    * both ports are enabled */
   if (connected_port)
   {
      LOCK_CONNECTION(connected_port);
      status = mmal_port_connection_enable(port, connected_port);
      if (status != MMAL_SUCCESS)
      {
         UNLOCK_CONNECTION(connected_port);
         UNLOCK_CONNECTION(port);
         return status;
      }

      cb = connected_port->type == MMAL_PORT_TYPE_INPUT ?
         mmal_port_connected_output_cb : mmal_port_connected_input_cb;
   }

   /* Enable the input port of a connection first */
   if (connected_port && connected_port->type == MMAL_PORT_TYPE_INPUT)
   {
      status = mmal_port_enable_internal(connected_port, mmal_port_connected_input_cb);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to enable connected port (%s)%p (%s)", connected_port->name,
            connected_port, mmal_status_to_string(status));
         goto error;
      }
   }

   status = mmal_port_enable_internal(port, cb);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to enable port %s(%p) (%s)", port->name, port,
         mmal_status_to_string(status));
      goto error;
   }

   /* Enable the output port of a connection last */
   if (connected_port && connected_port->type != MMAL_PORT_TYPE_INPUT)
   {
      status = mmal_port_enable_internal(connected_port, mmal_port_connected_output_cb);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to enable connected port (%s)%p (%s)", connected_port->name,
            connected_port, mmal_status_to_string(status));
         goto error;
      }
   }

   /* Kick off the connection */
   if (connected_port && core->core_owns_connection)
   {
      status = mmal_port_connection_start(port, connected_port);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to start connection (%s)%p (%s)", port->name,
            port, mmal_status_to_string(status));
         goto error;
      }
   }

   if (connected_port)
      UNLOCK_CONNECTION(connected_port);
   UNLOCK_CONNECTION(port);
   return MMAL_SUCCESS;

error:
   if (connected_port && connected_port->is_enabled)
      mmal_port_disable_internal(connected_port);
   if (port->is_enabled)
      mmal_port_disable_internal(port);
   if (connected_port)
      mmal_port_connection_disable(port, connected_port);

   if (connected_port)
      UNLOCK_CONNECTION(connected_port);
   UNLOCK_CONNECTION(port);
   return status;
}

static MMAL_STATUS_T mmal_port_enable_internal(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
{
   MMAL_PORT_PRIVATE_CORE_T* core = port->priv->core;
   MMAL_STATUS_T status = MMAL_SUCCESS;

   LOCK_PORT(port);

   if (port->is_enabled)
      goto end;

   /* Sanity check the buffer requirements */
   if (port->buffer_num < port->buffer_num_min)
   {
      LOG_ERROR("buffer_num too small (%i/%i)", (int)port->buffer_num, (int)port->buffer_num_min);
      status = MMAL_EINVAL;
      goto end;
   }
   if (port->buffer_size < port->buffer_size_min)
   {
      LOG_ERROR("buffer_size too small (%i/%i)", (int)port->buffer_size, (int)port->buffer_size_min);
      status = MMAL_EINVAL;
      goto end;
   }

   core->buffer_header_callback = cb;
   status = port->priv->pf_enable(port, cb);
   if (status != MMAL_SUCCESS)
      goto end;

   LOCK_SENDING(port);
   port->is_enabled = 1;
   UNLOCK_SENDING(port);

end:
   UNLOCK_PORT(port);
   return status;
}

static MMAL_STATUS_T mmal_port_connection_enable(MMAL_PORT_T *port, MMAL_PORT_T *connected_port)
{
   MMAL_PORT_T *output = port->type == MMAL_PORT_TYPE_OUTPUT ? port : connected_port;
   MMAL_PORT_T *input = connected_port->type == MMAL_PORT_TYPE_INPUT ? connected_port : port;
   MMAL_PORT_T *pool_port = (output->capabilities & MMAL_PORT_CAPABILITY_ALLOCATION) ? output : input;
   MMAL_PORT_PRIVATE_CORE_T *pool_core = pool_port->priv->core;
   uint32_t buffer_size, buffer_num;
   MMAL_POOL_T *pool;

   /* At this point both ports hold the connection lock */

   /* Ensure that the buffer numbers and sizes used are the maxima between connected ports. */
   buffer_num  = MMAL_MAX(port->buffer_num,  connected_port->buffer_num);
   buffer_size = MMAL_MAX(port->buffer_size, connected_port->buffer_size);
   port->buffer_num  = connected_port->buffer_num  = buffer_num;
   port->buffer_size = connected_port->buffer_size = buffer_size;

   if (output->capabilities & MMAL_PORT_CAPABILITY_PASSTHROUGH)
      buffer_size = 0;

   if (!port->priv->core->core_owns_connection)
      return MMAL_SUCCESS;

   pool = mmal_port_pool_create(pool_port, buffer_num, buffer_size);
   if (!pool)
   {
      LOG_ERROR("failed to create pool for connection");
      return MMAL_ENOMEM;
   }

   pool_core->pool_for_connection = pool;
   mmal_pool_callback_set(pool, mmal_port_connected_pool_cb, output);
   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_port_connection_disable(MMAL_PORT_T *port, MMAL_PORT_T *connected_port)
{
   MMAL_POOL_T *pool = port->priv->core->pool_for_connection ?
      port->priv->core->pool_for_connection : connected_port->priv->core->pool_for_connection;

   mmal_pool_destroy(pool);
   port->priv->core->pool_for_connection =
      connected_port->priv->core->pool_for_connection = NULL;
   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_port_connection_start(MMAL_PORT_T *port, MMAL_PORT_T *connected_port)
{
   MMAL_PORT_T *output = port->type == MMAL_PORT_TYPE_OUTPUT ? port : connected_port;
   MMAL_PORT_T *input = connected_port->type == MMAL_PORT_TYPE_INPUT ? connected_port : port;
   MMAL_POOL_T *pool = port->priv->core->pool_for_connection ?
      port->priv->core->pool_for_connection : connected_port->priv->core->pool_for_connection;
   MMAL_STATUS_T status;

   if (output->type == MMAL_PORT_TYPE_CLOCK && input->type == MMAL_PORT_TYPE_CLOCK)
   {
      /* Clock ports need buffers to send clock updates, so
       * populate both clock ports */
      status = mmal_port_populate_clock_ports(output, input, pool);
   }
   else
   {
      /* Put the buffers into the output port */
      status = mmal_port_populate_from_pool(output, pool);
   }

   return status;
}

/** Disable processing on a port */
MMAL_STATUS_T mmal_port_disable(MMAL_PORT_T *port)
{
   MMAL_STATUS_T status;
   MMAL_PORT_T *connected_port;
   MMAL_PORT_PRIVATE_CORE_T *core;

   if (!port || !port->priv)
      return MMAL_EINVAL;

   LOG_TRACE("%s(%i:%i) port %p", port->component->name,
             (int)port->type, (int)port->index, port);

   if (!port->priv->pf_disable)
      return MMAL_ENOSYS;

   core = port->priv->core;
   LOCK_CONNECTION(port);
   connected_port = core->connected_port;

   /* Sanity checking */
   if (!port->is_enabled)
   {
      UNLOCK_CONNECTION(port);
      LOG_ERROR("port %s(%p) is not enabled", port->name, port);
      return MMAL_EINVAL;
   }

   if (connected_port)
      LOCK_CONNECTION(connected_port);

   /* Disable the output port of a connection first */
   if (connected_port && connected_port->type != MMAL_PORT_TYPE_INPUT)
   {
      status = mmal_port_disable_internal(connected_port);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to disable connected port (%s)%p (%s)", connected_port->name,
            connected_port, mmal_status_to_string(status));
         goto end;
      }
   }

   status = mmal_port_disable_internal(port);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to disable port (%s)%p", port->name, port);
      goto end;
   }

   /* Disable the input port of a connection last */
   if (connected_port && connected_port->type == MMAL_PORT_TYPE_INPUT)
   {
      status = mmal_port_disable_internal(connected_port);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to disable connected port (%s)%p (%s)", connected_port->name,
            connected_port, mmal_status_to_string(status));
         goto end;
      }
   }

   if (connected_port)
   {
      status = mmal_port_connection_disable(port, connected_port);
      if (status != MMAL_SUCCESS)
         LOG_ERROR("failed to disable connection (%s)%p (%s)", port->name,
            port, mmal_status_to_string(status));
   }

end:
   if (connected_port)
      UNLOCK_CONNECTION(connected_port);
   UNLOCK_CONNECTION(port);

   return status;
}

static MMAL_STATUS_T mmal_port_disable_internal(MMAL_PORT_T *port)
{
   MMAL_PORT_PRIVATE_CORE_T* core = port->priv->core;
   MMAL_STATUS_T status = MMAL_SUCCESS;
   MMAL_BUFFER_HEADER_T *buffer;

   LOCK_PORT(port);

   if (!port->is_enabled)
      goto end;

   LOCK_SENDING(port);
   port->is_enabled = 0;
   UNLOCK_SENDING(port);

   mmal_component_action_lock(port->component);

   if (core->pool_for_connection)
      mmal_pool_callback_set(core->pool_for_connection, NULL, NULL);

   status = port->priv->pf_disable(port);

   mmal_component_action_unlock(port->component);

   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("port %p could not be disabled (%s)", port->name, mmal_status_to_string(status));
      LOCK_SENDING(port);
      port->is_enabled = 1;
      UNLOCK_SENDING(port);
      goto end;
   }

   /* Flush our internal queue */
   buffer = port->priv->core->queue_first;
   while (buffer)
   {
      MMAL_BUFFER_HEADER_T *next = buffer->next;
      mmal_port_buffer_header_callback(port, buffer);
      buffer = next;
   }
   port->priv->core->queue_first = 0;
   port->priv->core->queue_last = &port->priv->core->queue_first;

   /* Wait for all the buffers to have come back from the component */
   LOG_DEBUG("%s waiting for %i buffers left in transit", port->name, (int)IN_TRANSIT_COUNT(port));
   IN_TRANSIT_WAIT(port);
   LOG_DEBUG("%s has no buffers left in transit", port->name);

   port->priv->core->buffer_header_callback = NULL;

 end:
   UNLOCK_PORT(port);
   return status;
}

/** Send a buffer header to a port */
MMAL_STATUS_T mmal_port_send_buffer(MMAL_PORT_T *port,
   MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_STATUS_T status = MMAL_SUCCESS;

   if (!port || !port->priv)
   {
      LOG_ERROR("invalid port");
      return MMAL_EINVAL;
   }

#ifdef ENABLE_MMAL_EXTRA_LOGGING
   LOG_TRACE("%s(%i:%i) port %p, buffer %p (%p,%i,%i)",
             port->component->name, (int)port->type, (int)port->index, port, buffer,
             buffer ? buffer->data: 0, buffer ? (int)buffer->offset : 0,
             buffer ? (int)buffer->length : 0);
#endif

   if (!buffer->data && !(port->capabilities & MMAL_PORT_CAPABILITY_PASSTHROUGH))
   {
      LOG_ERROR("%s(%p) received invalid buffer header", port->name, port);
      return MMAL_EINVAL;
   }

   if (!port->priv->pf_send)
      return MMAL_ENOSYS;

   LOCK_SENDING(port);

   if (!port->is_enabled)
   {
      UNLOCK_SENDING(port);
      return MMAL_EINVAL;
   }

   if (port->type == MMAL_PORT_TYPE_OUTPUT && buffer->length)
   {
      LOG_DEBUG("given an output buffer with length != 0");
      buffer->length = 0;
   }

   IN_TRANSIT_INCREMENT(port);

   if (port->priv->core->is_paused)
   {
      /* Add buffer to our internal queue */
      *port->priv->core->queue_last = buffer;
      port->priv->core->queue_last = &buffer->next;
   }
   else
   {
      /* Send buffer to component */
      status = port->priv->pf_send(port, buffer);
   }

   if (status != MMAL_SUCCESS)
   {
      IN_TRANSIT_DECREMENT(port);
      LOG_ERROR("%s: send failed: %s", port->name, mmal_status_to_string(status));
   }
   else
   {
      mmal_port_update_port_stats(port, MMAL_CORE_STATS_RX);
   }

   UNLOCK_SENDING(port);
   return status;
}

/** Flush a port */
MMAL_STATUS_T mmal_port_flush(MMAL_PORT_T *port)
{
   MMAL_BUFFER_HEADER_T *buffer = 0;
   MMAL_STATUS_T status;

   if (!port || !port->priv)
      return MMAL_EINVAL;

   LOG_TRACE("%s(%i:%i) port %p", port->component->name,
             (int)port->type, (int)port->index, port);

   if (!port->priv->pf_flush)
      return MMAL_ENOSYS;

   mmal_component_action_lock(port->component);
   LOCK_SENDING(port);
   status = port->priv->pf_flush(port);
   if (status == MMAL_SUCCESS)
   {
      /* Flush our internal queue */
      buffer = port->priv->core->queue_first;
      port->priv->core->queue_first = 0;
      port->priv->core->queue_last = &port->priv->core->queue_first;
   }
   UNLOCK_SENDING(port);
   mmal_component_action_unlock(port->component);

   while (buffer)
   {
      MMAL_BUFFER_HEADER_T *next = buffer->next;
      mmal_port_buffer_header_callback(port, buffer);
      buffer = next;
   }
   return status;
}

/* Set a parameter on a port. */
MMAL_STATUS_T mmal_port_parameter_set(MMAL_PORT_T *port,
   const MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_STATUS_T status = MMAL_ENOSYS;

   if (!port)
   {
      LOG_ERROR("no port");
      return MMAL_EINVAL;
   }
   if (!param)
   {
      LOG_ERROR("param not supplied");
      return MMAL_EINVAL;
   }
   if (!port->priv)
   {
      LOG_ERROR("port not configured");
      return MMAL_EINVAL;
   }

   LOG_TRACE("%s(%i:%i) port %p, param %p (%x,%i)", port->component->name,
             (int)port->type, (int)port->index, port,
             param, param ? param->id : 0, param ? (int)param->size : 0);

   LOCK_PORT(port);
   if (port->priv->pf_parameter_set)
      status = port->priv->pf_parameter_set(port, param);
   if (status == MMAL_ENOSYS)
   {
      /* is this a core parameter? */
      status = mmal_port_private_parameter_set(port, param);
   }
   UNLOCK_PORT(port);
   return status;
}

/* Get a port parameter */
MMAL_STATUS_T mmal_port_parameter_get(MMAL_PORT_T *port,
   MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_STATUS_T status = MMAL_ENOSYS;

   if (!port || !port->priv)
      return MMAL_EINVAL;

   LOG_TRACE("%s(%i:%i) port %p, param %p (%x,%i)", port->component->name,
             (int)port->type, (int)port->index, port,
             param, param ? param->id : 0, param ? (int)param->size : 0);

   if (!param)
      return MMAL_EINVAL;

   LOCK_PORT(port);
   if (port->priv->pf_parameter_get)
      status = port->priv->pf_parameter_get(port, param);
   if (status == MMAL_ENOSYS)
   {
      /* is this a core parameter? */
      status = mmal_port_private_parameter_get(port, param);
   }

   UNLOCK_PORT(port);
   return status;
}

/** Buffer header callback. */
void mmal_port_buffer_header_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
#ifdef ENABLE_MMAL_EXTRA_LOGGING
   LOG_TRACE("%s(%i:%i) port %p, buffer %p (%i,%p,%i,%i)",
             port->component->name, (int)port->type, (int)port->index, port, buffer,
             buffer ? (int)buffer->cmd : 0, buffer ? buffer->data : 0,
             buffer ? (int)buffer->offset : 0, buffer ? (int)buffer->length : 0);
#endif

   if (!vcos_verify(IN_TRANSIT_COUNT(port) >= 0))
      LOG_ERROR("%s: buffer headers in transit < 0 (%d)", port->name, (int)IN_TRANSIT_COUNT(port));

   if (MMAL_COLLECT_PORT_STATS_ENABLED)
   {
      mmal_port_update_port_stats(port, MMAL_CORE_STATS_TX);
   }

   port->priv->core->buffer_header_callback(port, buffer);

   IN_TRANSIT_DECREMENT(port);
}

/** Event callback */
void mmal_port_event_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   if (port->priv->core->buffer_header_callback)
   {
      port->priv->core->buffer_header_callback(port, buffer);
   }
   else
   {
      LOG_ERROR("event lost on port %i,%i (buffer header callback not defined)",
                (int)port->type, (int)port->index);
      mmal_buffer_header_release(buffer);
   }
}

/** Connect an output port to an input port. */
MMAL_STATUS_T mmal_port_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port)
{
   MMAL_PORT_PRIVATE_CORE_T* core;
   MMAL_PORT_PRIVATE_CORE_T* other_core;
   MMAL_STATUS_T status = MMAL_SUCCESS;
   MMAL_PORT_T* output_port = NULL;

   if (!port || !port->priv || !other_port || !other_port->priv)
   {
      LOG_ERROR("invalid port");
      return MMAL_EINVAL;
   }

   if ((port->type == MMAL_PORT_TYPE_CLOCK) && (port->type != other_port->type))
   {
      LOG_ERROR("invalid port connection");
      return MMAL_EINVAL;
   }

   LOG_TRACE("connecting %s(%p) to %s(%p)", port->name, port, other_port->name, other_port);

   if (!port->priv->pf_connect || !other_port->priv->pf_connect)
   {
      LOG_ERROR("at least one pf_connect is NULL");
      return MMAL_ENOSYS;
   }

   core = port->priv->core;
   other_core = other_port->priv->core;

   LOCK_CONNECTION(port);
   if (core->connected_port)
   {
      LOG_ERROR("port %p is already connected", port);
      UNLOCK_CONNECTION(port);
      return MMAL_EISCONN;
   }
   if (port->is_enabled)
   {
      LOG_ERROR("port %p should not be enabled", port);
      UNLOCK_CONNECTION(port);
      return MMAL_EINVAL;
   }

   LOCK_CONNECTION(other_port);
   if (other_core->connected_port)
   {
      LOG_ERROR("port %p is already connected", other_port);
      status = MMAL_EISCONN;
      goto finish;
   }
   if (other_port->is_enabled)
   {
      LOG_ERROR("port %p should not be enabled", other_port);
      status = MMAL_EINVAL;
      goto finish;
   }

   core->connected_port = other_port;
   other_core->connected_port = port;

   core->core_owns_connection = 0;
   other_core->core_owns_connection = 0;

   /* Check to see if the port will manage the connection on its own. If not then the core
    * will manage it. */
   output_port = port->type == MMAL_PORT_TYPE_OUTPUT ? port : other_port;
   if (output_port->priv->pf_connect(port, other_port) == MMAL_SUCCESS)
      goto finish;

   core->core_owns_connection = 1;
   other_core->core_owns_connection = 1;


finish:
   UNLOCK_CONNECTION(other_port);
   UNLOCK_CONNECTION(port);
   return status;
}

/** Disconnect a connected port. */
MMAL_STATUS_T mmal_port_disconnect(MMAL_PORT_T *port)
{
   MMAL_PORT_PRIVATE_CORE_T* core;
   MMAL_PORT_T* other_port;
   MMAL_STATUS_T status = MMAL_SUCCESS;

   if (!port || !port->priv)
   {
      LOG_ERROR("invalid port");
      return MMAL_EINVAL;
   }

   LOG_TRACE("%s(%p)", port->name, port);

   LOCK_CONNECTION(port);

   core = port->priv->core;
   other_port = core->connected_port;

   if (!other_port)
   {
      UNLOCK_CONNECTION(port);
      LOG_DEBUG("%s(%p) is not connected", port->name, port);
      return MMAL_ENOTCONN;
   }

   LOCK_CONNECTION(other_port);

   /* Make sure the connection is disabled first */
   if (port->is_enabled)
   {
      MMAL_PORT_T *output = port->type == MMAL_PORT_TYPE_OUTPUT ? port : other_port;
      MMAL_PORT_T *input = other_port->type == MMAL_PORT_TYPE_INPUT ? other_port : port;

      status = mmal_port_disable_internal(output);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to disable port (%s)%p", port->name, port);
         goto end;
      }
      status = mmal_port_disable_internal(input);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to disable port (%s)%p", port->name, port);
         goto end;
      }
      status = mmal_port_connection_disable(port, other_port);
   }

   if (!core->core_owns_connection)
   {
      status = port->priv->pf_connect(port, NULL);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("disconnection of %s(%p) failed (%i)", port->name, port, status);
         goto end;
      }
   }

   core->connected_port = NULL;
   other_port->priv->core->connected_port = NULL;

end:
   UNLOCK_CONNECTION(other_port);
   UNLOCK_CONNECTION(port);
   return status;
}

/** Allocate a payload buffer */
uint8_t *mmal_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size)
{
   uint8_t *mem;

   if (!port || !port->priv)
      return NULL;

   LOG_TRACE("%s(%i:%i) port %p, size %i", port->component->name,
             (int)port->type, (int)port->index, port, (int)payload_size);

   if (!payload_size)
      return NULL;

   /* TODO: keep track of the allocs so we can free them when the component is destroyed */

   if (!port->priv->pf_payload_alloc)
   {
      /* Revert to using the heap */
#ifdef _VIDEOCORE
      mem = (void *)mem_alloc(payload_size, 32, MEM_FLAG_DIRECT, port->name);
#else
      mem = vcos_malloc(payload_size, "mmal payload");
#endif
      goto end;
   }

   LOCK_PORT(port);
   mem = port->priv->pf_payload_alloc(port, payload_size);
   UNLOCK_PORT(port);

 end:
   /* Acquire the port if the allocation was successful.
    * This will ensure that the component is not destroyed until the payload has been freed. */
   if (mem)
      mmal_port_acquire(port);
   return mem;
}

/** Free a payload buffer */
void mmal_port_payload_free(MMAL_PORT_T *port, uint8_t *payload)
{
   if (!port || !port->priv)
      return;

   LOG_TRACE("%s(%i:%i) port %p, payload %p", port->component->name,
             (int)port->type, (int)port->index, port, payload);

   if (!port->priv->pf_payload_alloc)
   {
      /* Revert to using the heap */
#ifdef _VIDEOCORE
      mem_release((MEM_HANDLE_T)payload);
#else
      vcos_free(payload);
#endif
      mmal_port_release(port);
      return;
   }

   LOCK_PORT(port);
   port->priv->pf_payload_free(port, payload);
   UNLOCK_PORT(port);
   mmal_port_release(port);
}

MMAL_STATUS_T mmal_port_event_get(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t event)
{
   if (!port || !port->priv || !buffer)
      return MMAL_EINVAL;

   LOG_TRACE("%s(%i:%i) port %p, event %4.4s", port->component->name,
             (int)port->type, (int)port->index, port, (char *)&event);

   /* Get an event buffer from our event pool */
   *buffer = mmal_queue_get(port->component->priv->event_pool->queue);
   if (!*buffer)
   {
      LOG_ERROR("%s(%i:%i) port %p, no event buffer left for %4.4s", port->component->name,
                (int)port->type, (int)port->index, port, (char *)&event);
      return MMAL_ENOSPC;
   }

   (*buffer)->cmd = event;
   (*buffer)->length = 0;

   /* Special case for the FORMAT_CHANGED event. We need to properly initialise the event
    * buffer so that it contains an initialised MMAL_ES_FORMAT_T structure. */
   if (event == MMAL_EVENT_FORMAT_CHANGED)
   {
      uint32_t size = sizeof(MMAL_EVENT_FORMAT_CHANGED_T);
      size += sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T);

      if ((*buffer)->alloc_size < size)
      {
         LOG_ERROR("%s(%i:%i) port %p, event buffer for %4.4s is too small (%i/%i)",
                   port->component->name, (int)port->type, (int)port->index, port,
                   (char *)&event, (int)(*buffer)->alloc_size, (int)size);
         goto error;
      }

      memset((*buffer)->data, 0, size);
      (*buffer)->length = size;
   }

   return MMAL_SUCCESS;

error:
   if (*buffer)
      mmal_buffer_header_release(*buffer);
   *buffer = NULL;
   return MMAL_ENOSPC;
}

/** Populate clock ports from the given pool */
static MMAL_STATUS_T mmal_port_populate_clock_ports(MMAL_PORT_T* output, MMAL_PORT_T* input, MMAL_POOL_T* pool)
{
   MMAL_STATUS_T status = MMAL_SUCCESS;
   MMAL_BUFFER_HEADER_T *buffer;

   if (!output->priv->pf_send || !input->priv->pf_send)
      return MMAL_ENOSYS;

   LOG_TRACE("output %s %p, input %s %p, pool: %p", output->name, output, input->name, input, pool);

   buffer = mmal_queue_get(pool->queue);
   while (buffer)
   {
      status = mmal_port_send_buffer(output, buffer);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to send buffer to clock port %s", output->name);
         mmal_buffer_header_release(buffer);
         break;
      }

      buffer = mmal_queue_get(pool->queue);
      if (buffer)
      {
         status = mmal_port_send_buffer(input, buffer);
         if (status != MMAL_SUCCESS)
         {
            LOG_ERROR("failed to send buffer to clock port %s", output->name);
            mmal_buffer_header_release(buffer);
            break;
         }
         buffer = mmal_queue_get(pool->queue);
      }
   }

   return status;
}

/** Populate an output port with a pool of buffers */
static MMAL_STATUS_T mmal_port_populate_from_pool(MMAL_PORT_T* port, MMAL_POOL_T* pool)
{
   MMAL_STATUS_T status = MMAL_SUCCESS;
   uint32_t buffer_idx;
   MMAL_BUFFER_HEADER_T *buffer;

   if (!port->priv->pf_send)
      return MMAL_ENOSYS;

   LOG_TRACE("%s port %p, pool: %p", port->name, port, pool);

   /* Populate port from pool */
   for (buffer_idx = 0; buffer_idx < port->buffer_num; buffer_idx++)
   {
      buffer = mmal_queue_get(pool->queue);
      if (!buffer)
      {
         LOG_ERROR("too few buffers in the pool");
         status = MMAL_ENOMEM;
         break;
      }

      status = mmal_port_send_buffer(port, buffer);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("failed to send buffer to port");
         mmal_buffer_header_release(buffer);
         break;
      }
   }

   return status;
}

/** Default behaviour when setting up or tearing down a connection to another port */
static MMAL_STATUS_T mmal_port_connect_default(MMAL_PORT_T *port, MMAL_PORT_T *other_port)
{
   MMAL_PARAM_UNUSED(port);
   MMAL_PARAM_UNUSED(other_port);

   LOG_TRACE("port %p, other_port %p", port, other_port);
   return MMAL_ENOSYS;
}

/** Connected input port buffer callback */
static void mmal_port_connected_input_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_PARAM_UNUSED(port);

   LOG_TRACE("buffer %p from connected input port %p: data %p, alloc_size %u, length %u",
             buffer, port, buffer->data, buffer->alloc_size, buffer->length);

   /* Simply release buffer back into pool for re-use */
   mmal_buffer_header_release(buffer);
}

/** Connected output port buffer callback */
static void mmal_port_connected_output_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_PORT_T* connected_port = port->priv->core->connected_port;
   MMAL_STATUS_T status;

   LOG_TRACE("buffer %p from connected output port %p: data %p, alloc_size %u, length %u",
             buffer, port, buffer->data, buffer->alloc_size, buffer->length);

   if (buffer->cmd)
   {
      MMAL_EVENT_FORMAT_CHANGED_T *event = mmal_event_format_changed_get(buffer);

      /* Handle format changed events */
      if (event)
      {
         /* Apply the change */
         status = mmal_format_full_copy(port->format, event->format);
         if (status == MMAL_SUCCESS)
            status = mmal_port_format_commit(port);
         if (status != MMAL_SUCCESS)
            LOG_ERROR("format commit failed on port %s (%i)", port->name, status);

         /* Forward to the connected port */
         if (status == MMAL_SUCCESS)
            status = mmal_port_send_buffer(connected_port, buffer);

         if (status != MMAL_SUCCESS)
         {
            mmal_event_error_send(port->component, status);
            mmal_buffer_header_release(buffer);
         }
         return; /* Event handled */
      }

      /* FIXME Release other event buffers for now, until we can deal with shared memory issues */
      mmal_buffer_header_release(buffer);
   }
   else
   {
      if (port->is_enabled)
      {
         /* Forward data buffers to the connected input port */
         status = mmal_port_send_buffer(connected_port, buffer);
         if (status != MMAL_SUCCESS)
         {
            LOG_ERROR("%s could not send buffer on port %s (%s)",
                      port->name, connected_port->name, mmal_status_to_string(status));
            mmal_buffer_header_release(buffer);
         }
      }
      else
      {
         /* This port is disabled. Buffer will be a flushed buffer, so
          * return to the pool rather than delivering it.
          */
         mmal_buffer_header_release(buffer);
      }
   }
}

/** Callback for when a buffer from a connected input port is finally released */
static MMAL_BOOL_T mmal_port_connected_pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata)
{
   MMAL_PORT_T* port = (MMAL_PORT_T*)userdata;
   MMAL_STATUS_T status;
   MMAL_PARAM_UNUSED(pool);

   LOG_TRACE("released buffer %p, data %p alloc_size %u length %u",
             buffer, buffer->data, buffer->alloc_size, buffer->length);

   /* Reset buffer header */
   buffer->cmd = 0;
   buffer->length = 0;
   buffer->offset = 0;
   buffer->flags = 0;
   buffer->pts = 0;
   buffer->dts = 0;

   /* Pipe the buffer back to the output port */
   status = mmal_port_send_buffer(port, buffer);

   /* Put the buffer back in the pool if we were successful */
   return status != MMAL_SUCCESS;
}

/*****************************************************************************/
static void mmal_port_name_update(MMAL_PORT_T *port)
{
   MMAL_PORT_PRIVATE_CORE_T* core = port->priv->core;

   vcos_snprintf(core->name, core->name_size - 1, PORT_NAME_FORMAT,
            port->component->name, mmal_port_type_to_string(port->type), (int)port->index,
            port->format && port->format->encoding ? '(' : '\0',
            port->format && port->format->encoding ? (char *)&port->format->encoding : "");
}

static MMAL_STATUS_T mmal_port_get_core_stats(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_PARAMETER_CORE_STATISTICS_T *stats_param = (MMAL_PARAMETER_CORE_STATISTICS_T*)param;
   MMAL_CORE_STATISTICS_T *stats = &stats_param->stats;
   MMAL_CORE_STATISTICS_T *src_stats;
   MMAL_PORT_PRIVATE_CORE_T *core = port->priv->core;
   vcos_mutex_lock(&core->stats_lock);
   switch (stats_param->dir)
   {
   case MMAL_CORE_STATS_RX:
      src_stats = &port->priv->core->stats.rx;
      break;
   default:
      src_stats = &port->priv->core->stats.tx;
      break;
   }
   *stats = *src_stats;
   if (stats_param->reset)
      memset(src_stats, 0, sizeof(*src_stats));
   vcos_mutex_unlock(&core->stats_lock);
   return MMAL_SUCCESS;
}

/** Update the port stats, called per buffer.
 *
 */
static void mmal_port_update_port_stats(MMAL_PORT_T *port, MMAL_CORE_STATS_DIR direction)
{
   MMAL_PORT_PRIVATE_CORE_T *core = port->priv->core;
   MMAL_CORE_STATISTICS_T *stats;
   unsigned stc = vcos_getmicrosecs();

   vcos_mutex_lock(&core->stats_lock);

   stats = direction == MMAL_CORE_STATS_RX ? &core->stats.rx : &core->stats.tx;

   stats->buffer_count++;

   if (!stats->first_buffer_time)
   {
      stats->last_buffer_time = stats->first_buffer_time = stc;
   }
   else
   {
      stats->max_delay = vcos_max(stats->max_delay, stc-stats->last_buffer_time);
      stats->last_buffer_time = stc;
   }
   vcos_mutex_unlock(&core->stats_lock);
}

static MMAL_STATUS_T mmal_port_private_parameter_get(MMAL_PORT_T *port,
                                                     MMAL_PARAMETER_HEADER_T *param)
{
   switch (param->id)
   {
   case MMAL_PARAMETER_CORE_STATISTICS:
      return mmal_port_get_core_stats(port, param);
   default:
      return MMAL_ENOSYS;
   }
}

static MMAL_STATUS_T mmal_port_private_parameter_set(MMAL_PORT_T *port,
                                                     const MMAL_PARAMETER_HEADER_T *param)
{
   (void)port;
   switch (param->id)
   {
   default:
      return MMAL_ENOSYS;
   }
}

MMAL_STATUS_T mmal_port_pause(MMAL_PORT_T *port, MMAL_BOOL_T pause)
{
   MMAL_STATUS_T status = MMAL_SUCCESS;

   LOCK_SENDING(port);

   /* When resuming from pause, we send all our queued buffers to the port */
   if (!pause && port->is_enabled)
   {
      MMAL_BUFFER_HEADER_T *buffer = port->priv->core->queue_first;
      while (buffer)
      {
         MMAL_BUFFER_HEADER_T *next = buffer->next;
         status = port->priv->pf_send(port, buffer);
         if (status != MMAL_SUCCESS)
         {
            buffer->next = next;
            break;
         }
         buffer = next;
      }

      /* If for some reason we could not send one of the buffers, we just
       * leave all the buffers in our internal queue and return an error. */
      if (status != MMAL_SUCCESS)
      {
         port->priv->core->queue_first = buffer;
      }
      else
      {
         port->priv->core->queue_first = 0;
         port->priv->core->queue_last = &port->priv->core->queue_first;
      }
   }

   if (status == MMAL_SUCCESS)
      port->priv->core->is_paused = pause;

   UNLOCK_SENDING(port);
   return status;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_queue.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "mmal_queue.h"

/** Definition of the QUEUE */
struct MMAL_QUEUE_T
{
   VCOS_MUTEX_T lock;
   unsigned int length;
   MMAL_BUFFER_HEADER_T *first;
   MMAL_BUFFER_HEADER_T **last;
   VCOS_SEMAPHORE_T semaphore;
};

/** Create a QUEUE of MMAL_BUFFER_HEADER_T */
MMAL_QUEUE_T *mmal_queue_create(void)
{
   MMAL_QUEUE_T *queue;

   queue = vcos_malloc(sizeof(*queue), "MMAL queue");
   if(!queue) return 0;

   if(vcos_mutex_create(&queue->lock, "MMAL queue lock") != VCOS_SUCCESS )
   {
      vcos_free(queue);
      return 0;
   }

   if(vcos_semaphore_create(&queue->semaphore, "MMAL queue sema", 0) != VCOS_SUCCESS )
   {
      vcos_mutex_delete(&queue->lock);
      vcos_free(queue);
      return 0;
   }

   queue->length = 0;
   queue->first = 0;
   queue->last = &queue->first;
   return queue;
}

/** Put a MMAL_BUFFER_HEADER_T into a QUEUE */
void mmal_queue_put(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer)
{
   if(!queue || !buffer) return;

	vcos_mutex_lock(&queue->lock);
   queue->length++;
   *queue->last = buffer;
   buffer->next = 0;
   queue->last = &buffer->next;
   vcos_semaphore_post(&queue->semaphore);
   vcos_mutex_unlock(&queue->lock);
}

/** Put a MMAL_BUFFER_HEADER_T back at the start of a QUEUE. */
void mmal_queue_put_back(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer)
{
   if(!queue || !buffer) return;

	vcos_mutex_lock(&queue->lock);
   queue->length++;
   buffer->next = queue->first;
   queue->first = buffer;
   if(queue->last == &queue->first) queue->last = &buffer->next;
   vcos_semaphore_post(&queue->semaphore);
   vcos_mutex_unlock(&queue->lock);
}

/** Get a MMAL_BUFFER_HEADER_T from a QUEUE. */
MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue)
{
   MMAL_BUFFER_HEADER_T *buffer;

	if(!queue) return 0;

   vcos_mutex_lock(&queue->lock);
   buffer = queue->first;
   if(!buffer)
   {
      vcos_mutex_unlock(&queue->lock);
      return 0;
   }

   /* coverity[lock] This semaphore isn't being used as a mutex */
   vcos_semaphore_wait(&queue->semaphore); /* Will always succeed */

   queue->first = buffer->next;
   if(!queue->first) queue->last = &queue->first;

   queue->length--;
   vcos_mutex_unlock(&queue->lock);

   return buffer;
}

/** Wait for a MMAL_BUFFER_HEADER_T from a QUEUE. */
MMAL_BUFFER_HEADER_T *mmal_queue_wait(MMAL_QUEUE_T *queue)
{
	if(!queue) return 0;

	vcos_semaphore_wait(&queue->semaphore);
   vcos_semaphore_post(&queue->semaphore);
   return mmal_queue_get(queue);
}

/** Get the number of MMAL_BUFFER_HEADER_T currently in a QUEUE */
unsigned int mmal_queue_length(MMAL_QUEUE_T *queue)
{
	if(!queue) return 0;

	return queue->length;
}

/** Destroy a queue of MMAL_BUFFER_HEADER_T */
void mmal_queue_destroy(MMAL_QUEUE_T *queue)
{
   if(!queue) return;
   vcos_mutex_delete(&queue->lock);
   vcos_semaphore_delete(&queue->semaphore);
   vcos_free(queue);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/CMakeLists.txt
================
add_library (mmal_util SHARED
   mmal_il.c
   mmal_util.c
   mmal_connection.c
   mmal_graph.c
   mmal_list.c
   mmal_param_convert.c
   mmal_util_params.c
   mmal_component_wrapper.c
   mmal_util_rational.c
)

target_link_libraries (mmal_util vcos)

install(TARGETS mmal_util DESTINATION lib)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_component_wrapper.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "util/mmal_util.h"
#include "util/mmal_component_wrapper.h"
#include "mmal_logging.h"
#include <stdio.h>

typedef struct
{
   MMAL_WRAPPER_T wrapper; /**< Must be the first member! */

   VCOS_SEMAPHORE_T sema;

} MMAL_WRAPPER_PRIVATE_T;

/** Callback from a control port. Error events will be received there. */
static void mmal_wrapper_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
   LOG_TRACE("%s(%p),%p,%4.4s", port->name, port, buffer, (char *)&buffer->cmd);

   if (buffer->cmd == MMAL_EVENT_ERROR)
   {
      private->wrapper.status = *(MMAL_STATUS_T *)buffer->data;
      mmal_buffer_header_release(buffer);

      vcos_semaphore_post(&private->sema);

      if (private->wrapper.callback)
         private->wrapper.callback(&private->wrapper);
      return;
   }

   mmal_buffer_header_release(buffer);
}

/** Callback from an input port. Buffer is released. */
static void mmal_wrapper_bh_in_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_PARAM_UNUSED(port);
   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);

   /* We're done with the buffer, just recycle it */
   mmal_buffer_header_release(buffer);
}

/** Callback from an output port. Buffer is queued for the next component. */
static void mmal_wrapper_bh_out_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);

   /* Queue the buffer produced by the output port */
   mmal_queue_put(private->wrapper.output_queue[port->index], buffer);
   vcos_semaphore_post(&private->sema);

   if (private->wrapper.callback)
      private->wrapper.callback(&private->wrapper);
}

/** Callback from the pool. Buffer is available. */
static MMAL_BOOL_T mmal_wrapper_bh_release_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer,
   void *userdata)
{
   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)userdata;

   mmal_queue_put(pool->queue, buffer);
   vcos_semaphore_post(&private->sema);

   if (private->wrapper.callback)
      private->wrapper.callback(&private->wrapper);

   return 0;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_wrapper_destroy(MMAL_WRAPPER_T *wrapper)
{
   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)wrapper;
   unsigned int i;

   LOG_TRACE("%p, %s", wrapper, wrapper->component->name);

   /* Cleanup resources */
   mmal_component_destroy(wrapper->component);

   for (i = 0; i < wrapper->input_num; i++)
   {
      if (wrapper->input_pool[i])
         mmal_pool_destroy(wrapper->input_pool[i]);
   }

   for (i = 0; i < wrapper->output_num; i++)
   {
      if (wrapper->output_pool[i])
         mmal_pool_destroy(wrapper->output_pool[i]);
      if (wrapper->output_queue[i])
         mmal_queue_destroy(wrapper->output_queue[i]);
   }

   vcos_semaphore_delete(&private->sema);
   vcos_free(private);
   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_wrapper_create(MMAL_WRAPPER_T **ctx, const char *name)
{
   MMAL_STATUS_T status;
   MMAL_COMPONENT_T *component;
   MMAL_WRAPPER_PRIVATE_T *private;
   MMAL_WRAPPER_T *wrapper;
   int64_t start_time;
   unsigned int i, extra_size;

   LOG_TRACE("wrapper %p, name %s", ctx, name);

   /* Sanity checking */
   if (!ctx || !name)
      return MMAL_EINVAL;

   start_time = vcos_getmicrosecs();

   status = mmal_component_create(name, &component);
   if (status != MMAL_SUCCESS)
      return status;

   extra_size = (component->input_num + component->output_num) * 2;
   private = vcos_calloc(1, sizeof(*private) + extra_size, "mmal wrapper");
   if (!private)
   {
      mmal_component_destroy(component);
      return MMAL_ENOMEM;
   }

   if (vcos_semaphore_create(&private->sema, "mmal wrapper", 0) != VCOS_SUCCESS)
   {
      mmal_component_destroy(component);
      vcos_free(private);
      return MMAL_ENOMEM;
   }

   wrapper = &private->wrapper;
   wrapper->component = component;
   wrapper->control = component->control;
   wrapper->input_num = component->input_num;
   wrapper->input = component->input;
   wrapper->output_num = component->output_num;
   wrapper->output = component->output;
   wrapper->input_pool = (MMAL_POOL_T **)&private[1];
   wrapper->output_pool = (MMAL_POOL_T **)&wrapper->input_pool[component->input_num];
   wrapper->output_queue = (MMAL_QUEUE_T **)&wrapper->output_pool[component->output_num];

   /* Create our pools and queues */
   for (i = 0; i < wrapper->input_num; i++)
   {
      wrapper->input_pool[i] = mmal_port_pool_create(wrapper->input[i], 0, 0);
      if (!wrapper->input_pool[i])
         goto error;
      mmal_pool_callback_set(wrapper->input_pool[i], mmal_wrapper_bh_release_cb, (void *)wrapper);

      wrapper->input[i]->userdata = (void *)wrapper;
   }
   for (i = 0; i < wrapper->output_num; i++)
   {
      wrapper->output_pool[i] = mmal_port_pool_create(wrapper->output[i], 0, 0);
      wrapper->output_queue[i] = mmal_queue_create();
      if (!wrapper->output_pool[i] || !wrapper->output_queue[i])
         goto error;
      mmal_pool_callback_set(wrapper->output_pool[i], mmal_wrapper_bh_release_cb, (void *)wrapper);

      wrapper->output[i]->userdata = (void *)wrapper;
   }

   /* Setup control port */
   wrapper->control->userdata = (void *)wrapper;
   status = mmal_port_enable(wrapper->control, mmal_wrapper_control_cb);
   if (status != MMAL_SUCCESS)
      goto error;

   wrapper->time_setup = vcos_getmicrosecs() - start_time;
   *ctx = wrapper;
   return MMAL_SUCCESS;

 error:
   mmal_wrapper_destroy(wrapper);
   return status == MMAL_SUCCESS ? MMAL_ENOMEM : status;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_wrapper_port_enable(MMAL_PORT_T *port, uint32_t flags)
{
   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
   MMAL_WRAPPER_T *wrapper = &private->wrapper;
   int64_t start_time = vcos_getmicrosecs();
   uint32_t buffer_size;
   MMAL_STATUS_T status;
   MMAL_POOL_T *pool;

   LOG_TRACE("%p, %s", wrapper, port->name);

   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
      return MMAL_EINVAL;

   if (port->is_enabled)
      return MMAL_SUCCESS;

   pool = port->type == MMAL_PORT_TYPE_INPUT ?
      wrapper->input_pool[port->index] : wrapper->output_pool[port->index];
   buffer_size = (flags & MMAL_WRAPPER_FLAG_PAYLOAD_ALLOCATE) ? port->buffer_size : 0;

   /* FIXME: we don't support switching between shared and non-shared memory.
    * We would need to save the flag and force a pool resize when switching. */
   if (flags & MMAL_WRAPPER_FLAG_PAYLOAD_USE_SHARED_MEMORY)
   {
      MMAL_PARAMETER_BOOLEAN_T param_zc =
         {{MMAL_PARAMETER_ZERO_COPY, sizeof(MMAL_PARAMETER_BOOLEAN_T)}, 1};
      status = mmal_port_parameter_set(port, &param_zc.hdr);
      if (status != MMAL_SUCCESS && status != MMAL_ENOSYS)
      {
         LOG_ERROR("failed to set zero copy on %s", port->name);
         return status;
      }
   }

   /* Resize the pool */
   status = mmal_pool_resize(pool, port->buffer_num, buffer_size);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("could not resize pool (%i/%i)", (int)port->buffer_num, (int)buffer_size);
      return status;
   }

   /* Enable port. The callback specified here is the function which
    * will be called when a buffer header comes back to the port. */
   status = mmal_port_enable(port, port->type == MMAL_PORT_TYPE_INPUT ?
                             mmal_wrapper_bh_in_cb : mmal_wrapper_bh_out_cb);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("could not enable port");
      return status;
   }

   wrapper->time_enable += vcos_getmicrosecs() - start_time;
   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_wrapper_port_disable(MMAL_PORT_T *port)
{
   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
   MMAL_WRAPPER_T *wrapper = &private->wrapper;
   int64_t start_time = vcos_getmicrosecs();
   MMAL_STATUS_T status;

   LOG_TRACE("%p, %s", wrapper, port->name);

   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
      return MMAL_EINVAL;

   if (!port->is_enabled)
      return MMAL_SUCCESS;

   /* Disable port */
   status = mmal_port_disable(port);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("could not disable port");
      return status;
   }

   /* Flush the queue */
   if (port->type == MMAL_PORT_TYPE_OUTPUT)
   {
      MMAL_POOL_T *pool = wrapper->output_pool[port->index];
      MMAL_QUEUE_T *queue = wrapper->output_queue[port->index];
      MMAL_BUFFER_HEADER_T *buffer;

      while ((buffer = mmal_queue_get(queue)) != NULL)
         mmal_buffer_header_release(buffer);

      if ( !vcos_verify(mmal_queue_length(pool->queue) == pool->headers_num) )
      {
         LOG_ERROR("coul dnot release all buffers");
      }
   }

   wrapper->time_disable = vcos_getmicrosecs() - start_time;
   return status;
}

/** Wait for an empty buffer to be available on a port */
MMAL_STATUS_T mmal_wrapper_buffer_get_empty(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer,
   uint32_t flags)
{
   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
   MMAL_WRAPPER_T *wrapper = &private->wrapper;
   MMAL_POOL_T *pool;

   LOG_TRACE("%p, %s", wrapper, port->name);

   if (!buffer || (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT))
      return MMAL_EINVAL;

   pool = port->type == MMAL_PORT_TYPE_INPUT ?
      wrapper->input_pool[port->index] : wrapper->output_pool[port->index];

   while (wrapper->status == MMAL_SUCCESS &&
          (*buffer = mmal_queue_get(pool->queue)) == NULL)
   {
      if (!(flags & MMAL_WRAPPER_FLAG_WAIT))
         break;
      vcos_semaphore_wait(&private->sema);
   }

   return wrapper->status == MMAL_SUCCESS && !*buffer ? MMAL_EAGAIN : wrapper->status;
}

/** Wait for a full buffer to be available on a port */
MMAL_STATUS_T mmal_wrapper_buffer_get_full(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer,
   uint32_t flags)
{
   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
   MMAL_WRAPPER_T *wrapper = &private->wrapper;
   MMAL_QUEUE_T *queue;

   LOG_TRACE("%p, %s", wrapper, port->name);

   if (!buffer || port->type != MMAL_PORT_TYPE_OUTPUT)
      return MMAL_EINVAL;
   queue = wrapper->output_queue[port->index];

   while (wrapper->status == MMAL_SUCCESS &&
          (*buffer = mmal_queue_get(queue)) == NULL)
   {
      if (!(flags & MMAL_WRAPPER_FLAG_WAIT))
         break;
      vcos_semaphore_wait(&private->sema);
   }

   return wrapper->status == MMAL_SUCCESS && !*buffer ? MMAL_EAGAIN : wrapper->status;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_component_wrapper.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_WRAPPER_H
#define MMAL_WRAPPER_H

/** \defgroup MmalComponentWrapper utility
 * \ingroup MmalUtilities
 * The component wrapper utility functions can be used in place of common sequences
 * of calls to the MMAL API in order to control a standalone component. It hides some
 * of the complexity in using standalone components behind a fully synchronous
 * interface.
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** Forward type definition for a wrapper */
typedef struct MMAL_WRAPPER_T MMAL_WRAPPER_T;

/** Definition of the callback used by a wrapper to signal back to the client
 * that a buffer header is available either in the pool or in the output queue.
 *
 * @param wrapper Pointer to the wrapper
 */
typedef void (*MMAL_WRAPPER_CALLBACK_T)(MMAL_WRAPPER_T *wrapper);

/** Structure describing a wrapper around a component */
struct MMAL_WRAPPER_T {

   void *user_data;           /**< Field reserved for use by the client. */
   MMAL_WRAPPER_CALLBACK_T callback; /**< Callback set by the client. */
   MMAL_COMPONENT_T *component;
   MMAL_STATUS_T status;

   MMAL_PORT_T *control;        /**< Control port (Read Only). */

   uint32_t    input_num;       /**< Number of input ports (Read Only). */
   MMAL_PORT_T **input;         /**< Array of input ports (Read Only). */
   MMAL_POOL_T **input_pool;    /**< Array of input pools (Read Only). */

   uint32_t    output_num;      /**< Number of output ports (Read Only). */
   MMAL_PORT_T **output;        /**< Array of output ports (Read Only). */
   MMAL_POOL_T **output_pool;   /**< Array of output pools (Read Only). */
   MMAL_QUEUE_T **output_queue; /**< Array of output queues (Read Only). */

   /* Used for debug / statistics */
   int64_t time_setup;          /**< Time in microseconds taken to setup the connection. */
   int64_t time_enable;         /**< Time in microseconds taken to enable the connection. */
   int64_t time_disable;        /**< Time in microseconds taken to disable the connection. */

};

/** Create a wrapper around a component.
 * The wrapper shall include a pool of buffer headers for each port. The pools will be suitable
 * for the current format of its associated port.
 *
 * @param wrapper    The address of a wrapper pointer that will be set to point to the created
 *                   wrapper.
 * @param name       The name of the component to create.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_create(MMAL_WRAPPER_T **wrapper, const char *name);

/** \name MMAL wrapper flags
 * \anchor wrapperflags
 */
/* @{ */
/** The operation should be blocking */
#define MMAL_WRAPPER_FLAG_WAIT 1
/** The pool for the port should allocate memory for the payloads */
#define MMAL_WRAPPER_FLAG_PAYLOAD_ALLOCATE 2
/** The port will use shared memory payloads */
#define MMAL_WRAPPER_FLAG_PAYLOAD_USE_SHARED_MEMORY 4
/* @} */

/** Enable a port on a component wrapper.
 *
 * @param port port to enable
 * @param flags used to specify payload allocation flags for the pool
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_port_enable(MMAL_PORT_T *port, uint32_t flags);

/** Disable a port on a component wrapper.
 *
 * @param port port to disable
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_port_disable(MMAL_PORT_T *port);

/** Wait for an empty buffer to be available on a port.
 *
 * @param port port to get an empty buffer from
 * @param buffer points to the retreived buffer on return
 * @param flags specify MMAL_WRAPPER_FLAG_WAIT for a blocking operation
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_buffer_get_empty(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t flags);

/** Wait for a full buffer to be available on a port.
 *
 * @param port port to get a full buffer from
 * @param buffer points to the retreived buffer on return
 * @param flags specify MMAL_WRAPPER_FLAG_WAIT for a blocking operation
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_buffer_get_full(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t flags);

/** Cancel any ongoing blocking operation on a component wrapper.
 *
 * @param wrapper The wrapper on which to cancel operations.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_cancel(MMAL_WRAPPER_T *wrapper);

/** Destroy a wrapper.
 * Destroys a component wrapper and any resources it owns.
 *
 * @param wrapper The wrapper to be destroyed.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_wrapper_destroy(MMAL_WRAPPER_T *wrapper);

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* MMAL_WRAPPER_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "util/mmal_util.h"
#include "util/mmal_connection.h"
#include "mmal_logging.h"
#include <stdio.h>

#define CONNECTION_NAME_FORMAT "%s:%.2222s:%i/%s:%.2222s:%i"

typedef struct
{
   MMAL_CONNECTION_T connection; /**< Must be the first member! */
   MMAL_PORT_T *pool_port;       /**< Port used to create the pool */

   /** Reference counting */
   int refcount;

} MMAL_CONNECTION_PRIVATE_T;

/** Callback from an input port. Buffer is released. */
static void mmal_connection_bh_in_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_PARAM_UNUSED(port);
   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);
   /* We're done with the buffer, just recycle it */
   mmal_buffer_header_release(buffer);
}

/** Callback from an output port. Buffer is queued for the next component. */
static void mmal_connection_bh_out_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_CONNECTION_T *connection = (MMAL_CONNECTION_T *)port->userdata;
   MMAL_PARAM_UNUSED(port);
   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);

   /* Queue the buffer produced by the output port */
   mmal_queue_put(connection->queue, buffer);

   if (connection->callback)
      connection->callback(connection);
}

/** Callback from the pool. Buffer is available. */
static MMAL_BOOL_T mmal_connection_bh_release_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer,
   void *userdata)
{
   MMAL_CONNECTION_T *connection = (MMAL_CONNECTION_T *)userdata;
   MMAL_PARAM_UNUSED(pool);

   /* Queue the buffer produced by the output port */
   mmal_queue_put(pool->queue, buffer);

   if (connection->callback)
      connection->callback(connection);

   return 0;
}

/*****************************************************************************/
static MMAL_STATUS_T mmal_connection_destroy_internal(MMAL_CONNECTION_T *connection)
{
   MMAL_STATUS_T status;

   if (connection->is_enabled)
   {
      status = mmal_connection_disable(connection);
      if (status != MMAL_SUCCESS)
         return status;
   }

   /* Special case for tunnelling */
   if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
   {
      status = mmal_port_disconnect(connection->out);
      if (status != MMAL_SUCCESS)
         LOG_ERROR("connection %s could not be cleared", connection->name);
   }

   /* Cleanup resources */
   if (connection->pool)
      mmal_pool_destroy(connection->pool);
   if (connection->queue)
      mmal_queue_destroy(connection->queue);

   vcos_free(connection);
   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_connection_destroy(MMAL_CONNECTION_T *connection)
{
   MMAL_CONNECTION_PRIVATE_T *private = (MMAL_CONNECTION_PRIVATE_T *)connection;

   LOG_TRACE("%p, %s", connection, connection->name);

   if (--private->refcount)
   {
      LOG_DEBUG("delaying destruction of %s (refount %i)", connection->name,
                private->refcount);
      return MMAL_SUCCESS;
   }

   return mmal_connection_destroy_internal(connection);
}

/*****************************************************************************/
MMAL_STATUS_T mmal_connection_create(MMAL_CONNECTION_T **cx,
   MMAL_PORT_T *out, MMAL_PORT_T *in, uint32_t flags)
{
   MMAL_STATUS_T status = MMAL_ENOMEM;
   unsigned int name_size = strlen(out->component->name) + strlen(in->component->name) + sizeof(CONNECTION_NAME_FORMAT);
   unsigned int size = sizeof(MMAL_CONNECTION_PRIVATE_T) + name_size;
   MMAL_CONNECTION_PRIVATE_T *private;
   MMAL_CONNECTION_T *connection;
   char *name;

   /* Sanity checking */
   if (!cx)
      return MMAL_EINVAL;

   private = vcos_malloc(size, "mmal connection");
   if (!private)
      return MMAL_ENOMEM;
   memset(private, 0, size);
   connection = &private->connection;
   private->refcount = 1;
   name = (char *)&private[1];

   vcos_snprintf(name, name_size - 1, CONNECTION_NAME_FORMAT,
            out->component->name,
            mmal_port_type_to_string(out->type), (int)out->index,
            in->component->name,
            mmal_port_type_to_string(in->type), (int)in->index);

   LOG_TRACE("out %p, in %p, flags %x, %s", out, in, flags, name);

   connection->out = out;
   connection->in = in;
   connection->flags = flags;
   connection->name = name;

   connection->time_setup = vcos_getmicrosecs();

   /* Set the format of the input port to match the output one */
   status = mmal_format_full_copy(in->format, out->format);
   if (status == MMAL_SUCCESS)
      status = mmal_port_format_commit(in);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("format not set on input port");
      goto error;
   }

   /* In pass-through mode we need to propagate the buffer requirements of the
    * connected input port */
   if (out->capabilities & MMAL_PORT_CAPABILITY_PASSTHROUGH)
   {
      MMAL_PARAMETER_BUFFER_REQUIREMENTS_T param =
         {{MMAL_PARAMETER_BUFFER_REQUIREMENTS, sizeof(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T)},
           in->buffer_num_min, in->buffer_size_min, in->buffer_alignment_min,
           in->buffer_num_recommended, in->buffer_size_recommended};
      status = mmal_port_parameter_set(out, &param.hdr);
      if (status != MMAL_SUCCESS && status != MMAL_ENOSYS)
      {
         LOG_ERROR("failed to propagate buffer requirements");
         goto error;
      }
   }

   /* Special case for tunnelling */
   if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
   {
      status = mmal_port_connect(out, in);
      if (status != MMAL_SUCCESS)
         LOG_ERROR("connection could not be made");
      goto done;
   }

   /* Create empty pool of buffer headers for now (will be resized later on) */
   private->pool_port = (in->capabilities & MMAL_PORT_CAPABILITY_ALLOCATION) ? in : out;
   if (flags & MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT)
      private->pool_port = in;
   if (flags & MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT)
      private->pool_port = out;
   connection->pool = mmal_port_pool_create(private->pool_port, 0, 0);
   if (!connection->pool)
      goto error;
   mmal_pool_callback_set(connection->pool, mmal_connection_bh_release_cb, (void *)connection);

   /* Create a queue to store the buffers from the output port */
   connection->queue = mmal_queue_create();
   if (!connection->queue)
      goto error;

 done:
   out->userdata = (void *)connection;
   in->userdata = (void *)connection;
   connection->time_setup = vcos_getmicrosecs() - connection->time_setup;
   *cx = connection;
   return status;

 error:
   mmal_connection_destroy_internal(connection);
   return status == MMAL_SUCCESS ? MMAL_ENOMEM : status;
}

/*****************************************************************************/
void mmal_connection_acquire(MMAL_CONNECTION_T *connection)
{
   MMAL_CONNECTION_PRIVATE_T *private = (MMAL_CONNECTION_PRIVATE_T *)connection;
   LOG_TRACE("connection %s(%p), refcount %i", connection->name, connection,
             private->refcount);
   private->refcount++;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_connection_release(MMAL_CONNECTION_T *connection)
{
   MMAL_CONNECTION_PRIVATE_T *private = (MMAL_CONNECTION_PRIVATE_T *)connection;
   LOG_TRACE("connection %s(%p), refcount %i", connection->name, connection,
             private->refcount);

   if (--private->refcount)
      return MMAL_SUCCESS;

   LOG_TRACE("destroying connection %s(%p)", connection->name, connection);
   return mmal_connection_destroy_internal(connection);
}

/*****************************************************************************/
MMAL_STATUS_T mmal_connection_enable(MMAL_CONNECTION_T *connection)
{
   MMAL_PORT_T *in = connection->in, *out = connection->out;
   uint32_t buffer_num, buffer_size;
   MMAL_STATUS_T status;

   LOG_TRACE("%p, %s", connection, connection->name);

   if (connection->is_enabled)
      return MMAL_SUCCESS;

   connection->time_enable = vcos_getmicrosecs();

   /* Override the buffer values with the recommended ones (the port probably knows best) */
   if (out->buffer_num_recommended)
      out->buffer_num = out->buffer_num_recommended;
   if (out->buffer_size_recommended)
      out->buffer_size = out->buffer_size_recommended;
   if (in->buffer_num_recommended)
      in->buffer_num = in->buffer_num_recommended;
   if (in->buffer_size_recommended)
      in->buffer_size = in->buffer_size_recommended;

   /* Special case for tunnelling */
   if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
   {
      /* Enable port. No callback because the port is connected. Other end of the connection
       * will be enabled automatically. */
      status = mmal_port_enable(out, NULL);
      if (status)
         LOG_ERROR("output port couldn't be enabled");
      goto done;
   }

   /* Set the buffering properties on both ports */
   buffer_num = MMAL_MAX(out->buffer_num, in->buffer_num);
   buffer_size = MMAL_MAX(out->buffer_size, in->buffer_size);
   out->buffer_num = in->buffer_num = buffer_num;
   out->buffer_size = in->buffer_size = buffer_size;

   /* In pass-through mode there isn't any need to allocate memory */
   if (out->capabilities & MMAL_PORT_CAPABILITY_PASSTHROUGH)
      buffer_size = 0;

   /* Resize the output pool */
   status = mmal_pool_resize(connection->pool, buffer_num, buffer_size);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("couldn't resize pool");
      goto done;
   }

   /* Enable output port. The callback specified here is the function which
    * will be called when an empty buffer header comes back to the port. */
   status = mmal_port_enable(out, mmal_connection_bh_out_cb);
   if(status)
   {
      LOG_ERROR("output port couldn't be enabled");
      goto done;
   }

   /* Enable input port. The callback specified here is the function which
    * will be called when an empty buffer header comes back to the port. */
   status = mmal_port_enable(in, mmal_connection_bh_in_cb);
   if(status)
   {
      LOG_ERROR("input port couldn't be enabled");
      mmal_port_disable(out);
      goto done;
   }

   /* Clock ports need buffers to send clock updates, so
    * populate both connected clock ports */
   if ((out->type == MMAL_PORT_TYPE_CLOCK) && (in->type == MMAL_PORT_TYPE_CLOCK))
   {
      MMAL_BUFFER_HEADER_T *buffer = mmal_queue_get(connection->pool->queue);
      while (buffer)
      {
         mmal_port_send_buffer(out, buffer);
         buffer = mmal_queue_get(connection->pool->queue);
         if (buffer)
         {
            mmal_port_send_buffer(in, buffer);
            buffer = mmal_queue_get(connection->pool->queue);
         }
      }
   }

 done:
   connection->time_enable = vcos_getmicrosecs() - connection->time_enable;
   connection->is_enabled = status == MMAL_SUCCESS;
   return status;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_connection_disable(MMAL_CONNECTION_T *connection)
{
   MMAL_STATUS_T status;
   MMAL_BUFFER_HEADER_T *buffer;

   LOG_TRACE("%p, %s", connection, connection->name);

   if (!connection->is_enabled)
      return MMAL_SUCCESS;

   connection->time_disable = vcos_getmicrosecs();

   /* Special case for tunnelling */
   if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
   {
      /* Disable port. Other end of the connection will be disabled automatically. */
      status = mmal_port_disable(connection->out);
      if (status)
         LOG_ERROR("output port couldn't be disabled");
      goto done;
   }

   /* Disable input port. */
   status = mmal_port_disable(connection->in);
   if(status)
   {
      LOG_ERROR("input port couldn't be disabled");
      goto done;
   }

   /* Disable output port */
   status = mmal_port_disable(connection->out);
   if(status)
   {
      LOG_ERROR("output port couldn't be disabled");
      goto done;
   }

   /* Flush the queue */
   buffer = mmal_queue_get(connection->queue);
   while (buffer)
   {
      mmal_buffer_header_release(buffer);
      buffer = mmal_queue_get(connection->queue);
   }
   vcos_assert(mmal_queue_length(connection->pool->queue) == connection->pool->headers_num);

 done:
   connection->time_disable = vcos_getmicrosecs() - connection->time_disable;
   connection->is_enabled = !(status == MMAL_SUCCESS);
   return status;
}

/*****************************************************************************/
static MMAL_STATUS_T mmal_connection_reconfigure(MMAL_CONNECTION_T *connection, MMAL_ES_FORMAT_T *format)
{
   MMAL_STATUS_T status;
   LOG_TRACE("%p, %s", connection, connection->name);

   status = mmal_connection_disable(connection);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("connection couldn't be disabled");
      return status;
   }

   /* Set the new format for the output port */
   status = mmal_format_full_copy(connection->out->format, format);
   if (status == MMAL_SUCCESS)
      status = mmal_port_format_commit(connection->out);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("commit failed on port %s(%p) (%i)",
                connection->out->name, connection->out, status);
      return status;
   }

   /* Set the new format for the input port */
   status = mmal_format_full_copy(connection->in->format, connection->out->format);
   if (status == MMAL_SUCCESS)
      status = mmal_port_format_commit(connection->in);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("commit failed on port %s(%p) (%i)",
                connection->in->name, connection->in, status);
      return status;
   }

   /* Enable ports */
   status = mmal_connection_enable(connection);
   if (status)
   {
      LOG_ERROR("connection couldn't be enabled");
      return status;
   }

   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_connection_event_format_changed(MMAL_CONNECTION_T *connection,
   MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_EVENT_FORMAT_CHANGED_T *event;
   MMAL_STATUS_T status;

   LOG_TRACE("%p, %s", connection, connection->name);

   if (buffer->cmd != MMAL_EVENT_FORMAT_CHANGED)
      return MMAL_EINVAL;

   event = mmal_event_format_changed_get(buffer);
   if (!event)
      return MMAL_EINVAL;

   /* If we don't need to recreate our buffers then we can just forward the event
    * to the next component (so it gets configured properly) */
   if ((connection->in->capabilities & MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE) &&
       event->buffer_size_min <= connection->out->buffer_size &&
       event->buffer_num_min <= connection->out->buffer_num_min)
   {
      status = mmal_format_full_copy(connection->out->format, event->format);
      if (status == MMAL_SUCCESS)
         status = mmal_port_format_commit(connection->out);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("format commit failed on port %s(%p) (%i)",
                   connection->out->name, connection->out, status);
         return status;
      }

      mmal_buffer_header_acquire(buffer);
      status = mmal_port_send_buffer(connection->in, buffer);
      if (status != MMAL_SUCCESS)
      {
         LOG_ERROR("buffer send failed on port %s(%p) (%i)",
                   connection->in->name, connection->in, status);
         mmal_buffer_header_release(buffer);
         return status;
      }

      return MMAL_SUCCESS;
   }

   /* Otherwise we have to reconfigure our pipeline */
   return mmal_connection_reconfigure(connection, event->format);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_CONNECTION_H
#define MMAL_CONNECTION_H

/** \defgroup MmalConnectionUtility Port connection utility
 * \ingroup MmalUtilities
 * The port connection utility functions can be used in place of common sequences
 * of calls to the MMAL API in order to process buffers being passed between two
 * ports.
 *
 * \section ProcessingConnectionBufferHeaders Processing connection buffer headers
 * Either in response to the client callback function being called, or simply on a
 * timer, the client will need to process the buffer headers of the connection
 * (unless tunneling is used).
 *
 * Buffer headers that are in the pool queue will need to be sent to the output port,
 * while buffer headers in the connection queue are sent to the input port. The
 * buffer headers in the connection queue may contain pixel data (the cmd field is
 * zero) or an event (the cmd field is non-zero). In general, pixel data buffer
 * headers need to be passed on, while event buffer headers are released. In the
 * case of the format changed event, mmal_connection_event_format_changed() can be
 * called before the event is released.
 *
 * Other, specialized use cases may also be implemented, such as getting and
 * immediately releasing buffer headers from the connection queue in order to
 * prevent their propagation. This could be used to drop out video, for example.
 *
 * \section TunnellingConnections Tunnelling connections
 * If the \ref MMAL_CONNECTION_FLAG_TUNNELLING flag is set when the connection is
 * created, MMAL tunneling will be used. This automates the passing of the buffer
 * headers between the output port and input port, and back again. It will also do
 * this as efficiently as possible, avoiding trips between the ARM and the VideoCore
 * if both components are implemented on the VideoCore. The consequence of this is
 * that there is no client callback made as buffer headers get transferred.
 *
 * The client can still monitor the control port of a component (usually a sink
 * component, such as video_render) for the end of stream, in order to know when to
 * dismantle the connection.
 *
 * \section ConnectionClientCallback Client callback
 * When not using tunnelling, the client callback function is called each time a
 * buffer arrives from a port (either input or output).
 *
 * \note The callback is made on a different thread from the one used by the
 * client to set up the connection, so care must be taken with thread safety.
 * One option is to raise a signal to the main client thread that queue processing
 * needs to be done, another is for the callback to perform the queue processing
 * itself.
 *
 * The client can also store an opaque pointer in the connection object, which is
 * never used by the MMAL code and is only meaningful to the client.
 *
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** \name Connection flags
 * \anchor connectionflags
 * The following flags describe the properties of the connection. */
/* @{ */
/** The connection is tunnelled. Buffer headers do not transit via the client but
 * directly from the output port to the input port. */
#define MMAL_CONNECTION_FLAG_TUNNELLING 0x1
/** Force the pool of buffer headers used by the connection to be allocated on the input port. */
#define MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT 0x2
/** Force the pool of buffer headers used by the connection to be allocated on the output port. */
#define MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT 0x4
/* @} */

/** Forward type definition for a connection */
typedef struct MMAL_CONNECTION_T MMAL_CONNECTION_T;

/** Definition of the callback used by a connection to signal back to the client
 * that a buffer header is available either in the pool or in the output queue.
 *
 * @param connection Pointer to the connection
 */
typedef void (*MMAL_CONNECTION_CALLBACK_T)(MMAL_CONNECTION_T *connection);

/** Structure describing a connection between 2 ports (1 output and 1 input port) */
struct MMAL_CONNECTION_T {

   void *user_data;           /**< Field reserved for use by the client. */
   MMAL_CONNECTION_CALLBACK_T callback; /**< Callback set by the client. */

   uint32_t is_enabled;       /**< Specifies whether the connection is enabled or not (Read Only). */

   uint32_t flags;            /**< Flags passed during the create call (Read Only). A bitwise
                               * combination of \ref connectionflags "Connection flags" values.
                               */
   MMAL_PORT_T *in;           /**< Input port used for the connection (Read Only). */
   MMAL_PORT_T *out;          /**< Output port used for the connection (Read Only). */

   MMAL_POOL_T *pool;         /**< Pool of buffer headers used by the output port (Read Only). */
   MMAL_QUEUE_T *queue;       /**< Queue for the buffer headers produced by the output port (Read Only). */

   const char *name;          /**< Connection name (Read Only). Used for debugging purposes. */

   /* Used for debug / statistics */
   int64_t time_setup;        /**< Time in microseconds taken to setup the connection. */
   int64_t time_enable;       /**< Time in microseconds taken to enable the connection. */
   int64_t time_disable;      /**< Time in microseconds taken to disable the connection. */
};

/** Create a connection between two ports.
 * The connection shall include a pool of buffer headers suitable for the current format of
 * the output port. The format of the input port shall have been set to the same as that of
 * the input port.
 * Note that connections are reference counted and creating a connection automatically
 * acquires a reference to it (released when \ref mmal_connection_destroy is called).
 *
 * @param connection The address of a connection pointer that will be set to point to the created
 * connection.
 * @param out        The output port to use for the connection.
 * @param in         The input port to use for the connection.
 * @param flags      The flags specifying which type of connection should be created.
 *    A bitwise combination of \ref connectionflags "Connection flags" values.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_create(MMAL_CONNECTION_T **connection,
   MMAL_PORT_T *out, MMAL_PORT_T *in, uint32_t flags);

/** Acquire a reference on a connection.
 * Acquiring a reference on a connection will prevent a connection from being destroyed until
 * the acquired reference is released (by a call to \ref mmal_connection_destroy).
 * References are internally counted so all acquired references need a matching call to
 * release them.
 *
 * @param connection connection to acquire
 */
void mmal_connection_acquire(MMAL_CONNECTION_T *connection);

/** Release a reference on a connection
 * Release an acquired reference on a connection. Triggers the destruction of the connection when
 * the last reference is being released.
 * \note This is in fact an alias of \ref mmal_connection_destroy which is added to make client
 * code clearer.
 *
 * @param connection connection to release
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_connection_release(MMAL_CONNECTION_T *connection);

/** Destroy a connection.
 * Release an acquired reference on a connection. Only actually destroys the connection when
 * the last reference is being released.
 * The actual destruction of the connection will start by disabling it, if necessary.
 * Any pool, queue, and so on owned by the connection shall then be destroyed.
 *
 * @param connection The connection to be destroyed.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_destroy(MMAL_CONNECTION_T *connection);

/** Enable a connection.
 * The format of the two ports must have been committed before calling this function,
 * although note that on creation, the connection automatically copies and commits the
 * output port's format to the input port.
 *
 * The MMAL_CONNECTION_T::callback field must have been set if the \ref MMAL_CONNECTION_FLAG_TUNNELLING
 * flag was not specified on creation. The client may also set the MMAL_CONNECTION_T::user_data
 * in order to get a pointer passed, via the connection, to the callback.
 *
 * @param connection The connection to be enabled.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_enable(MMAL_CONNECTION_T *connection);

/** Disable a connection.
 *
 * @param connection The connection to be disabled.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_disable(MMAL_CONNECTION_T *connection);

/** Apply a format changed event to the connection.
 * This function can be used when the client is processing buffer headers and receives
 * a format changed event (\ref MMAL_EVENT_FORMAT_CHANGED). The connection is
 * reconfigured, changing the format of the ports, the number of buffer headers and
 * the size of the payload buffers as necessary.
 *
 * @param connection The connection to which the event shall be applied.
 * @param buffer The buffer containing a format changed event.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_connection_event_format_changed(MMAL_CONNECTION_T *connection,
   MMAL_BUFFER_HEADER_T *buffer);

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* MMAL_CONNECTION_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_default_components.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_DEFAULT_COMPONENTS_H
#define MMAL_DEFAULT_COMPONENTS_H

/** \defgroup MmalDefaultComponents List of default components
 * This provides a list of default components on a per platform basis.
 * @{
 */

#define MMAL_COMPONENT_DEFAULT_CONTAINER_READER "container_reader"
#define MMAL_COMPONENT_DEFAULT_CONTAINER_WRITER "container_writer"

#if defined(ENABLE_MMAL_STANDALONE)
# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "avcodec.video_decode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "avcodec.video_encode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "sdl.video_render"
# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "avcodec.video_decode"
# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "avcodec.video_encode"
# define MMAL_COMPONENT_DEFAULT_CAMERA           "artificial_camera"
# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "avcodec.video_convert"
# define MMAL_COMPONENT_DEFAULT_SPLITTER         "splitter"
# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "scheduler"
# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "video_inject"
# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "avcodec.audio_decode"
# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "sdl.audio_render"
# define MMAL_COMPONENT_DEFAULT_MIRACAST         "miracast"
#elif defined(__VIDEOCORE__)
# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "ril.video_decode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "ril.video_encode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "ril.video_render"
# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "ril.image_decode"
# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "ril.image_encode"
# define MMAL_COMPONENT_DEFAULT_CAMERA           "ril.camera"
# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "video_convert"
# define MMAL_COMPONENT_DEFAULT_SPLITTER         "splitter"
# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "scheduler"
# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "video_inject"
# define MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER   "ril.video_splitter"
# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "none"
# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "ril.audio_render"
# define MMAL_COMPONENT_DEFAULT_MIRACAST         "miracast"
#else
# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "vc.ril.video_decode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "vc.ril.video_encode"
# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "vc.ril.video_render"
# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "vc.ril.image_decode"
# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "vc.ril.image_encode"
# define MMAL_COMPONENT_DEFAULT_CAMERA           "vc.ril.camera"
# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "vc.video_convert"
# define MMAL_COMPONENT_DEFAULT_SPLITTER         "vc.splitter"
# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "vc.scheduler"
# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "vc.video_inject"
# define MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER   "vc.ril.video_splitter"
# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "none"
# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "vc.ril.audio_render"
# define MMAL_COMPONENT_DEFAULT_MIRACAST         "vc.miracast"
#endif

/** @} */

#endif /* MMAL_DEFAULT_COMPONENTS_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "util/mmal_util.h"
#include "util/mmal_graph.h"
#include "core/mmal_component_private.h"
#include "core/mmal_port_private.h"
#include "mmal_logging.h"

#define GRAPH_CONNECTIONS_MAX 16

/*****************************************************************************/

/** Private context for our graph.
 * This also acts as a MMAL_COMPONENT_MODULE_T for when components are instantiated from graphs */
typedef struct MMAL_COMPONENT_MODULE_T
{
   MMAL_GRAPH_T graph; /**< Must be the first member! */

   MMAL_COMPONENT_T *component[GRAPH_CONNECTIONS_MAX];
   unsigned int component_num;

   MMAL_CONNECTION_T *connection[GRAPH_CONNECTIONS_MAX];
   unsigned int connection_num;

   MMAL_PORT_T *input[GRAPH_CONNECTIONS_MAX];
   unsigned int input_num;
   MMAL_PORT_T *output[GRAPH_CONNECTIONS_MAX];
   unsigned int output_num;

   MMAL_COMPONENT_T *graph_component;

   MMAL_BOOL_T stop_thread;      /**< informs the worker thread to exit */
   VCOS_THREAD_T thread;         /**< worker thread which processes all internal connections */
   VCOS_SEMAPHORE_T sema;        /**< informs the worker thread that buffers are available */

   MMAL_GRAPH_EVENT_CB event_cb; /**< callback for sending control port events to the client */
   void *event_cb_data;          /**< callback data supplied by the client */

} MMAL_GRAPH_PRIVATE_T;

typedef MMAL_GRAPH_PRIVATE_T MMAL_COMPONENT_MODULE_T;

/*****************************************************************************/
static MMAL_STATUS_T mmal_component_create_from_graph(const char *name, MMAL_COMPONENT_T *component);
static MMAL_BOOL_T graph_do_processing(MMAL_GRAPH_PRIVATE_T *graph);

/*****************************************************************************/
static void graph_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_GRAPH_PRIVATE_T *graph = (MMAL_GRAPH_PRIVATE_T *)port->userdata;

   LOG_TRACE("port: %s(%p), buffer: %p, event: %4.4s", port->name, port,
             buffer, (char *)&buffer->cmd);

   if (graph->event_cb)
   {
      graph->event_cb((MMAL_GRAPH_T *)graph, port, buffer, graph->event_cb_data);
   }
   else
   {
      LOG_ERROR("event lost on port %i,%i (event callback not defined)",
                (int)port->type, (int)port->index);
      mmal_buffer_header_release(buffer);
   }
}

/*****************************************************************************/
static void graph_connection_cb(MMAL_CONNECTION_T *connection)
{
   MMAL_GRAPH_PRIVATE_T *graph = (MMAL_GRAPH_PRIVATE_T *)connection->user_data;
   vcos_semaphore_post(&graph->sema);
}

/*****************************************************************************/
static void* graph_worker_thread(void* ctx)
{
   MMAL_GRAPH_PRIVATE_T *graph = (MMAL_GRAPH_PRIVATE_T *)ctx;

   while (1)
   {
      vcos_semaphore_wait(&graph->sema);
      if (graph->stop_thread)
         break;
      while(graph_do_processing(graph));
   }

   LOG_TRACE("worker thread exit %p", graph);

   return 0;
}

/*****************************************************************************/
static void graph_stop_worker_thread(MMAL_GRAPH_PRIVATE_T *graph)
{
   graph->stop_thread = MMAL_TRUE;
   vcos_semaphore_post(&graph->sema);
   vcos_thread_join(&graph->thread, NULL);
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_create(MMAL_GRAPH_T **graph, unsigned int userdata_size)
{
   MMAL_GRAPH_PRIVATE_T *private;

   LOG_TRACE("graph %p, userdata_size %u", graph, userdata_size);

   /* Sanity checking */
   if (!graph)
      return MMAL_EINVAL;

   private = vcos_calloc(1, sizeof(MMAL_GRAPH_PRIVATE_T) + userdata_size, "mmal connection graph");
   if (!private)
      return MMAL_ENOMEM;
   *graph = &private->graph;
   if (userdata_size)
      (*graph)->userdata = (struct MMAL_GRAPH_USERDATA_T *)&private[1];

   if (vcos_semaphore_create(&private->sema, "mmal graph sema", 0) != VCOS_SUCCESS)
   {
      LOG_ERROR("failed to create semaphore %p", graph);
      vcos_free(private);
      return MMAL_ENOSPC;
   }

   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_destroy(MMAL_GRAPH_T *graph)
{
   unsigned i;
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;

   if (!graph)
      return MMAL_EINVAL;

   LOG_TRACE("%p", graph);

   /* Notify client of destruction */
   if (graph->pf_destroy)
      graph->pf_destroy(graph);

   for (i = 0; i < private->connection_num; i++)
      mmal_connection_release(private->connection[i]);

   for (i = 0; i < private->component_num; i++)
      mmal_component_release(private->component[i]);

   vcos_semaphore_delete(&private->sema);

   vcos_free(graph);
   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_add_component(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component)
{
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;

   LOG_TRACE("graph: %p, component: %s(%p)", graph, component ? component->name: 0, component);

   if (!component)
      return MMAL_EINVAL;

   if (private->component_num >= GRAPH_CONNECTIONS_MAX)
   {
      LOG_ERROR("no space for component %s", component->name);
      return MMAL_ENOSPC;
   }

   mmal_component_acquire(component);
   private->component[private->component_num++] = component;

   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_add_connection(MMAL_GRAPH_T *graph, MMAL_CONNECTION_T *cx)
{
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;

   LOG_TRACE("graph: %p, connection: %s(%p)", graph, cx ? cx->name: 0, cx);

   if (!cx)
      return MMAL_EINVAL;

   if (private->connection_num >= GRAPH_CONNECTIONS_MAX)
   {
      LOG_ERROR("no space for connection %s", cx->name);
      return MMAL_ENOSPC;
   }

   mmal_connection_acquire(cx);
   private->connection[private->connection_num++] = cx;
   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_add_port(MMAL_GRAPH_T *graph, MMAL_PORT_T *port)
{
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
   MMAL_PORT_T **list;
   unsigned int *list_num;

   LOG_TRACE("graph: %p, port: %s(%p)", graph, port ? port->name: 0, port);

   if (!port || (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT))
      return MMAL_EINVAL;

   list = port->type == MMAL_PORT_TYPE_INPUT ? private->input : private->output;
   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &private->input_num : &private->output_num;
   if (*list_num >= GRAPH_CONNECTIONS_MAX)
   {
      LOG_ERROR("no space for port %s", port->name);
      return MMAL_ENOSPC;
   }

   list[(*list_num)++] = port;
   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_new_component(MMAL_GRAPH_T *graph, const char *name,
   MMAL_COMPONENT_T **component)
{
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
   MMAL_COMPONENT_T *comp;
   MMAL_STATUS_T status;

   LOG_TRACE("graph: %p, name: %s, component: %p", graph, name, component);

   if (private->component_num >= GRAPH_CONNECTIONS_MAX)
   {
      LOG_ERROR("no space for component %s", name);
      return MMAL_ENOSPC;
   }

   status = mmal_component_create(name, &comp);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("could not create component %s (%i)", name, status);
      return status;
   }

   private->component[private->component_num++] = comp;
   if (component)
   {
      mmal_component_acquire(comp);
      *component = comp;
   }

   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_new_connection(MMAL_GRAPH_T *graph, MMAL_PORT_T *out, MMAL_PORT_T *in,
   uint32_t flags, MMAL_CONNECTION_T **connection)
{
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
   MMAL_CONNECTION_T *cx;
   MMAL_STATUS_T status;

   if (!out || !in ||
       out->type != MMAL_PORT_TYPE_OUTPUT || in->type != MMAL_PORT_TYPE_INPUT)
      return MMAL_EINVAL;

   LOG_TRACE("graph: %p, out: %s(%p), in: %s(%p), flags %x, connection: %p",
             graph, out->name, out, in->name, in, (int)flags, connection);

   if (private->connection_num >= GRAPH_CONNECTIONS_MAX)
   {
      LOG_ERROR("no space for connection %s/%s", out->name, in->name);
      return MMAL_ENOSPC;
   }

   status = mmal_connection_create(&cx, out, in, flags);
   if (status != MMAL_SUCCESS)
      return status;

   private->connection[private->connection_num++] = cx;
   if (connection)
   {
      mmal_connection_acquire(cx);
      *connection = cx;
   }

   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_enable(MMAL_GRAPH_T *graph, MMAL_GRAPH_EVENT_CB cb, void *cb_data)
{
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
   MMAL_STATUS_T status = MMAL_SUCCESS;
   unsigned int i;

   LOG_TRACE("graph: %p", graph);

   if (vcos_thread_create(&private->thread, "mmal graph thread", NULL,
                          graph_worker_thread, private) != VCOS_SUCCESS)
   {
      LOG_ERROR("failed to create worker thread %p", graph);
      return MMAL_ENOSPC;
   }

   private->event_cb = cb;
   private->event_cb_data = cb_data;

   /* Enable all control ports */
   for (i = 0; i < private->component_num; i++)
   {
      private->component[i]->control->userdata = (void *)private;
      status = mmal_port_enable(private->component[i]->control, graph_control_cb);
      if (status != MMAL_SUCCESS)
         LOG_ERROR("could not enable port %s", private->component[i]->control->name);
   }

   /* Enable all our connections */
   for (i = 0; i < private->connection_num; i++)
   {
      MMAL_CONNECTION_T *cx = private->connection[i];

      cx->callback = graph_connection_cb;
      cx->user_data = private;

      status = mmal_connection_enable(cx);
      if (status != MMAL_SUCCESS)
         goto error;
   }

   /* Trigger the worker thread to populate the output ports with empty buffers */
   vcos_semaphore_post(&private->sema);
   return status;

 error:
   graph_stop_worker_thread(private);
   return status;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_disable(MMAL_GRAPH_T *graph)
{
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
   MMAL_STATUS_T status = MMAL_SUCCESS;
   unsigned int i;

   LOG_TRACE("graph: %p", graph);

   graph_stop_worker_thread(private);

   /* Disable all our connections */
   for (i = 0; i < private->connection_num; i++)
   {
      status = mmal_connection_disable(private->connection[i]);
      if (status != MMAL_SUCCESS)
         break;
   }

   return status;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_build(MMAL_GRAPH_T *graph,
   const char *name, MMAL_COMPONENT_T **component)
{
   LOG_TRACE("graph: %p, name: %s, component: %p", graph, name, component);
   return mmal_component_create_with_constructor(name, mmal_component_create_from_graph,
      (MMAL_GRAPH_PRIVATE_T *)graph, component);
}

/*****************************************************************************/
MMAL_STATUS_T mmal_graph_component_constructor(const char *name,
   MMAL_COMPONENT_T *component)
{
   LOG_TRACE("name: %s, component: %p", name, component);
   return mmal_component_create_from_graph(name, component);
}

/*****************************************************************************/
static void graph_component_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_COMPONENT_T *graph_component = (MMAL_COMPONENT_T *)port->userdata;
   LOG_TRACE("%s(%p),%p,%4.4s", port->name, port, buffer, (char *)&buffer->cmd);

   /* Forward the event on the graph control port */
   mmal_port_event_send(graph_component->control, buffer);
}

/*****************************************************************************/
static void graph_component_connection_cb(MMAL_CONNECTION_T *connection)
{
   MMAL_COMPONENT_T *component = (MMAL_COMPONENT_T *)connection->user_data;
   mmal_component_action_trigger(component);
}

/*****************************************************************************/
static void graph_port_event_handler(MMAL_CONNECTION_T *connection,
   MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_STATUS_T status;

   LOG_TRACE("port: %s(%p), buffer: %p, event: %4.4s", port->name, port,
             buffer, (char *)&buffer->cmd);

   if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED && port->type == MMAL_PORT_TYPE_OUTPUT)
   {
      MMAL_EVENT_FORMAT_CHANGED_T *event = mmal_event_format_changed_get(buffer);
      if (event)
      {
         LOG_DEBUG("----------Port format changed----------");
         mmal_log_dump_port(port);
         LOG_DEBUG("-----------------to---------------------");
         mmal_log_dump_format(event->format);
         LOG_DEBUG(" buffers num (opt %i, min %i), size (opt %i, min: %i)",
                   event->buffer_num_recommended, event->buffer_num_min,
                   event->buffer_size_recommended, event->buffer_size_min);
         LOG_DEBUG("----------------------------------------");
      }

      status = mmal_connection_event_format_changed(connection, buffer);
   }

   else
      status = MMAL_SUCCESS; /* FIXME: ignore any other event for now */

   mmal_buffer_header_release(buffer);

   if (status != MMAL_SUCCESS)
      mmal_event_error_send(port->component, status);
}

/*****************************************************************************/
static MMAL_BOOL_T graph_do_processing(MMAL_GRAPH_PRIVATE_T *graph)
{
   MMAL_BUFFER_HEADER_T *buffer;
   MMAL_BOOL_T run_again = 0;
   MMAL_STATUS_T status;
   unsigned int i;

   /* Loop through all the connections */
   for (i = 0; i < graph->connection_num; i++)
   {
      MMAL_CONNECTION_T *connection = graph->connection[i];

      if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
         continue; /* Nothing else to do in tunnelling mode */

      /* Send any queued buffer to the next component */
      buffer = mmal_queue_get(connection->queue);
      while (buffer)
      {
         run_again = 1;

         if (buffer->cmd)
         {
            graph_port_event_handler(connection, connection->out, buffer);
            buffer = mmal_queue_get(connection->queue);
            continue;
         }

         status = mmal_port_send_buffer(connection->in, buffer);
         if (status != MMAL_SUCCESS)
         {
            LOG_ERROR("%s(%p) could not send buffer to %s(%p) (%s)",
                      connection->out->name, connection->out,
                      connection->in->name, connection->in,
                      mmal_status_to_string(status));
            mmal_buffer_header_release(buffer);
            mmal_event_error_send(connection->out->component, status);
         }
         buffer = mmal_queue_get(connection->queue);
      }

      /* Send empty buffers to the output port of the connection */
      buffer = connection->pool ? mmal_queue_get(connection->pool->queue) : NULL;
      while (buffer)
      {
         run_again = 1;

         status = mmal_port_send_buffer(connection->out, buffer);
         if (status != MMAL_SUCCESS)
         {
            LOG_ERROR("mmal_port_send_buffer failed (%i)", status);
            mmal_queue_put_back(connection->pool->queue, buffer);
            run_again = 0;
            // FIXME: send error ?
            break;
         }
         buffer = mmal_queue_get(connection->pool->queue);
      }
   }

   return run_again;
}

/*****************************************************************************/
static void graph_do_processing_loop(MMAL_COMPONENT_T *component)
{
   while (graph_do_processing((MMAL_GRAPH_PRIVATE_T *)component->priv->module));
}

/*****************************************************************************/
static MMAL_PORT_T *find_port_from_graph(MMAL_GRAPH_PRIVATE_T *graph, MMAL_PORT_T *port)
{
   MMAL_PORT_T **list;
   unsigned int *list_num;

   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
      return 0;

   list = port->type == MMAL_PORT_TYPE_INPUT ? graph->input : graph->output;
   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &graph->input_num : &graph->output_num;
   if (port->index > *list_num)
      return 0;

   return list[port->index];
}

static MMAL_PORT_T *find_port_to_graph(MMAL_GRAPH_PRIVATE_T *graph, MMAL_PORT_T *port)
{
   MMAL_COMPONENT_T *component = graph->graph_component;
   MMAL_PORT_T **list;
   unsigned int i, *list_num;

   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
      return 0;

   list = port->type == MMAL_PORT_TYPE_INPUT ? graph->input : graph->output;
   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &graph->input_num : &graph->output_num;

   for (i = 0; i < *list_num; i++)
      if (list[i] == port)
         break;

   if (i == *list_num)
      return 0;
   return port->type == MMAL_PORT_TYPE_INPUT ? component->input[i] : component->output[i];
}

static MMAL_STATUS_T graph_port_update(MMAL_GRAPH_PRIVATE_T *graph,
   MMAL_PORT_T *graph_port, MMAL_BOOL_T init)
{
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;

   port = find_port_from_graph(graph, graph_port);
   if (!port)
   {
      LOG_ERROR("could not find matching port for %p", graph_port);
      return MMAL_EINVAL;
   }

   status = mmal_format_full_copy(graph_port->format, port->format);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("format copy failed on port %s", port->name);
      return status;
   }

   graph_port->buffer_num_min = port->buffer_num_min;
   graph_port->buffer_num_recommended = port->buffer_num_recommended;
   graph_port->buffer_size_min = port->buffer_size_min;
   graph_port->buffer_size_recommended = port->buffer_size_recommended;
   graph_port->buffer_alignment_min = port->buffer_alignment_min;
   graph_port->capabilities = port->capabilities;
   if (init)
   {
      graph_port->buffer_num = port->buffer_num;
      graph_port->buffer_size = port->buffer_size;
   }
   return MMAL_SUCCESS;
}

static MMAL_STATUS_T graph_port_update_requirements(MMAL_GRAPH_PRIVATE_T *graph,
   MMAL_PORT_T *graph_port)
{
   MMAL_PORT_T *port;

   port = find_port_from_graph(graph, graph_port);
   if (!port)
   {
      LOG_ERROR("could not find matching port for %p", graph_port);
      return MMAL_EINVAL;
   }

   graph_port->buffer_num_min = port->buffer_num_min;
   graph_port->buffer_num_recommended = port->buffer_num_recommended;
   graph_port->buffer_size_min = port->buffer_size_min;
   graph_port->buffer_size_recommended = port->buffer_size_recommended;
   graph_port->buffer_alignment_min = port->buffer_alignment_min;
   return MMAL_SUCCESS;
}

/** Destroy a previously created component */
static MMAL_STATUS_T graph_component_destroy(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_MODULE_T *graph = component->priv->module;

   /* Notify client of destruction */
   if (graph->graph.pf_destroy)
      graph->graph.pf_destroy(&graph->graph);
   graph->graph.pf_destroy = NULL;

   if (component->input_num)
      mmal_ports_free(component->input, component->input_num);

   if (component->output_num)
      mmal_ports_free(component->output, component->output_num);

   /* coverity[address_free] Freeing the first item in the structure is safe */
   mmal_graph_destroy(&graph->graph);
   return MMAL_SUCCESS;
}

/** Enable processing on a component */
static MMAL_STATUS_T graph_component_enable(MMAL_COMPONENT_T *component)
{
   MMAL_PARAM_UNUSED(component);
   return MMAL_SUCCESS;
}

/** Disable processing on a component */
static MMAL_STATUS_T graph_component_disable(MMAL_COMPONENT_T *component)
{
   MMAL_PARAM_UNUSED(component);
   return MMAL_SUCCESS;
}

/** Callback given to mmal_port_enable() */
static void graph_port_enable_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = (MMAL_GRAPH_PRIVATE_T *)port->userdata;
   MMAL_PORT_T *graph_port;
   MMAL_STATUS_T status;

   graph_port = find_port_to_graph(graph_private, port);
   if (!graph_port)
   {
      vcos_assert(0);
      mmal_buffer_header_release(buffer);
      return;
   }

   /* Call user defined function first */
   if (graph_private->graph.pf_return_buffer)
   {
      status = graph_private->graph.pf_return_buffer(&graph_private->graph, graph_port, buffer);
      if (status != MMAL_ENOSYS)
         return;
   }

   /* Forward the callback */
   if (buffer->cmd)
      mmal_port_event_send(graph_port, buffer);
   else
      mmal_port_buffer_header_callback(graph_port, buffer);
}

/** Propagate a port enable */
static MMAL_STATUS_T graph_port_state_propagate(MMAL_GRAPH_PRIVATE_T *graph,
   MMAL_PORT_T *port, MMAL_BOOL_T enable)
{
   MMAL_COMPONENT_T *component = port->component;
   MMAL_STATUS_T status = MMAL_SUCCESS;
   MMAL_PORT_TYPE_T type = port->type;
   unsigned int i, j;

   LOG_TRACE("graph: %p, port %s(%p)", graph, port->name, port);

   if (port->type == MMAL_PORT_TYPE_OUTPUT)
      type = MMAL_PORT_TYPE_INPUT;
   if (port->type == MMAL_PORT_TYPE_INPUT)
      type = MMAL_PORT_TYPE_OUTPUT;

   /* Loop through all the output ports of the component and if they are not enabled and
    * match one of the connections we maintain, then we need to propagate the port enable. */
   for (i = 0; i < component->port_num; i++)
   {
      if (component->port[i]->type != type)
         continue;

      if ((component->port[i]->is_enabled && enable) ||
          (!component->port[i]->is_enabled && !enable))
         continue;

      /* Find the matching connection */
      for (j = 0; j < graph->connection_num; j++)
         if (graph->connection[j]->out == component->port[i] ||
             graph->connection[j]->in == component->port[i])
            break;

      if (j == graph->connection_num)
         continue; /* No match */

      if (enable)
      {
         status = mmal_connection_enable(graph->connection[j]);
         if (status != MMAL_SUCCESS)
            break;

         mmal_log_dump_port(graph->connection[j]->out);
         mmal_log_dump_port(graph->connection[j]->in);
      }

      status = graph_port_state_propagate(graph, graph->connection[j]->in == component->port[i] ?
         graph->connection[j]->out : graph->connection[j]->in, enable);
      if (status != MMAL_SUCCESS)
         break;

      if (!enable)
      {
         status = mmal_connection_disable(graph->connection[j]);
         if (status != MMAL_SUCCESS)
            break;
      }
   }

   return status;
}

/** Enable processing on a port */
static MMAL_STATUS_T graph_port_enable(MMAL_PORT_T *graph_port, MMAL_PORT_BH_CB_T cb)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_PORT_T *port;
   MMAL_STATUS_T status;
   MMAL_PARAM_UNUSED(cb);

   port = find_port_from_graph(graph_private, graph_port);
   if (!port)
      return MMAL_EINVAL;

   /* Update the buffer requirements */
   port->buffer_num = graph_port->buffer_num;
   port->buffer_size = graph_port->buffer_size;

   /* We'll intercept the callback */
   port->userdata = (void *)graph_private;
   status = mmal_port_enable(port, graph_port_enable_cb);
   if (status != MMAL_SUCCESS)
      return status;

   /* We need to enable all the connected connections */
   status = graph_port_state_propagate(graph_private, port, 1);

   mmal_component_action_trigger(graph_port->component);
   return status;
}

/** Disable processing on a port */
static MMAL_STATUS_T graph_port_disable(MMAL_PORT_T *graph_port)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_PORT_T *port;

   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
   if (!port)
      return MMAL_EINVAL;

   /* We need to disable all the connected connections.
    * Since disable does an implicit flush, we only want to do that if
    * we're acting on an input port or we risk discarding buffers along
    * the way. */
   if (!graph_private->input_num || port->type == MMAL_PORT_TYPE_INPUT)
   {
      MMAL_STATUS_T status = graph_port_state_propagate(graph_private, port, 0);
      if (status != MMAL_SUCCESS)
         return status;
   }

   /* Forward the call */
   return mmal_port_disable(port);
}

/** Propagate a port flush */
static MMAL_STATUS_T graph_port_flush_propagate(MMAL_GRAPH_PRIVATE_T *graph,
   MMAL_PORT_T *port)
{
   MMAL_COMPONENT_T *component = port->component;
   MMAL_STATUS_T status;
   unsigned int i, j;

   LOG_TRACE("graph: %p, port %s(%p)", graph, port->name, port);

   status = mmal_port_flush(port);
   if (status != MMAL_SUCCESS)
      return status;

   if (port->type == MMAL_PORT_TYPE_OUTPUT)
      return MMAL_SUCCESS;

   /* Loop through all the output ports of the component and if they match one
    * of the connections we maintain, then we need to propagate the flush. */
   for (i = 0; i < component->port_num; i++)
   {
      if (component->port[i]->type != MMAL_PORT_TYPE_OUTPUT)
         continue;
      if (!component->port[i]->is_enabled)
         continue;

      /* Find the matching connection */
      for (j = 0; j < graph->connection_num; j++)
         if (graph->connection[j]->out == component->port[i])
            break;

      if (j == graph->connection_num)
         continue; /* No match */

      /* Flush any buffer waiting in the connection queue */
      if (graph->connection[j]->queue)
      {
         MMAL_BUFFER_HEADER_T *buffer = mmal_queue_get(graph->connection[j]->queue);
         while(buffer)
         {
            mmal_buffer_header_release(buffer);
            buffer = mmal_queue_get(graph->connection[j]->queue);
         }
      }

      status = graph_port_flush_propagate(graph, graph->connection[j]->in);
      if (status != MMAL_SUCCESS)
         break;
   }

   return status;
}

/** Flush a port */
static MMAL_STATUS_T graph_port_flush(MMAL_PORT_T *graph_port)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;

   port = find_port_from_graph(graph_private, graph_port);
   if (!port)
      return MMAL_EINVAL;

   /* Call user defined function first */
   if (graph_private->graph.pf_flush)
   {
      status = graph_private->graph.pf_flush(&graph_private->graph, graph_port);
      if (status != MMAL_ENOSYS)
         return status;
   }

   /* Forward the call */
   return graph_port_flush_propagate(graph_private, port);
}

/** Send a buffer header to a port */
static MMAL_STATUS_T graph_port_send(MMAL_PORT_T *graph_port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;

   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
   if (!port)
      return MMAL_EINVAL;

   /* Call user defined function first */
   if (graph_private->graph.pf_send_buffer)
   {
      status = graph_private->graph.pf_send_buffer(&graph_private->graph, graph_port, buffer);
      if (status != MMAL_ENOSYS)
         return status;
   }

   /* Forward the call */
   return mmal_port_send_buffer(port, buffer);
}

/** Propagate a format change */
static MMAL_STATUS_T graph_port_format_commit_propagate(MMAL_GRAPH_PRIVATE_T *graph,
   MMAL_PORT_T *port)
{
   MMAL_COMPONENT_T *component = port->component;
   MMAL_STATUS_T status = MMAL_SUCCESS;
   unsigned int i, j;

   LOG_TRACE("graph: %p, port %s(%p)", graph, port->name, port);

   if (port->type == MMAL_PORT_TYPE_OUTPUT)
      return MMAL_SUCCESS; /* Nothing to do */

   /* Loop through all the output ports of the component and if they are not enabled and
    * match one of the connections we maintain, then we need to propagate the format change. */
   for (i = 0; i < component->output_num; i++)
   {
      MMAL_PORT_T *in, *out;

      if (component->output[i]->is_enabled)
         continue;

      /* Find the matching connection */
      for (j = 0; j < graph->connection_num; j++)
         if (graph->connection[j]->out == component->output[i])
            break;

      if (j == graph->connection_num)
         continue; /* No match */

      in = graph->connection[j]->in;
      out = graph->connection[j]->out;

      /* Apply the format to the input port */
      status = mmal_format_full_copy(in->format, out->format);
      if (status != MMAL_SUCCESS)
         break;
      status = mmal_port_format_commit(in);
      if (status != MMAL_SUCCESS)
         break;

      mmal_log_dump_port(out);
      mmal_log_dump_port(in);

      status = graph_port_format_commit_propagate(graph, in);
      if (status != MMAL_SUCCESS)
         break;
   }

   return status;
}

/** Set format on a port */
static MMAL_STATUS_T graph_port_format_commit(MMAL_PORT_T *graph_port)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;
   unsigned int i;

   /* Call user defined function first */
   if (graph_private->graph.pf_format_commit)
   {
      status = graph_private->graph.pf_format_commit(&graph_private->graph, graph_port);
      if (status == MMAL_SUCCESS)
         goto end;
      if (status != MMAL_ENOSYS)
         return status;
   }

   port = find_port_from_graph(graph_private, graph_port);
   if (!port)
      return MMAL_EINVAL;

   /* Update actual port */
   status = mmal_format_full_copy(port->format, graph_port->format);
   if (status != MMAL_SUCCESS)
      return status;
   port->buffer_num = graph_port->buffer_num;
   port->buffer_size = graph_port->buffer_size;

   /* Forward the call */
   status = mmal_port_format_commit(port);
   if (status != MMAL_SUCCESS)
      return status;

   /* Propagate format changes to the connections */
   status = graph_port_format_commit_propagate(graph_private, port);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("couldn't propagate format commit of port %s(%p)", port->name, port);
      return status;
   }

 end:
   /* Read the values back */
   status = graph_port_update(graph_private, graph_port, MMAL_FALSE);
   if (status != MMAL_SUCCESS)
      return status;

   /* Get the settings for the output ports in case they have changed */
   if (graph_port->type == MMAL_PORT_TYPE_INPUT)
   {
      for (i = 0; i < graph_private->output_num; i++)
      {
         status = graph_port_update(graph_private, graph_port->component->output[i], MMAL_FALSE);
         if (status != MMAL_SUCCESS)
            return status;
      }
   }

   return MMAL_SUCCESS;
}

static MMAL_STATUS_T graph_port_control_parameter_get(MMAL_PORT_T *graph_port,
   MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status = MMAL_ENOSYS;
   unsigned int i;

   /* Call user defined function first */
   if (graph_private->graph.pf_parameter_get)
   {
      status = graph_private->graph.pf_parameter_get(&graph_private->graph, graph_port, param);
      if (status != MMAL_ENOSYS)
         return status;
   }

   /* By default we do a get parameter on each component until one succeeds */
   for (i = 0; i < graph_private->component_num && status != MMAL_SUCCESS; i++)
      status = mmal_port_parameter_get(graph_private->component[i]->control, param);

   return status;
}

static MMAL_STATUS_T graph_port_parameter_get(MMAL_PORT_T *graph_port,
   MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;

   /* Call user defined function first */
   if (graph_private->graph.pf_parameter_get)
   {
      status = graph_private->graph.pf_parameter_get(&graph_private->graph, graph_port, param);
      if (status != MMAL_ENOSYS)
         return status;
   }

   port = find_port_from_graph(graph_private, graph_port);
   if (!port)
      return MMAL_EINVAL;

   /* Forward the call */
   return mmal_port_parameter_get(port, param);
}

static MMAL_STATUS_T graph_port_control_parameter_set(MMAL_PORT_T *graph_port,
   const MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status = MMAL_ENOSYS;
   unsigned int i;

   /* Call user defined function first */
   if (graph_private->graph.pf_parameter_set)
   {
      status = graph_private->graph.pf_parameter_set(&graph_private->graph, graph_port, param);
      if (status != MMAL_ENOSYS)
         return status;
   }

   /* By default we do a set parameter on each component until one succeeds */
   for (i = 0; i < graph_private->component_num && status != MMAL_SUCCESS; i++)
      status = mmal_port_parameter_set(graph_private->component[i]->control, param);

   return status;
}

static MMAL_STATUS_T graph_port_parameter_set(MMAL_PORT_T *graph_port,
   const MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;

   /* Call user defined function first */
   if (graph_private->graph.pf_parameter_set)
   {
      status = graph_private->graph.pf_parameter_set(&graph_private->graph, graph_port, param);
      if (status != MMAL_ENOSYS)
         return status;
   }

   port = find_port_from_graph(graph_private, graph_port);
   if (!port)
      return MMAL_EINVAL;

   /* Forward the call */
   status = mmal_port_parameter_set(port, param);
   if (status != MMAL_SUCCESS)
      goto end;

   if (param->id == MMAL_PARAMETER_BUFFER_REQUIREMENTS)
   {
      /* This might have changed the buffer requirements of other ports so fetch them all */
      MMAL_COMPONENT_T *component = graph_port->component;
      unsigned int i;
      for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
         status = graph_port_update_requirements(graph_private, component->input[i]);
      for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
         status = graph_port_update_requirements(graph_private, component->output[i]);
   }

 end:
   return status;
}

static MMAL_STATUS_T graph_port_connect(MMAL_PORT_T *graph_port, MMAL_PORT_T *other_port)
{
   MMAL_PORT_T *port;

   LOG_TRACE("%s(%p) %s(%p)", graph_port->name, graph_port, other_port->name, other_port);

   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
   if (!port)
      return MMAL_EINVAL;

   /* Forward the call */
   return other_port ? mmal_port_connect(port, other_port) : mmal_port_disconnect(port);
}

static uint8_t *graph_port_payload_alloc(MMAL_PORT_T *graph_port, uint32_t payload_size)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;
   uint8_t *payload;

   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
   if (!port)
      return 0;

   /* Call user defined function first */
   if (graph_private->graph.pf_payload_alloc)
   {
      status = graph_private->graph.pf_payload_alloc(&graph_private->graph, graph_port,
         payload_size, &payload);
      if (status != MMAL_ENOSYS)
         return status == MMAL_SUCCESS ? payload : NULL;
   }

   /* Forward the call */
   return mmal_port_payload_alloc(port, payload_size);
}

static void graph_port_payload_free(MMAL_PORT_T *graph_port, uint8_t *payload)
{
   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;

   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
   if (!port)
      return;

   /* Call user defined function first */
   if (graph_private->graph.pf_payload_free)
   {
      status = graph_private->graph.pf_payload_free(&graph_private->graph, graph_port, payload);
      if (status == MMAL_SUCCESS)
         return;
   }

   /* Forward the call */
   mmal_port_payload_free(port, payload);
}

/** Create an instance of a component  */
static MMAL_STATUS_T mmal_component_create_from_graph(const char *name, MMAL_COMPONENT_T *component)
{
   MMAL_STATUS_T status = MMAL_ENOMEM;
   /* Our context is already allocated and available */
   MMAL_GRAPH_PRIVATE_T *graph = component->priv->module;
   unsigned int i;
   MMAL_PARAM_UNUSED(name);

   component->control->priv->pf_parameter_get = graph_port_control_parameter_get;
   component->control->priv->pf_parameter_set = graph_port_control_parameter_set;

   /* Allocate the ports for this component */
   if(graph->input_num)
   {
      component->input = mmal_ports_alloc(component, graph->input_num, MMAL_PORT_TYPE_INPUT, 0);
      if(!component->input)
         goto error;
   }
   component->input_num = graph->input_num;
   for(i = 0; i < component->input_num; i++)
   {
      component->input[i]->priv->pf_enable = graph_port_enable;
      component->input[i]->priv->pf_disable = graph_port_disable;
      component->input[i]->priv->pf_flush = graph_port_flush;
      component->input[i]->priv->pf_send = graph_port_send;
      component->input[i]->priv->pf_set_format = graph_port_format_commit;
      component->input[i]->priv->pf_parameter_get = graph_port_parameter_get;
      component->input[i]->priv->pf_parameter_set = graph_port_parameter_set;
      if (graph->input[i]->priv->pf_connect && 0 /* FIXME: disabled for now */)
         component->input[i]->priv->pf_connect = graph_port_connect;
      component->input[i]->priv->pf_payload_alloc = graph_port_payload_alloc;
      component->input[i]->priv->pf_payload_free = graph_port_payload_free;

      /* Mirror the port values */
      status = graph_port_update(graph, component->input[i], MMAL_TRUE);
      if (status != MMAL_SUCCESS)
         goto error;
   }
   if(graph->output_num)
   {
      component->output = mmal_ports_alloc(component, graph->output_num, MMAL_PORT_TYPE_OUTPUT, 0);
      if(!component->output)
         goto error;
   }
   component->output_num = graph->output_num;
   for(i = 0; i < component->output_num; i++)
   {
      component->output[i]->priv->pf_enable = graph_port_enable;
      component->output[i]->priv->pf_disable = graph_port_disable;
      component->output[i]->priv->pf_flush = graph_port_flush;
      component->output[i]->priv->pf_send = graph_port_send;
      component->output[i]->priv->pf_set_format = graph_port_format_commit;
      component->output[i]->priv->pf_parameter_get = graph_port_parameter_get;
      component->output[i]->priv->pf_parameter_set = graph_port_parameter_set;
      if (graph->output[i]->priv->pf_connect && 0 /* FIXME: disabled for now */)
         component->output[i]->priv->pf_connect = graph_port_connect;
      component->output[i]->priv->pf_payload_alloc = graph_port_payload_alloc;
      component->output[i]->priv->pf_payload_free = graph_port_payload_free;

      /* Mirror the port values */
      status = graph_port_update(graph, component->output[i], MMAL_TRUE);
      if (status != MMAL_SUCCESS)
         goto error;
   }

   status = mmal_component_action_register(component, graph_do_processing_loop);
   if (status != MMAL_SUCCESS)
      goto error;

#if 1 // FIXME
   /* Set our connection callback */
   for (i = 0; i < graph->connection_num; i++)
   {
      graph->connection[i]->callback = graph_component_connection_cb;
      graph->connection[i]->user_data = (void *)component;
   }
#endif

   component->priv->pf_destroy = graph_component_destroy;
   component->priv->pf_enable = graph_component_enable;
   component->priv->pf_disable = graph_component_disable;
   graph->graph_component = component;

   /* Enable all the control ports */
   for (i = 0; i < graph->component_num; i++)
   {
      graph->component[i]->control->userdata = (void *)component;
      status = mmal_port_enable(graph->component[i]->control, graph_component_control_cb);
      if (status != MMAL_SUCCESS)
         LOG_ERROR("could not enable port %s", component->control->name);
   }

   return MMAL_SUCCESS;

 error:
   graph_component_destroy(component);
   return status;
}

MMAL_PORT_T *mmal_graph_find_port(MMAL_GRAPH_T *graph,
                                  const char *name,
                                  MMAL_PORT_TYPE_T type,
                                  unsigned index)
{
   unsigned i;
   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
   for (i=0; i<private->component_num; i++)
   {
      MMAL_COMPONENT_T *comp = private->component[i];
      if (vcos_strcasecmp(name, comp->name) == 0)
      {
         unsigned num;
         MMAL_PORT_T **ports;
         if (type == MMAL_PORT_TYPE_INPUT) {
            num = comp->input_num;
            ports = comp->input;
         }
         else if (type == MMAL_PORT_TYPE_OUTPUT) {
            num = comp->output_num;
            ports = comp->output;
         }
         else if (type == MMAL_PORT_TYPE_CONTROL) {
            num = 1;
            ports = &comp->control;
         }
         else {
            vcos_assert(0);
            return NULL;
         }
         if (index < num)
         {
            return ports[index];
         }
      }
   }
   LOG_INFO("port %s:%d not found", name, index);
   return NULL;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_GRAPH_H
#define MMAL_GRAPH_H

#include "util/mmal_connection.h"

/** \defgroup MmalGraphUtility Graph Utility
 * \ingroup MmalUtilities
 * The graph utility functions allows one to easily create graphs of MMAL components.
 *
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** Structure describing a graph */
typedef struct MMAL_GRAPH_T
{
   /** Pointer to private data of the client */
   struct MMAL_GRAPH_USERDATA_T *userdata;

   /** Optional callback that the client can set to get notified when the graph is going to be destroyed */
   void (*pf_destroy)(struct MMAL_GRAPH_T *);

   /** Optional callback that the client can set to intercept parameter requests on ports exposed by the graph */
   MMAL_STATUS_T (*pf_parameter_set)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param);
   /** Optional callback that the client can set to intercept parameter requests on ports exposed by the graph */
   MMAL_STATUS_T (*pf_parameter_get)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param);
   /** Optional callback that the client can set to intercept format commit calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_format_commit)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
   /** Optional callback that the client can set to intercept send buffer calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_send_buffer)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
   /** Optional callback that the client can set to intercept buffer callbacks on ports exposed by the graph */
   MMAL_STATUS_T (*pf_return_buffer)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
   /** Optional callback that the client can set to intercept payload alloc calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_payload_alloc)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, uint32_t payload_size, uint8_t **);
   /** Optional callback that the client can set to intercept payload free calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_payload_free)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, uint8_t *payload);
   /** Optional callback that the client can set to intercept flush calls on ports exposed by the graph */
   MMAL_STATUS_T (*pf_flush)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);

} MMAL_GRAPH_T;

/** Create an instance of a graph.
 * The newly created graph will need to be populated by the client.
 *
 * @param graph returned graph
 * @param userdata_size size to be allocated for the userdata field
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_create(MMAL_GRAPH_T **graph, unsigned int userdata_size);

/** Add a component to a graph.
 * Allows the client to add a component to the graph.
 *
 * @param graph instance of the graph
 * @param component component to add to a graph
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_add_component(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component);

/** Add a port to a graph.
 * Allows the client to add an input or output port to a graph. The given port
 * will effectively become an end point for the graph.
 *
 * @param graph instance of the graph
 * @param port port to add to the graph
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_add_port(MMAL_GRAPH_T *graph, MMAL_PORT_T *port);

/** Add a connection to a graph.
 * Allows the client to add an internal connection to a graph.
 *
 * @param graph instance of the graph
 * @param connection connection to add to the graph
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_add_connection(MMAL_GRAPH_T *graph, MMAL_CONNECTION_T *connection);

/** Create a new component and add it to a graph.
 * Allows the client to create and add a component to the graph.
 *
 * @param graph instance of the graph
 * @param name name of the component to create
 * @param component if not NULL, will contain a pointer to the created component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_new_component(MMAL_GRAPH_T *graph, const char *name,
   MMAL_COMPONENT_T **component);

/** Create and add a connection to a graph.
 * Allows the client to create and add an internal connection to a graph.
 *
 * @param graph      instance of the graph
 * @param out        the output port to use for the connection
 * @param in         the input port to use for the connection
 * @param flags      the flags specifying which type of connection should be created
 * @param connection if not NULL, will contain a pointer to the created connection
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_new_connection(MMAL_GRAPH_T *graph, MMAL_PORT_T *out, MMAL_PORT_T *in,
   uint32_t flags, MMAL_CONNECTION_T **connection);

/** Definition of the callback used by a graph to send events to the client.
 *
 * @param graph   the graph sending the event
 * @param port    the port which generated the event
 * @param buffer  the buffer header containing the event data
 * @param cb_data data passed back to the client when the callback is invoked
 */
typedef void (*MMAL_GRAPH_EVENT_CB)(MMAL_GRAPH_T *graph, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer,
   void *cb_data);

/** Enable the graph and start processing.
 *
 * @param graph   the graph to enable
 * @param cb      the callback to invoke when an event occurs on any of the internal control ports
 * @param cb_data data passed back to the client when the callback is invoked
 *
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_enable(MMAL_GRAPH_T *graph, MMAL_GRAPH_EVENT_CB cb, void *cb_data);

MMAL_STATUS_T mmal_graph_disable(MMAL_GRAPH_T *graph);

/** Find a port in the graph.
 *
 * @param graph graph instance
 * @param name  name of the component of interest
 * @param type  type of port (in/out)
 * @param index which port index within the component
 *
 * @return port, or NULL if not found
 */
MMAL_PORT_T *mmal_graph_find_port(MMAL_GRAPH_T *graph,
                                  const char *name,
                                  MMAL_PORT_TYPE_T type,
                                  unsigned index);

/** Create an instance of a component from a graph.
 * The newly created component will expose input and output ports to the client.
 * Not that all the exposed ports will be in a disabled state by default.
 *
 * @param graph graph to create the component from
 * @param name name of the component to create
 * @param component returned component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_build(MMAL_GRAPH_T *ctx,
   const char *name, MMAL_COMPONENT_T **component);

/** Component constructor for a graph.
 * FIXME: private function
 *
 * @param name name of the component to create
 * @param component component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_component_constructor(const char *name, MMAL_COMPONENT_T *component);

/** Destroy a previously created graph
 * @param graph graph to destroy
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_graph_destroy(MMAL_GRAPH_T *ctx);

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* MMAL_GRAPH_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal.h"
#include "util/mmal_il.h"
#include "interface/vmcs_host/khronos/IL/OMX_Broadcom.h"

/*****************************************************************************/
static struct {
   MMAL_STATUS_T mmal;
   OMX_ERRORTYPE omx;
} mmal_omx_error[] =
{
   {MMAL_SUCCESS, OMX_ErrorNone},
   {MMAL_ENOMEM, OMX_ErrorInsufficientResources},
   {MMAL_ENOSPC, OMX_ErrorInsufficientResources},
   {MMAL_EINVAL, OMX_ErrorBadParameter},
   {MMAL_ENOSYS, OMX_ErrorNotImplemented},
   {(MMAL_STATUS_T)-1, OMX_ErrorUndefined},
};

OMX_ERRORTYPE mmalil_error_to_omx(MMAL_STATUS_T status)
{
   unsigned int i;
   for(i = 0; mmal_omx_error[i].mmal != (MMAL_STATUS_T)-1; i++)
      if(mmal_omx_error[i].mmal == status) break;
   return mmal_omx_error[i].omx;
}

MMAL_STATUS_T mmalil_error_to_mmal(OMX_ERRORTYPE error)
{
   unsigned int i;
   for(i = 0; mmal_omx_error[i].mmal != (MMAL_STATUS_T)-1; i++)
      if(mmal_omx_error[i].omx == error) break;
   return mmal_omx_error[i].mmal;
}

/*****************************************************************************/
OMX_U32 mmalil_buffer_flags_to_omx(uint32_t flags)
{
   OMX_U32 omx_flags = 0;

   if(flags & MMAL_BUFFER_HEADER_FLAG_KEYFRAME)
      omx_flags |= OMX_BUFFERFLAG_SYNCFRAME;
   if(flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END)
      omx_flags |= OMX_BUFFERFLAG_ENDOFFRAME;
   if(flags & MMAL_BUFFER_HEADER_FLAG_EOS)
      omx_flags |= OMX_BUFFERFLAG_EOS;
   if(flags & MMAL_BUFFER_HEADER_FLAG_CONFIG)
      omx_flags |= OMX_BUFFERFLAG_CODECCONFIG;
   if(flags & MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY)
      omx_flags |= OMX_BUFFERFLAG_DISCONTINUITY;
   if (flags & MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO)
      omx_flags |= OMX_BUFFERFLAG_CODECSIDEINFO;
   if (flags & MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT)
      omx_flags |= OMX_BUFFERFLAG_CAPTURE_PREVIEW;
   if (flags & MMAL_BUFFER_HEADER_FLAG_CORRUPTED)
      omx_flags |= OMX_BUFFERFLAG_DATACORRUPT;

   return omx_flags;
}

uint32_t mmalil_buffer_flags_to_mmal(OMX_U32 flags)
{
   uint32_t mmal_flags = 0;

   if (flags & OMX_BUFFERFLAG_SYNCFRAME)
      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_KEYFRAME;
   if (flags & OMX_BUFFERFLAG_ENDOFFRAME)
      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
   if (flags & OMX_BUFFERFLAG_EOS)
      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_EOS;
   if (flags & OMX_BUFFERFLAG_CODECCONFIG)
      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;
   if (flags & OMX_BUFFERFLAG_DISCONTINUITY)
      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY;
   if (flags & OMX_BUFFERFLAG_CODECSIDEINFO)
      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO;
   if (flags & OMX_BUFFERFLAG_CAPTURE_PREVIEW)
      mmal_flags |= MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT;
   if (flags & OMX_BUFFERFLAG_DATACORRUPT)
      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_CORRUPTED;

   return mmal_flags;
}

/*****************************************************************************/
void mmalil_buffer_header_to_omx(OMX_BUFFERHEADERTYPE *omx, MMAL_BUFFER_HEADER_T *mmal)
{
   omx->pBuffer = mmal->data;
   omx->nAllocLen = mmal->alloc_size;
   omx->nFilledLen = mmal->length;
   omx->nOffset = mmal->offset;
   omx->nFlags = mmalil_buffer_flags_to_omx(mmal->flags);
   omx->nTimeStamp = omx_ticks_from_s64(mmal->pts);
   if (mmal->pts == MMAL_TIME_UNKNOWN)
   {
      omx->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
      omx->nTimeStamp = omx_ticks_from_s64(0);
   }
}

void mmalil_buffer_header_to_mmal(MMAL_BUFFER_HEADER_T *mmal, OMX_BUFFERHEADERTYPE *omx)
{
   mmal->cmd = 0;
   mmal->data = omx->pBuffer;
   mmal->alloc_size = omx->nAllocLen;
   mmal->length = omx->nFilledLen;
   mmal->offset = omx->nOffset;
   mmal->pts = omx_ticks_to_s64(omx->nTimeStamp);
   if (omx->nFlags & OMX_BUFFERFLAG_TIME_UNKNOWN)
      mmal->pts = MMAL_TIME_UNKNOWN;
   mmal->dts = MMAL_TIME_UNKNOWN;
   mmal->flags = mmalil_buffer_flags_to_mmal(omx->nFlags);
}

/*****************************************************************************/
static struct {
   MMAL_ES_TYPE_T type;
   OMX_PORTDOMAINTYPE domain;
} mmal_omx_es_type_table[] =
{
   {MMAL_ES_TYPE_VIDEO,           OMX_PortDomainVideo},
   {MMAL_ES_TYPE_VIDEO,           OMX_PortDomainImage},
   {MMAL_ES_TYPE_AUDIO,           OMX_PortDomainAudio},
   {MMAL_ES_TYPE_UNKNOWN,         OMX_PortDomainMax}
};

OMX_PORTDOMAINTYPE mmalil_es_type_to_omx_domain(MMAL_ES_TYPE_T type)
{
   unsigned int i;
   for(i = 0; mmal_omx_es_type_table[i].type != MMAL_ES_TYPE_UNKNOWN; i++)
      if(mmal_omx_es_type_table[i].type == type) break;
   return mmal_omx_es_type_table[i].domain;
}

MMAL_ES_TYPE_T mmalil_omx_domain_to_es_type(OMX_PORTDOMAINTYPE domain)
{
   unsigned int i;
   for(i = 0; mmal_omx_es_type_table[i].type != MMAL_ES_TYPE_UNKNOWN; i++)
      if(mmal_omx_es_type_table[i].domain == domain) break;
   return mmal_omx_es_type_table[i].type;
}

/*****************************************************************************/
static struct {
   uint32_t encoding;
   OMX_AUDIO_CODINGTYPE coding;
} mmal_omx_audio_coding_table[] =
{
   {MMAL_ENCODING_MP4A,           OMX_AUDIO_CodingAAC},
   {MMAL_ENCODING_MPGA,           OMX_AUDIO_CodingMP3},
   {MMAL_ENCODING_WMA2,           OMX_AUDIO_CodingWMA},
   {MMAL_ENCODING_WMA1,           OMX_AUDIO_CodingWMA},
   {MMAL_ENCODING_AMRNB,          OMX_AUDIO_CodingAMR},
   {MMAL_ENCODING_AMRWB,          OMX_AUDIO_CodingAMR},
   {MMAL_ENCODING_AMRWBP,         OMX_AUDIO_CodingAMR},
   {MMAL_ENCODING_VORBIS,         OMX_AUDIO_CodingVORBIS},
   {MMAL_ENCODING_ALAW,           OMX_AUDIO_CodingPCM},
   {MMAL_ENCODING_MULAW,          OMX_AUDIO_CodingPCM},
   {MMAL_ENCODING_PCM_SIGNED_LE,  OMX_AUDIO_CodingPCM},
   {MMAL_ENCODING_PCM_UNSIGNED_LE,OMX_AUDIO_CodingPCM},
   {MMAL_ENCODING_PCM_SIGNED_BE,  OMX_AUDIO_CodingPCM},
   {MMAL_ENCODING_PCM_UNSIGNED_BE,OMX_AUDIO_CodingPCM},
   {MMAL_ENCODING_UNKNOWN,        OMX_AUDIO_CodingUnused}
};

uint32_t mmalil_omx_audio_coding_to_encoding(OMX_AUDIO_CODINGTYPE coding)
{
   unsigned int i;
   for(i = 0; mmal_omx_audio_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(mmal_omx_audio_coding_table[i].coding == coding) break;
   return mmal_omx_audio_coding_table[i].encoding;
}

OMX_AUDIO_CODINGTYPE mmalil_encoding_to_omx_audio_coding(uint32_t encoding)
{
   unsigned int i;
   for(i = 0; mmal_omx_audio_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(mmal_omx_audio_coding_table[i].encoding == encoding) break;
   return mmal_omx_audio_coding_table[i].coding;
}

static struct {
   OMX_AUDIO_CODINGTYPE coding;
   OMX_INDEXTYPE index;
   unsigned int size;
} mmal_omx_audio_format_table[] =
{
   {OMX_AUDIO_CodingPCM, OMX_IndexParamAudioPcm, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE)},
   {OMX_AUDIO_CodingADPCM, OMX_IndexParamAudioAdpcm, sizeof(OMX_AUDIO_PARAM_ADPCMTYPE)},
   {OMX_AUDIO_CodingAMR, OMX_IndexParamAudioAmr, sizeof(OMX_AUDIO_PARAM_AMRTYPE)},
   {OMX_AUDIO_CodingGSMFR, OMX_IndexParamAudioGsm_FR, sizeof(OMX_AUDIO_PARAM_GSMFRTYPE)},
   {OMX_AUDIO_CodingGSMEFR, OMX_IndexParamAudioGsm_EFR, sizeof(OMX_AUDIO_PARAM_GSMEFRTYPE)},
   {OMX_AUDIO_CodingGSMHR, OMX_IndexParamAudioGsm_HR, sizeof(OMX_AUDIO_PARAM_GSMHRTYPE)},
   {OMX_AUDIO_CodingPDCFR, OMX_IndexParamAudioPdc_FR, sizeof(OMX_AUDIO_PARAM_PDCFRTYPE)},
   {OMX_AUDIO_CodingPDCEFR, OMX_IndexParamAudioPdc_EFR, sizeof(OMX_AUDIO_PARAM_PDCEFRTYPE)},
   {OMX_AUDIO_CodingPDCHR, OMX_IndexParamAudioPdc_HR, sizeof(OMX_AUDIO_PARAM_PDCHRTYPE)},
   {OMX_AUDIO_CodingTDMAFR, OMX_IndexParamAudioTdma_FR, sizeof(OMX_AUDIO_PARAM_TDMAFRTYPE)},
   {OMX_AUDIO_CodingTDMAEFR, OMX_IndexParamAudioTdma_EFR, sizeof(OMX_AUDIO_PARAM_TDMAEFRTYPE)},
   {OMX_AUDIO_CodingQCELP8, OMX_IndexParamAudioQcelp8, sizeof(OMX_AUDIO_PARAM_QCELP8TYPE)},
   {OMX_AUDIO_CodingQCELP13, OMX_IndexParamAudioQcelp13, sizeof(OMX_AUDIO_PARAM_QCELP13TYPE)},
   {OMX_AUDIO_CodingEVRC, OMX_IndexParamAudioEvrc, sizeof(OMX_AUDIO_PARAM_EVRCTYPE)},
   {OMX_AUDIO_CodingSMV, OMX_IndexParamAudioSmv, sizeof(OMX_AUDIO_PARAM_SMVTYPE)},
   {OMX_AUDIO_CodingG723, OMX_IndexParamAudioG723, sizeof(OMX_AUDIO_PARAM_G723TYPE)},
   {OMX_AUDIO_CodingG726, OMX_IndexParamAudioG726, sizeof(OMX_AUDIO_PARAM_G726TYPE)},
   {OMX_AUDIO_CodingG729, OMX_IndexParamAudioG729, sizeof(OMX_AUDIO_PARAM_G729TYPE)},
   {OMX_AUDIO_CodingAAC, OMX_IndexParamAudioAac, sizeof(OMX_AUDIO_PARAM_AACPROFILETYPE)},
   {OMX_AUDIO_CodingMP3, OMX_IndexParamAudioMp3, sizeof(OMX_AUDIO_PARAM_MP3TYPE)},
   {OMX_AUDIO_CodingSBC, OMX_IndexParamAudioSbc, sizeof(OMX_AUDIO_PARAM_SBCTYPE)},
   {OMX_AUDIO_CodingVORBIS, OMX_IndexParamAudioVorbis, sizeof(OMX_AUDIO_PARAM_VORBISTYPE)},
   {OMX_AUDIO_CodingWMA, OMX_IndexParamAudioWma, sizeof(OMX_AUDIO_PARAM_WMATYPE)},
   {OMX_AUDIO_CodingRA, OMX_IndexParamAudioRa, sizeof(OMX_AUDIO_PARAM_RATYPE)},
   {OMX_AUDIO_CodingMIDI, OMX_IndexParamAudioMidi, sizeof(OMX_AUDIO_PARAM_MIDITYPE)},
   {OMX_AUDIO_CodingUnused, 0, 0}
};

OMX_INDEXTYPE mmalil_omx_audio_param_index(OMX_AUDIO_CODINGTYPE coding, OMX_U32 *size)
{
   unsigned int i;
   for(i = 0; mmal_omx_audio_format_table[i].coding != OMX_AUDIO_CodingUnused; i++)
      if(mmal_omx_audio_format_table[i].coding == coding) break;

   if(size) *size = mmal_omx_audio_format_table[i].size;
   return mmal_omx_audio_format_table[i].index;
}

MMAL_FOURCC_T mmalil_omx_audio_param_to_format(MMAL_ES_FORMAT_T *format,
   OMX_AUDIO_CODINGTYPE coding, OMX_FORMAT_PARAM_TYPE *param)
{
   MMAL_AUDIO_FORMAT_T *audio = &format->es->audio;
   format->encoding = MMAL_ENCODING_UNKNOWN;

   switch(coding)
   {
   case OMX_AUDIO_CodingPCM:
      audio->channels = param->pcm.nChannels;
      audio->sample_rate = param->pcm.nSamplingRate;
      audio->bits_per_sample = param->pcm.nBitPerSample;
      if(param->pcm.ePCMMode == OMX_AUDIO_PCMModeLinear && param->pcm.bInterleaved)
      {
         if(param->pcm.eEndian == OMX_EndianBig &&
            param->pcm.eNumData == OMX_NumericalDataSigned)
            format->encoding = MMAL_ENCODING_PCM_SIGNED_BE;
         else if(param->pcm.eEndian == OMX_EndianLittle &&
            param->pcm.eNumData == OMX_NumericalDataSigned)
            format->encoding = MMAL_ENCODING_PCM_SIGNED_LE;
         if(param->pcm.eEndian == OMX_EndianBig &&
            param->pcm.eNumData == OMX_NumericalDataUnsigned)
            format->encoding = MMAL_ENCODING_PCM_UNSIGNED_BE;
         if(param->pcm.eEndian == OMX_EndianLittle &&
            param->pcm.eNumData == OMX_NumericalDataUnsigned)
            format->encoding = MMAL_ENCODING_PCM_UNSIGNED_LE;
      }
      else if(param->pcm.ePCMMode == OMX_AUDIO_PCMModeALaw)
         format->encoding = MMAL_ENCODING_ALAW;
      else if(param->pcm.ePCMMode == OMX_AUDIO_PCMModeMULaw)
         format->encoding = MMAL_ENCODING_MULAW;
      break;
   case OMX_AUDIO_CodingAAC:
      audio->channels = param->aac.nChannels;
      audio->sample_rate = param->aac.nSampleRate;
      format->bitrate = param->aac.nBitRate;
      switch(param->aac.eAACStreamFormat)
      {
      case OMX_AUDIO_AACStreamFormatMP2ADTS:
      case OMX_AUDIO_AACStreamFormatMP4ADTS:
         format->encoding = MMAL_ENCODING_MP4A;
         format->encoding_variant = MMAL_ENCODING_VARIANT_MP4A_ADTS;
         break;
      case OMX_AUDIO_AACStreamFormatMP4FF:
      case OMX_AUDIO_AACStreamFormatRAW:
         format->encoding = MMAL_ENCODING_MP4A;
         format->encoding_variant = MMAL_ENCODING_VARIANT_MP4A_DEFAULT;
         break;
      default: break;
      }
      break;
   case OMX_AUDIO_CodingMP3:
      format->encoding = MMAL_ENCODING_MPGA;
      audio->channels = param->mp3.nChannels;
      audio->sample_rate = param->mp3.nSampleRate;
      format->bitrate = param->mp3.nBitRate;
      break;
   case OMX_AUDIO_CodingWMA:
      audio->channels = param->wma.nChannels;
      audio->sample_rate = param->wma.nSamplingRate;
      audio->block_align = param->wma.nBlockAlign;
      format->bitrate = param->wma.nBitRate;
      switch(param->wma.eFormat)
      {
      case OMX_AUDIO_WMAFormat7:
         format->encoding = MMAL_ENCODING_WMA1;
         break;
      case OMX_AUDIO_WMAFormat8:
      case OMX_AUDIO_WMAFormat9:
         format->encoding = MMAL_ENCODING_WMA2;
         break;
      default: break;
      }
      break;
   case OMX_AUDIO_CodingVORBIS:
      format->encoding = MMAL_ENCODING_VORBIS;
      audio->channels = param->vorbis.nChannels;
      audio->sample_rate = param->vorbis.nSampleRate;
      format->bitrate = param->vorbis.nBitRate;
      break;
   case OMX_AUDIO_CodingAMR:
      audio->channels = param->amr.nChannels;
      audio->sample_rate = 8000;
      format->bitrate = param->amr.nBitRate;
      if(param->amr.eAMRBandMode >= OMX_AUDIO_AMRBandModeNB0 &&
         param->amr.eAMRBandMode <= OMX_AUDIO_AMRBandModeNB7)
         format->encoding = MMAL_ENCODING_AMRNB;
      if(param->amr.eAMRBandMode >= OMX_AUDIO_AMRBandModeWB0 &&
         param->amr.eAMRBandMode <= OMX_AUDIO_AMRBandModeWB8)
         format->encoding = MMAL_ENCODING_AMRWB;
      break;
   case OMX_AUDIO_CodingADPCM:
   case OMX_AUDIO_CodingGSMFR:
   case OMX_AUDIO_CodingGSMEFR:
   case OMX_AUDIO_CodingGSMHR:
   case OMX_AUDIO_CodingPDCFR:
   case OMX_AUDIO_CodingPDCEFR:
   case OMX_AUDIO_CodingPDCHR:
   case OMX_AUDIO_CodingTDMAFR:
   case OMX_AUDIO_CodingTDMAEFR:
   case OMX_AUDIO_CodingQCELP8:
   case OMX_AUDIO_CodingQCELP13:
   case OMX_AUDIO_CodingEVRC:
   case OMX_AUDIO_CodingSMV:
   case OMX_AUDIO_CodingG711:
   case OMX_AUDIO_CodingG723:
   case OMX_AUDIO_CodingG726:
   case OMX_AUDIO_CodingG729:
   case OMX_AUDIO_CodingSBC:
   case OMX_AUDIO_CodingRA:
   case OMX_AUDIO_CodingMIDI:
   default:
      vcos_assert(0);
      break;
   }

   return format->encoding;
}

OMX_AUDIO_CODINGTYPE mmalil_format_to_omx_audio_param(OMX_FORMAT_PARAM_TYPE *param,
   OMX_INDEXTYPE *param_index, MMAL_ES_FORMAT_T *format)
{
   MMAL_AUDIO_FORMAT_T *audio = &format->es->audio;
   OMX_AUDIO_CODINGTYPE coding = mmalil_encoding_to_omx_audio_coding(format->encoding);
   OMX_U32 size = 0;
   OMX_INDEXTYPE index = mmalil_omx_audio_param_index(coding, &size);

   if(param_index) *param_index = index;
   memset(param, 0, size);
   param->common.nSize = size;

   switch(coding)
   {
   case OMX_AUDIO_CodingPCM:
      param->pcm.nChannels = audio->channels;
      param->pcm.nSamplingRate = audio->sample_rate;
      param->pcm.nBitPerSample = audio->bits_per_sample;
      if(audio->channels == 1)
      {
         param->pcm.eChannelMapping[0] = OMX_AUDIO_ChannelCF;
      }
      else if(audio->channels == 2)
      {
         param->pcm.eChannelMapping[0] = OMX_AUDIO_ChannelLF;
         param->pcm.eChannelMapping[1] = OMX_AUDIO_ChannelRF;
      }
      if(format->encoding == MMAL_ENCODING_PCM_SIGNED_BE ||
         format->encoding == MMAL_ENCODING_PCM_SIGNED_LE ||
         format->encoding == MMAL_ENCODING_PCM_UNSIGNED_BE ||
         format->encoding == MMAL_ENCODING_PCM_UNSIGNED_LE)
      {
         param->pcm.ePCMMode = OMX_AUDIO_PCMModeLinear;
         param->pcm.bInterleaved = OMX_TRUE;
         param->pcm.eEndian = OMX_EndianLittle;
         param->pcm.eNumData = OMX_NumericalDataSigned;
         if(format->encoding == MMAL_ENCODING_PCM_SIGNED_BE ||
            format->encoding == MMAL_ENCODING_PCM_UNSIGNED_BE)
            param->pcm.eEndian = OMX_EndianBig;
         if(format->encoding == MMAL_ENCODING_PCM_UNSIGNED_LE ||
            format->encoding == MMAL_ENCODING_PCM_UNSIGNED_BE)
            param->pcm.eNumData = OMX_NumericalDataUnsigned;
      }
      else if(format->encoding == MMAL_ENCODING_ALAW)
         param->pcm.ePCMMode = OMX_AUDIO_PCMModeALaw;
      else if(format->encoding == MMAL_ENCODING_MULAW)
         param->pcm.ePCMMode = OMX_AUDIO_PCMModeMULaw;
      break;
   case OMX_AUDIO_CodingAAC:
      param->aac.nChannels = audio->channels;
      param->aac.nSampleRate = audio->sample_rate;
      param->aac.nBitRate = format->bitrate;
      switch(format->encoding_variant)
      {
      case MMAL_ENCODING_VARIANT_MP4A_ADTS:
         param->aac.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4ADTS;
         break;
      case MMAL_ENCODING_VARIANT_MP4A_DEFAULT:
         param->aac.eAACStreamFormat = OMX_AUDIO_AACStreamFormatRAW;
         break;
      default: break;
      }
      break;
   case OMX_AUDIO_CodingMP3:
      param->mp3.nChannels = audio->channels;
      param->mp3.nSampleRate = audio->sample_rate;
      param->mp3.nBitRate = format->bitrate;
      break;
   case OMX_AUDIO_CodingWMA:
      param->wma.nChannels = audio->channels;
      param->wma.nSamplingRate = audio->sample_rate;
      param->wma.nBlockAlign = audio->block_align;
      param->wma.nBitRate = format->bitrate;
      switch(format->encoding)
      {
      case MMAL_ENCODING_WMA1:
         param->wma.eFormat = OMX_AUDIO_WMAFormat7;
         break;
      case MMAL_ENCODING_WMA2:
         param->wma.eFormat = OMX_AUDIO_WMAFormat8;
         break;
      default: break;
      }
      break;
   case OMX_AUDIO_CodingVORBIS:
      param->vorbis.nChannels = audio->channels;
      param->vorbis.nSampleRate = audio->sample_rate;
      param->vorbis.nBitRate = format->bitrate;
      break;
   case OMX_AUDIO_CodingAMR:
      param->amr.nChannels = audio->channels;
      param->amr.nBitRate = format->bitrate;
      if(format->encoding == MMAL_ENCODING_AMRNB)
         param->amr.eAMRBandMode = OMX_AUDIO_AMRBandModeNB0;
      if(format->encoding == MMAL_ENCODING_AMRWB)
         param->amr.eAMRBandMode = OMX_AUDIO_AMRBandModeWB0;
      break;
   case OMX_AUDIO_CodingADPCM:
   case OMX_AUDIO_CodingGSMFR:
   case OMX_AUDIO_CodingGSMEFR:
   case OMX_AUDIO_CodingGSMHR:
   case OMX_AUDIO_CodingPDCFR:
   case OMX_AUDIO_CodingPDCEFR:
   case OMX_AUDIO_CodingPDCHR:
   case OMX_AUDIO_CodingTDMAFR:
   case OMX_AUDIO_CodingTDMAEFR:
   case OMX_AUDIO_CodingQCELP8:
   case OMX_AUDIO_CodingQCELP13:
   case OMX_AUDIO_CodingEVRC:
   case OMX_AUDIO_CodingSMV:
   case OMX_AUDIO_CodingG711:
   case OMX_AUDIO_CodingG723:
   case OMX_AUDIO_CodingG726:
   case OMX_AUDIO_CodingG729:
   case OMX_AUDIO_CodingSBC:
   case OMX_AUDIO_CodingRA:
   case OMX_AUDIO_CodingMIDI:
   default:
      vcos_assert(0);
      break;
   }

   return coding;
}

/*****************************************************************************/
static struct {
   uint32_t encoding;
   OMX_VIDEO_CODINGTYPE coding;
} mmal_omx_video_coding_table[] =
{
   {MMAL_ENCODING_H264,           OMX_VIDEO_CodingAVC},
   {MMAL_ENCODING_MP4V,           OMX_VIDEO_CodingMPEG4},
   {MMAL_ENCODING_MP2V,           OMX_VIDEO_CodingMPEG2},
   {MMAL_ENCODING_MP1V,           OMX_VIDEO_CodingMPEG2},
   {MMAL_ENCODING_H263,           OMX_VIDEO_CodingH263},
   {MMAL_ENCODING_WMV3,           OMX_VIDEO_CodingWMV},
   {MMAL_ENCODING_WMV2,           OMX_VIDEO_CodingWMV},
   {MMAL_ENCODING_WMV1,           OMX_VIDEO_CodingWMV},
   {MMAL_ENCODING_WVC1,           OMX_VIDEO_CodingWMV},
   {MMAL_ENCODING_VP6,            OMX_VIDEO_CodingVP6},
   {MMAL_ENCODING_VP7,            OMX_VIDEO_CodingVP7},
   {MMAL_ENCODING_VP8,            OMX_VIDEO_CodingVP8},
   {MMAL_ENCODING_SPARK,          OMX_VIDEO_CodingSorenson},
   {MMAL_ENCODING_THEORA,         OMX_VIDEO_CodingTheora},
   {MMAL_ENCODING_UNKNOWN,        OMX_VIDEO_CodingUnused}
};

uint32_t mmalil_omx_video_coding_to_encoding(OMX_VIDEO_CODINGTYPE coding)
{
   unsigned int i;
   for(i = 0; mmal_omx_video_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(mmal_omx_video_coding_table[i].coding == coding) break;
   return mmal_omx_video_coding_table[i].encoding;
}

OMX_VIDEO_CODINGTYPE mmalil_encoding_to_omx_video_coding(uint32_t encoding)
{
   unsigned int i;
   for(i = 0; mmal_omx_video_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(mmal_omx_video_coding_table[i].encoding == encoding) break;
   return mmal_omx_video_coding_table[i].coding;
}

/*****************************************************************************/
static struct {
   uint32_t encoding;
   OMX_IMAGE_CODINGTYPE coding;
} mmal_omx_image_coding_table[] =
{
   {MMAL_ENCODING_JPEG,           OMX_IMAGE_CodingJPEG},
   {MMAL_ENCODING_GIF,            OMX_IMAGE_CodingGIF},
   {MMAL_ENCODING_PNG,            OMX_IMAGE_CodingPNG},
   {MMAL_ENCODING_BMP,            OMX_IMAGE_CodingBMP},
   {MMAL_ENCODING_TGA,            OMX_IMAGE_CodingTGA},
   {MMAL_ENCODING_PPM,            OMX_IMAGE_CodingPPM},
   {MMAL_ENCODING_UNKNOWN,        OMX_IMAGE_CodingUnused}
};

uint32_t mmalil_omx_image_coding_to_encoding(OMX_IMAGE_CODINGTYPE coding)
{
   unsigned int i;
   for(i = 0; mmal_omx_image_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(mmal_omx_image_coding_table[i].coding == coding) break;
   return mmal_omx_image_coding_table[i].encoding;
}

OMX_IMAGE_CODINGTYPE mmalil_encoding_to_omx_image_coding(uint32_t encoding)
{
   unsigned int i;
   for(i = 0; mmal_omx_image_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(mmal_omx_image_coding_table[i].encoding == encoding) break;
   return mmal_omx_image_coding_table[i].coding;
}

uint32_t mmalil_omx_coding_to_encoding(uint32_t encoding, OMX_PORTDOMAINTYPE domain)
{
   if(domain == OMX_PortDomainVideo)
      return mmalil_omx_video_coding_to_encoding((OMX_VIDEO_CODINGTYPE)encoding);
   else if(domain == OMX_PortDomainAudio)
      return mmalil_omx_audio_coding_to_encoding((OMX_AUDIO_CODINGTYPE)encoding);
   else if(domain == OMX_PortDomainImage)
      return mmalil_omx_image_coding_to_encoding((OMX_IMAGE_CODINGTYPE)encoding);
   else
      return MMAL_ENCODING_UNKNOWN;
}

/*****************************************************************************/
static struct {
   uint32_t encoding;
   OMX_COLOR_FORMATTYPE coding;
} mmal_omx_colorformat_coding_table[] =
{
   {MMAL_ENCODING_I420,           OMX_COLOR_FormatYUV420PackedPlanar},
   {MMAL_ENCODING_I422,           OMX_COLOR_FormatYUV422PackedPlanar},
   {MMAL_ENCODING_I420_SLICE,     OMX_COLOR_FormatYUV420PackedPlanar},
   {MMAL_ENCODING_I422_SLICE,     OMX_COLOR_FormatYUV422PackedPlanar},
   {MMAL_ENCODING_I420,           OMX_COLOR_FormatYUV420Planar},
   {MMAL_ENCODING_YV12,           OMX_COLOR_FormatYVU420PackedPlanar},
   {MMAL_ENCODING_NV12,           OMX_COLOR_FormatYUV420PackedSemiPlanar},
   {MMAL_ENCODING_NV12,           OMX_COLOR_FormatYUV420SemiPlanar},
   {MMAL_ENCODING_NV21,           OMX_COLOR_FormatYVU420PackedSemiPlanar},
   {MMAL_ENCODING_YUVUV128,       OMX_COLOR_FormatYUVUV128},
   {MMAL_ENCODING_YUYV,           OMX_COLOR_FormatYCbYCr},
   {MMAL_ENCODING_YVYU,           OMX_COLOR_FormatYCrYCb},
   {MMAL_ENCODING_UYVY,           OMX_COLOR_FormatCbYCrY},
   {MMAL_ENCODING_VYUY,           OMX_COLOR_FormatCrYCbY},
   {MMAL_ENCODING_RGB16,          OMX_COLOR_Format16bitRGB565},
   {MMAL_ENCODING_BGR24,          OMX_COLOR_Format24bitRGB888},
   {MMAL_ENCODING_BGRA,           OMX_COLOR_Format32bitARGB8888},
   {MMAL_ENCODING_BGR16,          OMX_COLOR_Format16bitBGR565},
   {MMAL_ENCODING_RGB24,          OMX_COLOR_Format24bitBGR888},
   {MMAL_ENCODING_ARGB,           OMX_COLOR_Format32bitBGRA8888},
   {MMAL_ENCODING_RGBA,           OMX_COLOR_Format32bitABGR8888},
   {MMAL_ENCODING_EGL_IMAGE,      OMX_COLOR_FormatBRCMEGL},
   {MMAL_ENCODING_OPAQUE,         OMX_COLOR_FormatBRCMOpaque},
   {MMAL_ENCODING_UNKNOWN,        OMX_COLOR_FormatUnused}
};

uint32_t mmalil_omx_color_format_to_encoding(OMX_COLOR_FORMATTYPE coding)
{
   unsigned int i;
   for(i = 0; mmal_omx_colorformat_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(mmal_omx_colorformat_coding_table[i].coding == coding) break;
   return mmal_omx_colorformat_coding_table[i].encoding;
}

OMX_COLOR_FORMATTYPE mmalil_encoding_to_omx_color_format(uint32_t encoding)
{
   unsigned int i;
   for(i = 0; mmal_omx_colorformat_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(mmal_omx_colorformat_coding_table[i].encoding == encoding) break;
   return mmal_omx_colorformat_coding_table[i].coding;
}

/*****************************************************************************/
static struct {
   uint32_t mmal;
   OMX_COLORSPACETYPE omx;
} mmal_omx_colorspace_coding_table[] =
{
   {MMAL_COLOR_SPACE_ITUR_BT601,    OMX_COLORSPACE_ITU_R_BT601},
   {MMAL_COLOR_SPACE_ITUR_BT709,    OMX_COLORSPACE_ITU_R_BT709},
   {MMAL_COLOR_SPACE_JPEG_JFIF,     OMX_COLORSPACE_JPEG_JFIF},
   {MMAL_COLOR_SPACE_FCC,           OMX_COLORSPACE_FCC},
   {MMAL_COLOR_SPACE_SMPTE240M,     OMX_COLORSPACE_SMPTE240M},
   {MMAL_COLOR_SPACE_BT470_2_M,     OMX_COLORSPACE_BT470_2_M},
   {MMAL_COLOR_SPACE_BT470_2_BG,    OMX_COLORSPACE_BT470_2_BG},
   {MMAL_COLOR_SPACE_JFIF_Y16_255,  OMX_COLORSPACE_JFIF_Y16_255},
   {MMAL_COLOR_SPACE_UNKNOWN,       OMX_COLORSPACE_UNKNOWN}
};

uint32_t mmalil_omx_color_space_to_mmal(OMX_COLORSPACETYPE coding)
{
   unsigned int i;
   for(i = 0; mmal_omx_colorspace_coding_table[i].mmal != MMAL_COLOR_SPACE_UNKNOWN; i++)
      if(mmal_omx_colorspace_coding_table[i].omx == coding) break;
   return mmal_omx_colorspace_coding_table[i].mmal;
}

OMX_COLORSPACETYPE mmalil_color_space_to_omx(uint32_t coding)
{
   unsigned int i;
   for(i = 0; mmal_omx_colorspace_coding_table[i].mmal != MMAL_COLOR_SPACE_UNKNOWN; i++)
      if(mmal_omx_colorspace_coding_table[i].mmal == coding) break;
   return mmal_omx_colorspace_coding_table[i].omx;
}

/*****************************************************************************/
static struct {
   uint32_t mmal;
   OMX_U32 omx;
   OMX_VIDEO_CODINGTYPE omx_coding;
} mmal_omx_video_profile_table[] =
{
   { MMAL_VIDEO_PROFILE_H263_BASELINE,           OMX_VIDEO_H263ProfileBaseline,           OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_H263_H320CODING,         OMX_VIDEO_H263ProfileH320Coding,         OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_H263_BACKWARDCOMPATIBLE, OMX_VIDEO_H263ProfileBackwardCompatible, OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_H263_ISWV2,              OMX_VIDEO_H263ProfileISWV2,              OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_H263_ISWV3,              OMX_VIDEO_H263ProfileISWV3,              OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_H263_HIGHCOMPRESSION,    OMX_VIDEO_H263ProfileHighCompression,    OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_H263_INTERNET,           OMX_VIDEO_H263ProfileInternet,           OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_H263_INTERLACE,          OMX_VIDEO_H263ProfileInterlace,          OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_H263_HIGHLATENCY,        OMX_VIDEO_H263ProfileHighLatency,        OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_PROFILE_MP4V_SIMPLE,             OMX_VIDEO_MPEG4ProfileSimple,            OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_SIMPLESCALABLE,     OMX_VIDEO_MPEG4ProfileSimpleScalable,    OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_CORE,               OMX_VIDEO_MPEG4ProfileCore,              OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_MAIN,               OMX_VIDEO_MPEG4ProfileMain,              OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_NBIT,               OMX_VIDEO_MPEG4ProfileNbit,              OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_SCALABLETEXTURE,    OMX_VIDEO_MPEG4ProfileScalableTexture,   OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_SIMPLEFACE,         OMX_VIDEO_MPEG4ProfileSimpleFace,        OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_SIMPLEFBA,          OMX_VIDEO_MPEG4ProfileSimpleFBA,         OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_BASICANIMATED,      OMX_VIDEO_MPEG4ProfileBasicAnimated,     OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_HYBRID,             OMX_VIDEO_MPEG4ProfileHybrid,            OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDREALTIME,   OMX_VIDEO_MPEG4ProfileAdvancedRealTime,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_CORESCALABLE,       OMX_VIDEO_MPEG4ProfileCoreScalable,      OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCODING,     OMX_VIDEO_MPEG4ProfileAdvancedCoding,    OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCORE,       OMX_VIDEO_MPEG4ProfileAdvancedCore,      OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSCALABLE,   OMX_VIDEO_MPEG4ProfileAdvancedScalable,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSIMPLE,     OMX_VIDEO_MPEG4ProfileAdvancedSimple,    OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_PROFILE_H264_BASELINE,           OMX_VIDEO_AVCProfileBaseline,            OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_PROFILE_H264_MAIN,               OMX_VIDEO_AVCProfileMain,                OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_PROFILE_H264_EXTENDED,           OMX_VIDEO_AVCProfileExtended,            OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_PROFILE_H264_HIGH,               OMX_VIDEO_AVCProfileHigh,                OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_PROFILE_H264_HIGH10,             OMX_VIDEO_AVCProfileHigh10,              OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_PROFILE_H264_HIGH422,            OMX_VIDEO_AVCProfileHigh422,             OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_PROFILE_H264_HIGH444,            OMX_VIDEO_AVCProfileHigh444,             OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE, OMX_VIDEO_AVCProfileConstrainedBaseline,             OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_PROFILE_DUMMY,                   OMX_VIDEO_AVCProfileMax,                 OMX_VIDEO_CodingAVC},
};

uint32_t mmalil_omx_video_profile_to_mmal(OMX_U32 profile, OMX_VIDEO_CODINGTYPE coding)
{
   unsigned int i;
   for(i = 0; mmal_omx_video_profile_table[i].mmal != MMAL_VIDEO_PROFILE_DUMMY; i++)
      if(mmal_omx_video_profile_table[i].omx == profile
         && mmal_omx_video_profile_table[i].omx_coding == coding) break;
   return mmal_omx_video_profile_table[i].mmal;
}

OMX_U32 mmalil_video_profile_to_omx(uint32_t profile)
{
   unsigned int i;
   for(i = 0; mmal_omx_video_profile_table[i].mmal != MMAL_VIDEO_PROFILE_DUMMY; i++)
      if(mmal_omx_video_profile_table[i].mmal == profile) break;
   return mmal_omx_video_profile_table[i].omx;
}

/*****************************************************************************/
static struct {
   uint32_t mmal;
   OMX_U32 omx;
   OMX_VIDEO_CODINGTYPE omx_coding;
} mmal_omx_video_level_table[] =
{
   { MMAL_VIDEO_LEVEL_H263_10, OMX_VIDEO_H263Level10,  OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_LEVEL_H263_20, OMX_VIDEO_H263Level20,  OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_LEVEL_H263_30, OMX_VIDEO_H263Level30,  OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_LEVEL_H263_40, OMX_VIDEO_H263Level40,  OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_LEVEL_H263_45, OMX_VIDEO_H263Level45,  OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_LEVEL_H263_50, OMX_VIDEO_H263Level50,  OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_LEVEL_H263_60, OMX_VIDEO_H263Level60,  OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_LEVEL_H263_70, OMX_VIDEO_H263Level70,  OMX_VIDEO_CodingH263},
   { MMAL_VIDEO_LEVEL_MP4V_0,  OMX_VIDEO_MPEG4Level0,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_MP4V_0b, OMX_VIDEO_MPEG4Level0b, OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_MP4V_1,  OMX_VIDEO_MPEG4Level1,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_MP4V_2,  OMX_VIDEO_MPEG4Level2,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_MP4V_3,  OMX_VIDEO_MPEG4Level3,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_MP4V_4,  OMX_VIDEO_MPEG4Level4,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_MP4V_4a, OMX_VIDEO_MPEG4Level4a, OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_MP4V_5,  OMX_VIDEO_MPEG4Level5,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_MP4V_6,  OMX_VIDEO_MPEG4Level6,  OMX_VIDEO_CodingMPEG4},
   { MMAL_VIDEO_LEVEL_H264_1,  OMX_VIDEO_AVCLevel1,    OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_1b, OMX_VIDEO_AVCLevel1b,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_11, OMX_VIDEO_AVCLevel11,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_12, OMX_VIDEO_AVCLevel12,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_13, OMX_VIDEO_AVCLevel13,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_2,  OMX_VIDEO_AVCLevel2,    OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_21, OMX_VIDEO_AVCLevel21,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_22, OMX_VIDEO_AVCLevel22,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_3,  OMX_VIDEO_AVCLevel3,    OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_31, OMX_VIDEO_AVCLevel31,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_32, OMX_VIDEO_AVCLevel32,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_4,  OMX_VIDEO_AVCLevel4,    OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_41, OMX_VIDEO_AVCLevel41,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_42, OMX_VIDEO_AVCLevel42,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_5,  OMX_VIDEO_AVCLevel5,    OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_H264_51, OMX_VIDEO_AVCLevel51,   OMX_VIDEO_CodingAVC},
   { MMAL_VIDEO_LEVEL_DUMMY,   OMX_VIDEO_AVCLevelMax,  OMX_VIDEO_CodingMax},
};

uint32_t mmalil_omx_video_level_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding)
{
   unsigned int i;
   for(i = 0; mmal_omx_video_level_table[i].mmal != MMAL_VIDEO_LEVEL_DUMMY; i++)
      if(mmal_omx_video_level_table[i].omx == level
         && mmal_omx_video_level_table[i].omx_coding == coding) break;
   return mmal_omx_video_level_table[i].mmal;
}

OMX_U32 mmalil_video_level_to_omx(uint32_t level)
{
   unsigned int i;
   for(i = 0; mmal_omx_video_level_table[i].mmal != MMAL_VIDEO_LEVEL_DUMMY; i++)
      if(mmal_omx_video_level_table[i].mmal == level) break;
   return mmal_omx_video_level_table[i].omx;
}

/*****************************************************************************/
static struct {
   MMAL_VIDEO_RATECONTROL_T mmal;
   OMX_VIDEO_CONTROLRATETYPE omx;
} mmal_omx_video_ratecontrol_table[] =
{
   { MMAL_VIDEO_RATECONTROL_DEFAULT,              OMX_Video_ControlRateDisable},
   { MMAL_VIDEO_RATECONTROL_VARIABLE,             OMX_Video_ControlRateVariable},
   { MMAL_VIDEO_RATECONTROL_CONSTANT,             OMX_Video_ControlRateConstant},
   { MMAL_VIDEO_RATECONTROL_VARIABLE_SKIP_FRAMES, OMX_Video_ControlRateVariableSkipFrames},
   { MMAL_VIDEO_RATECONTROL_CONSTANT_SKIP_FRAMES, OMX_Video_ControlRateConstantSkipFrames},
   { MMAL_VIDEO_RATECONTROL_DUMMY,                OMX_Video_ControlRateMax},
};

MMAL_VIDEO_RATECONTROL_T mmalil_omx_video_ratecontrol_to_mmal(OMX_VIDEO_CONTROLRATETYPE omx)
{
   unsigned int i;
   for(i = 0; mmal_omx_video_ratecontrol_table[i].mmal != MMAL_VIDEO_RATECONTROL_DUMMY; i++)
      if(mmal_omx_video_ratecontrol_table[i].omx == omx) break;
   return mmal_omx_video_ratecontrol_table[i].mmal;
}

OMX_VIDEO_CONTROLRATETYPE mmalil_video_ratecontrol_to_omx(MMAL_VIDEO_RATECONTROL_T mmal)
{
   unsigned int i;
   for(i = 0; mmal_omx_video_ratecontrol_table[i].mmal != MMAL_VIDEO_RATECONTROL_DUMMY; i++)
      if(mmal_omx_video_ratecontrol_table[i].mmal == mmal) break;
   return mmal_omx_video_ratecontrol_table[i].omx;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_IL_H
#define MMAL_IL_H

/** \defgroup MmalILUtility MMAL to OMX IL conversion utilities
 * \ingroup MmalUtilities
 *
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

#include "interface/vmcs_host/khronos/IL/OMX_Core.h"
#include "interface/vmcs_host/khronos/IL/OMX_Component.h"
#include "interface/vmcs_host/khronos/IL/OMX_Video.h"
#include "interface/vmcs_host/khronos/IL/OMX_Audio.h"
#include "interface/vmcs_host/khronos/IL/OMX_Broadcom.h"

/** Convert MMAL status codes into OMX error codes.
 *
 * @param status MMAL status code.
 * @return OMX error code.
 */
OMX_ERRORTYPE mmalil_error_to_omx(MMAL_STATUS_T status);

/** Convert OMX error codes into MMAL status codes.
 *
 * @param error OMX error code.
 * @return MMAL status code.
 */
MMAL_STATUS_T mmalil_error_to_mmal(OMX_ERRORTYPE error);

/** Convert MMAL buffer header flags into OMX buffer header flags.
 *
 * @param flags OMX buffer header flags.
 * @return MMAL buffer header flags.
 */
uint32_t mmalil_buffer_flags_to_mmal(OMX_U32 flags);

/** Convert OMX buffer header flags into MMAL buffer header flags.
 *
 * @param flags MMAL buffer header flags.
 * @return OMX buffer header flags.
 */
OMX_U32 mmalil_buffer_flags_to_omx(uint32_t flags);

/** Convert a MMAL buffer header into an OMX buffer header.
 * Note that only the fields which have a direct mapping between OMX and MMAL are converted.
 *
 * @param omx  Pointer to the destination OMX buffer header.
 * @param mmal Pointer to the source MMAL buffer header.
 */
void mmalil_buffer_header_to_omx(OMX_BUFFERHEADERTYPE *omx, MMAL_BUFFER_HEADER_T *mmal);

/** Convert an OMX buffer header into a MMAL buffer header.
 *
 * @param mmal Pointer to the destination MMAL buffer header.
 * @param omx  Pointer to the source OMX buffer header.
 */
void mmalil_buffer_header_to_mmal(MMAL_BUFFER_HEADER_T *mmal, OMX_BUFFERHEADERTYPE *omx);


OMX_PORTDOMAINTYPE mmalil_es_type_to_omx_domain(MMAL_ES_TYPE_T type);
MMAL_ES_TYPE_T mmalil_omx_domain_to_es_type(OMX_PORTDOMAINTYPE domain);
uint32_t mmalil_omx_audio_coding_to_encoding(OMX_AUDIO_CODINGTYPE coding);
OMX_AUDIO_CODINGTYPE mmalil_encoding_to_omx_audio_coding(uint32_t encoding);
uint32_t mmalil_omx_video_coding_to_encoding(OMX_VIDEO_CODINGTYPE coding);
OMX_VIDEO_CODINGTYPE mmalil_encoding_to_omx_video_coding(uint32_t encoding);
uint32_t mmalil_omx_image_coding_to_encoding(OMX_IMAGE_CODINGTYPE coding);
OMX_IMAGE_CODINGTYPE mmalil_encoding_to_omx_image_coding(uint32_t encoding);
uint32_t mmalil_omx_coding_to_encoding(uint32_t encoding, OMX_PORTDOMAINTYPE domain);
uint32_t mmalil_omx_color_format_to_encoding(OMX_COLOR_FORMATTYPE coding);
OMX_COLOR_FORMATTYPE mmalil_encoding_to_omx_color_format(uint32_t encoding);
uint32_t mmalil_omx_color_space_to_mmal(OMX_COLORSPACETYPE coding);
OMX_COLORSPACETYPE mmalil_color_space_to_omx(uint32_t coding);
uint32_t mmalil_omx_video_profile_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding);
OMX_U32 mmalil_video_profile_to_omx(uint32_t profile);
uint32_t mmalil_omx_video_level_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding);
OMX_U32 mmalil_video_level_to_omx(uint32_t level);
MMAL_VIDEO_RATECONTROL_T mmalil_omx_video_ratecontrol_to_mmal(OMX_VIDEO_CONTROLRATETYPE omx);
OMX_VIDEO_CONTROLRATETYPE mmalil_video_ratecontrol_to_omx(MMAL_VIDEO_RATECONTROL_T mmal);

/** Union of all the OMX_VIDEO/AUDIO_PARAM types */
typedef union OMX_FORMAT_PARAM_TYPE {
   OMX_PARAM_U32TYPE common;

   /* Video */
   OMX_VIDEO_PARAM_AVCTYPE avc;
   OMX_VIDEO_PARAM_H263TYPE h263;
   OMX_VIDEO_PARAM_MPEG2TYPE mpeg2;
   OMX_VIDEO_PARAM_MPEG4TYPE mpeg4;
   OMX_VIDEO_PARAM_WMVTYPE wmv;
   OMX_VIDEO_PARAM_RVTYPE rv;

   /* Audio */
   OMX_AUDIO_PARAM_PCMMODETYPE pcm;
   OMX_AUDIO_PARAM_MP3TYPE mp3;
   OMX_AUDIO_PARAM_AACPROFILETYPE aac;
   OMX_AUDIO_PARAM_VORBISTYPE vorbis;
   OMX_AUDIO_PARAM_WMATYPE wma;
   OMX_AUDIO_PARAM_RATYPE ra;
   OMX_AUDIO_PARAM_SBCTYPE sbc;
   OMX_AUDIO_PARAM_ADPCMTYPE adpcm;
   OMX_AUDIO_PARAM_G723TYPE g723;
   OMX_AUDIO_PARAM_G726TYPE g726;
   OMX_AUDIO_PARAM_G729TYPE g729;
   OMX_AUDIO_PARAM_AMRTYPE amr;
   OMX_AUDIO_PARAM_GSMFRTYPE gsmfr;
   OMX_AUDIO_PARAM_GSMHRTYPE gsmhr;
   OMX_AUDIO_PARAM_GSMEFRTYPE gsmefr;
   OMX_AUDIO_PARAM_TDMAFRTYPE tdmafr;
   OMX_AUDIO_PARAM_TDMAEFRTYPE tdmaefr;
   OMX_AUDIO_PARAM_PDCFRTYPE pdcfr;
   OMX_AUDIO_PARAM_PDCEFRTYPE pdcefr;
   OMX_AUDIO_PARAM_PDCHRTYPE pdchr;
   OMX_AUDIO_PARAM_QCELP8TYPE qcelp8;
   OMX_AUDIO_PARAM_QCELP13TYPE qcelp13;
   OMX_AUDIO_PARAM_EVRCTYPE evrc;
   OMX_AUDIO_PARAM_SMVTYPE smv;
   OMX_AUDIO_PARAM_MIDITYPE midi;

} OMX_FORMAT_PARAM_TYPE;

/** Get the OMX_IndexParamAudio index corresponding to a specified audio coding type.
 *
 * @param coding Audio coding type.
 * @param size  Pointer used to return the size of the parameter.
 *
 * @return OMX index or 0 if no match was found.
 */
OMX_INDEXTYPE mmalil_omx_audio_param_index(OMX_AUDIO_CODINGTYPE coding, OMX_U32 *size);

/** Convert an OMX_IndexParamAudio into a MMAL elementary stream format.
 *
 * @param format Format structure to update.
 * @param coding Audio coding type.
 * @param param  Source OMX_IndexParamAudio structure.
 *
 * @return The MMAL encoding if a match was found or MMAL_ENCODING_UNKNOWN otherwise.
 */
MMAL_FOURCC_T mmalil_omx_audio_param_to_format(MMAL_ES_FORMAT_T *format,
   OMX_AUDIO_CODINGTYPE coding, OMX_FORMAT_PARAM_TYPE *param);

/** Convert a MMAL elementary stream format into a OMX_IndexParamAudio structure.
 *
 * @param param  OMX_IndexParamAudio structure to update.
 * @param param_index returns the OMX_IndexParamAudio index corresponding to the format.
 * @param format Source format structure.
 *
 * @return The OMX aduio coding type if a match was found or OMX_AUDIO_CodingUnused otherwise.
 */
OMX_AUDIO_CODINGTYPE mmalil_format_to_omx_audio_param(OMX_FORMAT_PARAM_TYPE *param,
   OMX_INDEXTYPE *param_index, MMAL_ES_FORMAT_T *format);

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* MMAL_IL_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "interface/vcos/vcos.h"
#include "interface/mmal/util/mmal_list.h"


/* Private list context */
typedef struct MMAL_LIST_PRIVATE_T
{
   MMAL_LIST_T list;    /* must be first */
   VCOS_MUTEX_T lock;
} MMAL_LIST_PRIVATE_T;


/* Lock the list. */
static inline void mmal_list_lock(MMAL_LIST_T *list)
{
   vcos_mutex_lock(&((MMAL_LIST_PRIVATE_T*)list)->lock);
}

/* Unlock the list. */
static inline void mmal_list_unlock(MMAL_LIST_T *list)
{
   vcos_mutex_unlock(&((MMAL_LIST_PRIVATE_T*)list)->lock);
}

/* Create a new linked list. */
MMAL_LIST_T* mmal_list_create(void)
{
   MMAL_LIST_PRIVATE_T *private;

   private = vcos_malloc(sizeof(MMAL_LIST_PRIVATE_T), "mmal-list");
   if (private == NULL)
      goto error;

   if (vcos_mutex_create(&private->lock, "mmal-list lock") != VCOS_SUCCESS)
      goto error;

   private->list.first = NULL;
   private->list.last = NULL;
   private->list.length = 0;

   return &private->list;

error:
   vcos_free(private);
   return NULL;
}

/* Destroy a linked list. */
void mmal_list_destroy(MMAL_LIST_T *list)
{
   MMAL_LIST_PRIVATE_T *private = (MMAL_LIST_PRIVATE_T*)list;

   vcos_mutex_delete(&private->lock);
   vcos_free(private);
}

/* Remove the last element in the list. */
MMAL_LIST_ELEMENT_T* mmal_list_pop_back(MMAL_LIST_T *list)
{
   MMAL_LIST_ELEMENT_T *element;

   mmal_list_lock(list);

   element = list->last;
   if (element != NULL)
   {
      list->length--;

      list->last = element->prev;
      if (list->last)
         list->last->next = NULL;
      else
         list->first = NULL; /* list is now empty */

      element->prev = NULL;
      element->next = NULL;
   }

   mmal_list_unlock(list);

   return element;
}

/* Remove the first element in the list. */
MMAL_LIST_ELEMENT_T* mmal_list_pop_front(MMAL_LIST_T *list)
{
   MMAL_LIST_ELEMENT_T *element;

   mmal_list_lock(list);

   element = list->first;
   if (element != NULL)
   {
      list->length--;

      list->first = element->next;
      if (list->first)
         list->first->prev = NULL;
      else
         list->last = NULL; /* list is now empty */

      element->prev = NULL;
      element->next = NULL;
   }

   mmal_list_unlock(list);

   return element;
}

/* Add an element to the front of the list. */
void mmal_list_push_front(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element)
{
   mmal_list_lock(list);

   list->length++;

   element->prev = NULL;
   element->next = list->first;

   if (list->first)
      list->first->prev = element;
   else
      list->last = element; /* list was empty */

   list->first = element;

   mmal_list_unlock(list);
}

/* Add an element to the back of the list. */
void mmal_list_push_back(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element)
{
   mmal_list_lock(list);

   list->length++;

   element->next = NULL;
   element->prev = list->last;

   if (list->last)
      list->last->next = element;
   else
      list->first = element; /* list was empty */

   list->last = element;

   mmal_list_unlock(list);
}

/* Insert an element into the list. */
void mmal_list_insert(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element, MMAL_LIST_COMPARE_T compare)
{
   MMAL_LIST_ELEMENT_T *cur;

   mmal_list_lock(list);

   if (list->first == NULL)
   {
      /* List empty */
      mmal_list_unlock(list);
      mmal_list_push_front(list, element);
      return;
   }

   cur = list->first;
   while (cur)
   {
      if (compare(element, cur))
      {
         /* Slot found! */
         list->length++;
         if (cur == list->first)
            list->first = element;
         else
            cur->prev->next = element;
         element->prev = cur->prev;
         element->next = cur;
         cur->prev = element;
         mmal_list_unlock(list);
         return;
      }

      cur = cur->next;
   }

   /* If we get here, none of the existing elements are greater
    * than the new on, so just add it to the back of the list */
   mmal_list_unlock(list);
   mmal_list_push_back(list, element);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_LIST_H
#define MMAL_LIST_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalList Generic Linked List
 * This provides a thread-safe implementation of a linked list which can be used
 * with any data type. */
/* @{ */

/** Single element in the list */
typedef struct MMAL_LIST_ELEMENT_T
{
   struct MMAL_LIST_ELEMENT_T *next;
   struct MMAL_LIST_ELEMENT_T *prev;
} MMAL_LIST_ELEMENT_T;

/** Linked list type.
 * Clients shouldn't modify this directly. Use the provided API functions to
 * add new elements. The public members are only for debug purposes.
 * */
typedef struct MMAL_LIST_T
{
   unsigned int length;         /**< Number of elements in the list (read-only) */
   MMAL_LIST_ELEMENT_T *first;  /**< First element in the list (read-only) */
   MMAL_LIST_ELEMENT_T *last;   /**< Last element in the list (read-only) */
} MMAL_LIST_T;

/** Create a new linked list.
 *
 * @return Pointer to new queue (NULL on failure).
 */
MMAL_LIST_T* mmal_list_create(void);

/** Destroy a linked list.
 *
 * @param list List to destroy
 */
void mmal_list_destroy(MMAL_LIST_T *list);

/** Remove the last element in the list.
 *
 * @param list    List to remove from
 *
 * @return Pointer to the last element (or NULL if empty)
 */
MMAL_LIST_ELEMENT_T* mmal_list_pop_back(MMAL_LIST_T *list);

/** Remove the first element in the list.
 *
 * @param list    List to remove from
 *
 * @return Pointer to the first element (or NULL if empty)
 */
MMAL_LIST_ELEMENT_T* mmal_list_pop_front(MMAL_LIST_T *list);

/** Add an element to the front of the list.
 *
 * @param list    List to add to
 * @param element The element to add
 */
void mmal_list_push_front(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element);

/** Add an element to the back of the list.
 *
 * @param list    List to add to
 * @param element The element to add
 */
void mmal_list_push_back(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element);

/** List comparison function.
 * This is supplied by a client when inserting an element in
 * the middle of the list. The list will always insert a smaller
 * element in front of a larger element.
 *
 * @return TRUE:  lhs <  rhs
 *         FALSE: lhs >= rhs
 */
typedef int (*MMAL_LIST_COMPARE_T)(MMAL_LIST_ELEMENT_T *lhs, MMAL_LIST_ELEMENT_T *rhs);

/** Insert an element into the list.
 * The location where the element is inserted is determined using
 * the supplied comparison function. Smaller elements are inserted
 * in front of larger elements.
 *
 * @param list    List to add to
 * @param element The element to insert
 * @param compare Comparison function supplied by the client
 */
void mmal_list_insert(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element, MMAL_LIST_COMPARE_T compare);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_LIST_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include "mmal_param_convert.h"
#include <stdlib.h>
#include <stdio.h>

typedef struct string_pair_t
{
   const char *string;
   int value;
} string_pair_t;

static MMAL_STATUS_T parse_enum(int *dest, string_pair_t *pairs, size_t n_pairs, const char *str)
{
   size_t i;
   for (i=0; i<n_pairs; i++)
   {
      if (vcos_strcasecmp(str, pairs[i].string) == 0)
      {
         *dest = pairs[i].value;
         return MMAL_SUCCESS;
      }
      i++;
   }
   return MMAL_EINVAL;
}

MMAL_STATUS_T mmal_parse_video_size(uint32_t *w, uint32_t *h, const char *str)
{
   static struct {
      const char *name;
      uint32_t width;
      uint32_t height;
   } sizes[] = {
      { "1080p", 1920, 1080 },
      { "720p",  1280,  720 },
      { "vga",    640,  480 },
      { "wvga",   800,  480 },
      { "cif",    352,  288 },
      { "qcif",   352/2, 288/2 },
   };
   size_t i;
   for (i=0; i<vcos_countof(sizes); i++)
   {
      if (vcos_strcasecmp(str, sizes[i].name) == 0)
      {
         *w = sizes[i].width;
         *h = sizes[i].height;
         return MMAL_SUCCESS;
      }
   }
   return MMAL_EINVAL;
}

MMAL_STATUS_T mmal_parse_rational(MMAL_RATIONAL_T *dest, const char *str)
{
   MMAL_STATUS_T ret;
   char *endptr;
   long num, den = 1;
   num = strtoul(str, &endptr, 0);
   if (endptr[0] == '\0')
   {
      /* that's it */
      ret = MMAL_SUCCESS;
   }
   else if (endptr[0] == '/')
   {
      den = strtoul(endptr+1, &endptr, 0);
      if (endptr[0] == '\0')
         ret = MMAL_SUCCESS;
      else
         ret = MMAL_EINVAL;
   }
   else
   {
      ret = MMAL_EINVAL;
   }
   dest->num = num;
   dest->den = den;
   return ret;
}

MMAL_STATUS_T mmal_parse_int(int *dest, const char *str)
{
   char *endptr;
   long i = strtol(str, &endptr, 0);
   if (endptr[0] == '\0')
   {
      *dest = i;
      return MMAL_SUCCESS;
   }
   else
   {
      return MMAL_EINVAL;
   }
}

MMAL_STATUS_T mmal_parse_uint(unsigned int *dest, const char *str)
{
   char *endptr;
   unsigned long i = strtoul(str, &endptr, 0);
   if (endptr[0] == '\0')
   {
      *dest = i;
      return MMAL_SUCCESS;
   }
   else
   {
      return MMAL_EINVAL;
   }
}

MMAL_STATUS_T mmal_parse_video_codec(uint32_t *dest, const char *str)
{
   static string_pair_t video_codec_enums[] = {
      { "h264",  MMAL_ENCODING_H264 },
      { "h263",  MMAL_ENCODING_H263 },
      { "mpeg4", MMAL_ENCODING_MP4V },
      { "mpeg2", MMAL_ENCODING_MP2V },
      { "vp8",   MMAL_ENCODING_VP8 },
      { "vp7",   MMAL_ENCODING_VP7 },
      { "vp6",   MMAL_ENCODING_VP6 },
   };
   int i = 0;
   MMAL_STATUS_T ret;

   ret = parse_enum(&i, video_codec_enums, vcos_countof(video_codec_enums), str);
   *dest = i;
   return ret;
}

MMAL_STATUS_T mmal_parse_geometry(MMAL_RECT_T *dest, const char *str)
{
   MMAL_STATUS_T ret;
   uint32_t w, h, x, y;
   x = y = w = h = 0;
   /* coverity[secure_coding] */
   if (sscanf(str, "%d*%d+%d+%d", &w,&h,&x,&y) == 4 ||
       sscanf(str, "%d*%d", &w,&h) == 2)
   {
      dest->x = x;
      dest->y = y;
      dest->width = w;
      dest->height = h;
      ret = MMAL_SUCCESS;
   }
   else
   {
      ret = MMAL_EINVAL;
   }
   return ret;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** \file
 * Support for setting/getting parameters as string values.
 */

#ifndef MMAL_PARAM_CONVERT_H
#define MMAL_PARAM_CONVERT_H

#include "interface/mmal/mmal.h"

#ifdef __cplusplus
extern "C" {
#endif

/** Parse a video size. e.g. "1080p" gives 1920x1080.
 *
 * @param w width result
 * @param h height result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_video_size(uint32_t *w, uint32_t *h, const char *str);

/** Parse a rational number. e.g. "30000/1001", "30", etc.
 * @param dest filled in with result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_rational(MMAL_RATIONAL_T *dest, const char *str);

/** Parse an integer, e.g. -10, 0x1A, etc.
 * @param dest filled in with result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_int(int *dest, const char *str);

/** Parse an unsigned integer, e.g. 10, 0x1A, etc.
 * @param dest filled in with result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_uint(unsigned int *dest, const char *str);

/** Parse a geometry for a rectangle
 *
 * e.g. 100*100+50+75
 * or   200*150
 * @param dest filled in with result
 * @param str string to convert
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_geometry(MMAL_RECT_T *dest, const char *str);

/** Parse a video codec name (something that can be encoded/decoded)
 * @param str string to convert
 * @param dest filled in with result
 * @return MMAL_SUCCESS or error code
 */
MMAL_STATUS_T mmal_parse_video_codec(uint32_t *dest, const char *str);

#ifdef __cplusplus
}
#endif

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal_util_params.h"

/** Helper function to set the value of a boolean parameter */
MMAL_STATUS_T mmal_port_parameter_set_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T value)
{
   MMAL_PARAMETER_BOOLEAN_T param = {{id, sizeof(param)}, value};
   return mmal_port_parameter_set(port, &param.hdr);
}

/** Helper function to get the value of a boolean parameter */
MMAL_STATUS_T mmal_port_parameter_get_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T *value)
{
   MMAL_PARAMETER_BOOLEAN_T param = {{id, sizeof(param)}, 0};
   // coverity[overrun-buffer-val] Structure accessed correctly via size field
   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
   if (status == MMAL_SUCCESS)
      *value = param.enable;
   return status;
}

/** Helper function to set the value of a 64 bits unsigned integer parameter */
MMAL_STATUS_T mmal_port_parameter_set_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t value)
{
   MMAL_PARAMETER_UINT64_T param = {{id, sizeof(param)}, value};
   return mmal_port_parameter_set(port, &param.hdr);
}

/** Helper function to get the value of a 64 bits unsigned integer parameter */
MMAL_STATUS_T mmal_port_parameter_get_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t *value)
{
   MMAL_PARAMETER_UINT64_T param = {{id, sizeof(param)}, 0LL};
   // coverity[overrun-buffer-val] Structure accessed correctly via size field
   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
   if (status == MMAL_SUCCESS)
      *value = param.value;
   return status;
}

/** Helper function to set the value of a 64 bits signed integer parameter */
MMAL_STATUS_T mmal_port_parameter_set_int64(MMAL_PORT_T *port, uint32_t id, int64_t value)
{
   MMAL_PARAMETER_INT64_T param = {{id, sizeof(param)}, value};
   return mmal_port_parameter_set(port, &param.hdr);
}

/** Helper function to get the value of a 64 bits signed integer parameter */
MMAL_STATUS_T mmal_port_parameter_get_int64(MMAL_PORT_T *port, uint32_t id, int64_t *value)
{
   MMAL_PARAMETER_INT64_T param = {{id, sizeof(param)}, 0LL};
   // coverity[overrun-buffer-val] Structure accessed correctly via size field
   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
   if (status == MMAL_SUCCESS)
      *value = param.value;
   return status;
}

/** Helper function to set the value of a 32 bits unsigned integer parameter */
MMAL_STATUS_T mmal_port_parameter_set_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t value)
{
   MMAL_PARAMETER_UINT32_T param = {{id, sizeof(param)}, value};
   return mmal_port_parameter_set(port, &param.hdr);
}

/** Helper function to get the value of a 32 bits unsigned integer parameter */
MMAL_STATUS_T mmal_port_parameter_get_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t *value)
{
   MMAL_PARAMETER_UINT32_T param = {{id, sizeof(param)}, 0};
   // coverity[overrun-buffer-val] Structure accessed correctly via size field
   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
   if (status == MMAL_SUCCESS)
      *value = param.value;
   return status;
}

/** Helper function to set the value of a 32 bits signed integer parameter */
MMAL_STATUS_T mmal_port_parameter_set_int32(MMAL_PORT_T *port, uint32_t id, int32_t value)
{
   MMAL_PARAMETER_INT32_T param = {{id, sizeof(param)}, value};
   return mmal_port_parameter_set(port, &param.hdr);
}

/** Helper function to get the value of a 32 bits signed integer parameter */
MMAL_STATUS_T mmal_port_parameter_get_int32(MMAL_PORT_T *port, uint32_t id, int32_t *value)
{
   MMAL_PARAMETER_INT32_T param = {{id, sizeof(param)}, 0};
   // coverity[overrun-buffer-val] Structure accessed correctly via size field
   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
   if (status == MMAL_SUCCESS)
      *value = param.value;
   return status;
}

/** Helper function to set the value of a rational parameter */
MMAL_STATUS_T mmal_port_parameter_set_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T value)
{
   MMAL_PARAMETER_RATIONAL_T param = {{id, sizeof(param)}, {value.num, value.den}};
   return mmal_port_parameter_set(port, &param.hdr);
}

/** Helper function to get the value of a rational parameter */
MMAL_STATUS_T mmal_port_parameter_get_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T *value)
{
   MMAL_PARAMETER_RATIONAL_T param = {{id, sizeof(param)}, {0,0}};
   // coverity[overrun-buffer-val] Structure accessed correctly via size field
   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
   if (status == MMAL_SUCCESS)
      *value = param.value;
   return status;
}

/** Helper function to set the value of a string parameter */
MMAL_STATUS_T mmal_port_parameter_set_string(MMAL_PORT_T *port, uint32_t id, const char *value)
{
   MMAL_PARAMETER_STRING_T *param = 0;
   MMAL_STATUS_T status;
   size_t param_size = sizeof(param->hdr) + strlen(value) + 1;

   param = calloc(1, param_size);
   if (!param)
      return MMAL_ENOMEM;

   param->hdr.id = id;
   param->hdr.size = param_size;
   memcpy(param->str, value, strlen(value)+1);
   status = mmal_port_parameter_set(port, &param->hdr);
   free(param);
   return status;
}

/** Helper function to set a MMAL_PARAMETER_URI_T parameter on a port */
MMAL_STATUS_T mmal_util_port_set_uri(MMAL_PORT_T *port, const char *uri)
{
   return mmal_port_parameter_set_string(port, MMAL_PARAMETER_URI, uri);
}

/** Helper function to set the value of an array of bytes parameter */
MMAL_STATUS_T mmal_port_parameter_set_bytes(MMAL_PORT_T *port, uint32_t id,
   const uint8_t *data, unsigned int size)
{
   MMAL_PARAMETER_BYTES_T *param = 0;
   MMAL_STATUS_T status;
   size_t param_size = sizeof(param->hdr) + size;

   param = calloc(1, param_size);
   if (!param)
      return MMAL_ENOMEM;

   param->hdr.id = id;
   param->hdr.size = param_size;
   memcpy(param->data, data, size);
   status = mmal_port_parameter_set(port, &param->hdr);
   free(param);
   return status;
}

/** Set the display region.
 * @param port   port to configure
 * @param region region
 *
 * @return MMAL_SUCCESS or error
 */

MMAL_STATUS_T mmal_util_set_display_region(MMAL_PORT_T *port,
                                           MMAL_DISPLAYREGION_T *region)
{
   region->hdr.id = MMAL_PARAMETER_DISPLAYREGION;
   region->hdr.size = sizeof(*region);
   return mmal_port_parameter_set(port, &region->hdr);
}

MMAL_STATUS_T mmal_util_camera_use_stc_timestamp(MMAL_PORT_T *port, MMAL_CAMERA_STC_MODE_T mode)
{
   MMAL_PARAMETER_CAMERA_STC_MODE_T param =
      {{MMAL_PARAMETER_USE_STC, sizeof(MMAL_PARAMETER_CAMERA_STC_MODE_T)},mode};
   return mmal_port_parameter_set(port, &param.hdr);
}

MMAL_STATUS_T mmal_util_get_core_port_stats(MMAL_PORT_T *port, 
                                            MMAL_CORE_STATS_DIR dir,
                                            MMAL_BOOL_T reset,
                                            MMAL_CORE_STATISTICS_T *stats)
{
   MMAL_PARAMETER_CORE_STATISTICS_T param;
   MMAL_STATUS_T ret;

   memset(&param, 0, sizeof(param));
   param.hdr.id = MMAL_PARAMETER_CORE_STATISTICS;
   param.hdr.size = sizeof(param);
   param.dir = dir;
   param.reset = reset;
   // coverity[overrun-buffer-val] Structure accessed correctly via size field
   ret = mmal_port_parameter_get(port, &param.hdr);
   if (ret == MMAL_SUCCESS)
      *stats = param.stats;
   return ret;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_UTIL_PARAMS_H
#define MMAL_UTIL_PARAMS_H

#include "../mmal.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @file
 * Utility functions to set some common parameters.
 */

/** Helper function to set the value of a boolean parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T value);

/** Helper function to get the value of a boolean parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T *value);

/** Helper function to set the value of a 64 bits unsigned integer parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t value);

/** Helper function to get the value of a 64 bits unsigned integer parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t *value);

/** Helper function to set the value of a 64 bits signed integer parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_int64(MMAL_PORT_T *port, uint32_t id, int64_t value);

/** Helper function to get the value of a 64 bits signed integer parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_int64(MMAL_PORT_T *port, uint32_t id, int64_t *value);

/** Helper function to set the value of a 32 bits unsigned integer parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t value);

/** Helper function to get the value of a 32 bits unsigned integer parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t *value);

/** Helper function to set the value of a 32 bits signed integer parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_int32(MMAL_PORT_T *port, uint32_t id, int32_t value);

/** Helper function to get the value of a 32 bits signed integer parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_int32(MMAL_PORT_T *port, uint32_t id, int32_t *value);

/** Helper function to set the value of a rational parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  value to set the parameter to
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T value);

/** Helper function to get the value of a rational parameter.
 * @param port   port on which to get the parameter
 * @param id     parameter id
 * @param value  pointer to where the value will be returned
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_get_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T *value);

/** Helper function to set the value of a string parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param value  null-terminated string value
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_string(MMAL_PORT_T *port, uint32_t id, const char *value);

/** Helper function to set the value of an array of bytes parameter.
 * @param port   port on which to set the parameter
 * @param id     parameter id
 * @param data   pointer to the array of bytes
 * @param size   size of the array of bytes
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_port_parameter_set_bytes(MMAL_PORT_T *port, uint32_t id,
   const uint8_t *data, unsigned int size);

/** Helper function to set a MMAL_PARAMETER_URI_T parameter on a port.
 * @param port   port on which to set the parameter
 * @param uri    URI string
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_util_port_set_uri(MMAL_PORT_T *port, const char *uri);

/** Set the display region.
 * @param port   port to configure
 * @param region region
 *
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_util_set_display_region(MMAL_PORT_T *port,
                                           MMAL_DISPLAYREGION_T *region);

/** Tell the camera to use the STC for timestamps rather than the clock.
 *
 * @param port   port to configure
 * @param mode   STC mode to use
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_util_camera_use_stc_timestamp(MMAL_PORT_T *port, MMAL_CAMERA_STC_MODE_T mode);

/** Get the MMAL core statistics for a given port.
 *
 * @param port  port to query
 * @param dir   port direction
 * @param reset reset the stats as well
 * @param stats filled in with results
 * @return MMAL_SUCCESS or error
 */
MMAL_STATUS_T mmal_util_get_core_port_stats(MMAL_PORT_T *port, MMAL_CORE_STATS_DIR dir, MMAL_BOOL_T reset,
                                            MMAL_CORE_STATISTICS_T *stats);

#ifdef __cplusplus
}
#endif

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <limits.h>
#include "interface/mmal/util/mmal_util_rational.h"

#define Q16_ONE   (1 << 16)

#define ABS(v)    (((v) < 0) ? -(v) : (v))

/** Calculate the greatest common denominator between 2 integers.
 * Avoids division. */
static int32_t gcd(int32_t a, int32_t b)
{
   int shift;

   if (a == 0 || b == 0)
      return 1;

   a = ABS(a);
   b = ABS(b);
   for (shift = 0; !((a | b) & 0x01); shift++)
      a >>= 1, b >>= 1;

   while (a > 0)
   {
      while (!(a & 0x01))
         a >>= 1;
      while (!(b & 0x01))
         b >>= 1;
      if (a >= b)
         a = (a - b) >> 1;
      else
         b = (b - a) >> 1;
   }
   return b << shift;
}

/** Calculate a + b. */
MMAL_RATIONAL_T mmal_rational_add(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
{
   MMAL_RATIONAL_T result;
   int32_t g = gcd(a.den, b.den);
   a.den /= g;
   a.num = a.num * (b.den / g) + b.num * a.den;
   g = gcd(a.num, g);
   a.num /= g;
   a.den *= b.den / g;

   result.num = a.num;
   result.den = a.den;
   return result;
}

/** Calculate a - b. */
MMAL_RATIONAL_T mmal_rational_subtract(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
{
   b.num = -b.num;
   return mmal_rational_add(a, b);
}

/** Calculate a * b */
MMAL_RATIONAL_T mmal_rational_multiply(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
{
   MMAL_RATIONAL_T result;
   int32_t gcd1 = gcd(a.num, b.den);
   int32_t gcd2 = gcd(b.num, a.den);
   result.num = (a.num / gcd1) * (b.num / gcd2);
   result.den = (a.den / gcd2) * (b.den / gcd1);

   return result;
}

/** Calculate a / b */
MMAL_RATIONAL_T mmal_rational_divide(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
{
   MMAL_RATIONAL_T result;
   int32_t gcd1, gcd2;

   if (b.num == 0)
   {
      vcos_assert(0);
      return a;
   }

   if (a.num == 0)
      return a;

   gcd1 = gcd(a.num, b.num);
   gcd2 = gcd(b.den, a.den);
   result.num = (a.num / gcd1) * (b.den / gcd2);
   result.den = (a.den / gcd2) * (b.num / gcd1);

   return result;
}

/** Convert a rational number to a signed 32-bit Q16 number. */
int32_t mmal_rational_to_fixed_16_16(MMAL_RATIONAL_T rational)
{
   int64_t result = (int64_t)rational.num << 16;
   if (rational.den)
      result /= rational.den;

   if (result > INT_MAX)
      result = INT_MAX;
   else if (result < INT_MIN)
      result = INT_MIN;

   return (int32_t)result;
}

/** Convert a rational number to a signed 32-bit Q16 number. */
MMAL_RATIONAL_T mmal_rational_from_fixed_16_16(int32_t fixed)
{
   MMAL_RATIONAL_T result = { fixed, Q16_ONE };
   mmal_rational_simplify(&result);
   return result;
}

/** Reduce a rational number to it's simplest form. */
void mmal_rational_simplify(MMAL_RATIONAL_T *rational)
{
   int g = gcd(rational->num, rational->den);
   rational->num /= g;
   rational->den /= g;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_UTIL_RATIONAL_H
#define MMAL_UTIL_RATIONAL_H

#include "interface/mmal/mmal_types.h"

/** \defgroup MmalRationalUtilities Rational Utility Functions
 * \ingroup MmalUtilities
 * The rational utility functions allow easy manipulation of rational numbers.
 *
 * @{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** Add 2 rational numbers.
 * It is assumed that both input rational numbers are in
 * their simplest form.
 *
 * @param a First operand
 * @param b Second operand
 *
 * @return a + b
 */
MMAL_RATIONAL_T mmal_rational_add(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

/** Subtract 2 rational numbers.
 * It is assumed that both input rational numbers are in
 * their simplest form.
 *
 * @param a        First operand
 * @param b        Second operand
 *
 * @return a - b
 */
MMAL_RATIONAL_T mmal_rational_subtract(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

/** Multiply 2 rational numbers.
 * It is assumed that both input rational numbers are in
 * their simplest form.
 *
 * @param a        First operand
 * @param b        Second operand
 *
 * @return a * b
 */
MMAL_RATIONAL_T mmal_rational_multiply(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

/** Divide 2 rational numbers.
 * It is assumed that both input rational numbers are in
 * their simplest form.
 *
 * @param a        First operand
 * @param b        Second operand
 *
 * @return a / b
 */
MMAL_RATIONAL_T mmal_rational_divide(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);

/** Convert a rational number to a 32-bit signed Q16 number.
 * Saturation will occur for rational numbers with an absolute
 * value greater than 32768.
 *
 * @param rational Rational number to convert
 *
 * @return 32-bit signed Q16 number
 */
int32_t mmal_rational_to_fixed_16_16(MMAL_RATIONAL_T rational);

/** Convert a signed 32-bit Q16 number to a rational number.
 *
 * @param fixed    Signed 32-bit Q16 number to convert
 *
 * @return Rational number
 */
MMAL_RATIONAL_T mmal_rational_from_fixed_16_16(int32_t fixed);

/** Reduce a rational number to it's simplest form.
 *
 * @param rational Rational number to simplify
 */
void mmal_rational_simplify(MMAL_RATIONAL_T *rational);

#ifdef __cplusplus
}
#endif

/** @} */

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include "../mmal.h"
#include "mmal_encodings.h"
#include "mmal_util.h"
#include "mmal_logging.h"
#include <string.h>
#include <stdio.h>

#define STATUS_TO_STR(x) { MMAL_##x, #x }

static struct {
   MMAL_STATUS_T status;
   const char *str;
} status_to_string_map[] =
{
   STATUS_TO_STR(SUCCESS),
   STATUS_TO_STR(ENOMEM),
   STATUS_TO_STR(ENOSPC),
   STATUS_TO_STR(EINVAL),
   STATUS_TO_STR(ENOSYS),
   STATUS_TO_STR(ENOENT),
   STATUS_TO_STR(ENXIO),
   STATUS_TO_STR(EIO),
   STATUS_TO_STR(ESPIPE),
   STATUS_TO_STR(ECORRUPT),
   STATUS_TO_STR(ENOTREADY),
   STATUS_TO_STR(ECONFIG),
   {0, 0}
};

const char *mmal_status_to_string(MMAL_STATUS_T status)
{
   unsigned i;

   for (i=0; status_to_string_map[i].str; i++)
      if (status_to_string_map[i].status == status)
         break;

   return status_to_string_map[i].str ? status_to_string_map[i].str : "UNKNOWN";
}

static struct {
   uint32_t encoding;
   uint32_t pitch_num;
   uint32_t pitch_den;
} pixel_pitch[] =
{
   {MMAL_ENCODING_I420,  1, 1},
   {MMAL_ENCODING_YV12,  1, 1},
   {MMAL_ENCODING_I422,  1, 1},
   {MMAL_ENCODING_NV21,  1, 1},
   {MMAL_ENCODING_NV12,  1, 1},
   {MMAL_ENCODING_ARGB,  4, 1},
   {MMAL_ENCODING_RGBA,  4, 1},
   {MMAL_ENCODING_RGB32, 4, 1},
   {MMAL_ENCODING_ABGR,  4, 1},
   {MMAL_ENCODING_BGRA,  4, 1},
   {MMAL_ENCODING_BGR32, 4, 1},
   {MMAL_ENCODING_RGB16, 2, 1},
   {MMAL_ENCODING_RGB24, 3, 1},
   {MMAL_ENCODING_BGR16, 2, 1},
   {MMAL_ENCODING_BGR24, 3, 1},
   /* {MMAL_ENCODING_YUVUV128, 1, 1}, That's a special case which must not be included */
   {MMAL_ENCODING_UNKNOWN, 0, 0}
};

uint32_t mmal_encoding_stride_to_width(uint32_t encoding, uint32_t stride)
{
   unsigned int i;

   for(i = 0; pixel_pitch[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(pixel_pitch[i].encoding == encoding) break;

   if(pixel_pitch[i].encoding == MMAL_ENCODING_UNKNOWN)
      return 0;

   return pixel_pitch[i].pitch_den * stride / pixel_pitch[i].pitch_num;
}

uint32_t mmal_encoding_width_to_stride(uint32_t encoding, uint32_t width)
{
   unsigned int i;

   for(i = 0; pixel_pitch[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
      if(pixel_pitch[i].encoding == encoding) break;

   if(pixel_pitch[i].encoding == MMAL_ENCODING_UNKNOWN)
      return 0;

   return pixel_pitch[i].pitch_num * width / pixel_pitch[i].pitch_den;
}

const char* mmal_port_type_to_string(MMAL_PORT_TYPE_T type)
{
   const char *str;

   switch (type)
   {
   case MMAL_PORT_TYPE_INPUT:   str = "in";  break;
   case MMAL_PORT_TYPE_OUTPUT:  str = "out"; break;
   case MMAL_PORT_TYPE_CLOCK:   str = "clk"; break;
   case MMAL_PORT_TYPE_CONTROL: str = "ctr"; break;
   default:                     str = "invalid"; break;
   }

   return str;
}

MMAL_PARAMETER_HEADER_T *mmal_port_parameter_alloc_get(MMAL_PORT_T *port,
   uint32_t id, uint32_t size, MMAL_STATUS_T *p_status)
{
   MMAL_PARAMETER_HEADER_T *param = NULL;
   MMAL_STATUS_T status = MMAL_ENOSYS;

   if (size < sizeof(MMAL_PARAMETER_HEADER_T))
      size = sizeof(MMAL_PARAMETER_HEADER_T);

   if ((param = vcos_calloc(1, size, "mmal_port_param_get")) == NULL)
   {
      status = MMAL_ENOMEM;
      goto error;
   }

   param->id = id;
   param->size = size;

   if ((status = mmal_port_parameter_get(port, param)) == MMAL_ENOSPC)
   {
      /* We need to reallocate to get enough space for all parameter data */
      size = param->size;
      vcos_free(param);
      if ((param = vcos_calloc(1, size, "mmal_port_param_get")) == NULL)
      {
         status = MMAL_ENOMEM;
         goto error;
      }

      /* Now retrieve it again */
      param->id = id;
      param->size = size;
      status = mmal_port_parameter_get(port, param);
   }

   if (status != MMAL_SUCCESS)
      goto error;

end:
   if (p_status) *p_status = status;
   return param;
error:
   if (param) vcos_free(param);
   param = NULL;
   goto end;
}

void mmal_port_parameter_free(MMAL_PARAMETER_HEADER_T *param)
{
   vcos_free(param);
}

/** Copy buffer header metadata from source to dest
 */
void mmal_buffer_header_copy_header(MMAL_BUFFER_HEADER_T *dest, const MMAL_BUFFER_HEADER_T *src)
{
   dest->cmd    = src->cmd;
   dest->offset = src->offset;
   dest->length = src->length;
   dest->flags  = src->flags;
   dest->pts    = src->pts;
   dest->dts    = src->dts;
   *dest->type = *src->type;
}

/** Create a pool of MMAL_BUFFER_HEADER_T */
MMAL_POOL_T *mmal_port_pool_create(MMAL_PORT_T *port, unsigned int headers, uint32_t payload_size)
{
   if (!port || !port->priv)
      return NULL;

   LOG_TRACE("%s(%i:%i) port %p, headers %u, size %i", port->component->name,
             (int)port->type, (int)port->index, port, headers, (int)payload_size);

   /* Create a pool and ask the port for some memory */
   return mmal_pool_create_with_allocator(headers, payload_size, (void *)port,
                                          (mmal_pool_allocator_alloc_t)mmal_port_payload_alloc,
                                          (mmal_pool_allocator_free_t)mmal_port_payload_free);
}

/** Destroy a pool of MMAL_BUFFER_HEADER_T */
void mmal_port_pool_destroy(MMAL_PORT_T *port, MMAL_POOL_T *pool)
{
   if (!port || !port->priv || !pool)
      return;

   LOG_TRACE("%s(%i:%i) port %p, pool %p", port->component->name,
             (int)port->type, (int)port->index, port, pool);

   if (!vcos_verify(!port->is_enabled))
   {
      LOG_ERROR("port %p, pool %p destroyed while port enabled", port, pool);
      mmal_port_disable(port);
   }

   mmal_pool_destroy(pool);
}

/*****************************************************************************/
void mmal_log_dump_port(MMAL_PORT_T *port)
{
   if (!port)
      return;

   LOG_DEBUG("%s(%p)", port->name, port);

   mmal_log_dump_format(port->format);

   LOG_DEBUG(" buffers num: %i(opt %i, min %i), size: %i(opt %i, min: %i), align: %i",
            port->buffer_num, port->buffer_num_recommended, port->buffer_num_min,
            port->buffer_size, port->buffer_size_recommended, port->buffer_size_min,
            port->buffer_alignment_min);
}

/*****************************************************************************/
void mmal_log_dump_format(MMAL_ES_FORMAT_T *format)
{
   const char *name_type;

   if (!format)
      return;

   switch(format->type)
   {
   case MMAL_ES_TYPE_AUDIO: name_type = "audio"; break;
   case MMAL_ES_TYPE_VIDEO: name_type = "video"; break;
   case MMAL_ES_TYPE_SUBPICTURE: name_type = "subpicture"; break;
   default: name_type = "unknown"; break;
   }

   LOG_DEBUG("type: %s, fourcc: %4.4s", name_type, (char *)&format->encoding);
   LOG_DEBUG(" bitrate: %i, framed: %i", format->bitrate,
            !!(format->flags & MMAL_ES_FORMAT_FLAG_FRAMED));
   LOG_DEBUG(" extra data: %i, %p", format->extradata_size, format->extradata);
   switch(format->type)
   {
   case MMAL_ES_TYPE_AUDIO:
      LOG_DEBUG(" samplerate: %i, channels: %i, bps: %i, block align: %i",
               format->es->audio.sample_rate, format->es->audio.channels,
               format->es->audio.bits_per_sample, format->es->audio.block_align);
      break;

   case MMAL_ES_TYPE_VIDEO:
      LOG_DEBUG(" width: %i, height: %i, (%i,%i,%i,%i)",
               format->es->video.width, format->es->video.height,
               format->es->video.crop.x, format->es->video.crop.y,
               format->es->video.crop.width, format->es->video.crop.height);
      LOG_DEBUG(" pixel aspect ratio: %i/%i, frame rate: %i/%i",
               format->es->video.par.num, format->es->video.par.den,
               format->es->video.frame_rate.num, format->es->video.frame_rate.den);
      break;

   case MMAL_ES_TYPE_SUBPICTURE:
      break;

   default: break;
   }
}

MMAL_PORT_T *mmal_util_get_port(MMAL_COMPONENT_T *comp, MMAL_PORT_TYPE_T type, unsigned index)
{
   unsigned num;
   MMAL_PORT_T **list;

   switch (type)
   {
   case MMAL_PORT_TYPE_INPUT:
      num = comp->input_num;
      list = comp->input;
      break;

   case MMAL_PORT_TYPE_OUTPUT:
      num = comp->output_num;
      list = comp->output;
      break;

   case MMAL_PORT_TYPE_CLOCK:
      num = comp->clock_num;
      list = comp->clock;
      break;

   case MMAL_PORT_TYPE_CONTROL:
      num = 1;
      list = &comp->control;
      break;

   default:
      vcos_assert(0);
      return NULL;
   }
   if (index < num)
      return list[index];
   else
      return NULL;
}

char *mmal_4cc_to_string(char *buf, size_t len, uint32_t fourcc)
{
   char *src = (char*)&fourcc;
   vcos_assert(len >= 5);
   if (len < 5)
   {
      buf[0] = '\0';
   }
   else if (fourcc)
   {
      memcpy(buf, src, 4);
      buf[4] = '\0';
   }
   else
   {
      snprintf(buf, len, "<0>");
   }
   return buf;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_UTIL_H
#define MMAL_UTIL_H

#include "../mmal.h"

/** \defgroup MmalUtilities Utility functions
 * The utility functions provide helpers for common functionality that is not part
 * of the core MMAL API.
 * @{
 */

/** Offset in bytes of FIELD in TYPE. */
#define MMAL_OFFSET(TYPE, FIELD) ((size_t)((uint8_t *)&((TYPE*)0)->FIELD - (uint8_t *)0))

#ifdef __cplusplus
extern "C" {
#endif

/** Convert a status to a statically-allocated string.
 *
 * @param status The MMAL status code.
 * @return A C string describing the status code.
 */
const char *mmal_status_to_string(MMAL_STATUS_T status);

/** Convert stride to pixel width for a given pixel encoding.
 *
 * @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
 * @param stride The stride in bytes.
 * @return The width in pixels.
 */
uint32_t mmal_encoding_stride_to_width(uint32_t encoding, uint32_t stride);

/** Convert pixel width to stride for a given pixel encoding
 *
 * @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
 * @param width The width in pixels.
 * @return The stride in bytes.
 */
uint32_t mmal_encoding_width_to_stride(uint32_t encoding, uint32_t width);

/** Convert a port type to a string.
 *
 * @param type The MMAL port type.
 * @return A NULL-terminated string describing the port type.
 */
const char* mmal_port_type_to_string(MMAL_PORT_TYPE_T type);

/** Get a parameter from a port allocating the required amount of memory
 * for the parameter (i.e. for variable length parameters like URI or arrays).
 * The size field will be set on output to the actual size of the
 * parameter allocated and retrieved.
 *
 * The pointer returned must be released by a call to \ref mmal_port_parameter_free().
 *
 * @param port port to send request to
 * @param id parameter id
 * @param size initial size hint for allocation (can be 0)
 * @param status status of the parameter get operation (can be 0)
 * @return pointer to the header of the parameter or NULL on failure.
 */
MMAL_PARAMETER_HEADER_T *mmal_port_parameter_alloc_get(MMAL_PORT_T *port,
   uint32_t id, uint32_t size, MMAL_STATUS_T *status);

/** Free a parameter structure previously allocated via
 * \ref mmal_port_parameter_alloc_get().
 *
 * @param param pointer to header of the parameter
 */
void mmal_port_parameter_free(MMAL_PARAMETER_HEADER_T *param);

/** Copy buffer header metadata from source to destination.
 *
 * @param dest The destination buffer header.
 * @param src  The source buffer header.
 */
void mmal_buffer_header_copy_header(MMAL_BUFFER_HEADER_T *dest, const MMAL_BUFFER_HEADER_T *src);

/** Create a pool of MMAL_BUFFER_HEADER_T associated with a specific port.
 * This allows a client to allocate memory for the payload buffers based on the preferences
 * of a port. This for instance will allow the port to allocate memory which can be shared
 * between the host processor and videocore.
 * After allocation, all allocated buffer headers will have been added to the queue.
 *
 * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
 * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
 * headers, or the size of the payload buffers, after creation of the pool.
 *
 * @param port         Port responsible for creating the pool.
 * @param headers      Number of buffers which will be allocated with the pool.
 * @param payload_size Size of the payload buffer which will be allocated in
 *                     each of the buffer headers.
 * @return Pointer to the newly created pool or NULL on failure.
 */
MMAL_POOL_T *mmal_port_pool_create(MMAL_PORT_T *port,
   unsigned int headers, uint32_t payload_size);

/** Destroy a pool of MMAL_BUFFER_HEADER_T associated with a specific port.
 * This will also deallocate all of the memory which was allocated when creating or
 * resizing the pool.
 *
 * @param port  Pointer to the port responsible for creating the pool.
 * @param pool  Pointer to the pool to be destroyed.
 */
void mmal_port_pool_destroy(MMAL_PORT_T *port, MMAL_POOL_T *pool);

/** Log the content of a \ref MMAL_PORT_T structure.
 *
 * @param port  Pointer to the port to dump.
 */
void mmal_log_dump_port(MMAL_PORT_T *port);

/** Log the content of a \ref MMAL_ES_FORMAT_T structure.
 *
 * @param format  Pointer to the format to dump.
 */
void mmal_log_dump_format(MMAL_ES_FORMAT_T *format);

/** Return the nth port.
 *
 * @param comp   component to query
 * @param index  port index
 * @param type   port type
 *
 * @return port or NULL if not found
 */
MMAL_PORT_T *mmal_util_get_port(MMAL_COMPONENT_T *comp, MMAL_PORT_TYPE_T type, unsigned index);

/** Convert a 4cc into a string.
 *
 * @param buf    Destination for result
 * @param len    Size of result buffer
 * @param fourcc 4cc to be converted
 * @return converted string (buf)
 *
 */
char *mmal_4cc_to_string(char *buf, size_t len, uint32_t fourcc);


#ifdef __cplusplus
}
#endif

/** @} */

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/CMakeLists.txt
================
add_library(mmal_vc_client SHARED mmal_vc_client.c mmal_vc_shm.c mmal_vc_api.c mmal_vc_opaque_alloc.c mmal_vc_msgnames.c mmal_vc_api_drm.c)
target_link_libraries(mmal_vc_client vchiq_arm vcos)

if(BUILD_MMAL_APPS)
add_executable(mmal_vc_diag mmal_vc_diag.c)
target_link_libraries(mmal_vc_diag mmal mmal_vc_client debug_sym vcos)
endif(BUILD_MMAL_APPS)

install(TARGETS mmal_vc_client DESTINATION lib)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api_drm.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include "mmal_vc_api_drm.h"
#include "mmal_vc_api.h"
#include "interface/mmal/mmal_logging.h"
#include "interface/mmal/mmal.h"
#include "mmal_vc_api.h"
#include "mmal_vc_msgs.h"
#include "mmal_vc_client_priv.h"
#include "mmal_vc_opaque_alloc.h"
#include "mmal_vc_shm.h"
#include "interface/mmal/util/mmal_util.h"
#include "interface/mmal/core/mmal_component_private.h"
#include "interface/mmal/core/mmal_port_private.h"
#include "interface/mmal/core/mmal_buffer_private.h"
#include "interface/vcos/vcos.h"


int mmal_vc_drm_get_time(unsigned int * time)
{
   MMAL_STATUS_T status;
   mmal_worker_msg_header req;
   mmal_worker_drm_get_time_reply reply;
   size_t len = sizeof(reply);
   status = mmal_vc_init();
   if (status != MMAL_SUCCESS) return status;
   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                     &req, sizeof(req),
                                     MMAL_WORKER_DRM_GET_TIME,
                                     &reply, &len, MMAL_FALSE);
   *time = reply.time;
   mmal_vc_deinit();
   return status;
}


int mmal_vc_drm_get_lhs32(unsigned char * into)
{
   MMAL_STATUS_T status;
   mmal_worker_msg_header req;
   mmal_worker_drm_get_lhs32_reply reply;
   size_t len = sizeof(reply);
   status = mmal_vc_init();
   if (status != MMAL_SUCCESS) return status;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                     &req, sizeof(req),
                                     MMAL_WORKER_DRM_GET_LHS32,
                                     &reply, &len, MMAL_FALSE);
   memcpy(into, reply.secret, 32);
   mmal_vc_deinit();
   return status;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api_drm.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef MMAL_VC_API_DRM_H
#define MMAL_VC_API_DRM_H

/** @file
  *
  * Public API for MMAL VC client. (Divx DRM part)
  */


#ifdef __cplusplus
extern "C" {
#endif

// Reads the current clock (in microseconds) into the "time" variable.
// Returns zero on success, nonszero on failure
int mmal_vc_drm_get_time(unsigned int * time);

// Reads the local hardware secret into the "into" variable (needs to be 32 bytes of space for this)
// Returns 0 on success, nonzero on failure
// Usage:
//   unsigned char buffer[32];
//   success = mmal_vc_divx_drm_get_lhs(buffer);
int mmal_vc_drm_get_lhs32(unsigned char * into);


#ifdef __cplusplus
}
#endif
#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "interface/mmal/mmal_logging.h"
#include "interface/mmal/mmal.h"
#include "mmal_vc_api.h"
#include "mmal_vc_msgs.h"
#include "mmal_vc_client_priv.h"
#include "mmal_vc_opaque_alloc.h"
#include "mmal_vc_shm.h"
#include "interface/mmal/util/mmal_util.h"
#include "interface/mmal/core/mmal_component_private.h"
#include "interface/mmal/core/mmal_port_private.h"
#include "interface/mmal/core/mmal_buffer_private.h"
#include "interface/vcos/vcos.h"

/** Private information for MMAL VC components
 */

typedef enum MMAL_ZEROLEN_CHECK_T
{
   ZEROLEN_NOT_INITIALIZED,
   ZEROLEN_COMPATIBLE,
   ZEROLEN_INCOMPATIBLE
} MMAL_ZEROLEN_CHECK_T;

typedef enum MMAL_PORT_FLUSH_CHECK_T
{
   PORT_FLUSH_NOT_INITIALIZED,
   PORT_FLUSH_COMPATIBLE,
   PORT_FLUSH_INCOMPATIBLE
} MMAL_PORT_FLUSH_CHECK_T;

typedef struct MMAL_PORT_MODULE_T
{
   uint32_t magic;
   uint32_t component_handle;
   MMAL_PORT_T *port;
   uint32_t port_handle;

   MMAL_BOOL_T has_pool;
   VCOS_BLOCKPOOL_T pool;

   MMAL_BOOL_T is_zero_copy;
   MMAL_BOOL_T zero_copy_workaround;

   MMAL_BOOL_T sent_data_on_port;

   MMAL_PORT_T *connected;           /**< Connected port if any */
} MMAL_PORT_MODULE_T;

typedef struct MMAL_COMPONENT_MODULE_T
{
   uint32_t component_handle;

   MMAL_PORT_MODULE_T **ports;
   uint32_t ports_num;

   MMAL_QUEUE_T *callback_queue;   /**< Used to queue the callbacks we need to make to the client */

   MMAL_BOOL_T event_ctx_initialised;
   MMAL_VC_CLIENT_BUFFER_CONTEXT_T event_ctx; /**< Used as the ctx for event buffers */
} MMAL_COMPONENT_MODULE_T;

/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/
static void mmal_vc_do_callback(MMAL_COMPONENT_T *component);
static MMAL_STATUS_T mmal_vc_port_info_get(MMAL_PORT_T *port);

/*****************************************************************************/
MMAL_STATUS_T mmal_vc_get_version(uint32_t *major, uint32_t *minor, uint32_t *minimum)
{
   mmal_worker_version msg;
   size_t len = sizeof(msg);
   MMAL_STATUS_T status;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_GET_VERSION, &msg, &len, MMAL_FALSE);

   if (status != MMAL_SUCCESS)
      return status;

   if (!vcos_verify(len == sizeof(msg)))
      return MMAL_EINVAL;

   *major = msg.major;
   *minor = msg.minor;
   *minimum = msg.minimum;
   return MMAL_SUCCESS;
}

/*****************************************************************************/
MMAL_STATUS_T mmal_vc_get_stats(MMAL_VC_STATS_T *stats, int reset)
{
   mmal_worker_stats msg;
   size_t len = sizeof(msg);
   msg.reset = reset;

   MMAL_STATUS_T status = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                                   &msg.header, sizeof(msg),
                                                   MMAL_WORKER_GET_STATS,
                                                   &msg, &len, MMAL_FALSE);


   if (status == MMAL_SUCCESS)
   {
      vcos_assert(len == sizeof(msg));
      *stats = msg.stats;
   }
   return status;
}

/** Set port buffer requirements. */
static MMAL_STATUS_T mmal_vc_port_requirements_set(MMAL_PORT_T *port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   mmal_worker_reply reply;
   mmal_worker_port_action msg;
   size_t replylen = sizeof(reply);

   msg.component_handle = module->component_handle;
   msg.action = MMAL_WORKER_PORT_ACTION_SET_REQUIREMENTS;
   msg.port_handle = module->port_handle;
   msg.param.enable.port = *port;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }
   if (status != MMAL_SUCCESS)
      LOG_ERROR("failed to set port requirements (%i/%i,%i/%i)",
                port->buffer_num, port->buffer_num_min,
                port->buffer_size, port->buffer_size_min);

   return status;
}

/** Get port buffer requirements. */
static MMAL_STATUS_T mmal_vc_port_requirements_get(MMAL_PORT_T *port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   mmal_worker_port_info_get msg;
   mmal_worker_port_info reply;
   size_t replylen = sizeof(reply);
   MMAL_STATUS_T status;

   msg.component_handle = module->component_handle;
   msg.port_type = port->type;
   msg.index = port->index;

   LOG_TRACE("get port requirements (%i:%i)", port->type, port->index);

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_INFO_GET, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to get port requirements (%i:%i)", port->type, port->index);
      return status;
   }

   port->buffer_num_min = reply.port.buffer_num_min;
   port->buffer_num_recommended = reply.port.buffer_num_recommended;
   port->buffer_size_min = reply.port.buffer_size_min;
   port->buffer_size_recommended = reply.port.buffer_size_recommended;
   port->buffer_alignment_min = reply.port.buffer_alignment_min;

   return MMAL_SUCCESS;
}

/** Enable processing on a port */
static MMAL_STATUS_T mmal_vc_port_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   mmal_worker_reply reply;
   mmal_worker_port_action msg;
   size_t replylen = sizeof(reply);
   MMAL_PARAM_UNUSED(cb);

   if (!port->component->priv->module->event_ctx_initialised)
   {
      MMAL_POOL_T *pool = port->component->priv->event_pool;
      MMAL_DRIVER_BUFFER_T *drv;
      unsigned int i;

      /* We need to associate our vc client context to all our event buffers.
       * This only needs to be done when the first port is enabled because no event
       * can be received on disabled ports. */
      for (i = 0; i < pool->headers_num; i++)
      {
         drv = mmal_buffer_header_driver_data(pool->header[i]);
         drv->client_context = &port->component->priv->module->event_ctx;
         drv->magic = MMAL_MAGIC;
      }

      port->component->priv->module->event_ctx_initialised = MMAL_TRUE;
   }

   if (!module->connected)
   {
      if (vcos_blockpool_create_on_heap(&module->pool, port->buffer_num,
             sizeof(MMAL_VC_CLIENT_BUFFER_CONTEXT_T),
             VCOS_BLOCKPOOL_ALIGN_DEFAULT, VCOS_BLOCKPOOL_FLAG_NONE, "mmal vc port pool") != VCOS_SUCCESS)
      {
         LOG_ERROR("failed to create port pool");
         return MMAL_ENOMEM;
      }
      module->has_pool = 1;
   }

   if (module->connected)
   {
      /* The connected port won't be enabled explicitly so make sure we apply
       * the buffer requirements now. */
      status = mmal_vc_port_requirements_set(module->connected);
      if (status != MMAL_SUCCESS)
         goto error;
   }

   msg.component_handle = module->component_handle;
   msg.action = MMAL_WORKER_PORT_ACTION_ENABLE;
   msg.port_handle = module->port_handle;
   msg.param.enable.port = *port;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to enable port %s: %s",
               port->name, mmal_status_to_string(status));
      goto error;
   }

   if (module->connected)
      mmal_vc_port_info_get(module->connected);

   return MMAL_SUCCESS;

 error:
   if (module->has_pool)
      vcos_blockpool_delete(&module->pool);
   return status;
}

/** Disable processing on a port */
static MMAL_STATUS_T mmal_vc_port_disable(MMAL_PORT_T *port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   mmal_worker_reply reply;
   mmal_worker_port_action msg;
   size_t replylen = sizeof(reply);

   msg.component_handle = module->component_handle;
   msg.action = MMAL_WORKER_PORT_ACTION_DISABLE;
   msg.port_handle = module->port_handle;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }
   if (status != MMAL_SUCCESS)
      LOG_ERROR("failed to disable port - reason %d", status);

   if (module->has_pool)
   {
      /* MMAL server should make sure that all buffers are sent back before it
       * disables the port. */
      vcos_assert(vcos_blockpool_available_count(&module->pool) == port->buffer_num);
      vcos_blockpool_delete(&module->pool);
      module->has_pool = 0;
   }

   /* We need to make sure all the queued callbacks have been done */
   while (mmal_queue_length(port->component->priv->module->callback_queue))
      mmal_vc_do_callback(port->component);

   if (module->connected)
      mmal_vc_port_info_get(module->connected);

   return status;
}

/** Flush a port using MMAL_WORKER_PORT_ACTION - when the port is zero-copy or no data has been sent */
static MMAL_STATUS_T mmal_vc_port_flush_normal(MMAL_PORT_T *port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   mmal_worker_reply reply;
   mmal_worker_port_action msg;
   size_t replylen = sizeof(reply);

   msg.component_handle = module->component_handle;
   msg.action = MMAL_WORKER_PORT_ACTION_FLUSH;
   msg.port_handle = module->port_handle;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }
   if (status != MMAL_SUCCESS)
      LOG_ERROR("failed to disable port - reason %d", status);

   return status;
}


/** Flush a port using PORT_FLUSH - generates a dummy bulk transfer to keep it in sync
  * with buffers being passed using bulk transfer */
static MMAL_STATUS_T mmal_vc_port_flush_sync(MMAL_PORT_T *port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   mmal_worker_reply reply;
   MMAL_VC_CLIENT_BUFFER_CONTEXT_T client_context;
   mmal_worker_buffer_from_host *msg;

   size_t replylen = sizeof(reply);

   msg = &client_context.msg;

   client_context.magic = MMAL_MAGIC;
   client_context.port = port;

   msg->drvbuf.client_context = &client_context;
   msg->drvbuf.component_handle = module->component_handle;
   msg->drvbuf.port_handle = module->port_handle;
   msg->drvbuf.magic = MMAL_MAGIC;


   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg->header, sizeof(*msg),
                                     MMAL_WORKER_PORT_FLUSH, &reply, &replylen, MMAL_TRUE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }
   if (status != MMAL_SUCCESS)
      LOG_ERROR("failed to disable port - reason %d", status);

   return status;
}

/** Flush a port */
static MMAL_STATUS_T mmal_vc_port_flush(MMAL_PORT_T *port)
{
   static MMAL_PORT_FLUSH_CHECK_T is_port_flush_compatible = PORT_FLUSH_NOT_INITIALIZED;
   uint32_t major = 0, minor = 0, minimum = 0;
   MMAL_STATUS_T status;
   /* Buffers sent to videocore, if not zero-copy, use vchiq bulk transfers to copy the data.
      A flush could be sent while one of these buffers is being copied. If the normal flushing method
      is used, the flush can arrive before the buffer, which causes confusion when a pre-flush buffer
      arrives after the flush. So use a special flush mode that uses a dummy vchiq transfer to synchronise
      things.
      If data has never been sent on the port, then we don't need to worry about a flush overtaking data.
      In that case, the port may not actually be set up on the other end to receive bulk transfers, so use
      the normal flushing mechanism in that case.
    */

   if (port->priv->module->is_zero_copy || !port->priv->module->sent_data_on_port)
      return mmal_vc_port_flush_normal(port);

   if (is_port_flush_compatible == PORT_FLUSH_NOT_INITIALIZED)
   {
      status = mmal_vc_get_version(&major, &minor, &minimum);
      if (major >= 15)
      {
         is_port_flush_compatible = PORT_FLUSH_COMPATIBLE;
      }
      else
      {
         LOG_ERROR("Version number of MMAL Server incompatible. Required Major:14 Minor: 2 \
          or Greater. Current Major %d , Minor %d",major,minor);
         is_port_flush_compatible = PORT_FLUSH_INCOMPATIBLE;
      }
   }

   if (is_port_flush_compatible == PORT_FLUSH_COMPATIBLE)
      return mmal_vc_port_flush_sync(port);
   else
      return mmal_vc_port_flush_normal(port);
}


/** Connect 2 ports together */
static MMAL_STATUS_T mmal_vc_port_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   mmal_worker_reply reply;
   mmal_worker_port_action msg;
   size_t replylen = sizeof(reply);

   /* We only support connecting vc components together */
   if (other_port && port->priv->pf_enable != other_port->priv->pf_enable)
      return MMAL_ENOSYS;

   /* Send the request to the video side */
   msg.component_handle = module->component_handle;
   msg.action = other_port ? MMAL_WORKER_PORT_ACTION_CONNECT : MMAL_WORKER_PORT_ACTION_DISCONNECT;
   msg.port_handle = module->port_handle;
   if (other_port)
   {
      msg.param.connect.component_handle = other_port->priv->module->component_handle;
      msg.param.connect.port_handle = other_port->priv->module->port_handle;
   }

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }

   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to connect ports: %s", mmal_status_to_string(status));
      return status;
   }

   if (other_port)
   {
      /* Connection */
      module->connected = other_port;
      other_port->priv->module->connected = port;
   }
   else
   {
      /* Disconnection */
      if (module->connected)
         module->connected->priv->module->connected = NULL;
      module->connected = NULL;
   }

   return MMAL_SUCCESS;
}

/*****************************************************************************/
static void mmal_vc_do_callback(MMAL_COMPONENT_T *component)
{
   MMAL_COMPONENT_MODULE_T *module = component->priv->module;
   MMAL_BUFFER_HEADER_T *buffer;
   MMAL_PORT_T *port;

   /* Get a buffer from this port */
   buffer = mmal_queue_get(module->callback_queue);
   if (!buffer)
      return; /* Will happen when a port gets disabled */

   port = (MMAL_PORT_T *)buffer->priv->component_data;

   /* Catch and report any transmission error */
   if (buffer->flags & MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED)
       mmal_event_error_send(port->component, MMAL_EIO);

   /* Events generated by this component are handled differently */
   if (mmal_buffer_header_driver_data(buffer)->client_context ==
       &component->priv->module->event_ctx)
   {
      mmal_port_event_send(port, buffer);
      return;
   }

   buffer->data = mmal_vc_shm_lock(buffer->data, port->priv->module->zero_copy_workaround);
   mmal_port_buffer_header_callback(port, buffer);
}

/** Called back from VCHI(Q) event handler when buffers come back from the copro.
 *
 * The message points to the message sent by videocore, and which should have
 * a pointer back to our original client side context.
 *
 */
static void mmal_vc_port_send_callback(mmal_worker_buffer_from_host *msg)
{
   MMAL_BUFFER_HEADER_T *buffer;
   MMAL_PORT_T *port;
   MMAL_VC_CLIENT_BUFFER_CONTEXT_T *client_context = msg->drvbuf.client_context;

   vcos_assert(client_context);
   vcos_assert(client_context->magic == MMAL_MAGIC);

   buffer = client_context->buffer;
   port = client_context->port;
   vcos_blockpool_free(msg->drvbuf.client_context);

   vcos_assert(port->priv->module->magic == MMAL_MAGIC);
   mmal_vc_msg_to_buffer_header(buffer, msg);

   /* Queue the callback so it is delivered by the action thread */
   buffer->priv->component_data = (void *)port;
   mmal_queue_put(port->component->priv->module->callback_queue, buffer);
   mmal_component_action_trigger(port->component);
}

static void mmal_vc_port_send_event_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   /* Queue the event to be delivered by the action thread */
   buffer->priv->component_data = (void *)port;
   mmal_queue_put(port->component->priv->module->callback_queue, buffer);
   mmal_component_action_trigger(port->component);
}

/** Called from the client to send a buffer (empty or full) to
  * the copro.
  */
static MMAL_STATUS_T mmal_vc_port_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   MMAL_VC_CLIENT_BUFFER_CONTEXT_T *client_context;
   mmal_worker_buffer_from_host *msg;
   uint32_t length;
   uint32_t msgid = MMAL_WORKER_BUFFER_FROM_HOST;
   uint32_t major = 0, minor = 0, minimum = 0;
   static MMAL_ZEROLEN_CHECK_T is_vc_zerolength_compatible = ZEROLEN_NOT_INITIALIZED;

   vcos_assert(port);
   vcos_assert(module);
   vcos_assert(module->magic == MMAL_MAGIC);

   /* Handle event buffers */
   if (buffer->cmd)
   {
      MMAL_EVENT_FORMAT_CHANGED_T *event = mmal_event_format_changed_get(buffer);
      if (event)
      {
         mmal_format_copy(port->format, event->format);
         status = port->priv->pf_set_format(port);
         if(status != MMAL_SUCCESS)
            LOG_ERROR("format not set on port %p", port);
      }
      else
      {
         LOG_ERROR("discarding event %i on port %p", (int)buffer->cmd, port);
      }

      buffer->length = 0;
      mmal_port_buffer_header_callback(port, buffer);
      return MMAL_SUCCESS;
   }

   /* We can only send buffers if we have a pool */
   if (!module->has_pool)
   {
      LOG_ERROR("no pool on port %p", port);
      return MMAL_EINVAL;
   }

   client_context = vcos_blockpool_alloc(&module->pool);
   if(!client_context)
   {
      LOG_INFO("couldn't allocate client buffer context from pool");
      return MMAL_ENOMEM;
   }
   msg = &client_context->msg;

   client_context->magic = MMAL_MAGIC;
   client_context->buffer = buffer;
   client_context->callback = mmal_vc_port_send_callback;
   client_context->callback_event = NULL;
   client_context->port = port;

   msg->drvbuf.client_context = client_context;
   msg->drvbuf.component_handle = module->component_handle;
   msg->drvbuf.port_handle = module->port_handle;
   msg->drvbuf.magic = MMAL_MAGIC;

   length = buffer->length;

   if (length <= MMAL_VC_SHORT_DATA && !port->priv->module->is_zero_copy &&
       port->format->encoding == MMAL_ENCODING_OPAQUE)
   {
      memcpy(msg->short_data, buffer->data + buffer->offset, buffer->length);
      msg->payload_in_message = length;
      length = 0;
   }
   else
   {
      msg->payload_in_message = 0;
   }

   buffer->data =
      mmal_vc_shm_unlock(buffer->data, &length, port->priv->module->zero_copy_workaround);
   mmal_vc_buffer_header_to_msg(msg, buffer);

   if (!VCOS_BLOCKPOOL_IS_VALID_HANDLE_FORMAT(msg->drvbuf.component_handle, 256))
   {
      LOG_ERROR("bad component handle 0x%x", msg->drvbuf.component_handle);
      return MMAL_EINVAL;
   }

   if (msg->drvbuf.port_handle > 255)
   {
      LOG_ERROR("bad port handle 0x%x", msg->drvbuf.port_handle);
      return MMAL_EINVAL;
   }

   if (module->is_zero_copy)
      length = 0;

   if (is_vc_zerolength_compatible == ZEROLEN_NOT_INITIALIZED)
   {
      status = mmal_vc_get_version(&major, &minor, &minimum);
      if ((major > 12 ) || ((major == 12) && (minor >= 2)))
      {
         is_vc_zerolength_compatible = ZEROLEN_COMPATIBLE;
      }
      else
      {
         LOG_ERROR("Version number of MMAL Server incompatible. Required Major:12 Minor: 2 \
          or Greater. Current Major %d , Minor %d",major,minor);
         is_vc_zerolength_compatible = ZEROLEN_INCOMPATIBLE;
      }
   }

   if ((is_vc_zerolength_compatible == ZEROLEN_COMPATIBLE) && !(module->is_zero_copy) && !length
       && (msg->buffer_header.flags & MMAL_BUFFER_HEADER_FLAG_EOS))
   {
      length = 8;
      msgid = MMAL_WORKER_BUFFER_FROM_HOST_ZEROLEN;
   }

   if (length)
   {
      // We're doing a bulk transfer. Note this so that flushes know
      // they need to use the more cumbersome fake-bulk-transfer mechanism
      // to guarantee correct ordering.
      port->priv->module->sent_data_on_port = MMAL_TRUE;
   }

   status = mmal_vc_send_message(mmal_vc_get_client(), &msg->header, sizeof(*msg),
                                 buffer->data + buffer->offset, length,
                                 msgid);
   if (status != MMAL_SUCCESS)
   {
      LOG_INFO("failed %d", status);
      vcos_blockpool_free(msg->drvbuf.client_context);
      buffer->data = mmal_vc_shm_lock(buffer->data, port->priv->module->zero_copy_workaround);
   }

   return status;
}

static MMAL_STATUS_T mmal_vc_component_disable(MMAL_COMPONENT_T *component)
{
   MMAL_STATUS_T status;
   mmal_worker_reply reply;
   mmal_worker_component_disable msg;
   size_t replylen = sizeof(reply);

   vcos_assert(component && component->priv && component->priv->module);

   msg.component_handle = component->priv->module->component_handle;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
         MMAL_WORKER_COMPONENT_DISABLE,
         &reply, &replylen, MMAL_FALSE);

   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }

   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to disable component - reason %d", status);
      goto fail;
   }

   return status;
fail:
   return status;
}

static MMAL_STATUS_T mmal_vc_component_enable(MMAL_COMPONENT_T *component)
{
   MMAL_STATUS_T status;
   mmal_worker_reply reply;
   mmal_worker_component_enable msg;
   size_t replylen = sizeof(reply);

   vcos_assert(component && component->priv && component->priv->module);

   msg.component_handle = component->priv->module->component_handle;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_COMPONENT_ENABLE, &reply, &replylen, MMAL_FALSE);

   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }

   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to enable component: %s", mmal_status_to_string(status));
      return status;
   }

   return MMAL_SUCCESS;
}

static MMAL_STATUS_T mmal_vc_component_destroy(MMAL_COMPONENT_T *component)
{
   MMAL_STATUS_T status;
   mmal_worker_component_destroy msg;
   mmal_worker_reply reply;
   size_t replylen = sizeof(reply);

   vcos_assert(component && component->priv && component->priv->module);

   msg.component_handle = component->priv->module->component_handle;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
         MMAL_WORKER_COMPONENT_DESTROY,
         &reply, &replylen, MMAL_FALSE);

   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to destroy component - reason %d", status );
      goto fail;
   }

   if(component->input_num)
      mmal_ports_free(component->input, component->input_num);
   if(component->output_num)
      mmal_ports_free(component->output, component->output_num);
   if(component->clock_num)
      mmal_ports_free(component->clock, component->clock_num);

   vcos_free(component->priv->module);
   component->priv->module = NULL;

fail:
   // no longer require videocore
   mmal_vc_release();
   mmal_vc_deinit();
   return status;
}

MMAL_STATUS_T mmal_vc_consume_mem(size_t size, uint32_t *handle)
{
   MMAL_STATUS_T status;
   mmal_worker_consume_mem req;
   mmal_worker_consume_mem reply;
   size_t len = sizeof(reply);

   req.size = (uint32_t) size;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                     &req.header, sizeof(req),
                                     MMAL_WORKER_CONSUME_MEM,
                                     &reply, &len, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(len == sizeof(reply));
      status = reply.status;
      *handle = reply.handle;
   }
   return status;
}

MMAL_STATUS_T mmal_vc_lmk(uint32_t alloc_size)
{
   MMAL_STATUS_T status;
   mmal_worker_lmk req;
   mmal_worker_lmk reply;
   size_t len = sizeof(reply);

   req.alloc_size = alloc_size;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                     &req.header, sizeof(req),
                                     MMAL_WORKER_LMK,
                                     &reply, &len, MMAL_FALSE);
   return status;
}

MMAL_STATUS_T mmal_vc_host_log(const char *msg)
{
   MMAL_STATUS_T status = MMAL_EINVAL;
   if (msg)
   {
      mmal_worker_host_log req;
      mmal_worker_reply reply;
      size_t replylen = sizeof(reply);
      size_t msg_len = vcos_safe_strcpy(req.msg, msg, sizeof(req.msg), 0);

      /* Reduce the length if it is shorter than the max message length */
      status = mmal_vc_sendwait_message(mmal_vc_get_client(), &req.header,
            sizeof(req) - sizeof(req.msg) + vcos_min(sizeof(req.msg), msg_len + 1),
            MMAL_WORKER_HOST_LOG,
            &reply, &replylen, MMAL_FALSE);

      if (status == MMAL_SUCCESS)
      {
         vcos_assert(replylen == sizeof(reply));
         status = reply.status;
      }
   }
   return status;
}

MMAL_STATUS_T mmal_vc_get_core_stats(MMAL_CORE_STATISTICS_T *stats,
                                     MMAL_STATS_RESULT_T *result,
                                     char *name,
                                     size_t namelen,
                                     MMAL_PORT_TYPE_T type,
                                     unsigned component_index,
                                     unsigned port_index,
                                     MMAL_CORE_STATS_DIR dir,
                                     MMAL_BOOL_T reset)
{
   mmal_worker_get_core_stats_for_port req;
   mmal_worker_get_core_stats_for_port_reply reply;
   MMAL_STATUS_T status;
   size_t len = sizeof(reply);

   req.component_index = component_index;
   req.port_index = port_index;
   req.type = type;
   req.reset = reset;
   req.dir = dir;
   
   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                     &req.header, sizeof(req),
                                     MMAL_WORKER_GET_CORE_STATS_FOR_PORT,
                                     &reply, &len, MMAL_FALSE);

   if (status == MMAL_SUCCESS)
   {
      vcos_assert(len == sizeof(reply));
      *stats = reply.stats;
      *result = reply.result;
      strncpy(name, reply.component_name, namelen);
      name[namelen-1] = '\0';
   }
   return status;
}


/** Get port context data. */
static MMAL_STATUS_T mmal_vc_port_info_get(MMAL_PORT_T *port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   mmal_worker_port_info_get msg;
   mmal_worker_port_info reply;
   size_t replylen = sizeof(reply);
   MMAL_STATUS_T status;

   msg.component_handle = module->component_handle;
   msg.port_type = port->type;
   msg.index = port->index;

   LOG_TRACE("get port info (%i:%i)", port->type, port->index);

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_INFO_GET, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }

   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to get port info (%i:%i): %s", port->type, port->index,
                mmal_status_to_string(status));
      return status;
   }

   module->port_handle = reply.port_handle;
   port->buffer_num_min = reply.port.buffer_num_min;
   port->buffer_num_recommended = reply.port.buffer_num_recommended;
   port->buffer_num = reply.port.buffer_num;
   port->buffer_size_min = reply.port.buffer_size_min;
   port->buffer_size_recommended = reply.port.buffer_size_recommended;
   port->buffer_size = reply.port.buffer_size;
   port->buffer_alignment_min = reply.port.buffer_alignment_min;
   port->is_enabled = reply.port.is_enabled;
   port->capabilities = reply.port.capabilities;
   reply.format.extradata = port->format->extradata;
   reply.format.es = port->format->es;
   *port->format = reply.format;
   *port->format->es = reply.es;
   if(port->format->extradata_size)
   {
      status = mmal_format_extradata_alloc(port->format, port->format->extradata_size);
      if(status != MMAL_SUCCESS)
      {
         vcos_assert(0);
         port->format->extradata_size = 0;
         LOG_ERROR("couldn't allocate extradata %i", port->format->extradata_size);
         return MMAL_ENOMEM;
      }
      memcpy(port->format->extradata, reply.extradata, port->format->extradata_size);
   }

   return MMAL_SUCCESS;
}

/** Set port context data. */
static MMAL_STATUS_T mmal_vc_port_info_set(MMAL_PORT_T *port)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   mmal_worker_port_info_set msg;
   mmal_worker_port_info reply;
   size_t replylen = sizeof(reply);
   MMAL_STATUS_T status;

   msg.component_handle = module->component_handle;
   msg.port_type = port->type;
   msg.index = port->index;
   msg.port = *port;
   msg.format = *port->format;
   msg.es = *port->format->es;
   if(msg.format.extradata_size > MMAL_FORMAT_EXTRADATA_MAX_SIZE)
   {
      vcos_assert(0);
      msg.format.extradata_size = MMAL_FORMAT_EXTRADATA_MAX_SIZE;
   }
   memcpy(msg.extradata, msg.format.extradata, msg.format.extradata_size);

   LOG_TRACE("set port info (%i:%i)", port->type, port->index);

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_INFO_SET, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }

   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to set port info (%i:%i): %s", port->type, port->index,
                mmal_status_to_string(status));
      return status;
   }

   port->buffer_num_min = reply.port.buffer_num_min;
   port->buffer_num_recommended = reply.port.buffer_num_recommended;
   port->buffer_num = reply.port.buffer_num;
   port->buffer_size_min = reply.port.buffer_size_min;
   port->buffer_size_recommended = reply.port.buffer_size_recommended;
   port->buffer_size = reply.port.buffer_size;
   port->buffer_alignment_min = reply.port.buffer_alignment_min;
   port->is_enabled = reply.port.is_enabled;
   port->capabilities = reply.port.capabilities;
   reply.format.extradata = port->format->extradata;
   reply.format.es = port->format->es;
   *port->format = reply.format;
   *port->format->es = reply.es;
   if(port->format->extradata_size)
   {
      status = mmal_format_extradata_alloc(port->format, port->format->extradata_size);
      if(status != MMAL_SUCCESS)
      {
         vcos_assert(0);
         port->format->extradata_size = 0;
         LOG_ERROR("couldn't allocate extradata %i", port->format->extradata_size);
         return MMAL_ENOMEM;
      }
      memcpy(port->format->extradata, reply.extradata, port->format->extradata_size);
   }

   return MMAL_SUCCESS;
}

/** Set format on a port */
static MMAL_STATUS_T mmal_vc_port_set_format(MMAL_PORT_T *port)
{
   MMAL_COMPONENT_T *component = port->component;
   MMAL_COMPONENT_MODULE_T *module = component->priv->module;
   MMAL_STATUS_T status;
   unsigned int i;

   status = mmal_vc_port_info_set(port);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("mmal_vc_port_info_set failed %p (%s)", port,
                mmal_status_to_string(status));
      return status;
   }

   /* Get the setting back for this port */
   status = mmal_vc_port_info_get(port);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("mmal_vc_port_info_get failed %p (%s)", port,
                mmal_status_to_string(status));
      return status;
   }

   /* Get the settings for the output ports in case they have changed */
   if (port->type == MMAL_PORT_TYPE_INPUT)
   {
      for (i = 0; i < module->ports_num; i++)
      {
         if (module->ports[i]->port->type != MMAL_PORT_TYPE_OUTPUT)
            continue;

         status = mmal_vc_port_info_get(module->ports[i]->port);
         if (status != MMAL_SUCCESS)
         {
            LOG_ERROR("mmal_vc_port_info_get failed %p (%i)",
                      module->ports[i]->port, status);
            return status;
         }
      }
   }

   return MMAL_SUCCESS;
}

/** Set parameter on a port */
static MMAL_STATUS_T mmal_vc_port_parameter_set(MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   mmal_worker_port_param_set msg;
   size_t msglen = MMAL_OFFSET(mmal_worker_port_param_set, param) + param->size;
   mmal_worker_reply reply;
   size_t replylen = sizeof(reply);

   if(param->size > MMAL_WORKER_PORT_PARAMETER_SET_MAX)
   {
      LOG_ERROR("parameter too large (%u > %u)", param->size, MMAL_WORKER_PORT_PARAMETER_SET_MAX);
      return MMAL_ENOSPC;
   }

   /* Intercept the zero copy parameter */
   if (param->id == MMAL_PARAMETER_ZERO_COPY &&
       param->size >= sizeof(MMAL_PARAMETER_BOOLEAN_T) )
   {
      module->is_zero_copy = !!((MMAL_PARAMETER_BOOLEAN_T *)param)->enable;
      module->zero_copy_workaround = ((MMAL_PARAMETER_BOOLEAN_T *)param)->enable == 0xBEEF;
      LOG_DEBUG("%s zero copy on port %p", module->is_zero_copy ? "enable" : "disable", port);
   }

   msg.component_handle = module->component_handle;
   msg.port_handle = module->port_handle;
   /* coverity[overrun-buffer-arg] */
   memcpy(&msg.param, param, param->size);

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, msglen,
                                     MMAL_WORKER_PORT_PARAMETER_SET, &reply, &replylen, MMAL_FALSE);

   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to set port parameter %u:%u:%s", msg.component_handle, msg.port_handle,
                mmal_status_to_string(status));
      return status;
   }

   if (param->id == MMAL_PARAMETER_BUFFER_REQUIREMENTS)
   {
      /* This might have changed the buffer requirements of other ports so fetch them all */
      MMAL_COMPONENT_T *component = port->component;
      unsigned int i;
      for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
         status = mmal_vc_port_requirements_get(component->input[i]);
      for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
         status = mmal_vc_port_requirements_get(component->output[i]);
   }

   return status;
}

/** Get parameter on a port */
static MMAL_STATUS_T mmal_vc_port_parameter_get(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_STATUS_T status;
   mmal_worker_port_param_get msg;
   mmal_worker_port_param_get_reply reply;
   size_t replylen = MMAL_OFFSET(mmal_worker_port_param_get_reply, param) + param->size;

   if(param->size > MMAL_WORKER_PORT_PARAMETER_GET_MAX)
   {
      LOG_ERROR("parameter too large (%u > %u)", param->size, MMAL_WORKER_PORT_PARAMETER_GET_MAX);
      return MMAL_ENOMEM;
   }

   msg.component_handle = module->component_handle;
   msg.port_handle = module->port_handle;
   msg.param = *param;

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_PORT_PARAMETER_GET, &reply, &replylen, MMAL_FALSE);
   if (status == MMAL_SUCCESS)
   {
      status = reply.status;
      /* Reply must include the parameter header */
      vcos_assert(replylen >= MMAL_OFFSET(mmal_worker_port_param_get_reply, space));
      
      /* If the call fails with MMAL_ENOSPC then reply.param.size is set to the size required for
       * the call to succeed, and that may be bigger than the buffers, so only check these asserts
       * if the call succeeded.
       */
      if ( status == MMAL_SUCCESS )
      {
         /* Reply mustn't be bigger than the parameter given */
         vcos_assert(replylen <= (MMAL_OFFSET(mmal_worker_port_param_get_reply, param) + param->size));
         /* Reply must be consistent with the parameter size embedded in it */
         vcos_assert(replylen == (MMAL_OFFSET(mmal_worker_port_param_get_reply, param) + reply.param.size));
      }
   }

   if (status != MMAL_SUCCESS && status != MMAL_ENOSPC)
   {
      LOG_ERROR("failed to get port parameter %u:%u", msg.component_handle, msg.port_handle);
      return status;
   }
   
   if (status == MMAL_ENOSPC)
   {
      /* Copy only as much as we have space for but report true size of parameter */
      /* coverity[overrun-buffer-arg] */
      memcpy(param, &reply.param, param->size);
      param->size = reply.param.size;
   }
   else
   {
      memcpy(param, &reply.param, reply.param.size);
   }

   return status;
}

static uint8_t *mmal_vc_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size)
{
   MMAL_PORT_MODULE_T *module = port->priv->module;
   MMAL_BOOL_T can_deref = MMAL_TRUE;
   char buf[5];
   MMAL_PARAM_UNUSED(module);
   void *ret;
   (void)buf;

   LOG_TRACE("%s: allocating %d bytes, format %s, is_zero_copy %d",
             port->name,
             payload_size,
             mmal_4cc_to_string(buf, sizeof(buf), port->format->encoding),
             module->is_zero_copy);

   if (port->format->encoding == MMAL_ENCODING_OPAQUE &&
       module->is_zero_copy)
   {
      MMAL_OPAQUE_IMAGE_HANDLE_T h = mmal_vc_opaque_alloc_desc(port->name);
      can_deref = MMAL_FALSE;
      ret = (void*)h;
      if (!ret)
      {
         LOG_ERROR("%s: failed to allocate %d bytes opaque memory",
                   port->name, payload_size);
         return NULL;
      }
   }

   else if (module->is_zero_copy)
   {
      ret = mmal_vc_shm_alloc(payload_size);
      if (!ret)
      {
         LOG_ERROR("%s: failed to allocate %d bytes of shared memory",
                   port->name, payload_size);
         return NULL;
      }
   }

   else
   {
      /* Allocate conventional memory */
      ret = vcos_malloc(payload_size, "mmal_vc_port payload");
      if (!ret)
      {
         LOG_ERROR("could not allocate %i bytes", (int)payload_size);
         return NULL;
      }
   }

   /* Ensure that newly minted opaque buffers are always in a sensible
    * state, and don't have random garbage in them.
    */
   if (can_deref && port->format->encoding == MMAL_ENCODING_OPAQUE)
      memset(ret, 0, payload_size);

   LOG_DEBUG("%s: allocated at %p", port->name, ret);
   return ret;
}

static void mmal_vc_port_payload_free(MMAL_PORT_T *port, uint8_t *payload)
{
   MMAL_PARAM_UNUSED(port);

   if (port->format->encoding == MMAL_ENCODING_OPAQUE)
   {
      mmal_vc_opaque_release((MMAL_OPAQUE_IMAGE_HANDLE_T)payload);
      return;
   }

   else if (mmal_vc_shm_free(payload) == MMAL_SUCCESS)
      return;

   /* We're dealing with conventional memory */
   vcos_free(payload);
}

/** Create a component given its name. */
static MMAL_STATUS_T mmal_vc_component_create(const char *name, MMAL_COMPONENT_T *component)
{
   MMAL_STATUS_T status;
   const char *basename;
   mmal_worker_component_create msg;
   mmal_worker_component_create_reply reply;
   size_t replylen = sizeof(reply);
   MMAL_COMPONENT_MODULE_T *module = NULL;
   unsigned int ports_num, i;

   LOG_TRACE("%s", name);

   if (strstr(name, VIDEOCORE_PREFIX ".") != name)
      return MMAL_ENOSYS;

   basename = name + sizeof(VIDEOCORE_PREFIX ".") - 1;
   if (strlen(basename) >= sizeof(msg.name)-1)
   {
      vcos_assert(0);
      return MMAL_EINVAL;
   }

   msg.client_component = component;
   /* coverity[secure_coding] Length tested above */
   strcpy(msg.name, basename);
#ifdef __linux__
   msg.pid = getpid();
#endif

   status = mmal_vc_init();
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to initialise mmal ipc for '%s' (%i:%s)",
                name, status, mmal_status_to_string(status));
      return status;
   }
   // claim VC for entire duration of component.
   status = mmal_vc_use();

   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                                     MMAL_WORKER_COMPONENT_CREATE, &reply, &replylen, MMAL_FALSE);

   vcos_log_info("%s: %s: handle 0x%x status %d reply status %d",
                 __FUNCTION__, name, reply.component_handle, status, reply.status);

   if (status == MMAL_SUCCESS)
   {
      vcos_assert(replylen == sizeof(reply));
      status = reply.status;
   }

   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("failed to create component '%s' (%i:%s)", name, status,
                mmal_status_to_string(status));
      mmal_vc_release();
      mmal_vc_deinit();
      return status;
   }

   /* Component has been created, allocate our context. */
   status = MMAL_ENOMEM;
   ports_num = 1 + reply.input_num + reply.output_num + reply.clock_num;
   module = vcos_calloc(1, sizeof(*module) + ports_num * sizeof(*module->ports), "mmal_vc_module");
   if (!module)
   {
      mmal_worker_component_destroy msg;
      mmal_worker_reply reply;
      size_t replylen = sizeof(reply);
      MMAL_STATUS_T destroy_status;

      destroy_status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
                               MMAL_WORKER_COMPONENT_DESTROY, &reply, &replylen, MMAL_FALSE);
      vcos_assert(destroy_status == MMAL_SUCCESS);
      mmal_vc_release();
      mmal_vc_deinit();
      return status;
   }
   module->ports = (MMAL_PORT_MODULE_T **)&module[1];
   module->component_handle = reply.component_handle;
   component->priv->module = module;

   /* Allocate our local ports. Control port reallocated to set module size. */
   mmal_port_free(component->control);
   component->control = mmal_port_alloc(component, MMAL_PORT_TYPE_CONTROL,
                                        sizeof(MMAL_PORT_MODULE_T));
   if (!component->control)
      goto fail;
   component->input = mmal_ports_alloc(component, reply.input_num, MMAL_PORT_TYPE_INPUT,
                                       sizeof(MMAL_PORT_MODULE_T));
   if (!component->input)
      goto fail;
   component->input_num = reply.input_num;
   component->output = mmal_ports_alloc(component, reply.output_num, MMAL_PORT_TYPE_OUTPUT,
                                        sizeof(MMAL_PORT_MODULE_T));
   if (!component->output)
      goto fail;
   component->output_num = reply.output_num;
   component->clock = mmal_ports_alloc(component, reply.clock_num, MMAL_PORT_TYPE_CLOCK,
                                        sizeof(MMAL_PORT_MODULE_T));
   if (!component->clock)
      goto fail;
   component->clock_num = reply.clock_num;

   /* We want to do the buffer callbacks to the client into a separate thread.
    * We'll need to queue these callbacks and have an action which does the actual callback. */
   module->callback_queue = mmal_queue_create();
   if (!module->callback_queue)
      goto fail;
   status = mmal_component_action_register(component, mmal_vc_do_callback);
   if (status != MMAL_SUCCESS)
      goto fail;

   LOG_TRACE(" handle %i", reply.component_handle);

   module->ports[module->ports_num] = component->control->priv->module;
   module->ports[module->ports_num]->port = component->control;
   module->ports[module->ports_num]->component_handle = module->component_handle;
   module->ports_num++;

   for (i = 0; i < component->input_num; i++, module->ports_num++)
   {
      module->ports[module->ports_num] = component->input[i]->priv->module;
      module->ports[module->ports_num]->port = component->input[i];
      module->ports[module->ports_num]->component_handle = module->component_handle;
   }

   for (i = 0; i < component->output_num; i++, module->ports_num++)
   {
      module->ports[module->ports_num] = component->output[i]->priv->module;
      module->ports[module->ports_num]->port = component->output[i];
      module->ports[module->ports_num]->component_handle = module->component_handle;
   }

   for (i = 0; i < component->clock_num; i++, module->ports_num++)
   {
      module->ports[module->ports_num] = component->clock[i]->priv->module;
      module->ports[module->ports_num]->port = component->clock[i];
      module->ports[module->ports_num]->component_handle = module->component_handle;
   }

   /* Get the ports info */
   for (i = 0; i < module->ports_num; i++)
   {
      MMAL_PORT_T *port = module->ports[i]->port;
      port->priv->pf_set_format = mmal_vc_port_set_format;
      port->priv->pf_enable = mmal_vc_port_enable;
      port->priv->pf_disable = mmal_vc_port_disable;
      port->priv->pf_send = mmal_vc_port_send;
      port->priv->pf_flush = mmal_vc_port_flush;
      port->priv->pf_connect = mmal_vc_port_connect;
      port->priv->pf_parameter_set = mmal_vc_port_parameter_set;
      port->priv->pf_parameter_get = mmal_vc_port_parameter_get;
      port->priv->pf_payload_alloc = mmal_vc_port_payload_alloc;
      port->priv->pf_payload_free = mmal_vc_port_payload_free;
      port->priv->module->component_handle = module->component_handle;
      port->priv->module->magic = MMAL_MAGIC;

      status = mmal_vc_port_info_get(port);
      if (status != MMAL_SUCCESS)
         goto fail;
   }

   /* Initialise the vc client context which will be used for our event buffers */
   module->event_ctx_initialised = MMAL_FALSE;
   module->event_ctx.magic = MMAL_MAGIC;
   module->event_ctx.callback_event = mmal_vc_port_send_event_callback;

   /* populate component structure */
   component->priv->pf_enable = mmal_vc_component_enable;
   component->priv->pf_disable = mmal_vc_component_disable;
   component->priv->pf_destroy = mmal_vc_component_destroy;
   return MMAL_SUCCESS;

fail:
   mmal_vc_component_destroy(component);
   return status;
}

MMAL_CONSTRUCTOR(mmal_register_component_videocore);
void mmal_register_component_videocore(void)
{
   mmal_vc_shm_init();
   mmal_component_supplier_register(VIDEOCORE_PREFIX, mmal_vc_component_create);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_API_H
#define MMAL_VC_API_H

/** @file
  *
  * Public API for MMAL VC client. Most functionality is exposed
  * via MMAL itself.
  */

#include "interface/mmal/mmal_types.h"
#include "interface/mmal/mmal_parameters.h"
#include "interface/mmal/mmal_port.h"

#ifdef __cplusplus
extern "C" {
#endif

/** State of components created by the VC adaptation layer, used for
 * statistics reporting.
 */
typedef enum {
   MMAL_STATS_COMP_IDLE,
   MMAL_STATS_COMP_CREATED,
   MMAL_STATS_COMP_DESTROYING,
   MMAL_STATS_COMP_DESTROYED,
   MMAL_STATS_COMP_UNUSED = 0xffffffff /* force 32bit */
} MMAL_STATS_COMP_STATE_T;

/** Per-component statistics collected by the VC adaptation layer.
 */
struct MMAL_VC_COMP_STATS_T {
   struct MMAL_DRIVER_COMPONENT_T *comp;
   MMAL_STATS_COMP_STATE_T state;
   uint32_t pid;
   uint32_t pool_mem_alloc_size;
   char name[20];
};

/** VC adaptation layer statistics.
 */
struct MMAL_VC_STATS_T
{
   struct
   {
      uint32_t rx;               /**< Count of data buffers received */
      uint32_t rx_zero_copy;     /**< Count of zero-copy data buffers received */
      uint32_t rx_empty;         /**< Empty data buffers (to be filled) */
      uint32_t rx_fails;         /**< Gave up partway through */
      uint32_t tx;               /**< Count of data buffers sent */
      uint32_t tx_zero_copy;     /**< Count of zero-copy data buffers sent */
      uint32_t tx_empty;         /**< Count of empty data buffers sent */
      uint32_t tx_fails;         /**< Gave up partway through */
      uint32_t tx_short_msg;     /**< Messages sent directly in the control message */
      uint32_t rx_short_msg;     /**< Messages received directly in the control message */
   } buffers;
   struct service
   {
      uint32_t created;          /**< How many services created */
      uint32_t pending_destroy;  /**< How many destroyed */
      uint32_t destroyed;        /**< How many destroyed */
      uint32_t failures;         /**< Failures to create a service */
   } service;
   struct commands
   {
      uint32_t bad_messages;
      uint32_t executed;
      uint32_t failed;
      uint32_t replies;
      uint32_t reply_fails;
   } commands;
   struct
   {
      uint32_t tx;               /**< Count of events sent */
      uint32_t tx_fails;         /**< Count of events not fully sent */
   } events;
   struct
   {
      uint32_t created;
      uint32_t destroyed;
      uint32_t destroying;
      uint32_t failed;
      uint32_t list_size;
      struct MMAL_VC_COMP_STATS_T component_list[8];
   } components;
   struct
   {
      uint32_t enqueued_messages;
      uint32_t dequeued_messages;
      uint32_t max_parameter_set_delay;
      uint32_t max_messages_waiting;
   } worker;

};
typedef struct MMAL_VC_STATS_T MMAL_VC_STATS_T;

/* Simple circular text buffer used to store 'interesting' data
 * from MMAL clients. e.g. settings for each picture taken */
struct MMAL_VC_HOST_LOG_T
{
   /** Simple circular buffer of plain text log messages separated by NUL */
   char buffer[16 << 10];
   /** For VCDBG validation and to help detect buffer overflow */
   uint32_t magic;
   /** Write offset into buffer */
   int32_t offset;
   /** Counter of host messages logged since boot */
   unsigned count;
};
typedef struct MMAL_VC_HOST_LOG_T MMAL_VC_HOST_LOG_T;

/** Status from querying MMAL core statistics.
 */
typedef enum
{
   MMAL_STATS_FOUND,
   MMAL_STATS_COMPONENT_NOT_FOUND,
   MMAL_STATS_PORT_NOT_FOUND,
   MMAL_STATS_INVALID = 0x7fffffff
} MMAL_STATS_RESULT_T;

MMAL_STATUS_T mmal_vc_init(void);
void mmal_vc_deinit(void);

MMAL_STATUS_T mmal_vc_use(void);
MMAL_STATUS_T mmal_vc_release(void);

MMAL_STATUS_T mmal_vc_get_version(uint32_t *major, uint32_t *minor, uint32_t *minimum);
MMAL_STATUS_T mmal_vc_get_stats(MMAL_VC_STATS_T *stats, int reset);

/** Return the MMAL core statistics for a given component/port.
 *
 * @param stats         Updated with given port statistics
 * @param result        Whether the port/component was found
 * @param name          Filled in with the name of the port
 * @param namelen       Length of name
 * @param component     Which component (indexed from zero)
 * @param port_type     Which type of port
 * @param port          Which port (index from zero)
 * @param reset         Reset the stats.
 */
MMAL_STATUS_T mmal_vc_get_core_stats(MMAL_CORE_STATISTICS_T *stats,
                                     MMAL_STATS_RESULT_T *result,
                                     char *name,
                                     size_t namelen,
                                     MMAL_PORT_TYPE_T type,
                                     unsigned component,
                                     unsigned port,
                                     MMAL_CORE_STATS_DIR dir,
                                     MMAL_BOOL_T reset);
/**
 * Stores an arbitrary text message in a circular buffer inside the MMAL VC server.
 * The purpose of this message is to log high level events from the host in order
 * to diagnose problems that require multiple actions to reproduce. e.g. taking
 * multiple pictures with different settings.
 *
 * @param   msg  The message text.
 * @return  MMAL_SUCCESS if the message was logged or MMAL_ENOSYS if the API
 *          if not supported.
 */
MMAL_STATUS_T mmal_vc_host_log(const char *msg);

/* For backwards compatibility in builds */
#define MMAL_VC_API_HAVE_HOST_LOG

/* VC DEBUG ONLY ************************************************************/
/** Consumes memory in the relocatable heap.
 *
 * The existing reserved memory is freed first then the new chunk is allocated.
 * If zero is specified for the size then the previously reserved memory
 * is freed and no allocation occurs.
 *
 * At startup no memory is reserved.
 *
 * @param size    Size of memory to consume in bytes.
 * @param handle  Set to the mem handle for the reserved memory or zero
 *                if no memory was allocated.
 * @return        MMAL_SUCCESS if memory was reserved (or size zero requested),
 *                MMAL_ENOSPC if the allocation failed or MMAL_ENOSYS if the
 *                API is not supported e.g in release mode VC images.
 * @internal
 */
MMAL_STATUS_T mmal_vc_consume_mem(size_t size, uint32_t *handle);

/** Trigger LMK action from VC, for diagnostics.
 * @internal
 */
MMAL_STATUS_T mmal_vc_lmk(uint32_t alloc_size);

#ifdef __cplusplus
}
#endif
#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client_priv.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_CLIENT_H
#define MMAL_VC_CLIENT_H

/** @file mmal_vc_client_priv.h
  *
  * Internal API for vchiq_arm MMAL client.
  */

struct MMAL_CLIENT_T;
typedef struct MMAL_CLIENT_T MMAL_CLIENT_T;

void mmal_vc_client_init(void);

/** Hold the context required when sending a buffer to the copro.
 */
typedef struct MMAL_VC_CLIENT_BUFFER_CONTEXT_T
{
   uint32_t magic;

   /** Called when VC is done with the buffer */
   void (*callback)(struct mmal_worker_buffer_from_host *);

   /** Called when VC sends an event */
   void (*callback_event)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *event);

   /** The port this buffer was sent to */
   MMAL_PORT_T *port;

   /** The original buffer from the host. */
   MMAL_BUFFER_HEADER_T *buffer;

   /** The actual message sent to the host */
   struct mmal_worker_buffer_from_host msg;
} MMAL_VC_CLIENT_BUFFER_CONTEXT_T;


MMAL_CLIENT_T *mmal_vc_get_client(void);

MMAL_STATUS_T mmal_vc_sendwait_message(MMAL_CLIENT_T *client,
                                       mmal_worker_msg_header *header,
                                       size_t size,
                                       uint32_t msgid,
                                       void *dest,
                                       size_t *destlen,
                                       MMAL_BOOL_T send_dummy_bulk);

MMAL_STATUS_T mmal_vc_send_message(MMAL_CLIENT_T *client,
                                   mmal_worker_msg_header *header, size_t size,
                                   uint8_t *data, size_t data_size,
                                   uint32_t msgid);

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "mmal.h"
#include "mmal_vc_msgs.h"
#include "mmal_vc_api.h"
#include "mmal_vc_client_priv.h"
#include "interface/vcos/vcos.h"
#include "vchiq_util.h"
#include "interface/mmal/core/mmal_buffer_private.h"
#include "interface/mmal/core/mmal_component_private.h"
#include "interface/mmal/core/mmal_port_private.h"
#include "interface/mmal/util/mmal_list.h"
#include "interface/mmal/util/mmal_util.h"

#define VCOS_LOG_CATEGORY (&mmal_ipc_log_category)
#include "interface/mmal/mmal_logging.h"

#include <stdio.h>

#define MAX_WAITERS 16
static VCOS_ONCE_T once = VCOS_ONCE_INIT;
static VCHIQ_INSTANCE_T mmal_vchiq_instance;
static VCOS_LOG_CAT_T mmal_ipc_log_category;

/** Client threads use one of these to wait for
 * a reply from VideoCore.
 */
typedef struct MMAL_WAITER_T
{
   VCOS_SEMAPHORE_T sem;
   unsigned inuse;
   void *dest;                   /**< Where to write reply */
   size_t destlen;               /**< Max length for reply */
} MMAL_WAITER_T;

/** We have an array of waiters and allocate them to waiting
  * threads. They can be released back to the pool in any order.
  * If there are none free, the calling thread will block until
  * one becomes available.
  */
typedef struct 
{
   MMAL_WAITER_T waiters[MAX_WAITERS];
   VCOS_SEMAPHORE_T sem;
} MMAL_WAITPOOL_T;

struct MMAL_CLIENT_T
{
   int refcount;
   int usecount;
   VCOS_MUTEX_T lock;
   VCHIQ_SERVICE_HANDLE_T service;
   MMAL_WAITPOOL_T waitpool;
   VCOS_MUTEX_T bulk_lock;

   MMAL_BOOL_T inited;
};

/* One client per process/VC connection. Multiple threads may
 * be using a single client.
 */
static MMAL_CLIENT_T client;

static void init_once(void)
{
   vcos_mutex_create(&client.lock, VCOS_FUNCTION);
}

/** Create a pool of wait-structures.
  */
static MMAL_STATUS_T create_waitpool(MMAL_WAITPOOL_T *waitpool)
{
   MMAL_STATUS_T status;
   int i;

   status = vcos_semaphore_create(&waitpool->sem, VCOS_FUNCTION,
                                  MAX_WAITERS);
   if (status != MMAL_SUCCESS)
      return status;

   for (i=0; i<MAX_WAITERS; i++)
   {
      waitpool->waiters[i].inuse = 0;
      status = vcos_semaphore_create(&waitpool->waiters[i].sem,
                                     "mmal waiter", 0);
      if (status != MMAL_SUCCESS)
         break;
   }

   if (status != MMAL_SUCCESS)
   {
      /* clean up */
      i--;
      while (i>=0)
      {
         vcos_semaphore_delete(&waitpool->waiters[i].sem);
         i--;
      }
      vcos_semaphore_delete(&waitpool->sem);
   }
   return status;
}

static void destroy_waitpool(MMAL_WAITPOOL_T *waitpool)
{
   int i;
   for (i=0; i<MAX_WAITERS; i++)
      vcos_semaphore_delete(&waitpool->waiters[i].sem);

   vcos_semaphore_delete(&waitpool->sem);
}

/** Grab a waiter from the pool. Return immediately if one already
  * available, or wait for one to become available.
  */
static MMAL_WAITER_T *get_waiter(MMAL_CLIENT_T *client)
{
   int i;
   MMAL_WAITER_T *waiter = NULL;
   vcos_semaphore_wait(&client->waitpool.sem);
   vcos_mutex_lock(&client->lock);
   for (i=0; i<MAX_WAITERS; i++)
   {
      if (client->waitpool.waiters[i].inuse == 0)
         break;
   }
   /* If this fails, the semaphore is not working */
   if (vcos_verify(i != MAX_WAITERS))
   {
      waiter = client->waitpool.waiters+i;
      waiter->inuse = 1;
   }
   vcos_mutex_unlock(&client->lock);

   return waiter;
}

/** Return a waiter to the pool.
  */
static void release_waiter(MMAL_CLIENT_T *client, MMAL_WAITER_T *waiter)
{
   LOG_TRACE("at %p", waiter);
   vcos_assert(waiter);
   vcos_assert(waiter->inuse);
   waiter->inuse = 0;
   vcos_semaphore_post(&client->waitpool.sem);
}

static MMAL_PORT_T *mmal_vc_port_by_number(MMAL_COMPONENT_T *component, uint32_t type, uint32_t number)
{
   switch (type)
   {
      case MMAL_PORT_TYPE_CONTROL:
         vcos_assert(number == 0);
         return component->control;
      case MMAL_PORT_TYPE_INPUT:
         vcos_assert(number < component->input_num);
         return component->input[number];
      case MMAL_PORT_TYPE_OUTPUT:
         vcos_assert(number < component->output_num);
         return component->output[number];
      case MMAL_PORT_TYPE_CLOCK:
         vcos_assert(number < component->clock_num);
         return component->clock[number];
   }

   return NULL;
}

static void mmal_vc_handle_event_msg(VCHIQ_HEADER_T *vchiq_header,
                                    VCHIQ_SERVICE_HANDLE_T service,
                                    void *context)
{
   mmal_worker_event_to_host *msg = (mmal_worker_event_to_host *)vchiq_header->data;
   MMAL_COMPONENT_T *component = msg->client_component;
   MMAL_BUFFER_HEADER_T *buffer;
   MMAL_STATUS_T status;
   MMAL_PORT_T *port;

   LOG_DEBUG("event to host, cmd 0x%08x len %d to component %p port (%d,%d)",
         msg->cmd, msg->length, msg->client_component, msg->port_type, msg->port_num);
   (void)context;

   port = mmal_vc_port_by_number(component, msg->port_type, msg->port_num);
   if (!vcos_verify(port))
   {
      LOG_ERROR("port (%i,%i) doesn't exist", (int)msg->port_type, (int)msg->port_num);
      goto error;
   }

   status = mmal_port_event_get(port, &buffer, msg->cmd);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("no event buffer available to receive event (%i)", (int)status);
      goto error;
   }

   if (!vcos_verify(msg->length <= buffer->alloc_size))
   {
      LOG_ERROR("event buffer to small to receive event (%i/%i)",
                (int)buffer->alloc_size, (int)msg->length);
      goto error;
   }
   buffer->length = msg->length;

   /* Sanity check that the event buffers have the proper vc client context */
   if (!vcos_verify(mmal_buffer_header_driver_data(buffer)->magic == MMAL_MAGIC &&
          mmal_buffer_header_driver_data(buffer)->client_context &&
          mmal_buffer_header_driver_data(buffer)->client_context->magic == MMAL_MAGIC &&
          mmal_buffer_header_driver_data(buffer)->client_context->callback_event))
   {
      LOG_ERROR("event buffers not configured properly by component");
      goto error;
   }

   if (buffer->length > MMAL_WORKER_EVENT_SPACE)
   {
      /* a buffer full of data for us to process */
      int len = buffer->length;
      len = (len+3) & (~3);
      LOG_DEBUG("queue event bulk rx: %p, %d", buffer->data, buffer->length);
      msg->delayed_buffer = buffer;

      VCHIQ_STATUS_T vst = vchiq_queue_bulk_receive(service, buffer->data, len, vchiq_header);
      if (vst != VCHIQ_SUCCESS)
      {
         LOG_TRACE("queue event bulk rx len %d failed to start", buffer->length);
         mmal_buffer_header_release(buffer);
         goto error;
      }
   }
   else
   {
      if (msg->length)
         memcpy(buffer->data, msg->data, msg->length);

      mmal_buffer_header_driver_data(buffer)->client_context->callback_event(port, buffer);
      LOG_DEBUG("done callback back to client");
      vchiq_release_message(service, vchiq_header);
   }

   return;

error:
   /* FIXME: How to abort bulk receive if necessary? */
   msg->length = 0; /* FIXME: set a buffer flag to signal error */
   vchiq_release_message(service, vchiq_header);
}

static MMAL_STATUS_T mmal_vc_use_internal(MMAL_CLIENT_T *client)
{
   MMAL_STATUS_T status = MMAL_SUCCESS;
   vcos_mutex_lock(&client->lock);
   if(client->usecount++ == 0)
   {
      if(vchiq_use_service(client->service) != VCHIQ_SUCCESS)
      {
         client->usecount--;
         status = MMAL_EIO;
      }
   }
   vcos_mutex_unlock(&client->lock);
   return status;
}

static MMAL_STATUS_T mmal_vc_release_internal(MMAL_CLIENT_T *client)
{
   MMAL_STATUS_T status = MMAL_SUCCESS;
   vcos_mutex_lock(&client->lock);
   if(--client->usecount == 0)
   {
      if(vchiq_release_service(client->service) != VCHIQ_SUCCESS)
      {
         client->usecount++;
         status = MMAL_EIO;
      }
   }
   vcos_mutex_unlock(&client->lock);
   return status;
}


/** Callback invoked by VCHIQ
  */
static VCHIQ_STATUS_T mmal_vc_vchiq_callback(VCHIQ_REASON_T reason,
                                             VCHIQ_HEADER_T *vchiq_header,
                                             VCHIQ_SERVICE_HANDLE_T service,
                                             void *context)
{
   LOG_TRACE("reason %d", reason);

   switch (reason)
   {
   case VCHIQ_MESSAGE_AVAILABLE:
      {
         mmal_worker_msg_header *msg = (mmal_worker_msg_header*)vchiq_header->data;
         vcos_assert(msg->magic == MMAL_MAGIC);

         if (msg->msgid == MMAL_WORKER_BUFFER_TO_HOST)
         {
            LOG_TRACE("buffer to host");
            mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)vchiq_header->data;
            LOG_TRACE("len %d context %p", msg->buffer_header.length, msg->drvbuf.client_context);
            vcos_assert(msg->drvbuf.client_context);
            vcos_assert(msg->drvbuf.client_context->magic == MMAL_MAGIC);

            /* If the buffer is referencing another, need to replicate it here
             * in order to use the reference buffer's payload and ensure the
             * reference is not released prematurely */
            if (msg->has_reference)
               mmal_buffer_header_replicate(msg->drvbuf.client_context->buffer,
                                            msg->drvbuf_ref.client_context->buffer);

            /* Sanity check the size of the transfer so we don't overrun our buffer */
            if (!vcos_verify(msg->buffer_header.offset + msg->buffer_header.length <=
                             msg->drvbuf.client_context->buffer->alloc_size))
            {
               LOG_TRACE("buffer too small (%i, %i)",
                         msg->buffer_header.offset + msg->buffer_header.length,
                         msg->drvbuf.client_context->buffer->alloc_size);
               msg->buffer_header.length = 0; /* FIXME: set a buffer flag to signal error */
               msg->drvbuf.client_context->callback(msg);
               vchiq_release_message(service, vchiq_header);
               break;
            }
            /*To handle VC to HOST filled buffer callback of EOS buffer to receive in sync with data buffers*/
            if (!msg->is_zero_copy &&
                  (msg->buffer_header.length != 0 ||
                     (msg->buffer_header.flags & MMAL_BUFFER_HEADER_FLAG_EOS)))
            {
               /* a buffer full of data for us to process */
               VCHIQ_STATUS_T vst = VCHIQ_SUCCESS;
               LOG_TRACE("queue bulk rx: %p, %d", msg->drvbuf.client_context->buffer->data +
                         msg->buffer_header.offset, msg->buffer_header.length);
               int len = msg->buffer_header.length;
               len = (len+3) & (~3);

               if (!len && (msg->buffer_header.flags & MMAL_BUFFER_HEADER_FLAG_EOS))
               {
                  len = 8;
               }
               if (!msg->payload_in_message)
               {
                  /* buffer transferred using vchiq bulk xfer */
                  vst = vchiq_queue_bulk_receive(service,
                     msg->drvbuf.client_context->buffer->data + msg->buffer_header.offset,
                     len, vchiq_header);

                  if (vst != VCHIQ_SUCCESS)
                  {
                     LOG_TRACE("queue bulk rx len %d failed to start", msg->buffer_header.length);
                     msg->buffer_header.length = 0; /* FIXME: set a buffer flag to signal error */
                     msg->drvbuf.client_context->callback(msg);
                     vchiq_release_message(service, vchiq_header);
                  }
               }
               else if (msg->payload_in_message <= MMAL_VC_SHORT_DATA)
               {
                  /* we have already received the buffer data in the message! */
                  MMAL_BUFFER_HEADER_T *dst = msg->drvbuf.client_context->buffer;
                  LOG_TRACE("short data: dst = %p, dst->data = %p, len %d short len %d", dst, dst? dst->data : 0, msg->buffer_header.length, msg->payload_in_message);
                  memcpy(dst->data, msg->short_data, msg->payload_in_message);
                  dst->offset = 0;
                  dst->length = msg->payload_in_message;
                  vchiq_release_message(service, vchiq_header);
                  msg->drvbuf.client_context->callback(msg);
               }
               else
               {
                  /* impossible short data length */
                  LOG_ERROR("Message with invalid short payload length %d",
                            msg->payload_in_message);
                  vcos_assert(0);
               }
            }
            else
            {

               /* Message received from videocore; the client_context should have
                * been passed all the way through by videocore back to us, and will
                * be picked up in the callback to complete the sequence.
                */
               LOG_TRACE("doing cb (%p) context %p",
                         msg->drvbuf.client_context, msg->drvbuf.client_context ?
                         msg->drvbuf.client_context->callback : 0);
               msg->drvbuf.client_context->callback(msg);
               LOG_TRACE("done callback back to client");
               vchiq_release_message(service, vchiq_header);
            }
         }
         else if (msg->msgid == MMAL_WORKER_EVENT_TO_HOST)
         {
            mmal_vc_handle_event_msg(vchiq_header, service, context);
         }
         else
         {
            MMAL_WAITER_T *waiter = msg->u.waiter;
            LOG_TRACE("waking up waiter at %p", waiter);
            vcos_assert(waiter->inuse);
            int len = vcos_min(waiter->destlen, vchiq_header->size);
            waiter->destlen = len;
            LOG_TRACE("copying payload @%p to %p len %d", waiter->dest, msg, len);
            memcpy(waiter->dest, msg, len);
            vchiq_release_message(service, vchiq_header);
            vcos_semaphore_post(&waiter->sem);
         }
      }
      break;
   case VCHIQ_BULK_TRANSMIT_DONE:
      {
         /* nothing to do here, need to wait for the copro to tell us it
          * has emptied the buffer before we can recycle it, otherwise we
          * end up feeding the copro with buffers it cannot handle.
          */
#ifdef VCOS_LOGGING_ENABLED
         mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)context;
#endif
         LOG_TRACE("bulk tx done: %p, %d", msg->buffer_header.data, msg->buffer_header.length);
      }
      break;
   case VCHIQ_BULK_RECEIVE_DONE:
      {
         VCHIQ_HEADER_T *header = (VCHIQ_HEADER_T *)context;
         mmal_worker_msg_header *msg_hdr = (mmal_worker_msg_header*)header->data;
         if (msg_hdr->msgid == MMAL_WORKER_BUFFER_TO_HOST)
         {
            mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)msg_hdr;
            vcos_assert(msg->drvbuf.client_context->magic == MMAL_MAGIC);
            msg->drvbuf.client_context->callback(msg);
            LOG_TRACE("bulk rx done: %p, %d", msg->buffer_header.data, msg->buffer_header.length);
         }
         else
         {
            mmal_worker_event_to_host *msg = (mmal_worker_event_to_host *)msg_hdr;
            MMAL_PORT_T *port = mmal_vc_port_by_number(msg->client_component, msg->port_type, msg->port_num);

            vcos_assert(port);
            mmal_buffer_header_driver_data(msg->delayed_buffer)->
               client_context->callback_event(port, msg->delayed_buffer);
            LOG_DEBUG("event bulk rx done, length %d", msg->length);
         }
         vchiq_release_message(service, header);
      }
      break;
   case VCHIQ_BULK_RECEIVE_ABORTED:
      {
         VCHIQ_HEADER_T *header = (VCHIQ_HEADER_T *)context;
         mmal_worker_msg_header *msg_hdr = (mmal_worker_msg_header*)header->data;
         if (msg_hdr->msgid == MMAL_WORKER_BUFFER_TO_HOST)
         {
            mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)msg_hdr;
            LOG_TRACE("bulk rx aborted: %p, %d", msg->buffer_header.data, msg->buffer_header.length);
            vcos_assert(msg->drvbuf.client_context->magic == MMAL_MAGIC);
            msg->buffer_header.flags |= MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED;
            msg->drvbuf.client_context->callback(msg);
         }
         else
         {
            mmal_worker_event_to_host *msg = (mmal_worker_event_to_host *)msg_hdr;
            MMAL_PORT_T *port = mmal_vc_port_by_number(msg->client_component, msg->port_type, msg->port_num);

            vcos_assert(port);
            LOG_DEBUG("event bulk rx aborted");
            msg->delayed_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED;
            mmal_buffer_header_driver_data(msg->delayed_buffer)->
               client_context->callback_event(port, msg->delayed_buffer);
         }
         vchiq_release_message(service, header);
      }
      break;
   case VCHIQ_BULK_TRANSMIT_ABORTED:
      {
         mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)context;
         LOG_INFO("bulk tx aborted: %p, %d", msg->buffer_header.data, msg->buffer_header.length);
         vcos_assert(msg->drvbuf.client_context->magic == MMAL_MAGIC);
         /* Nothing to do as the VC side will release the buffer and notify us of the error */
      }
      break;
   default:
      break;
   }

   return VCHIQ_SUCCESS;
}

/** Send a message and wait for a reply.
  *
  * @param client       client to send message for
  * @param msg_header   message vchiq_header to send
  * @param size         length of message, including header
  * @param msgid        message id
  * @param dest         destination for reply
  * @param destlen      size of destination, updated with actual length
  * @param send_dummy_bulk whether to send a dummy bulk transfer
  */
MMAL_STATUS_T mmal_vc_sendwait_message(struct MMAL_CLIENT_T *client,
                                       mmal_worker_msg_header *msg_header,
                                       size_t size,
                                       uint32_t msgid,
                                       void *dest,
                                       size_t *destlen,
                                       MMAL_BOOL_T send_dummy_bulk)
{
   MMAL_STATUS_T ret;
   MMAL_WAITER_T *waiter;
   VCHIQ_STATUS_T vst;
   VCHIQ_ELEMENT_T elems[] = {{msg_header, size}};

   vcos_assert(size >= sizeof(mmal_worker_msg_header));
   vcos_assert(dest);

   if (!client->inited)
   {
      vcos_assert(0);
      return MMAL_EINVAL;
   }

   if (send_dummy_bulk)
      vcos_mutex_lock(&client->bulk_lock);

   waiter = get_waiter(client);
   msg_header->msgid  = msgid;
   msg_header->u.waiter = waiter;
   msg_header->magic  = MMAL_MAGIC;

   waiter->dest    = dest;
   waiter->destlen = *destlen;
   LOG_TRACE("wait %p, reply to %p", waiter, dest);
   mmal_vc_use_internal(client);

   vst = vchiq_queue_message(client->service, elems, 1);

   if (vst != VCHIQ_SUCCESS)
   {
      ret = MMAL_EIO;
      if (send_dummy_bulk)
        vcos_mutex_unlock(&client->bulk_lock);
      goto fail_msg;
   }

   if (send_dummy_bulk)
   {
      uint32_t data_size = 8;
      /* The data is just some dummy bytes so it's fine for it to be static */
      static uint8_t data[8];
      vst = vchiq_queue_bulk_transmit(client->service, data, data_size, msg_header);

      vcos_mutex_unlock(&client->bulk_lock);

      if (!vcos_verify(vst == VCHIQ_SUCCESS))
      {
         LOG_ERROR("failed bulk transmit");
         /* This really should not happen and if it does, things will go wrong as
          * we've already queued the vchiq message above. */
         vcos_assert(0);
         ret = MMAL_EIO;
         goto fail_msg;
      }
   }

   /* now wait for the reply...
    *
    * FIXME: we could do with a timeout here. Need to be careful to cancel
    * the semaphore on a timeout.
    */
   vcos_semaphore_wait(&waiter->sem);

   mmal_vc_release_internal(client);
   LOG_TRACE("got reply (len %i/%i)", (int)*destlen, (int)waiter->destlen);
   *destlen = waiter->destlen;

   release_waiter(client, waiter);
   return MMAL_SUCCESS;

fail_msg:
   mmal_vc_release_internal(client);

   release_waiter(client, waiter);
   return ret;
}

/** Send a message and do not wait for a reply.
  *
  * @note
  * This function should only be called from within a mmal component, so
  * vchiq_use/release_service calls aren't required (dealt with at higher level).
  *
  * @param client       client to send message for
  * @param msg_header   message header to send
  * @param size         length of message, including header
  * @param msgid        message id
  */
MMAL_STATUS_T mmal_vc_send_message(MMAL_CLIENT_T *client,
                                   mmal_worker_msg_header *msg_header, size_t size,
                                   uint8_t *data, size_t data_size,
                                   uint32_t msgid)
{
   VCHIQ_STATUS_T vst;
   VCHIQ_ELEMENT_T elems[] = {{msg_header, size}};
   MMAL_BOOL_T using_bulk_transfer = (data_size != 0);

   LOG_TRACE("len %d", data_size);
   vcos_assert(size >= sizeof(mmal_worker_msg_header));

   if (!client->inited)
   {
      vcos_assert(0);
      return MMAL_EINVAL;
   }

   if (using_bulk_transfer)
      vcos_mutex_lock(&client->bulk_lock);

   msg_header->msgid  = msgid;
   msg_header->magic  = MMAL_MAGIC;

   vst = vchiq_queue_message(client->service, elems, 1);

   if (vst != VCHIQ_SUCCESS)
   {
      if (using_bulk_transfer)
         vcos_mutex_unlock(&client->bulk_lock);

      LOG_ERROR("failed");
      goto error;
   }

   if (using_bulk_transfer)
   {
      LOG_TRACE("bulk transmit: %p, %i", data, data_size);

      data_size = (data_size + 3) & ~3;
      vst = vchiq_queue_bulk_transmit(client->service, data, data_size, msg_header);

      vcos_mutex_unlock(&client->bulk_lock);

      if (!vcos_verify(vst == VCHIQ_SUCCESS))
      {
         LOG_ERROR("failed bulk transmit");
         /* This really should not happen and if it does, things will go wrong as
          * we've already queued the vchiq message above. */
         vcos_assert(0);
         goto error;
      }
   }

   return MMAL_SUCCESS;

 error:
   return MMAL_EIO;
}

MMAL_STATUS_T mmal_vc_use(void)
{
   MMAL_STATUS_T status = MMAL_ENOTCONN;
   if(client.inited)
      status = mmal_vc_use_internal(&client);
   return status;
}

MMAL_STATUS_T mmal_vc_release(void)
{
   MMAL_STATUS_T status = MMAL_ENOTCONN;
   if(client.inited)
      status = mmal_vc_release_internal(&client);
   return status;
}

MMAL_STATUS_T mmal_vc_init(void)
{
   VCHIQ_SERVICE_PARAMS_T vchiq_params;
   MMAL_BOOL_T vchiq_initialised = 0, waitpool_initialised = 0;
   MMAL_BOOL_T service_initialised = 0;
   MMAL_STATUS_T status = MMAL_EIO;
   VCHIQ_STATUS_T vchiq_status;
   int count;

   vcos_once(&once, init_once);

   vcos_mutex_lock(&client.lock);

   count = client.refcount++;
   if (count > 0)
   {
      /* Already initialised so nothing to do */
      vcos_mutex_unlock(&client.lock);
      return MMAL_SUCCESS;
   }

   vcos_log_register("mmalipc", VCOS_LOG_CATEGORY);

   /* Initialise a VCHIQ instance */
   vchiq_status = vchiq_initialise(&mmal_vchiq_instance);
   if (vchiq_status != VCHIQ_SUCCESS)
   {
      LOG_ERROR("failed to initialise vchiq");
      status = MMAL_EIO;
      goto error;
   }
   vchiq_initialised = 1;

   vchiq_status = vchiq_connect(mmal_vchiq_instance);
   if (vchiq_status != VCHIQ_SUCCESS)
   {
      LOG_ERROR("failed to connect to vchiq");
      status = MMAL_EIO;
      goto error;
   }

   memset(&vchiq_params,0,sizeof(vchiq_params));
   vchiq_params.fourcc = MMAL_CONTROL_FOURCC();
   vchiq_params.callback = mmal_vc_vchiq_callback;
   vchiq_params.userdata = &client;
   vchiq_params.version = WORKER_VER_MAJOR;
   vchiq_params.version_min = WORKER_VER_MINIMUM;

   vchiq_status = vchiq_open_service(mmal_vchiq_instance, &vchiq_params, &client.service);
   if (vchiq_status != VCHIQ_SUCCESS)
   {
      LOG_ERROR("could not open vchiq service");
      status = MMAL_EIO;
      goto error;
   }
   client.usecount = 1; /* usecount set to 1 by the open call. */
   service_initialised = 1;

   status = create_waitpool(&client.waitpool);
   if (status != MMAL_SUCCESS)
   {
      LOG_ERROR("could not create wait pool");
      goto error;
   }
   waitpool_initialised = 1;

   if (vcos_mutex_create(&client.bulk_lock, "mmal client bulk lock") != VCOS_SUCCESS)
   {
      LOG_ERROR("could not create bulk lock");
      status = MMAL_ENOSPC;
      goto error;
   }

   client.inited = 1;

   vcos_mutex_unlock(&client.lock);
   /* assume we're not using VC immediately.  Do this outside the lock */
   mmal_vc_release();


   return MMAL_SUCCESS;

 error:
   if (waitpool_initialised)
      destroy_waitpool(&client.waitpool);
   if (service_initialised)
   {
      client.usecount = 0;
      vchiq_close_service(client.service);
   }
   if (vchiq_initialised)
      vchiq_shutdown(mmal_vchiq_instance);
   vcos_log_unregister(VCOS_LOG_CATEGORY);
   client.refcount--;

   vcos_mutex_unlock(&client.lock);
   return status;
}

void mmal_vc_deinit(void)
{
   int count;

   vcos_mutex_lock(&client.lock);
   count = --client.refcount;
   if (count != 0)
   {
      /* Still in use so don't do anything */
      vcos_mutex_unlock(&client.lock);
      return;
   }

   vcos_mutex_delete(&client.bulk_lock);
   destroy_waitpool(&client.waitpool);
   vchiq_close_service(client.service);
   vchiq_shutdown(mmal_vchiq_instance);
   vcos_log_unregister(VCOS_LOG_CATEGORY);

   client.service = VCHIQ_SERVICE_HANDLE_INVALID;
   client.inited = 0;
   vcos_mutex_unlock(&client.lock);
}

MMAL_CLIENT_T *mmal_vc_get_client(void)
{
   return &client;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "mmal_vc_msgnames.h"
#include "mmal_vc_msgs.h"

/** Convert a message id to a name.
  */
const char *mmal_msgname(uint32_t id)
{
#define MSGNAME(x) { MMAL_WORKER_##x, #x }
   static struct {
      uint32_t id;
      const char *name;
   } msgnames[] = {
      MSGNAME(QUIT),
      MSGNAME(SERVICE_CLOSED),
      MSGNAME(GET_VERSION),
      MSGNAME(COMPONENT_CREATE),
      MSGNAME(COMPONENT_DESTROY),
      MSGNAME(COMPONENT_ENABLE),
      MSGNAME(COMPONENT_DISABLE),
      MSGNAME(PORT_INFO_GET),
      MSGNAME(PORT_INFO_SET),
      MSGNAME(PORT_ACTION),
      MSGNAME(BUFFER_FROM_HOST),
      MSGNAME(BUFFER_TO_HOST),
      MSGNAME(GET_STATS),
      MSGNAME(PORT_PARAMETER_SET),
      MSGNAME(PORT_PARAMETER_GET),
      MSGNAME(EVENT_TO_HOST),
      MSGNAME(GET_CORE_STATS_FOR_PORT),
      MSGNAME(OPAQUE_ALLOCATOR),
      MSGNAME(CONSUME_MEM),
      MSGNAME(LMK),
      MSGNAME(OPAQUE_ALLOCATOR_DESC),
      MSGNAME(DRM_GET_LHS32),
      MSGNAME(DRM_GET_TIME),
      MSGNAME(BUFFER_FROM_HOST_ZEROLEN),
      MSGNAME(PORT_FLUSH),
      MSGNAME(HOST_LOG),
      { 0, NULL },
   };
   vcos_static_assert(sizeof(msgnames)/sizeof(msgnames[0]) == MMAL_WORKER_MSG_LAST);
   int i = 0;
   while (msgnames[i].name)
   {
      if (msgnames[i].id == id)
         return msgnames[i].name;
      i++;
   }
   return "unknown-message";
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_MSGNAMES_H
#define MMAL_VC_MSGNAMES_H

#include "interface/vcos/vcos.h"

/** Convert a message id to a name.
  */
const char *mmal_msgname(uint32_t id);

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_MSGS_H
#define MMAL_VC_MSGS_H

/** @file mmal_vc_msgs.h
  *
  * Private message definitions, defining the message API between
  * the host and VideoCore.
  */
#include "interface/vcos/vcos.h"
#include "interface/mmal/mmal.h"
#include "mmal_vc_api.h"

#define MMAL_CONTROL_FOURCC() VCHIQ_MAKE_FOURCC('m','m','a','l')

/* Major version indicates binary backwards compatiblity */
#define WORKER_VER_MAJOR   15
#define WORKER_VER_MINIMUM 10
/* Minor version is not used normally.
 */
#define WORKER_VER_MINOR   1
#ifndef WORKER_VER_MINIMUM
#endif

#define VIDEOCORE_PREFIX "vc"

#define MMAL_MAX_PORTS     8                 /**< Max ports per component */

#define MMAL_WORKER_MAX_MSG_LEN  512
#define MMAL_VC_CORE_STATS_NAME_MAX      32  /**< Length of the name in the core stats message */

/** A MMAL_CONTROL_SERVICE_T gets space for a single message. This
  * is the space allocated for these messages.
  */
#define MMAL_WORKER_MSG_LEN  28

/** Maximum size of the format extradata.
 * FIXME: should probably be made bigger and maybe be passed separately from the info.
 */
#define MMAL_FORMAT_EXTRADATA_MAX_SIZE 128

/** Size of space reserved in a buffer message for short messages.
 */
#define MMAL_VC_SHORT_DATA 128

/** Message ids sent to worker thread.
  */

/* Please update the array in mmal_vc_msgnames.c if this is updated.
 */
typedef enum {
   MMAL_WORKER_QUIT = 1,
   MMAL_WORKER_SERVICE_CLOSED,
   MMAL_WORKER_GET_VERSION,
   MMAL_WORKER_COMPONENT_CREATE,
   MMAL_WORKER_COMPONENT_DESTROY,
   MMAL_WORKER_COMPONENT_ENABLE,
   MMAL_WORKER_COMPONENT_DISABLE,
   MMAL_WORKER_PORT_INFO_GET,
   MMAL_WORKER_PORT_INFO_SET,
   MMAL_WORKER_PORT_ACTION,
   MMAL_WORKER_BUFFER_FROM_HOST,
   MMAL_WORKER_BUFFER_TO_HOST,
   MMAL_WORKER_GET_STATS,
   MMAL_WORKER_PORT_PARAMETER_SET,
   MMAL_WORKER_PORT_PARAMETER_GET,
   MMAL_WORKER_EVENT_TO_HOST,
   MMAL_WORKER_GET_CORE_STATS_FOR_PORT,
   MMAL_WORKER_OPAQUE_ALLOCATOR,
   /* VC debug mode only - due to security, denial of service implications */
   MMAL_WORKER_CONSUME_MEM,
   MMAL_WORKER_LMK,
   MMAL_WORKER_OPAQUE_ALLOCATOR_DESC,
   MMAL_WORKER_DRM_GET_LHS32,
   MMAL_WORKER_DRM_GET_TIME,
   MMAL_WORKER_BUFFER_FROM_HOST_ZEROLEN,
   MMAL_WORKER_PORT_FLUSH,
   MMAL_WORKER_HOST_LOG,
   MMAL_WORKER_MSG_LAST
} MMAL_WORKER_CMD_T;

/** Every message has one of these at the start.
  */
typedef struct
{
   uint32_t magic;
   uint32_t msgid;
   struct MMAL_CONTROL_SERVICE_T *control_service;       /** Handle to the control service */

   union {
      struct MMAL_WAITER_T *waiter;    /** User-land wait structure, passed back */
   } u;

   MMAL_STATUS_T status;            /** Result code, passed back */
   /* Make sure this structure is 64 bit aligned */
   uint32_t dummy;
} mmal_worker_msg_header;

/* Make sure mmal_worker_msg_header will preserve 64 bits alignment */
vcos_static_assert(!(sizeof(mmal_worker_msg_header) & 0x7));

/* Message structures sent to worker thread.
 */

/** Tell the worker a service has closed. It should start to delete
  * the associated components.
  */
typedef struct
{
   mmal_worker_msg_header header;
} mmal_worker_service_closed;
vcos_static_assert(sizeof(mmal_worker_service_closed) <= MMAL_WORKER_MSG_LEN);

/** Send from VC to host to report our version */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t flags;
   uint32_t major;
   uint32_t minor;
   uint32_t minimum;
} mmal_worker_version;

/** Request component creation */
typedef struct
{
   mmal_worker_msg_header header;
   void *client_component;             /** Client component */
   char name[128];
   uint32_t pid;                       /**< For debug */
} mmal_worker_component_create;

/** Reply to component-creation message. Reports back
  * the number of ports.
  */
typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   uint32_t component_handle;          /** Handle on VideoCore for component */
   uint32_t input_num;                 /**< Number of input ports */
   uint32_t output_num;                /**< Number of output ports */
   uint32_t clock_num;                 /**< Number of clock ports */
} mmal_worker_component_create_reply;
vcos_static_assert(sizeof(mmal_worker_component_create_reply) <= MMAL_WORKER_MAX_MSG_LEN);

/** Destroys a component
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< which component */
} mmal_worker_component_destroy;

/** Enables a component
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< which component */
} mmal_worker_component_enable;

/** Disable a component
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
} mmal_worker_component_disable;

/** Component port info. Used to get port info.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
   uint32_t index;                     /**< Which port of given type to get */
} mmal_worker_port_info_get;
vcos_static_assert(sizeof(mmal_worker_port_info_get) <= MMAL_WORKER_MAX_MSG_LEN);

/** Component port info. Used to set port info.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
   uint32_t index;                     /**< Which port of given type to get */
   MMAL_PORT_T port;
   MMAL_ES_FORMAT_T format;
   MMAL_ES_SPECIFIC_FORMAT_T es;
   uint8_t  extradata[MMAL_FORMAT_EXTRADATA_MAX_SIZE];
} mmal_worker_port_info_set;
vcos_static_assert(sizeof(mmal_worker_port_info_set) <= MMAL_WORKER_MAX_MSG_LEN);

/** Report port info back in response to a get / set. */
typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;               /**< Result of query */
   uint32_t component_handle;          /**< Which component */
   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
   uint32_t index;                     /**< Which port of given type to get */
   int32_t found;                      /**< Did we find anything? */
   uint32_t port_handle;               /**< Handle to use for this port */
   MMAL_PORT_T port;
   MMAL_ES_FORMAT_T format;
   MMAL_ES_SPECIFIC_FORMAT_T es;
   uint8_t  extradata[MMAL_FORMAT_EXTRADATA_MAX_SIZE];
} mmal_worker_port_info;
vcos_static_assert(sizeof(mmal_worker_port_info) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
} mmal_worker_reply;

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   uint8_t secret[32];
} mmal_worker_drm_get_lhs32_reply;
vcos_static_assert(sizeof(mmal_worker_drm_get_lhs32_reply) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   uint32_t time;
} mmal_worker_drm_get_time_reply;
vcos_static_assert(sizeof(mmal_worker_drm_get_time_reply) <= MMAL_WORKER_MAX_MSG_LEN);

/** List of actions for a port */
enum MMAL_WORKER_PORT_ACTIONS
{
   MMAL_WORKER_PORT_ACTION_UNKNOWN = 0,        /**< Unkown action */
   MMAL_WORKER_PORT_ACTION_ENABLE,             /**< Enable a port */
   MMAL_WORKER_PORT_ACTION_DISABLE,            /**< Disable a port */
   MMAL_WORKER_PORT_ACTION_FLUSH,              /**< Flush a port */
   MMAL_WORKER_PORT_ACTION_CONNECT,            /**< Connect 2 ports together */
   MMAL_WORKER_PORT_ACTION_DISCONNECT,         /**< Disconnect 2 ports connected together */
   MMAL_WORKER_PORT_ACTION_SET_REQUIREMENTS,   /**< Set buffer requirements  */
   MMAL_WORKER_PORT_ACTION_MAX = 0x7fffffff    /**< Make the enum 32bits */
};

/** Trigger an action on a port.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;
   uint32_t port_handle;
   enum MMAL_WORKER_PORT_ACTIONS action;

   /** Action parameter */
   union {
      struct {
         MMAL_PORT_T port;
      } enable;
      struct {
         uint32_t component_handle;
         uint32_t port_handle;
      } connect;
   } param;

} mmal_worker_port_action;
vcos_static_assert(sizeof(mmal_worker_port_action) <= MMAL_WORKER_MAX_MSG_LEN);

#define MMAL_WORKER_PORT_PARAMETER_SPACE      96

#define MMAL_WORKER_PORT_PARAMETER_SET_MAX \
   (MMAL_WORKER_PORT_PARAMETER_SPACE*sizeof(uint32_t)+sizeof(MMAL_PARAMETER_HEADER_T))

#define MMAL_WORKER_PORT_PARAMETER_GET_MAX   MMAL_WORKER_PORT_PARAMETER_SET_MAX

/** Component port parameter set. Doesn't include space for the parameter data.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   uint32_t port_handle;               /**< Which port */
   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
   uint32_t space[MMAL_WORKER_PORT_PARAMETER_SPACE];
} mmal_worker_port_param_set;
vcos_static_assert(sizeof(mmal_worker_port_param_set) <= MMAL_WORKER_MAX_MSG_LEN);

/** Component port parameter get.
  */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_handle;          /**< Which component */
   uint32_t port_handle;               /**< Which port */
   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size (no data) */
} mmal_worker_port_param_get;
vcos_static_assert(sizeof(mmal_worker_port_param_get) <= MMAL_WORKER_MAX_MSG_LEN);

/** Component port parameter get reply. Doesn't include space for the parameter data.
  */
typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;               /**< Status of mmal_port_parameter_get call */
   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
   uint32_t space[MMAL_WORKER_PORT_PARAMETER_SPACE];
} mmal_worker_port_param_get_reply;
vcos_static_assert(sizeof(mmal_worker_port_param_get_reply) <= MMAL_WORKER_MAX_MSG_LEN);

/** Buffer header driver area structure. In the private area
  * of a buffer header there is a driver area where we can
  * put values. This structure defines the layout of that.
  */
struct MMAL_DRIVER_BUFFER_T
{
   uint32_t magic;
   uint32_t component_handle;    /**< The component this buffer is from */
   uint32_t port_handle;         /**< Index into array of ports for this component */

   /** Client side uses this to get back to its context structure. */
   struct MMAL_VC_CLIENT_BUFFER_CONTEXT_T *client_context;
};

/** Receive a buffer from the host.
  *
  * @sa mmal_port_send_buffer()
  */

typedef struct mmal_worker_buffer_from_host
{
   mmal_worker_msg_header header;

   /** Our control data, copied from the buffer header "driver area"
    * @sa mmal_buffer_header_driver_data().
    */
   struct MMAL_DRIVER_BUFFER_T drvbuf;

   /** Referenced buffer control data.
    * This is set if the buffer is referencing another
    * buffer as is the case with passthrough ports where
    * buffers on the output port reference buffers on the
    * input port. */
   struct MMAL_DRIVER_BUFFER_T drvbuf_ref;

   /** the buffer header itself */
   MMAL_BUFFER_HEADER_T buffer_header;
   MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T buffer_header_type_specific;

   MMAL_BOOL_T is_zero_copy;
   MMAL_BOOL_T has_reference;

   /** If the data is short enough, then send it in the control message rather
    * than using a separate VCHIQ bulk transfer.
    */
   uint32_t payload_in_message;
   uint8_t short_data[MMAL_VC_SHORT_DATA];

} mmal_worker_buffer_from_host;
vcos_static_assert(sizeof(mmal_worker_buffer_from_host) <= MMAL_WORKER_MAX_MSG_LEN);

/** Maximum number of event data bytes that can be passed in the message.
 * More than this and the data is passed in a bulk message.
 */
#define MMAL_WORKER_EVENT_SPACE 256

/** Send an event buffer from the host.
  *
  * @sa mmal_port_send_event()
  */

typedef struct mmal_worker_event_to_host
{
   mmal_worker_msg_header header;

   struct MMAL_COMPONENT_T *client_component;
   uint32_t port_type;
   uint32_t port_num;

   uint32_t cmd;
   uint32_t length;
   uint8_t data[MMAL_WORKER_EVENT_SPACE];
   MMAL_BUFFER_HEADER_T *delayed_buffer;  /* Only used to remember buffer for bulk rx */
} mmal_worker_event_to_host;
vcos_static_assert(sizeof(mmal_worker_event_to_host) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_VC_STATS_T stats;
   uint32_t reset;
} mmal_worker_stats;
vcos_static_assert(sizeof(mmal_worker_stats) <= MMAL_WORKER_MAX_MSG_LEN);

typedef enum {
   MMAL_WORKER_OPAQUE_MEM_ALLOC,
   MMAL_WORKER_OPAQUE_MEM_RELEASE,
   MMAL_WORKER_OPAQUE_MEM_ACQUIRE,
   MMAL_WORKER_OPAQUE_MEM_MAX = 0x7fffffff,
} MMAL_WORKER_OPAQUE_MEM_OP;

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_WORKER_OPAQUE_MEM_OP op;
   uint32_t handle;
   MMAL_STATUS_T status;
   char description[32];
} mmal_worker_opaque_allocator;

/*
 * Per-port core statistics
 */
typedef struct
{
   mmal_worker_msg_header header;
   uint32_t component_index;
   uint32_t port_index;
   MMAL_PORT_TYPE_T type;
   MMAL_CORE_STATS_DIR dir;
   MMAL_BOOL_T reset;
} mmal_worker_get_core_stats_for_port;

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   MMAL_STATS_RESULT_T result;
   MMAL_CORE_STATISTICS_T stats;
   char component_name[MMAL_VC_CORE_STATS_NAME_MAX];
} mmal_worker_get_core_stats_for_port_reply;

typedef struct
{
   mmal_worker_msg_header header;
   MMAL_STATUS_T status;
   /* The amount of memory to reserve */
   uint32_t size;
   /* Handle to newly allocated memory or MEM_HANDLE_INVALD on failure */
   uint32_t handle;
} mmal_worker_consume_mem;
vcos_static_assert(sizeof(mmal_worker_consume_mem) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   /* Message text to add to the circular buffer */
   char msg[MMAL_WORKER_MAX_MSG_LEN - sizeof(mmal_worker_msg_header)];
} mmal_worker_host_log;
vcos_static_assert(sizeof(mmal_worker_host_log) <= MMAL_WORKER_MAX_MSG_LEN);

typedef struct
{
   mmal_worker_msg_header header;
   /* The memory allocation size to pass to lmk, as if in a response to an
    * allocation for this amount of memory. */
   uint32_t alloc_size;
} mmal_worker_lmk;
vcos_static_assert(sizeof(mmal_worker_lmk) <= MMAL_WORKER_MAX_MSG_LEN);

static inline void mmal_vc_buffer_header_to_msg(mmal_worker_buffer_from_host *msg,
                                                MMAL_BUFFER_HEADER_T *header)
{
   msg->buffer_header.cmd           = header->cmd;
   msg->buffer_header.offset        = header->offset;
   msg->buffer_header.length        = header->length;
   msg->buffer_header.flags         = header->flags;
   msg->buffer_header.pts           = header->pts;
   msg->buffer_header.dts           = header->dts;
   msg->buffer_header.alloc_size    = header->alloc_size;
   msg->buffer_header.data          = header->data;
   msg->buffer_header_type_specific = *header->type;
}

static inline void mmal_vc_msg_to_buffer_header(MMAL_BUFFER_HEADER_T *header,
                                                mmal_worker_buffer_from_host *msg)
{
   header->cmd    = msg->buffer_header.cmd;
   header->offset = msg->buffer_header.offset;
   header->length = msg->buffer_header.length;
   header->flags  = msg->buffer_header.flags;
   header->pts    = msg->buffer_header.pts;
   header->dts    = msg->buffer_header.dts;
   *header->type  = msg->buffer_header_type_specific;
}

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_opaque_alloc.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "interface/mmal/vc/mmal_vc_opaque_alloc.h"
#include "mmal_vc_msgs.h"
#include "mmal_vc_client_priv.h"

MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc_desc(const char *description)
{
   MMAL_STATUS_T ret;
   MMAL_OPAQUE_IMAGE_HANDLE_T h = 0;
   mmal_worker_opaque_allocator msg;
   size_t len = sizeof(msg);
   msg.op = MMAL_WORKER_OPAQUE_MEM_ALLOC;
   vcos_safe_strcpy(msg.description, description, sizeof(msg.description), 0);
   ret = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                  &msg.header, sizeof(msg),
                                  MMAL_WORKER_OPAQUE_ALLOCATOR_DESC,
                                  &msg, &len, MMAL_FALSE);
   if (ret == MMAL_SUCCESS)
   {
      h = msg.handle;
   }
   return h;
}

MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc(void)
{
   return mmal_vc_opaque_alloc_desc("?");
}

MMAL_STATUS_T mmal_vc_opaque_acquire(unsigned int handle)
{
   MMAL_STATUS_T ret;
   mmal_worker_opaque_allocator msg;
   size_t len = sizeof(msg);
   msg.handle = handle;
   msg.op = MMAL_WORKER_OPAQUE_MEM_ACQUIRE;
   ret = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                  &msg.header, sizeof(msg),
                                  MMAL_WORKER_OPAQUE_ALLOCATOR,
                                  &msg, &len, MMAL_FALSE);
   if (ret == MMAL_SUCCESS)
      ret = msg.status;
   return ret;
}

MMAL_STATUS_T mmal_vc_opaque_release(unsigned int handle)
{
   MMAL_STATUS_T ret;
   mmal_worker_opaque_allocator msg;
   size_t len = sizeof(msg);
   msg.handle = handle;
   msg.op = MMAL_WORKER_OPAQUE_MEM_RELEASE;
   ret = mmal_vc_sendwait_message(mmal_vc_get_client(),
                                  &msg.header, sizeof(msg),
                                  MMAL_WORKER_OPAQUE_ALLOCATOR,
                                  &msg, &len, MMAL_FALSE);
   if (ret == MMAL_SUCCESS)
      ret = msg.status;
   return ret;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_opaque_alloc.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_VC_OPAQUE_ALLOC_H
#define MMAL_VC_OPAQUE_ALLOC_H


#include <stdint.h>
#include "interface/mmal/mmal.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef uint32_t MMAL_OPAQUE_IMAGE_HANDLE_T;

/** Allocate an opaque image on VideoCore.
 *
 * @return allocated handle, or zero if allocation failed.
 */
MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc(void);

/** Allocate an opaque image on VideoCore, providing a description.
 * @return allocated handle, or zero if allocation failed.
 */
MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc_desc(const char *description);

/** Release an opaque image.
 *
 * @param handle  handle allocated earlier
 * @return MMAL_SUCCESS or error code if handle not found
 */
MMAL_STATUS_T mmal_vc_opaque_release(MMAL_OPAQUE_IMAGE_HANDLE_T h);

/** Acquire an additional reference to an opaque image.
 *
 * @param handle  handle allocated earlier
 * @return MMAL_SUCCESS or error code if handle not found
 */
MMAL_STATUS_T mmal_vc_opaque_acquire(MMAL_OPAQUE_IMAGE_HANDLE_T h);


#ifdef __cplusplus
}
#endif


#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.c
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include "interface/mmal/mmal_logging.h"
#include "interface/mmal/mmal.h"
#include "interface/vcos/vcos.h"

#include "interface/mmal/vc/mmal_vc_shm.h"

#ifdef ENABLE_MMAL_VCSM
# include "user-vcsm.h"
#endif /* ENABLE_MMAL_VCSM */

#define MMAL_VC_PAYLOAD_ELEM_MAX 512

typedef struct MMAL_VC_PAYLOAD_ELEM_T
{
   struct MMAL_VC_PAYLOAD_ELEM_T *next;
   void *handle;
   void *vc_handle;
   uint8_t *mem;
   MMAL_BOOL_T in_use;
} MMAL_VC_PAYLOAD_ELEM_T;

typedef struct MMAL_VC_PAYLOAD_LIST_T
{
   MMAL_VC_PAYLOAD_ELEM_T list[MMAL_VC_PAYLOAD_ELEM_MAX];
   VCOS_MUTEX_T lock;
} MMAL_VC_PAYLOAD_LIST_T;

static MMAL_VC_PAYLOAD_LIST_T mmal_vc_payload_list;

static void mmal_vc_payload_list_init()
{
   vcos_mutex_create(&mmal_vc_payload_list.lock, "mmal_vc_payload_list");
}

static MMAL_VC_PAYLOAD_ELEM_T *mmal_vc_payload_list_get()
{
   MMAL_VC_PAYLOAD_ELEM_T *elem = 0;
   unsigned int i;

   vcos_mutex_lock(&mmal_vc_payload_list.lock);
   for (i = 0; i < MMAL_VC_PAYLOAD_ELEM_MAX; i++)
   {
      if (mmal_vc_payload_list.list[i].in_use)
         continue;
      elem = &mmal_vc_payload_list.list[i];
      elem->in_use = 1;
      break;
   }
   vcos_mutex_unlock(&mmal_vc_payload_list.lock);

   return elem;
}

static void mmal_vc_payload_list_release(MMAL_VC_PAYLOAD_ELEM_T *elem)
{
   vcos_mutex_lock(&mmal_vc_payload_list.lock);
   elem->handle = elem->vc_handle = 0;
   elem->mem = 0;
   elem->in_use = 0;
   vcos_mutex_unlock(&mmal_vc_payload_list.lock);
}

static MMAL_VC_PAYLOAD_ELEM_T *mmal_vc_payload_list_find_mem(uint8_t *mem)
{
   MMAL_VC_PAYLOAD_ELEM_T *elem = 0;
   unsigned int i;

   vcos_mutex_lock(&mmal_vc_payload_list.lock);
   for (i = 0; i < MMAL_VC_PAYLOAD_ELEM_MAX; i++)
   {
      if (!mmal_vc_payload_list.list[i].in_use)
         continue;
      if (mmal_vc_payload_list.list[i].mem != mem)
         continue;
      elem = &mmal_vc_payload_list.list[i];
      break;
   }
   vcos_mutex_unlock(&mmal_vc_payload_list.lock);

   return elem;
}

static MMAL_VC_PAYLOAD_ELEM_T *mmal_vc_payload_list_find_handle(uint8_t *mem)
{
   MMAL_VC_PAYLOAD_ELEM_T *elem = 0;
   unsigned int i;

   vcos_mutex_lock(&mmal_vc_payload_list.lock);
   for (i = 0; i < MMAL_VC_PAYLOAD_ELEM_MAX; i++)
   {
      if (!mmal_vc_payload_list.list[i].in_use)
         continue;
      if (mmal_vc_payload_list.list[i].vc_handle != (void *)mem)
         continue;
      elem = &mmal_vc_payload_list.list[i];
      break;
   }
   vcos_mutex_unlock(&mmal_vc_payload_list.lock);

   return elem;
}

/** Initialise the shared memory system */
MMAL_STATUS_T mmal_vc_shm_init(void)
{
#ifdef ENABLE_MMAL_VCSM
   if (vcsm_init() != 0)
   {
      LOG_ERROR("could not initialize vc shared memory service");
      return MMAL_EIO;
   }
#endif /* ENABLE_MMAL_VCSM */

   mmal_vc_payload_list_init();
   return MMAL_SUCCESS;
}

/** Allocate a shared memory buffer */
uint8_t *mmal_vc_shm_alloc(uint32_t size)
{
   uint8_t *mem = NULL;

   MMAL_VC_PAYLOAD_ELEM_T *payload_elem = mmal_vc_payload_list_get();
   if (!payload_elem)
   {
      LOG_ERROR("could not get a free slot in the payload list");
      return NULL;
   }

#ifdef ENABLE_MMAL_VCSM
   unsigned int vcsm_handle = vcsm_malloc_cache(size, VCSM_CACHE_TYPE_HOST, "mmal_vc_port buffer");
   unsigned int vc_handle = vcsm_vc_hdl_from_hdl(vcsm_handle);
   mem = (uint8_t *)vcsm_lock( vcsm_handle );
   if (!mem || !vc_handle)
   {
      LOG_ERROR("could not allocate %i bytes of shared memory (handle %x)",
                (int)size, vcsm_handle);
      if (mem)
         vcsm_unlock_hdl(vcsm_handle);
      if (vcsm_handle)
         vcsm_free(vcsm_handle);
      mmal_vc_payload_list_release(payload_elem);
      return NULL;
   }

   /* The memory area is automatically mem-locked by vcsm's fault
    * handler when it is next used. So leave it unlocked until it
    * is needed.
    */
   vcsm_unlock_hdl(vcsm_handle);

   payload_elem->mem = mem;
   payload_elem->handle = (void *)vcsm_handle;
   payload_elem->vc_handle = (void *)vc_handle;
#else /* ENABLE_MMAL_VCSM */
   MMAL_PARAM_UNUSED(size);
   mmal_vc_payload_list_release(payload_elem);
#endif /* ENABLE_MMAL_VCSM */

   return mem;
}

/** Free a shared memory buffer */
MMAL_STATUS_T mmal_vc_shm_free(uint8_t *mem)
{
   MMAL_VC_PAYLOAD_ELEM_T *payload_elem = mmal_vc_payload_list_find_mem(mem);
   if (payload_elem)
   {
#ifdef ENABLE_MMAL_VCSM
      vcsm_free((unsigned int)payload_elem->handle);
#endif /* ENABLE_MMAL_VCSM */
      mmal_vc_payload_list_release(payload_elem);
      return MMAL_SUCCESS;
   }

   return MMAL_EINVAL;
}

/** Lock a shared memory buffer */
uint8_t *mmal_vc_shm_lock(uint8_t *mem, uint32_t workaround)
{
   /* Zero copy stuff */
   MMAL_VC_PAYLOAD_ELEM_T *elem = mmal_vc_payload_list_find_handle(mem);
   MMAL_PARAM_UNUSED(workaround);

   if (elem)
      mem = elem->mem;

   return mem;
}

/** Unlock a shared memory buffer */
uint8_t *mmal_vc_shm_unlock(uint8_t *mem, uint32_t *length, uint32_t workaround)
{
   /* Zero copy stuff */
   MMAL_VC_PAYLOAD_ELEM_T *elem = mmal_vc_payload_list_find_mem(mem);
   MMAL_PARAM_UNUSED(workaround);

   if (elem)
   {
      *length = 0;
      mem = (uint8_t *)elem->vc_handle;
#ifdef ENABLE_MMAL_VCSM
      vcsm_unlock_ptr(elem->mem);
#endif /* ENABLE_MMAL_VCSM */
   }

   return mem;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef MMAL_VC_SHM_H
#define MMAL_VC_SHM_H

/** @file
  *
  * Abstraction layer for MMAL VC shared memory.
  * This API is only used by the MMAL VC component.
  */

#include "mmal_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/** Initialise the shared memory system */
MMAL_STATUS_T mmal_vc_shm_init(void);

/** Allocate a shared memory buffer */
uint8_t *mmal_vc_shm_alloc(uint32_t size);

/** Free a shared memory buffer */
MMAL_STATUS_T mmal_vc_shm_free(uint8_t *mem);

/** Lock a shared memory buffer */
uint8_t *mmal_vc_shm_lock(uint8_t *mem, uint32_t workaround);

/** Unlock a shared memory buffer */
uint8_t *mmal_vc_shm_unlock(uint8_t *mem, uint32_t *length, uint32_t workaround);


#ifdef __cplusplus
}
#endif

#endif /* MMAL_VC_SHM_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/CMakeLists.txt
================
add_definitions(-Wall -Werror)

add_library(mmal SHARED util/mmal_util.c)

add_subdirectory(core)
add_subdirectory(util)
add_subdirectory(vc)

#add_subdirectory(test/lua)
#add_subdirectory(test/standalone)

if(BUILD_MMAL_APPS)
add_subdirectory(components)
target_link_libraries(mmal mmal_core mmal_util mmal_vc_client vcos mmal_components)
else(BUILD_MMAL_APPS)
target_link_libraries(mmal mmal_core mmal_util mmal_vc_client)
endif(BUILD_MMAL_APPS)

install(TARGETS mmal DESTINATION lib)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_buffer.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_BUFFER_H
#define MMAL_BUFFER_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalBufferHeader Buffer headers
 * Definition of a buffer header and its associated API.
 * Buffer headers are the basic element used to pass data and information between different
 * parts of the system. They are passed to components via ports and sent back to the client
 * using a callback mechanism.
 */
/* @{ */

/** Specific data associated with video frames */
typedef struct {
   uint32_t planes;     /**< Number of planes composing the video frame */
   uint32_t offset[4];  /**< Offsets to the different planes. These must point within the
                             payload buffer */
   uint32_t pitch[4];   /**< Pitch (size in bytes of a line of a plane) of the different
                             planes */
   uint32_t flags;      /**< Flags describing video specific properties of a buffer header
                             (see \ref videobufferheaderflags "Video buffer header flags") */
   /* TBD stereoscopic support */
} MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T;

/** Type specific data that's associated with a payload buffer */
typedef union
{
   /** Specific data associated with video frames */
   MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T video;

} MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T;

/** Definition of the buffer header structure.
 * A buffer header does not directly carry the data to be passed to a component but instead
 * it references the actual data using a pointer (and an associated length).
 * It also contains an internal area which can be used to store command or metadata to be
 * associated with the external data.
 */
typedef struct MMAL_BUFFER_HEADER_T
{
   struct MMAL_BUFFER_HEADER_T *next; /**< Used to link several buffer headers together */

   struct MMAL_BUFFER_HEADER_PRIVATE_T *priv; /**< Data private to the framework */

   uint32_t cmd;              /**< Defines what the buffer header contains. This is a FourCC
                                   with 0 as a special value meaning stream data */

   uint8_t  *data;            /**< Pointer to the start of the payload buffer (should not be
                                   changed by component) */
   uint32_t alloc_size;       /**< Allocated size in bytes of payload buffer */
   uint32_t length;           /**< Number of bytes currently used in the payload buffer (starting
                                   from offset) */
   uint32_t offset;           /**< Offset in bytes to the start of valid data in the payload buffer */

   uint32_t flags;            /**< Flags describing properties of a buffer header (see
                                   \ref bufferheaderflags "Buffer header flags") */

   int64_t  pts;              /**< Presentation timestamp in microseconds. \ref MMAL_TIME_UNKNOWN
                                   is used when the pts is unknown. */
   int64_t  dts;              /**< Decode timestamp in microseconds (dts = pts, except in the case
                                   of video streams with B frames). \ref MMAL_TIME_UNKNOWN
                                   is used when the dts is unknown. */

   /** Type specific data that's associated with a payload buffer */
   MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T *type;

   void *user_data;           /**< Field reserved for use by the client */

} MMAL_BUFFER_HEADER_T;

/** \name Buffer header flags
 * \anchor bufferheaderflags
 * The following flags describe properties of a buffer header */
/* @{ */
/** Signals that the current payload is the end of the stream of data */
#define MMAL_BUFFER_HEADER_FLAG_EOS                    (1<<0)
/** Signals that the start of the current payload starts a frame */
#define MMAL_BUFFER_HEADER_FLAG_FRAME_START            (1<<1)
/** Signals that the end of the current payload ends a frame */
#define MMAL_BUFFER_HEADER_FLAG_FRAME_END              (1<<2)
/** Signals that the current payload contains only complete frames (1 or more) */
#define MMAL_BUFFER_HEADER_FLAG_FRAME                  (MMAL_BUFFER_HEADER_FLAG_FRAME_START|MMAL_BUFFER_HEADER_FLAG_FRAME_END)
/** Signals that the current payload is a keyframe (i.e. self decodable) */
#define MMAL_BUFFER_HEADER_FLAG_KEYFRAME               (1<<3)
/** Signals a discontinuity in the stream of data (e.g. after a seek).
 * Can be used for instance by a decoder to reset its state */
#define MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY          (1<<4)
/** Signals a buffer containing some kind of config data for the component
 * (e.g. codec config data) */
#define MMAL_BUFFER_HEADER_FLAG_CONFIG                 (1<<5)
/** Signals an encrypted payload */
#define MMAL_BUFFER_HEADER_FLAG_ENCRYPTED              (1<<6)
/** Signals a buffer containing side information */
#define MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO          (1<<7)
/** Signals a buffer which is the snapshot/postview image from a stills capture */
#define MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT              (1<<8)
/** Signals a buffer which contains data known to be corrupted */
#define MMAL_BUFFER_HEADER_FLAG_CORRUPTED              (1<<9)
/** Signals that a buffer failed to be transmitted */
#define MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED    (1<<10)
/* @} */

/** \name Video buffer header flags
 * \anchor videobufferheaderflags
 * The following flags describe properties of a video buffer header */
/* @{ */
/** Signals an interlaced video frame */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED       (1<<0)
/** Signals that the top field of the current interlaced frame should be displayed first */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST  (1<<2)
/** Signals that the buffer should be displayed on external display if attached. */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_DISPLAY_EXTERNAL (1<<3)
/** Signals that contents of the buffer requires copy protection. */
#define MMAL_BUFFER_HEADER_VIDEO_FLAG_PROTECTED        (1<<4)
/* @} */

/** Acquire a buffer header.
 * Acquiring a buffer header increases a reference counter on it and makes sure that the
 * buffer header won't be recycled until all the references to it are gone.
 * This is useful for instance if a component needs to return a buffer header but still needs
 * access to it for some internal processing (e.g. reference frames in video codecs).
 *
 * @param header buffer header to acquire
 */
void mmal_buffer_header_acquire(MMAL_BUFFER_HEADER_T *header);

/** Reset a buffer header.
 * Resets all header variables to default values.
 *
 * @param header buffer header to reset
 */
void mmal_buffer_header_reset(MMAL_BUFFER_HEADER_T *header);

/** Release a buffer header.
 * Releasing a buffer header will decrease its reference counter and when no more references
 * are left, the buffer header will be recycled by calling its 'release' callback function.
 *
 * If a pre-release callback is set (\ref MMAL_BH_PRE_RELEASE_CB_T), this will be invoked
 * before calling the buffer's release callback and potentially postpone buffer recycling.
 * Once pre-release is complete the buffer header is recycled with
 * \ref mmal_buffer_header_release_continue.
 *
 * @param header buffer header to release
 */
void mmal_buffer_header_release(MMAL_BUFFER_HEADER_T *header);

/** Continue the buffer header release process.
 * This should be called to complete buffer header recycling once all pre-release activity
 * has been completed.
 *
 * @param header buffer header to release
 */
void mmal_buffer_header_release_continue(MMAL_BUFFER_HEADER_T *header);

/** Buffer header pre-release callback.
 * The callback is invoked just before a buffer is released back into a
 * pool. This is used by clients who need to trigger additional actions
 * before the buffer can finally be released (e.g. wait for a bulk transfer
 * to complete).
 *
 * The callback should return TRUE if the buffer release need to be post-poned.
 *
 * @param header   buffer header about to be released
 * @param userdata user-specific data
 *
 * @return TRUE if the buffer should not be released
 */
typedef MMAL_BOOL_T (*MMAL_BH_PRE_RELEASE_CB_T)(MMAL_BUFFER_HEADER_T *header, void *userdata);

/** Set a buffer header pre-release callback.
 * If the callback is NULL, the buffer will be released back into the pool
 * immediately as usual.
 *
 * @param header   buffer header to associate callback with
 * @param cb       pre-release callback to invoke
 * @param userdata user-specific data
 */
void mmal_buffer_header_pre_release_cb_set(MMAL_BUFFER_HEADER_T *header, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata);

/** Replicate a buffer header into another one.
 * Replicating a buffer header will not only do an exact copy of all the public fields of the
 * buffer header (including data and alloc_size), but it will also acquire a reference to the
 * source buffer header which will only be released once the replicate has been released.
 *
 * @param dest buffer header into which to replicate
 * @param src buffer header to use as the source for the replication
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_buffer_header_replicate(MMAL_BUFFER_HEADER_T *dest, MMAL_BUFFER_HEADER_T *src);

/** Lock the data buffer contained in the buffer header in memory.
 * This call does nothing on all platforms except VideoCore where it is needed to pin a
 * buffer in memory before any access to it.
 *
 * @param header buffer header to lock
 */
MMAL_STATUS_T mmal_buffer_header_mem_lock(MMAL_BUFFER_HEADER_T *header);

/** Unlock the data buffer contained in the buffer header.
 * This call does nothing on all platforms except VideoCore where it is needed to un-pin a
 * buffer in memory after any access to it.
 *
 * @param header buffer header to unlock
 */
void mmal_buffer_header_mem_unlock(MMAL_BUFFER_HEADER_T *header);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_BUFFER_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_clock.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef MMAL_CLOCK_H
#define MMAL_CLOCK_H

#include "interface/vcos/vcos.h"
#include "mmal_types.h"
#include "mmal_common.h"

/** \defgroup MmalClock Clock Framework
 * The MMAL clock framework provides scheduling facilities to the rest of
 * MMAL.
 *
 * The framework consists mainly of clock ports and a clock module. Client
 * applications and components interact directly with clock ports, while
 * the clock module is only used internally by clock ports.
 *
 * Clock ports ensure that the local media-time for each component is
 * synchronised across all components. This is done by passing buffers between
 * clock ports which contain clock-specific data.
 *
 * One clock port will normally act as the reference clock for the rest of the
 * system. This is usually chosen to be the clock port of the audio render
 * component, but is configurable by the client and could potentially be any
 * other clock port (or even the client application itself).
 *
 * Components that are responsible for timed delivery of frames, do so by
 * registering callback requests for a particular time-stamp with the clock
 * port. These requests are scheduled using the clock module which maintains
 * an internal media-time.
 *
 * The clock framework also provides the ability to perform playback at different
 * speeds. This is achieved with a clock scale factor which determines the speed
 * at which the media-time advances relative to real-time, with:
 *   scale = 1.0 -> normal playback speed
 *   scale = 0   -> playback paused
 *   scale > 1.0 -> fast-forward
 *   scale < 1.0 -> slow motion
 */

/** Clock event magic */
#define MMAL_CLOCK_EVENT_MAGIC               MMAL_FOURCC('C','K','L','M')

/** Clock reference update */
#define MMAL_CLOCK_EVENT_REFERENCE           MMAL_FOURCC('C','R','E','F')

/** Clock state update */
#define MMAL_CLOCK_EVENT_ACTIVE              MMAL_FOURCC('C','A','C','T')

/** Clock scale update */
#define MMAL_CLOCK_EVENT_SCALE               MMAL_FOURCC('C','S','C','A')

/** Clock media-time update */
#define MMAL_CLOCK_EVENT_TIME                MMAL_FOURCC('C','T','I','M')

/** Clock update threshold */
#define MMAL_CLOCK_EVENT_UPDATE_THRESHOLD    MMAL_FOURCC('C','U','T','H')

/** Clock discontinuity threshold */
#define MMAL_CLOCK_EVENT_DISCONT_THRESHOLD   MMAL_FOURCC('C','D','T','H')

/** Clock request threshold */
#define MMAL_CLOCK_EVENT_REQUEST_THRESHOLD   MMAL_FOURCC('C','R','T','H')

/** Buffer statistics */
#define MMAL_CLOCK_EVENT_INPUT_BUFFER_INFO   MMAL_FOURCC('C','I','B','I')
#define MMAL_CLOCK_EVENT_OUTPUT_BUFFER_INFO  MMAL_FOURCC('C','O','B','I')

/** Clock latency setting */
#define MMAL_CLOCK_EVENT_LATENCY             MMAL_FOURCC('C','L','A','T')

/** Clock event not valid */
#define MMAL_CLOCK_EVENT_INVALID   0


/** Thresholds used when updating a clock's media-time */
typedef struct MMAL_CLOCK_UPDATE_THRESHOLD_T
{
   /** Time differences below this threshold are ignored (microseconds) */
   int64_t threshold_lower;

   /** Time differences above this threshold reset media-time (microseconds) */
   int64_t threshold_upper;
} MMAL_CLOCK_UPDATE_THRESHOLD_T;

/** Threshold for detecting a discontinuity in media-time */
typedef struct MMAL_CLOCK_DISCONT_THRESHOLD_T
{
   /** Threshold after which backward jumps in media-time are treated as a
    * discontinuity (microseconds) */
   int64_t threshold;

   /** Duration in microseconds for which a discontinuity applies (wall-time) */
   int64_t duration;
} MMAL_CLOCK_DISCONT_THRESHOLD_T;

/** Threshold applied to client callback requests */
typedef struct MMAL_CLOCK_REQUEST_THRESHOLD_T
{
   /** Frames with a media-time difference (compared to current media-time)
    * above this threshold are dropped (microseconds) */
   int64_t threshold;

   /** Enable/disable the request threshold */
   MMAL_BOOL_T threshold_enable;
} MMAL_CLOCK_REQUEST_THRESHOLD_T;

/** Structure for passing buffer information to a clock port */
typedef struct MMAL_CLOCK_BUFFER_INFO_T
{
   int64_t time_stamp;
   uint32_t arrival_time;
} MMAL_CLOCK_BUFFER_INFO_T;

/** Clock latency settings used by the clock component */
typedef struct MMAL_CLOCK_LATENCY_T
{
   int64_t target;            /**< target latency (microseconds) */
   int64_t attack_period;     /**< duration of one attack period (microseconds) */
   int64_t attack_rate;       /**< amount by which media-time will be adjusted
                                   every attack_period (microseconds) */
} MMAL_CLOCK_LATENCY_T;

/** Clock event used to pass data between clock ports and a client. */
typedef struct MMAL_CLOCK_EVENT_T
{
   /** 4cc event id */
   uint32_t id;

   /** 4cc event magic */
   uint32_t magic;

   /** buffer associated with this event (can be NULL) */
   struct MMAL_BUFFER_HEADER_T *buffer;

   /** pad to 64-bit boundary */
   uint32_t padding0;

   /** additional event data (type-specific) */
   union
   {
      /** used either for clock reference or clock state */
      MMAL_BOOL_T enable;

      /** new clock scale */
      MMAL_RATIONAL_T scale;

      /** new media-time */
      int64_t media_time;

      /** media-time update threshold */
      MMAL_CLOCK_UPDATE_THRESHOLD_T update_threshold;

      /** media-time discontinuity threshold */
      MMAL_CLOCK_DISCONT_THRESHOLD_T discont_threshold;

      /** client callback request threshold */
      MMAL_CLOCK_REQUEST_THRESHOLD_T request_threshold;

      /** input/output buffer information */
      MMAL_CLOCK_BUFFER_INFO_T buffer;

      /** clock latency setting */
      MMAL_CLOCK_LATENCY_T latency;
   } data;

   /** pad to 64-bit boundary */
   uint64_t padding1;
} MMAL_CLOCK_EVENT_T;

/* Make sure MMAL_CLOCK_EVENT_T will preserve 64-bit alignment */
vcos_static_assert(!(sizeof(MMAL_CLOCK_EVENT_T) & 0x7));

#define MMAL_CLOCK_EVENT_INIT(id) { id, MMAL_CLOCK_EVENT_MAGIC, NULL, 0, {0}, 0 }

#endif /* MMAL_CLOCK_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_common.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** \file mmal_common.h
 * Multi-Media Abstraction Layer - Common definitions
 */

#ifndef MMAL_COMMON_H
#define MMAL_COMMON_H

#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <assert.h>

#include <interface/vcos/vcos.h>

/* C99 64bits integers */
#ifndef INT64_C
# define INT64_C(value) value##LL
# define UINT64_C(value) value##ULL
#endif

#define MMAL_TSRING(s) #s
#define MMAL_TO_STRING(s) MMAL_TSRING(s)

#define MMAL_COUNTOF(x) (sizeof((x))/sizeof((x)[0]))
#define MMAL_MIN(a,b) ((a)<(b)?(a):(b))
#define MMAL_MAX(a,b) ((a)<(b)?(b):(a))

/* FIXME: should be different for big endian */
#define MMAL_FOURCC(a,b,c,d) ((a) | (b << 8) | (c << 16) | (d << 24))
#define MMAL_PARAM_UNUSED(a) (void)(a)
#define MMAL_MAGIC MMAL_FOURCC('m','m','a','l')

typedef int32_t MMAL_BOOL_T;
#define MMAL_FALSE   0
#define MMAL_TRUE    1

typedef struct MMAL_CORE_STATISTICS_T
{
   uint32_t buffer_count;        /**< Total buffer count on this port */
   uint32_t first_buffer_time;   /**< Time (us) of first buffer seen on this port */
   uint32_t last_buffer_time;    /**< Time (us) of most recently buffer on this port */
   uint32_t max_delay;           /**< Max delay (us) between buffers, ignoring first few frames */
} MMAL_CORE_STATISTICS_T;

/** Statistics collected by the core on all ports, if enabled in the build.
 */
typedef struct MMAL_CORE_PORT_STATISTICS_T
{
   MMAL_CORE_STATISTICS_T rx;
   MMAL_CORE_STATISTICS_T tx;
} MMAL_CORE_PORT_STATISTICS_T;

/** Unsigned 16.16 fixed point value, also known as Q16.16 */
typedef uint32_t MMAL_FIXED_16_16_T;

#endif /* MMAL_COMMON_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_component.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_COMPONENT_H
#define MMAL_COMPONENT_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalComponent Components
 * Definition of a MMAL component and its associated API. A component will always expose ports
 * which it uses to send and receive data in the form of buffer headers
 * (\ref MMAL_BUFFER_HEADER_T) */
/* @{ */

#include "mmal_types.h"
#include "mmal_port.h"

struct MMAL_COMPONENT_PRIVATE_T;
typedef struct MMAL_COMPONENT_PRIVATE_T MMAL_COMPONENT_PRIVATE_T;

/** Definition of a component. */
typedef struct MMAL_COMPONENT_T
{
   /** Pointer to the private data of the module in use */
   struct MMAL_COMPONENT_PRIVATE_T *priv;

   /** Pointer to private data of the client */
   struct MMAL_COMPONENT_USERDATA_T *userdata;

   /** Component name */
   const char *name;

   /** Specifies whether the component is enabled or not */
   uint32_t is_enabled;

   /** All components expose a control port.
    * The control port is used by clients to set / get parameters that are global to the
    * component. It is also used to receive events, which again are global to the component.
    * To be able to receive events, the client needs to enable and register a callback on the
    * control port. */
   MMAL_PORT_T *control;

   uint32_t    input_num;   /**< Number of input ports */
   MMAL_PORT_T **input;     /**< Array of input ports */

   uint32_t    output_num;  /**< Number of output ports */
   MMAL_PORT_T **output;    /**< Array of output ports */

   uint32_t    clock_num;   /**< Number of clock ports */
   MMAL_PORT_T **clock;     /**< Array of clock ports */

   uint32_t    port_num;    /**< Total number of ports */
   MMAL_PORT_T **port;      /**< Array of all the ports (control/input/output/clock) */

   /** Uniquely identifies the component's instance within the MMAL
    * context / process. For debugging. */
   uint32_t id;

} MMAL_COMPONENT_T;

/** Create an instance of a component.
 * The newly created component will expose ports to the client. All the exposed ports are
 * disabled by default.
 * Note that components are reference counted and creating a component automatically
 * acquires a reference to it (released when \ref mmal_component_destroy is called).
 *
 * @param name name of the component to create, e.g. "video_decode"
 * @param component returned component
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_create(const char *name,
                                    MMAL_COMPONENT_T **component);

/** Acquire a reference on a component.
 * Acquiring a reference on a component will prevent a component from being destroyed until
 * the acquired reference is released (by a call to \ref mmal_component_destroy).
 * References are internally counted so all acquired references need a matching call to
 * release them.
 *
 * @param component component to acquire
 */
void mmal_component_acquire(MMAL_COMPONENT_T *component);

/** Release a reference on a component
 * Release an acquired reference on a component. Triggers the destruction of the component when
 * the last reference is being released.
 * \note This is in fact an alias of \ref mmal_component_destroy which is added to make client
 * code clearer.
 *
 * @param component component to release
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_release(MMAL_COMPONENT_T *component);

/** Destroy a previously created component
 * Release an acquired reference on a component. Only actually destroys the component when
 * the last reference is being released.
 *
 * @param component component to destroy
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_destroy(MMAL_COMPONENT_T *component);

/** Enable processing on a component
 * @param component component to enable
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_enable(MMAL_COMPONENT_T *component);

/** Disable processing on a component
 * @param component component to disable
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_component_disable(MMAL_COMPONENT_T *component);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_COMPONENT_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_encodings.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_ENCODINGS_H
#define MMAL_ENCODINGS_H

#include "mmal_common.h"

/** \defgroup MmalEncodings List of pre-defined encodings
 * This defines a list of common encodings. This list isn't exhaustive and is only
 * provided as a convenience to avoid clients having to use FourCC codes directly.
 * However components are allowed to define and use their own FourCC codes. */
/* @{ */

/** \name Pre-defined video encodings */
/* @{ */
#define MMAL_ENCODING_H264             MMAL_FOURCC('H','2','6','4')
#define MMAL_ENCODING_H263             MMAL_FOURCC('H','2','6','3')
#define MMAL_ENCODING_MP4V             MMAL_FOURCC('M','P','4','V')
#define MMAL_ENCODING_MP2V             MMAL_FOURCC('M','P','2','V')
#define MMAL_ENCODING_MP1V             MMAL_FOURCC('M','P','1','V')
#define MMAL_ENCODING_WMV3             MMAL_FOURCC('W','M','V','3')
#define MMAL_ENCODING_WMV2             MMAL_FOURCC('W','M','V','2')
#define MMAL_ENCODING_WMV1             MMAL_FOURCC('W','M','V','1')
#define MMAL_ENCODING_WVC1             MMAL_FOURCC('W','V','C','1')
#define MMAL_ENCODING_VP8              MMAL_FOURCC('V','P','8',' ')
#define MMAL_ENCODING_VP7              MMAL_FOURCC('V','P','7',' ')
#define MMAL_ENCODING_VP6              MMAL_FOURCC('V','P','6',' ')
#define MMAL_ENCODING_THEORA           MMAL_FOURCC('T','H','E','O')
#define MMAL_ENCODING_SPARK            MMAL_FOURCC('S','P','R','K')

#define MMAL_ENCODING_JPEG             MMAL_FOURCC('J','P','E','G')
#define MMAL_ENCODING_GIF              MMAL_FOURCC('G','I','F',' ')
#define MMAL_ENCODING_PNG              MMAL_FOURCC('P','N','G',' ')
#define MMAL_ENCODING_PPM              MMAL_FOURCC('P','P','M',' ')
#define MMAL_ENCODING_TGA              MMAL_FOURCC('T','G','A',' ')
#define MMAL_ENCODING_BMP              MMAL_FOURCC('B','M','P',' ')

#define MMAL_ENCODING_I420             MMAL_FOURCC('I','4','2','0')
#define MMAL_ENCODING_I420_SLICE       MMAL_FOURCC('S','4','2','0')
#define MMAL_ENCODING_YV12             MMAL_FOURCC('Y','V','1','2')
#define MMAL_ENCODING_I422             MMAL_FOURCC('I','4','2','2')
#define MMAL_ENCODING_I422_SLICE       MMAL_FOURCC('S','4','2','2')
#define MMAL_ENCODING_YUYV             MMAL_FOURCC('Y','U','Y','V')
#define MMAL_ENCODING_YVYU             MMAL_FOURCC('Y','V','Y','U')
#define MMAL_ENCODING_UYVY             MMAL_FOURCC('U','Y','V','Y')
#define MMAL_ENCODING_VYUY             MMAL_FOURCC('V','Y','U','Y')
#define MMAL_ENCODING_NV12             MMAL_FOURCC('N','V','1','2')
#define MMAL_ENCODING_NV21             MMAL_FOURCC('N','V','2','1')
#define MMAL_ENCODING_ARGB             MMAL_FOURCC('A','R','G','B')
#define MMAL_ENCODING_RGBA             MMAL_FOURCC('R','G','B','A')
#define MMAL_ENCODING_ABGR             MMAL_FOURCC('A','B','G','R')
#define MMAL_ENCODING_BGRA             MMAL_FOURCC('B','G','R','A')
#define MMAL_ENCODING_RGB16            MMAL_FOURCC('R','G','B','2')
#define MMAL_ENCODING_RGB24            MMAL_FOURCC('R','G','B','3')
#define MMAL_ENCODING_RGB32            MMAL_FOURCC('R','G','B','4')
#define MMAL_ENCODING_BGR16            MMAL_FOURCC('B','G','R','2')
#define MMAL_ENCODING_BGR24            MMAL_FOURCC('B','G','R','3')
#define MMAL_ENCODING_BGR32            MMAL_FOURCC('B','G','R','4')

/** SAND Video (YUVUV128) format, native format understood by VideoCore.
 * This format is *not* opaque - if requested you will receive full frames
 * of YUV_UV video.
 */
#define MMAL_ENCODING_YUVUV128         MMAL_FOURCC('S','A','N','D')

/** VideoCore opaque image format, image handles are returned to
 * the host but not the actual image data.
 */
#define MMAL_ENCODING_OPAQUE           MMAL_FOURCC('O','P','Q','V')

/** An EGL image handle
 */
#define MMAL_ENCODING_EGL_IMAGE        MMAL_FOURCC('E','G','L','I')

/* }@ */

/** \name Pre-defined audio encodings */
/* @{ */
#define MMAL_ENCODING_PCM_UNSIGNED_BE  MMAL_FOURCC('P','C','M','U')
#define MMAL_ENCODING_PCM_UNSIGNED_LE  MMAL_FOURCC('p','c','m','u')
#define MMAL_ENCODING_PCM_SIGNED_BE    MMAL_FOURCC('P','C','M','S')
#define MMAL_ENCODING_PCM_SIGNED_LE    MMAL_FOURCC('p','c','m','s')
#define MMAL_ENCODING_PCM_FLOAT_BE     MMAL_FOURCC('P','C','M','F')
#define MMAL_ENCODING_PCM_FLOAT_LE     MMAL_FOURCC('p','c','m','f')
/* Defines for native endianness */
#ifdef MMAL_IS_BIG_ENDIAN
#define MMAL_ENCODING_PCM_UNSIGNED     MMAL_ENCODING_PCM_UNSIGNED_BE
#define MMAL_ENCODING_PCM_SIGNED       MMAL_ENCODING_PCM_SIGNED_BE
#define MMAL_ENCODING_PCM_FLOAT        MMAL_ENCODING_PCM_FLOAT_BE
#else
#define MMAL_ENCODING_PCM_UNSIGNED     MMAL_ENCODING_PCM_UNSIGNED_LE
#define MMAL_ENCODING_PCM_SIGNED       MMAL_ENCODING_PCM_SIGNED_LE
#define MMAL_ENCODING_PCM_FLOAT        MMAL_ENCODING_PCM_FLOAT_LE
#endif

#define MMAL_ENCODING_MP4A             MMAL_FOURCC('M','P','4','A')
#define MMAL_ENCODING_MPGA             MMAL_FOURCC('M','P','G','A')
#define MMAL_ENCODING_ALAW             MMAL_FOURCC('A','L','A','W')
#define MMAL_ENCODING_MULAW            MMAL_FOURCC('U','L','A','W')
#define MMAL_ENCODING_ADPCM_MS         MMAL_FOURCC('M','S',0x0,0x2)
#define MMAL_ENCODING_ADPCM_IMA_MS     MMAL_FOURCC('M','S',0x0,0x1)
#define MMAL_ENCODING_ADPCM_SWF        MMAL_FOURCC('A','S','W','F')
#define MMAL_ENCODING_WMA1             MMAL_FOURCC('W','M','A','1')
#define MMAL_ENCODING_WMA2             MMAL_FOURCC('W','M','A','2')
#define MMAL_ENCODING_WMAP             MMAL_FOURCC('W','M','A','P')
#define MMAL_ENCODING_WMAL             MMAL_FOURCC('W','M','A','L')
#define MMAL_ENCODING_AMRNB            MMAL_FOURCC('A','M','R','N')
#define MMAL_ENCODING_AMRWB            MMAL_FOURCC('A','M','R','W')
#define MMAL_ENCODING_AMRWBP           MMAL_FOURCC('A','M','R','P')
#define MMAL_ENCODING_AC3              MMAL_FOURCC('A','C','3',' ')
#define MMAL_ENCODING_EAC3             MMAL_FOURCC('E','A','C','3')
#define MMAL_ENCODING_DTS              MMAL_FOURCC('D','T','S',' ')
#define MMAL_ENCODING_MLP              MMAL_FOURCC('M','L','P',' ')
#define MMAL_ENCODING_FLAC             MMAL_FOURCC('F','L','A','C')
#define MMAL_ENCODING_VORBIS           MMAL_FOURCC('V','O','R','B')
#define MMAL_ENCODING_SPEEX            MMAL_FOURCC('S','P','X',' ')
#define MMAL_ENCODING_ATRAC3           MMAL_FOURCC('A','T','R','3')
#define MMAL_ENCODING_ATRACX           MMAL_FOURCC('A','T','R','X')
#define MMAL_ENCODING_ATRACL           MMAL_FOURCC('A','T','R','L')
#define MMAL_ENCODING_MIDI             MMAL_FOURCC('M','I','D','I')
#define MMAL_ENCODING_EVRC             MMAL_FOURCC('E','V','R','C')
#define MMAL_ENCODING_NELLYMOSER       MMAL_FOURCC('N','E','L','Y')
#define MMAL_ENCODING_QCELP            MMAL_FOURCC('Q','C','E','L')
#define MMAL_ENCODING_MP4V_DIVX_DRM    MMAL_FOURCC('M','4','V','D')
/* @} */

/* @} MmalEncodings List */

/** \defgroup MmalEncodingVariants List of pre-defined encoding variants
 * This defines a list of common encoding variants. This list isn't exhaustive and is only
 * provided as a convenience to avoid clients having to use FourCC codes directly.
 * However components are allowed to define and use their own FourCC codes. */
/* @{ */

/** \name Pre-defined H264 encoding variants */
/* @{ */
/** ISO 14496-10 Annex B byte stream format */
#define MMAL_ENCODING_VARIANT_H264_DEFAULT   0
/** ISO 14496-15 AVC stream format */
#define MMAL_ENCODING_VARIANT_H264_AVC1      MMAL_FOURCC('A','V','C','1')
/** Implicitly delineated NAL units without emulation prevention */
#define MMAL_ENCODING_VARIANT_H264_RAW       MMAL_FOURCC('R','A','W',' ')
/* @} */

/** \name Pre-defined MPEG4 audio encoding variants */
/* @{ */
/** Raw stream format */
#define MMAL_ENCODING_VARIANT_MP4A_DEFAULT   0
/** ADTS stream format */
#define MMAL_ENCODING_VARIANT_MP4A_ADTS      MMAL_FOURCC('A','D','T','S')
/* @} */

/* @} MmalEncodingVariants List */

/** \defgroup MmalColorSpace List of pre-defined video color spaces
 * This defines a list of common color spaces. This list isn't exhaustive and is only
 * provided as a convenience to avoid clients having to use FourCC codes directly.
 * However components are allowed to define and use their own FourCC codes. */
/* @{ */

/** Unknown color space */
#define MMAL_COLOR_SPACE_UNKNOWN       0
/** ITU-R BT.601-5 [SDTV] */
#define MMAL_COLOR_SPACE_ITUR_BT601    MMAL_FOURCC('Y','6','0','1')
/** ITU-R BT.709-3 [HDTV] */
#define MMAL_COLOR_SPACE_ITUR_BT709    MMAL_FOURCC('Y','7','0','9')
/** JPEG JFIF */
#define MMAL_COLOR_SPACE_JPEG_JFIF     MMAL_FOURCC('Y','J','F','I')
/** Title 47 Code of Federal Regulations (2003) 73.682 (a) (20) */
#define MMAL_COLOR_SPACE_FCC           MMAL_FOURCC('Y','F','C','C')
/** Society of Motion Picture and Television Engineers 240M (1999) */
#define MMAL_COLOR_SPACE_SMPTE240M     MMAL_FOURCC('Y','2','4','0')
/** ITU-R BT.470-2 System M */
#define MMAL_COLOR_SPACE_BT470_2_M     MMAL_FOURCC('Y','_','_','M')
/** ITU-R BT.470-2 System BG */
#define MMAL_COLOR_SPACE_BT470_2_BG    MMAL_FOURCC('Y','_','B','G')
/** JPEG JFIF, but with 16..255 luma */
#define MMAL_COLOR_SPACE_JFIF_Y16_255  MMAL_FOURCC('Y','Y','1','6')
/* @} MmalColorSpace List */

#endif /* MMAL_ENCODINGS_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_events.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_EVENTS_H
#define MMAL_EVENTS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "mmal_common.h"
#include "mmal_parameters.h"
#include "mmal_port.h"

/** \defgroup MmalEvents List of pre-defined event types
 * This defines a list of standard event types. Components can still define proprietary
 * event types by using their own FourCC and defining their own event structures. */
/* @{ */

/** \name Pre-defined event FourCCs */
/* @{ */

/** Error event. Data contains a \ref MMAL_STATUS_T */
#define MMAL_EVENT_ERROR                     MMAL_FOURCC('E','R','R','O')

/** End-of-stream event. Data contains a \ref MMAL_EVENT_END_OF_STREAM_T */
#define MMAL_EVENT_EOS                       MMAL_FOURCC('E','E','O','S')

/** Format changed event. Data contains a \ref MMAL_EVENT_FORMAT_CHANGED_T */
#define MMAL_EVENT_FORMAT_CHANGED            MMAL_FOURCC('E','F','C','H')

/** Parameter changed event. Data contains the new parameter value, see
 * \ref MMAL_EVENT_PARAMETER_CHANGED_T
 */
#define MMAL_EVENT_PARAMETER_CHANGED         MMAL_FOURCC('E','P','C','H')

/* @} */


/** End-of-stream event. */
typedef struct MMAL_EVENT_END_OF_STREAM_T
{
   MMAL_PORT_TYPE_T port_type;   /**< Type of port that received the end of stream */
   uint32_t port_index;          /**< Index of port that received the end of stream */
} MMAL_EVENT_END_OF_STREAM_T;

/** Format changed event data. */
typedef struct MMAL_EVENT_FORMAT_CHANGED_T
{
   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires */
   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires */
   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance.
                                          A value of zero means no special recommendation. */
   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal
                                          performance. A value of zero means no special recommendation. */

   MMAL_ES_FORMAT_T *format;         /**< New elementary stream format */
} MMAL_EVENT_FORMAT_CHANGED_T;

/** Parameter changed event data.
 * This is a variable sized event. The full parameter is included in the event
 * data, not just the header. Use the \ref MMAL_PARAMETER_HEADER_T::id field to determine how to
 * cast the structure. The \ref MMAL_PARAMETER_HEADER_T::size field can be used to check validity.
 */
typedef struct MMAL_EVENT_PARAMETER_CHANGED_T
{
   MMAL_PARAMETER_HEADER_T hdr;
} MMAL_EVENT_PARAMETER_CHANGED_T;

/** Get a pointer to the \ref MMAL_EVENT_FORMAT_CHANGED_T structure contained in the buffer header.
 * Note that the pointer will point inside the data contained in the buffer header
 * so doesn't need to be freed explicitly.
 *
 * @param buffer buffer header containing the MMAL_EVENT_FORMAT_CHANGED event.
 * @return pointer to a MMAL_EVENT_FORMAT_CHANGED_T structure.
 */
MMAL_EVENT_FORMAT_CHANGED_T *mmal_event_format_changed_get(MMAL_BUFFER_HEADER_T *buffer);

/** Send an error event to the component's control port.
 * The error event data will be the MMAL_STATUS_T passed in.
 *
 * @param component component to receive the error event.
 * @param error_status the error status to be sent.
 * @return MMAL_SUCCESS or an error if the event could not be sent.
 */
MMAL_STATUS_T mmal_event_error_send(MMAL_COMPONENT_T *component, MMAL_STATUS_T error_status);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_EVENTS_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_format.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_FORMAT_H
#define MMAL_FORMAT_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalFormat Elementary stream format
 * Definition of an elementary stream format and its associated API */
/* @{ */

#include "mmal_types.h"
#include "mmal_encodings.h"

/** Enumeration of the different types of elementary streams.
 * This divides elementary streams into 4 big categories, plus an invalid type. */
typedef enum {
   MMAL_ES_TYPE_UNKNOWN,     /**< Unknown elementary stream type */
   MMAL_ES_TYPE_CONTROL,     /**< Elementary stream of control commands */
   MMAL_ES_TYPE_AUDIO,       /**< Audio elementary stream */
   MMAL_ES_TYPE_VIDEO,       /**< Video elementary stream */
   MMAL_ES_TYPE_SUBPICTURE   /**< Sub-picture elementary stream (e.g. subtitles, overlays) */
} MMAL_ES_TYPE_T;

/** Definition of a video format.
 * This describes the properties specific to a video stream */
typedef struct
{
   uint32_t        width;        /**< Width of frame in pixels */
   uint32_t        height;       /**< Height of frame in rows of pixels */
   MMAL_RECT_T     crop;         /**< Visible region of the frame */
   MMAL_RATIONAL_T frame_rate;   /**< Frame rate */
   MMAL_RATIONAL_T par;          /**< Pixel aspect ratio */

   MMAL_FOURCC_T   color_space;  /**< FourCC specifying the color space of the
                                   * video stream. See the \ref MmalColorSpace
                                   * "pre-defined color spaces" for some examples.
                                   */

} MMAL_VIDEO_FORMAT_T;

/** Definition of an audio format.
 * This describes the properties specific to an audio stream */
typedef struct MMAL_AUDIO_FORMAT_T
{
   uint32_t channels;           /**< Number of audio channels */
   uint32_t sample_rate;        /**< Sample rate */

   uint32_t bits_per_sample;    /**< Bits per sample */
   uint32_t block_align;        /**< Size of a block of data */

   /** \todo add channel mapping, gapless and replay-gain support */

} MMAL_AUDIO_FORMAT_T;

/** Definition of a subpicture format.
 * This describes the properties specific to a subpicture stream */
typedef struct
{
   uint32_t x_offset;        /**< Width offset to the start of the subpicture */
   uint32_t y_offset;        /**< Height offset to the start of the subpicture */

   /** \todo surely more things are needed here */

} MMAL_SUBPICTURE_FORMAT_T;

/** Definition of the type specific format.
 * This describes the type specific information of the elementary stream. */
typedef union
{
   MMAL_AUDIO_FORMAT_T      audio;      /**< Audio specific information */
   MMAL_VIDEO_FORMAT_T      video;      /**< Video specific information */
   MMAL_SUBPICTURE_FORMAT_T subpicture; /**< Subpicture specific information */
} MMAL_ES_SPECIFIC_FORMAT_T;

/** \name Elementary stream flags
 * \anchor elementarystreamflags
 * The following flags describe properties of an elementary stream */
/* @{ */
#define MMAL_ES_FORMAT_FLAG_FRAMED       0x1 /**< The elementary stream will already be framed */
/* @} */

/** \name Undefined encoding value.
 * This value indicates an unknown encoding
 */
/* @{ */
#define MMAL_ENCODING_UNKNOWN            0
/* @} */

/** \name Default encoding variant value.
 * This value indicates the default encoding variant is used
 */
/* @{ */
#define MMAL_ENCODING_VARIANT_DEFAULT    0
/* @} */

/** Definition of an elementary stream format */
typedef struct MMAL_ES_FORMAT_T
{
   MMAL_ES_TYPE_T type;           /**< Type of the elementary stream */

   MMAL_FOURCC_T encoding;        /**< FourCC specifying the encoding of the elementary stream.
                                    * See the \ref MmalEncodings "pre-defined encodings" for some
                                    * examples.
                                    */
   MMAL_FOURCC_T encoding_variant;/**< FourCC specifying the specific encoding variant of
                                    * the elementary stream. See the \ref MmalEncodingVariants
                                    * "pre-defined encoding variants" for some examples.
                                    */

   MMAL_ES_SPECIFIC_FORMAT_T *es; /**< Type specific information for the elementary stream */

   uint32_t bitrate;              /**< Bitrate in bits per second */
   uint32_t flags;                /**< Flags describing properties of the elementary stream.
                                    * See \ref elementarystreamflags "Elementary stream flags".
                                    */

   uint32_t extradata_size;       /**< Size of the codec specific data */
   uint8_t  *extradata;           /**< Codec specific data */

} MMAL_ES_FORMAT_T;

/** Allocate and initialise a \ref MMAL_ES_FORMAT_T structure.
 *
 * @return a \ref MMAL_ES_FORMAT_T structure
 */
MMAL_ES_FORMAT_T *mmal_format_alloc(void);

/** Free a \ref MMAL_ES_FORMAT_T structure allocated by \ref mmal_format_alloc.
 *
 * @param format the \ref MMAL_ES_FORMAT_T structure to free
 */
void mmal_format_free(MMAL_ES_FORMAT_T *format);

/** Allocate the extradata buffer in \ref MMAL_ES_FORMAT_T.
 * This buffer will be freed automatically when the format is destroyed or
 * another allocation is done.
 *
 * @param format format structure for which the extradata buffer will be allocated
 * @param size size of the extradata buffer to allocate
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_format_extradata_alloc(MMAL_ES_FORMAT_T *format, unsigned int size);

/** Shallow copy a format structure.
 * It is worth noting that the extradata buffer will not be copied in the new format.
 *
 * @param format_dest destination \ref MMAL_ES_FORMAT_T for the copy
 * @param format_src source \ref MMAL_ES_FORMAT_T for the copy
 */
void mmal_format_copy(MMAL_ES_FORMAT_T *format_dest, MMAL_ES_FORMAT_T *format_src);

/** Fully copy a format structure, including the extradata buffer.
 *
 * @param format_dest destination \ref MMAL_ES_FORMAT_T for the copy
 * @param format_src source \ref MMAL_ES_FORMAT_T for the copy
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_format_full_copy(MMAL_ES_FORMAT_T *format_dest, MMAL_ES_FORMAT_T *format_src);

/** \name Comparison flags
 * \anchor comparisonflags
 * The following flags describe the differences between 2 format structures */
/* @{ */
#define MMAL_ES_FORMAT_COMPARE_FLAG_TYPE              0x01 /**< The type is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_ENCODING          0x02 /**< The encoding is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_BITRATE           0x04 /**< The bitrate is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_FLAGS             0x08 /**< The flags are different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_EXTRADATA         0x10 /**< The extradata is different */

#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION   0x0100 /**< The video resolution is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING     0x0200 /**< The video cropping is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE   0x0400 /**< The video frame rate is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO 0x0800 /**< The video aspect ratio is different */
#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE  0x1000 /**< The video color space is different */

#define MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER  0x10000000 /**< Other ES specific parameters are different */
/* @} */

/** Compare 2 format structures and returns a set of flags describing the differences.
 * The result will be zero if the structures are the same, or a combination of
 * one or more of the \ref comparisonflags "Comparison flags" if different.
 *
 * @param format_1 first \ref MMAL_ES_FORMAT_T to compare
 * @param format_2 second \ref MMAL_ES_FORMAT_T to compare
 * @return set of flags describing the differences
 */
uint32_t mmal_format_compare(MMAL_ES_FORMAT_T *format_1, MMAL_ES_FORMAT_T *format_2);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_FORMAT_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_logging.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_LOGGING_H
#define MMAL_LOGGING_H

#include "mmal_common.h"
#include "interface/vcos/vcos_logging.h"

#ifndef VCOS_LOG_CATEGORY
#define VCOS_LOG_CATEGORY (&mmal_log_category)
extern VCOS_LOG_CAT_T mmal_log_category;
#endif

#if defined(__GNUC__) && (( __GNUC__ > 2 ) || (( __GNUC__ == 2 ) && ( __GNUC_MINOR__ >= 3 )))
#define mmal_log_error(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#define mmal_log_info(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#define mmal_log_warn(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#define mmal_log_debug(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#define mmal_log_trace(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
#elif defined(_MSC_VER)
#define mmal_log_error(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_info(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_warn(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_debug(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_trace(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#else
#define mmal_log_error_fun(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_info_fun(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_warn_fun(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_debug_fun(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
#define mmal_log_trace_fun(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, __VA_ARGS__)

#define mmal_log_error(s...) mmal_log_error_fun(s, 0)
#define mmal_log_info(s...) mmal_log_info_fun(s, 0)
#define mmal_log_warn(s...)  mmal_log_warn_fun(s, 0)
#define mmal_log_debug(s...)  mmal_log_debug_fun(s, 0)
#define mmal_log_trace(s...) mmal_log_trace_fun(s, 0)
#endif

#define LOG_ERROR mmal_log_error
#define LOG_INFO mmal_log_info
#define LOG_WARN mmal_log_warn
#define LOG_DEBUG mmal_log_debug
#define LOG_TRACE mmal_log_trace

#endif /* MMAL_LOGGING_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_metadata.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_METADATA_H
#define MMAL_METADATA_H

#include "mmal_common.h"

/** \defgroup MmalMetadata List of pre-defined metadata types
 * This defines a list of standard metadata types. Components can still define proprietary
 * metadata types by using their own FourCC and defining their own metadata structures. */
/* @{ */

/** \name Pre-defined metadata FourCCs */
/* @{ */
#define MMAL_METADATA_HELLO_WORLD             MMAL_FOURCC('H','E','L','O')
/* @} */

/** Generic metadata type. All metadata structures need to begin with these fields. */
typedef struct MMAL_METATDATA_T
{
   uint32_t id;    /**< Metadata id. This is a FourCC */
   uint32_t size;  /**< Size in bytes of the following metadata (not including id and size) */
} MMAL_METADATA_T;

/** Hello World metadata. */
typedef struct MMAL_METATDATA_HELLO_WORLD_T
{
   uint32_t id;    /**< Metadata id. This is a FourCC */
   uint32_t size;  /**< Size in bytes of the following metadata (not including id and size) */

   uint32_t myvalue; /**< Metadata value */
} MMAL_METADATA_HELLO_WORLD_T;

/** Get metadata item from buffer header.
 * This will search through all the metadata in the buffer header and return a pointer to the
 * first instance of the requested metadata id.
 *
 * @param header buffer header containing the metadata
 * @param id     requested metadata id
 *
 * @return Pointer to metadata requested or NULL if not found.
 */
MMAL_METADATA_T *mmal_metadata_get(MMAL_BUFFER_HEADER_T *header, uint32_t id);

/** Set metadata item in buffer header.
 * This will store the metadata item into the buffer header. This operation can fail if not
 * enough memory is available in the data section of the buffer header.
 *
 * @param header   buffer header to store the metadata into
 * @param metadata metadata item to store in buffer header
 *
 * @return MMAL_SUCCESS on success or MMAL_ENOMEM if not enough memory is available for storing
 * the metadata
 */
MMAL_STATUS_T mmal_metadata_set(MMAL_BUFFER_HEADER_T *header, MMAL_METADATA_T *metadata);

/* @} */

#endif /* MMAL_METADATA_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_audio.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_AUDIO_H
#define MMAL_PARAMETERS_AUDIO_H

#include "mmal_parameters_common.h"

/*************************************************
 * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
 ************************************************/

/** Audio-specific MMAL parameter IDs.
 * @ingroup MMAL_PARAMETER_IDS
 */
enum
{
   MMAL_PARAMETER_AUDIO_DESTINATION      /**< Takes a MMAL_PARAMETER_STRING_T */
         = MMAL_PARAMETER_GROUP_AUDIO,
   MMAL_PARAMETER_AUDIO_LATENCY_TARGET,  /**< Takes a MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T */
   MMAL_PARAMETER_AUDIO_SOURCE,
   MMAL_PARAMETER_AUDIO_PASSTHROUGH,     /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
};

/** Audio latency target to maintain.
 * These settings are used to adjust the clock speed in order
 * to match the measured audio latency to a specified value. */
typedef struct MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;   /**< whether this mode is enabled */
   uint32_t filter;      /**< number of latency samples to filter on, good value: 1 */
   uint32_t target;      /**< target latency (microseconds) */
   uint32_t shift;       /**< shift for storing latency values, good value: 7 */
   int32_t speed_factor; /**< multiplier for speed changes, in 24.8 format, good value: 256-512 */
   int32_t inter_factor; /**< divider for comparing latency versus gradiant, good value: 300 */
   int32_t adj_cap;      /**< limit for speed change before nSpeedFactor is applied, good value: 100 */
} MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T;

#endif /* MMAL_PARAMETERS_AUDIO_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_camera.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
Copyright (c) 2011 Broadcom Europe Limited.
All rights reserved.
=============================================================================*/
/** \file
 * Multi-Media Abstraction Layer - Definition of some standard parameters.
 */

#ifndef MMAL_PARAMETERS_CAMERA_H
#define MMAL_PARAMETERS_CAMERA_H

#include "mmal_parameters_common.h"

/*************************************************
 * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
 ************************************************/

/** Camera-specific MMAL parameter IDs.
 * @ingroup MMAL_PARAMETER_IDS
 */
enum {
   /* 0 */
   MMAL_PARAMETER_THUMBNAIL_CONFIGURATION    /**< Takes a @ref MMAL_PARAMETER_THUMBNAIL_CONFIG_T */
         = MMAL_PARAMETER_GROUP_CAMERA,
   MMAL_PARAMETER_CAPTURE_QUALITY,           /**< Unused? */
   MMAL_PARAMETER_ROTATION,                  /**< Takes a @ref MMAL_PARAMETER_INT32_T */
   MMAL_PARAMETER_EXIF_DISABLE,              /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_EXIF,                      /**< Takes a @ref MMAL_PARAMETER_EXIF_T */
   MMAL_PARAMETER_AWB_MODE,                  /**< Takes a @ref MMAL_PARAM_AWBMODE_T */
   MMAL_PARAMETER_IMAGE_EFFECT,              /**< Takes a @ref MMAL_PARAMETER_IMAGEFX_T */
   MMAL_PARAMETER_COLOUR_EFFECT,             /**< Takes a @ref MMAL_PARAMETER_COLOURFX_T */
   MMAL_PARAMETER_FLICKER_AVOID,             /**< Takes a @ref MMAL_PARAMETER_FLICKERAVOID_T */
   MMAL_PARAMETER_FLASH,                     /**< Takes a @ref MMAL_PARAMETER_FLASH_T */
   MMAL_PARAMETER_REDEYE,                    /**< Takes a @ref MMAL_PARAMETER_REDEYE_T */
   MMAL_PARAMETER_FOCUS,                     /**< Takes a @ref MMAL_PARAMETER_FOCUS_T */
   MMAL_PARAMETER_FOCAL_LENGTHS,             /**< Unused? */
   MMAL_PARAMETER_EXPOSURE_COMP,             /**< Takes a @ref MMAL_PARAMETER_INT32_T or MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_ZOOM,                      /**< Takes a @ref MMAL_PARAMETER_SCALEFACTOR_T */
   MMAL_PARAMETER_MIRROR,                    /**< Takes a @ref MMAL_PARAMETER_MIRROR_T */

   /* 0x10 */
   MMAL_PARAMETER_CAMERA_NUM,                /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_CAPTURE,                   /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_EXPOSURE_MODE,             /**< Takes a @ref MMAL_PARAMETER_EXPOSUREMODE_T */
   MMAL_PARAMETER_EXP_METERING_MODE,         /**< Takes a @ref MMAL_PARAMETER_EXPOSUREMETERINGMODE_T */
   MMAL_PARAMETER_FOCUS_STATUS,              /**< Takes a @ref MMAL_PARAMETER_FOCUS_STATUS_T */
   MMAL_PARAMETER_CAMERA_CONFIG,             /**< Takes a @ref MMAL_PARAMETER_CAMERA_CONFIG_T */
   MMAL_PARAMETER_CAPTURE_STATUS,            /**< Takes a @ref MMAL_PARAMETER_CAPTURE_STATUS_T */
   MMAL_PARAMETER_FACE_TRACK,                /**< Takes a @ref MMAL_PARAMETER_FACE_TRACK_T */
   MMAL_PARAMETER_DRAW_BOX_FACES_AND_FOCUS,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_JPEG_Q_FACTOR,             /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_FRAME_RATE,                /**< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T */
   MMAL_PARAMETER_USE_STC,                   /**< Takes a @ref MMAL_PARAMETER_CAMERA_STC_MODE_T */
   MMAL_PARAMETER_CAMERA_INFO,               /**< Takes a @ref MMAL_PARAMETER_CAMERA_INFO_T */
   MMAL_PARAMETER_VIDEO_STABILISATION,       /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_FACE_TRACK_RESULTS,        /**< Takes a @ref MMAL_PARAMETER_FACE_TRACK_RESULTS_T */
   MMAL_PARAMETER_ENABLE_RAW_CAPTURE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */

   /* 0x20 */
   MMAL_PARAMETER_DPF_FILE,                  /**< Takes a @ref MMAL_PARAMETER_URI_T */
   MMAL_PARAMETER_ENABLE_DPF_FILE,           /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_DPF_FAIL_IS_FATAL,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CAPTURE_MODE,              /**< Takes a @ref MMAL_PARAMETER_CAPTUREMODE_T */
   MMAL_PARAMETER_FOCUS_REGIONS,             /**< Takes a @ref MMAL_PARAMETER_FOCUS_REGIONS_T */
   MMAL_PARAMETER_INPUT_CROP,                /**< Takes a @ref MMAL_PARAMETER_INPUT_CROP_T */
   MMAL_PARAMETER_SENSOR_INFORMATION,        /**< Takes a @ref MMAL_PARAMETER_SENSOR_INFORMATION_T */
   MMAL_PARAMETER_FLASH_SELECT,              /**< Takes a @ref MMAL_PARAMETER_FLASH_SELECT_T */
   MMAL_PARAMETER_FIELD_OF_VIEW,             /**< Takes a @ref MMAL_PARAMETER_FIELD_OF_VIEW_T */
   MMAL_PARAMETER_HIGH_DYNAMIC_RANGE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_DYNAMIC_RANGE_COMPRESSION, /**< Takes a @ref MMAL_PARAMETER_DRC_T */
   MMAL_PARAMETER_ALGORITHM_CONTROL,         /**< Takes a @ref MMAL_PARAMETER_ALGORITHM_CONTROL_T */
   MMAL_PARAMETER_SHARPNESS,                 /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_CONTRAST,                  /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_BRIGHTNESS,                /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_SATURATION,                /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */

   /* 0x30 */
   MMAL_PARAMETER_ISO,                       /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_ANTISHAKE,                 /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS,   /**< Takes a @ref MMAL_PARAMETER_IMAGEFX_PARAMETERS_T */
   MMAL_PARAMETER_CAMERA_BURST_CAPTURE,      /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CAMERA_MIN_ISO,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_CAMERA_USE_CASE,           /**< Takes a @ref MMAL_PARAMETER_CAMERA_USE_CASE_T */
   MMAL_PARAMETER_CAPTURE_STATS_PASS,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CAMERA_CUSTOM_SENSOR_CONFIG, /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_ENABLE_REGISTER_FILE,      /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_REGISTER_FAIL_IS_FATAL,    /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CONFIGFILE_REGISTERS,      /**< Takes a @ref MMAL_PARAMETER_CONFIGFILE_T */
   MMAL_PARAMETER_CONFIGFILE_CHUNK_REGISTERS,/**< Takes a @ref MMAL_PARAMETER_CONFIGFILE_CHUNK_T */
   MMAL_PARAMETER_JPEG_ATTACH_LOG,           /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_ZERO_SHUTTER_LAG,          /**< Takes a @ref MMAL_PARAMETER_ZEROSHUTTERLAG_T */
   MMAL_PARAMETER_FPS_RANGE,                 /**< Takes a @ref MMAL_PARAMETER_FPS_RANGE_T */
   MMAL_PARAMETER_CAPTURE_EXPOSURE_COMP,     /**< Takes a @ref MMAL_PARAMETER_INT32_T */

   /* 0x40 */
   MMAL_PARAMETER_SW_SHARPEN_DISABLE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_FLASH_REQUIRED,            /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_SW_SATURATION_DISABLE,     /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_SHUTTER_SPEED,             /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_CUSTOM_AWB_GAINS,          /**< Takes a @ref MMAL_PARAMETER_AWB_GAINS_T */
   MMAL_PARAMETER_CAMERA_SETTINGS,           /**< Takes a @ref MMAL_PARAMETER_CAMERA_SETTINGS_T */
   MMAL_PARAMETER_PRIVACY_INDICATOR,         /**< Takes a @ref MMAL_PARAMETER_PRIVACY_INDICATOR_T */
   MMAL_PARAMETER_VIDEO_DENOISE,             /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_STILLS_DENOISE,            /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_ANNOTATE,                  /**< Takes a @ref MMAL_PARAMETER_CAMERA_ANNOTATE_T */
   MMAL_PARAMETER_STEREOSCOPIC_MODE,         /**< Takes a @ref MMAL_PARAMETER_STEREOSCOPIC_MODE_T */
   MMAL_PARAMETER_CAMERA_INTERFACE,          /**< Takes a @ref MMAL_PARAMETER_CAMERA_INTERFACE_T */
   MMAL_PARAMETER_CAMERA_CLOCKING_MODE,      /**< Takes a @ref MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T */
   MMAL_PARAMETER_CAMERA_RX_CONFIG,          /**< Takes a @ref MMAL_PARAMETER_CAMERA_RX_CONFIG_T */
   MMAL_PARAMETER_CAMERA_RX_TIMING,          /**< Takes a @ref MMAL_PARAMETER_CAMERA_RX_TIMING_T */
   MMAL_PARAMETER_DPF_CONFIG,                /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
};

/** Thumbnail configuration parameter type */
typedef struct MMAL_PARAMETER_THUMBNAIL_CONFIG_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t enable;                  /**< Enable generation of thumbnails during still capture */
   uint32_t width;                   /**< Desired width of the thumbnail */
   uint32_t height;                  /**< Desired height of the thumbnail */
   uint32_t quality;                 /**< Desired compression quality of the thumbnail */
} MMAL_PARAMETER_THUMBNAIL_CONFIG_T;

/** EXIF parameter type. */
typedef struct MMAL_PARAMETER_EXIF_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t keylen;                            /**< If 0, assume key is terminated by '=', otherwise length of key and treat data as binary */
   uint32_t value_offset;                      /**< Offset within data buffer of the start of the value. If 0, look for a "key=value" string */
   uint32_t valuelen;                          /**< If 0, assume value is null-terminated, otherwise length of value and treat data as binary */
   uint8_t data[1];                            /**< EXIF key/value string. Variable length */
} MMAL_PARAMETER_EXIF_T;

/** Exposure modes. */
typedef enum
{
   MMAL_PARAM_EXPOSUREMODE_OFF,
   MMAL_PARAM_EXPOSUREMODE_AUTO,
   MMAL_PARAM_EXPOSUREMODE_NIGHT,
   MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW,
   MMAL_PARAM_EXPOSUREMODE_BACKLIGHT,
   MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT,
   MMAL_PARAM_EXPOSUREMODE_SPORTS,
   MMAL_PARAM_EXPOSUREMODE_SNOW,
   MMAL_PARAM_EXPOSUREMODE_BEACH,
   MMAL_PARAM_EXPOSUREMODE_VERYLONG,
   MMAL_PARAM_EXPOSUREMODE_FIXEDFPS,
   MMAL_PARAM_EXPOSUREMODE_ANTISHAKE,
   MMAL_PARAM_EXPOSUREMODE_FIREWORKS,
   MMAL_PARAM_EXPOSUREMODE_MAX = 0x7fffffff
} MMAL_PARAM_EXPOSUREMODE_T;

typedef struct MMAL_PARAMETER_EXPOSUREMODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_EXPOSUREMODE_T value;   /**< exposure mode */
} MMAL_PARAMETER_EXPOSUREMODE_T;

typedef enum
{
   MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE,
   MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT,
   MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT,
   MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX,
   MMAL_PARAM_EXPOSUREMETERINGMODE_MAX = 0x7fffffff
} MMAL_PARAM_EXPOSUREMETERINGMODE_T;

typedef struct MMAL_PARAMETER_EXPOSUREMETERINGMODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_EXPOSUREMETERINGMODE_T value;   /**< metering mode */
} MMAL_PARAMETER_EXPOSUREMETERINGMODE_T;

/** AWB parameter modes. */
typedef enum MMAL_PARAM_AWBMODE_T
{
   MMAL_PARAM_AWBMODE_OFF,
   MMAL_PARAM_AWBMODE_AUTO,
   MMAL_PARAM_AWBMODE_SUNLIGHT,
   MMAL_PARAM_AWBMODE_CLOUDY,
   MMAL_PARAM_AWBMODE_SHADE,
   MMAL_PARAM_AWBMODE_TUNGSTEN,
   MMAL_PARAM_AWBMODE_FLUORESCENT,
   MMAL_PARAM_AWBMODE_INCANDESCENT,
   MMAL_PARAM_AWBMODE_FLASH,
   MMAL_PARAM_AWBMODE_HORIZON,
   MMAL_PARAM_AWBMODE_MAX = 0x7fffffff
} MMAL_PARAM_AWBMODE_T;

/** AWB parameter type. */
typedef struct MMAL_PARAMETER_AWBMODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_AWBMODE_T value;   /**< AWB mode */
} MMAL_PARAMETER_AWBMODE_T;

/** Image effect */
typedef enum MMAL_PARAM_IMAGEFX_T
{
   MMAL_PARAM_IMAGEFX_NONE,
   MMAL_PARAM_IMAGEFX_NEGATIVE,
   MMAL_PARAM_IMAGEFX_SOLARIZE,
   MMAL_PARAM_IMAGEFX_POSTERIZE,
   MMAL_PARAM_IMAGEFX_WHITEBOARD,
   MMAL_PARAM_IMAGEFX_BLACKBOARD,
   MMAL_PARAM_IMAGEFX_SKETCH,
   MMAL_PARAM_IMAGEFX_DENOISE,
   MMAL_PARAM_IMAGEFX_EMBOSS,
   MMAL_PARAM_IMAGEFX_OILPAINT,
   MMAL_PARAM_IMAGEFX_HATCH,
   MMAL_PARAM_IMAGEFX_GPEN,
   MMAL_PARAM_IMAGEFX_PASTEL,
   MMAL_PARAM_IMAGEFX_WATERCOLOUR,
   MMAL_PARAM_IMAGEFX_FILM,
   MMAL_PARAM_IMAGEFX_BLUR,
   MMAL_PARAM_IMAGEFX_SATURATION,
   MMAL_PARAM_IMAGEFX_COLOURSWAP,
   MMAL_PARAM_IMAGEFX_WASHEDOUT,
   MMAL_PARAM_IMAGEFX_POSTERISE,
   MMAL_PARAM_IMAGEFX_COLOURPOINT,
   MMAL_PARAM_IMAGEFX_COLOURBALANCE,
   MMAL_PARAM_IMAGEFX_CARTOON,
   MMAL_PARAM_IMAGEFX_DEINTERLACE_DOUBLE,
   MMAL_PARAM_IMAGEFX_DEINTERLACE_ADV,
   MMAL_PARAM_IMAGEFX_DEINTERLACE_FAST,
   MMAL_PARAM_IMAGEFX_MAX = 0x7fffffff
} MMAL_PARAM_IMAGEFX_T;

typedef struct MMAL_PARAMETER_IMAGEFX_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_IMAGEFX_T value;   /**< Image effect mode */
} MMAL_PARAMETER_IMAGEFX_T;

#define MMAL_MAX_IMAGEFX_PARAMETERS 6  /* Image effects library currently uses a maximum of 5 parameters per effect */

typedef struct MMAL_PARAMETER_IMAGEFX_PARAMETERS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_IMAGEFX_T effect;   /**< Image effect mode */
   uint32_t num_effect_params;     /**< Number of used elements in */
   uint32_t effect_parameter[MMAL_MAX_IMAGEFX_PARAMETERS]; /**< Array of parameters */
} MMAL_PARAMETER_IMAGEFX_PARAMETERS_T;

/** Colour effect parameter type*/
typedef struct MMAL_PARAMETER_COLOURFX_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   int32_t enable;
   uint32_t u;
   uint32_t v;
} MMAL_PARAMETER_COLOURFX_T;

typedef enum MMAL_CAMERA_STC_MODE_T
{
   MMAL_PARAM_STC_MODE_OFF,         /**< Frames do not have STCs, as needed in OpenMAX/IL */
   MMAL_PARAM_STC_MODE_RAW,         /**< Use raw clock STC, needed for true pause/resume support */
   MMAL_PARAM_STC_MODE_COOKED,      /**< Start the STC from the start of capture, only for quick demo code */
   MMAL_PARAM_STC_MODE_MAX = 0x7fffffff
} MMAL_CAMERA_STC_MODE_T;

typedef struct MMAL_PARAMETER_CAMERA_STC_MODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_CAMERA_STC_MODE_T value;
} MMAL_PARAMETER_CAMERA_STC_MODE_T;

typedef enum MMAL_PARAM_FLICKERAVOID_T
{
   MMAL_PARAM_FLICKERAVOID_OFF,
   MMAL_PARAM_FLICKERAVOID_AUTO,
   MMAL_PARAM_FLICKERAVOID_50HZ,
   MMAL_PARAM_FLICKERAVOID_60HZ,
   MMAL_PARAM_FLICKERAVOID_MAX = 0x7FFFFFFF
} MMAL_PARAM_FLICKERAVOID_T;

typedef struct MMAL_PARAMETER_FLICKERAVOID_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_FLICKERAVOID_T value;   /**< Flicker avoidance mode */
} MMAL_PARAMETER_FLICKERAVOID_T;

typedef enum MMAL_PARAM_FLASH_T
{
   MMAL_PARAM_FLASH_OFF,
   MMAL_PARAM_FLASH_AUTO,
   MMAL_PARAM_FLASH_ON,
   MMAL_PARAM_FLASH_REDEYE,
   MMAL_PARAM_FLASH_FILLIN,
   MMAL_PARAM_FLASH_TORCH,
   MMAL_PARAM_FLASH_MAX = 0x7FFFFFFF
} MMAL_PARAM_FLASH_T;

typedef struct MMAL_PARAMETER_FLASH_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_FLASH_T value;   /**< Flash mode */
} MMAL_PARAMETER_FLASH_T;

typedef enum MMAL_PARAM_REDEYE_T
{
   MMAL_PARAM_REDEYE_OFF,
   MMAL_PARAM_REDEYE_ON,
   MMAL_PARAM_REDEYE_SIMPLE,
   MMAL_PARAM_REDEYE_MAX = 0x7FFFFFFF
} MMAL_PARAM_REDEYE_T;

typedef struct MMAL_PARAMETER_REDEYE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_REDEYE_T value;   /**< Red eye reduction mode */
} MMAL_PARAMETER_REDEYE_T;

typedef enum MMAL_PARAM_FOCUS_T
{
   MMAL_PARAM_FOCUS_AUTO,
   MMAL_PARAM_FOCUS_AUTO_NEAR,
   MMAL_PARAM_FOCUS_AUTO_MACRO,
   MMAL_PARAM_FOCUS_CAF,
   MMAL_PARAM_FOCUS_CAF_NEAR,
   MMAL_PARAM_FOCUS_FIXED_INFINITY,
   MMAL_PARAM_FOCUS_FIXED_HYPERFOCAL,
   MMAL_PARAM_FOCUS_FIXED_NEAR,
   MMAL_PARAM_FOCUS_FIXED_MACRO,
   MMAL_PARAM_FOCUS_EDOF,
   MMAL_PARAM_FOCUS_CAF_MACRO,
   MMAL_PARAM_FOCUS_CAF_FAST,
   MMAL_PARAM_FOCUS_CAF_NEAR_FAST,
   MMAL_PARAM_FOCUS_CAF_MACRO_FAST,
   MMAL_PARAM_FOCUS_FIXED_CURRENT,
   MMAL_PARAM_FOCUS_MAX = 0x7FFFFFFF
} MMAL_PARAM_FOCUS_T;

typedef struct MMAL_PARAMETER_FOCUS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_FOCUS_T value;   /**< Focus mode */
} MMAL_PARAMETER_FOCUS_T;

typedef enum MMAL_PARAM_CAPTURE_STATUS_T
{
   MMAL_PARAM_CAPTURE_STATUS_NOT_CAPTURING,
   MMAL_PARAM_CAPTURE_STATUS_CAPTURE_STARTED,
   MMAL_PARAM_CAPTURE_STATUS_CAPTURE_ENDED,

   MMAL_PARAM_CAPTURE_STATUS_MAX = 0x7FFFFFFF
} MMAL_PARAM_CAPTURE_STATUS_T;

typedef struct MMAL_PARAMETER_CAPTURE_STATUS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_CAPTURE_STATUS_T status;   /**< Capture status */
} MMAL_PARAMETER_CAPTURE_STATUS_T;

typedef enum MMAL_PARAM_FOCUS_STATUS_T
{
   MMAL_PARAM_FOCUS_STATUS_OFF,
   MMAL_PARAM_FOCUS_STATUS_REQUEST,
   MMAL_PARAM_FOCUS_STATUS_REACHED,
   MMAL_PARAM_FOCUS_STATUS_UNABLE_TO_REACH,
   MMAL_PARAM_FOCUS_STATUS_LOST,
   MMAL_PARAM_FOCUS_STATUS_CAF_MOVING,
   MMAL_PARAM_FOCUS_STATUS_CAF_SUCCESS,
   MMAL_PARAM_FOCUS_STATUS_CAF_FAILED,
   MMAL_PARAM_FOCUS_STATUS_MANUAL_MOVING,
   MMAL_PARAM_FOCUS_STATUS_MANUAL_REACHED,
   MMAL_PARAM_FOCUS_STATUS_CAF_WATCHING,
   MMAL_PARAM_FOCUS_STATUS_CAF_SCENE_CHANGED,

   MMAL_PARAM_FOCUS_STATUS_MAX = 0x7FFFFFFF
} MMAL_PARAM_FOCUS_STATUS_T;

typedef struct MMAL_PARAMETER_FOCUS_STATUS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_FOCUS_STATUS_T status;   /**< Focus status */
} MMAL_PARAMETER_FOCUS_STATUS_T;

typedef enum MMAL_PARAM_FACE_TRACK_MODE_T
{
   MMAL_PARAM_FACE_DETECT_NONE,                           /**< Disables face detection */
   MMAL_PARAM_FACE_DETECT_ON,                             /**< Enables face detection */
   MMAL_PARAM_FACE_DETECT_MAX = 0x7FFFFFFF
} MMAL_PARAM_FACE_TRACK_MODE_T;

typedef struct MMAL_PARAMETER_FACE_TRACK_T /* face tracking control */
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_PARAM_FACE_TRACK_MODE_T mode;
   uint32_t maxRegions;
   uint32_t frames;
   uint32_t quality;
} MMAL_PARAMETER_FACE_TRACK_T;

typedef struct MMAL_PARAMETER_FACE_TRACK_FACE_T /* face tracking face information */
{
   int32_t     face_id;             /**< Face ID. Should remain the same whilst the face is detected to remain in the scene */
   int32_t     score;               /**< Confidence of the face detection. Range 1-100 (1=unsure, 100=positive). */
   MMAL_RECT_T face_rect;           /**< Rectangle around the whole face */

   MMAL_RECT_T eye_rect[2];         /**< Rectangle around the eyes ([0] = left eye, [1] = right eye) */
   MMAL_RECT_T mouth_rect;          /**< Rectangle around the mouth */
} MMAL_PARAMETER_FACE_TRACK_FACE_T;

typedef struct MMAL_PARAMETER_FACE_TRACK_RESULTS_T /* face tracking results */
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t num_faces;        /**< Number of faces detected */
   uint32_t frame_width;      /**< Width of the frame on which the faces were detected (allows scaling) */
   uint32_t frame_height;     /**< Height of the frame on which the faces were detected (allows scaling) */

   MMAL_PARAMETER_FACE_TRACK_FACE_T faces[1];   /**< Face information (variable length array */
} MMAL_PARAMETER_FACE_TRACK_RESULTS_T;

typedef enum MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T
{
   MMAL_PARAM_TIMESTAMP_MODE_ZERO,           /**< Always timestamp frames as 0 */
   MMAL_PARAM_TIMESTAMP_MODE_RAW_STC,        /**< Use the raw STC value for the frame timestamp */
   MMAL_PARAM_TIMESTAMP_MODE_RESET_STC,      /**< Use the STC timestamp but subtract the timestamp
                                              * of the first frame sent to give a zero based timestamp.
                                              */
   MMAL_PARAM_TIMESTAMP_MODE_MAX = 0x7FFFFFFF
} MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T;

typedef struct MMAL_PARAMETER_CAMERA_CONFIG_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   /* Parameters for setting up the image pools */
   uint32_t max_stills_w;        /**< Max size of stills capture */
   uint32_t max_stills_h;
   uint32_t stills_yuv422;       /**< Allow YUV422 stills capture */
   uint32_t one_shot_stills;     /**< Continuous or one shot stills captures. */

   uint32_t max_preview_video_w; /**< Max size of the preview or video capture frames */
   uint32_t max_preview_video_h;
   uint32_t num_preview_video_frames;

   uint32_t stills_capture_circular_buffer_height; /**< Sets the height of the circular buffer for stills capture. */

   uint32_t fast_preview_resume;    /**< Allows preview/encode to resume as fast as possible after the stills input frame
                                     * has been received, and then processes the still frame in the background
                                     * whilst preview/encode has resumed.
                                     * Actual mode is controlled by MMAL_PARAMETER_CAPTURE_MODE.
                                     */

   MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T use_stc_timestamp;
                                    /**< Selects algorithm for timestamping frames if there is no clock component connected.
                                      */


} MMAL_PARAMETER_CAMERA_CONFIG_T;

#define MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS 4
#define MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES 2
#define MMAL_PARAMETER_CAMERA_INFO_MAX_STR_LEN 16

typedef struct MMAL_PARAMETER_CAMERA_INFO_CAMERA_T
{
   uint32_t    port_id;
   uint32_t    max_width;
   uint32_t    max_height;
   MMAL_BOOL_T lens_present;
   char        camera_name[MMAL_PARAMETER_CAMERA_INFO_MAX_STR_LEN];
} MMAL_PARAMETER_CAMERA_INFO_CAMERA_T;

typedef enum MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T
{
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_XENON = 0, /* Make values explicit */
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_LED   = 1, /* to ensure they match */
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_OTHER = 2, /* values in config ini */
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_MAX = 0x7FFFFFFF
} MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T;

typedef struct MMAL_PARAMETER_CAMERA_INFO_FLASH_T
{
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T flash_type;
} MMAL_PARAMETER_CAMERA_INFO_FLASH_T;

typedef struct MMAL_PARAMETER_CAMERA_INFO_T
{
   MMAL_PARAMETER_HEADER_T             hdr;
   uint32_t                            num_cameras;
   uint32_t                            num_flashes;
   MMAL_PARAMETER_CAMERA_INFO_CAMERA_T cameras[MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS];
   MMAL_PARAMETER_CAMERA_INFO_FLASH_T  flashes[MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES];
} MMAL_PARAMETER_CAMERA_INFO_T;

typedef enum MMAL_PARAMETER_CAPTUREMODE_MODE_T
{
   MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END,            /**< Resumes preview once capture is completed. */
   MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END_AND_HOLD,   /**< Resumes preview once capture is completed, and hold the image for subsequent reprocessing. */
   MMAL_PARAM_CAPTUREMODE_RESUME_VF_IMMEDIATELY,   /**< Resumes preview as soon as possible once capture frame is received from the sensor.
                                                    *   Requires fast_preview_resume to be set via MMAL_PARAMETER_CAMERA_CONFIG.
                                                    */
} MMAL_PARAMETER_CAPTUREMODE_MODE_T;

/** Stills capture mode control. */
typedef struct MMAL_PARAMETER_CAPTUREMODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_PARAMETER_CAPTUREMODE_MODE_T mode;
} MMAL_PARAMETER_CAPTUREMODE_T;

typedef enum MMAL_PARAMETER_FOCUS_REGION_TYPE_T
{
   MMAL_PARAMETER_FOCUS_REGION_TYPE_NORMAL,     /**< Region defines a generic region */
   MMAL_PARAMETER_FOCUS_REGION_TYPE_FACE,       /**< Region defines a face */
   MMAL_PARAMETER_FOCUS_REGION_TYPE_MAX
} MMAL_PARAMETER_FOCUS_REGION_TYPE_T;

typedef struct MMAL_PARAMETER_FOCUS_REGION_T
{
   MMAL_RECT_T rect;    /**< Focus rectangle as 0P16 fixed point values. */
   uint32_t weight;     /**< Region weighting. */
   uint32_t mask;       /**< Mask for multi-stage regions */
   MMAL_PARAMETER_FOCUS_REGION_TYPE_T type;  /**< Region type */
} MMAL_PARAMETER_FOCUS_REGION_T;

typedef struct MMAL_PARAMETER_FOCUS_REGIONS_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   uint32_t                         num_regions;      /**< Number of regions defined */
   MMAL_BOOL_T                      lock_to_faces;    /**< If region is within tolerance of a face, adopt face rect instead of defined region */
   MMAL_PARAMETER_FOCUS_REGION_T    regions[1];       /**< Variable number of regions */
} MMAL_PARAMETER_FOCUS_REGIONS_T;

typedef struct MMAL_PARAMETER_INPUT_CROP_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_RECT_T             rect;    /**< Crop rectangle as 16P16 fixed point values */
} MMAL_PARAMETER_INPUT_CROP_T;

typedef struct MMAL_PARAMETER_SENSOR_INFORMATION_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_RATIONAL_T                  f_number;         /**< Lens f-number */
   MMAL_RATIONAL_T                  focal_length;     /**< Lens focal length */
   uint32_t                         model_id;         /**< Sensor reported model id */
   uint32_t                         manufacturer_id;  /**< Sensor reported manufacturer id */
   uint32_t                         revision;         /**< Sensor reported revision */
} MMAL_PARAMETER_SENSOR_INFORMATION_T;

typedef struct MMAL_PARAMETER_FLASH_SELECT_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T flash_type;   /**< Flash type to use */
} MMAL_PARAMETER_FLASH_SELECT_T;

typedef struct MMAL_PARAMETER_FIELD_OF_VIEW_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_RATIONAL_T                  fov_h;         /**< Horizontal field of view */
   MMAL_RATIONAL_T                  fov_v;         /**< Vertical field of view */
} MMAL_PARAMETER_FIELD_OF_VIEW_T;

typedef enum MMAL_PARAMETER_DRC_STRENGTH_T
{
   MMAL_PARAMETER_DRC_STRENGTH_OFF,
   MMAL_PARAMETER_DRC_STRENGTH_LOW,
   MMAL_PARAMETER_DRC_STRENGTH_MEDIUM,
   MMAL_PARAMETER_DRC_STRENGTH_HIGH,
   MMAL_PARAMETER_DRC_STRENGTH_MAX = 0x7fffffff
} MMAL_PARAMETER_DRC_STRENGTH_T;

typedef struct MMAL_PARAMETER_DRC_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_PARAMETER_DRC_STRENGTH_T    strength;      /**< DRC strength */
} MMAL_PARAMETER_DRC_T;

typedef enum MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T
{
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACETRACKING,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_REDEYE_REDUCTION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_STABILISATION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_WRITE_RAW,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_DENOISE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_STILLS_DENOISE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_TEMPORAL_DENOISE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_ANTISHAKE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_IMAGE_EFFECTS,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_DYNAMIC_RANGE_COMPRESSION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_RECOGNITION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_BEAUTIFICATION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_SCENE_DETECTION,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_HIGH_DYNAMIC_RANGE,
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_MAX = 0x7fffffff
} MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T;

typedef struct MMAL_PARAMETER_ALGORITHM_CONTROL_T
{
   MMAL_PARAMETER_HEADER_T          hdr;
   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T algorithm;
   MMAL_BOOL_T                      enabled;
} MMAL_PARAMETER_ALGORITHM_CONTROL_T;


typedef enum MMAL_PARAM_CAMERA_USE_CASE_T
{
   MMAL_PARAM_CAMERA_USE_CASE_UNKNOWN,             /**< Compromise on behaviour as use case totally unknown */
   MMAL_PARAM_CAMERA_USE_CASE_STILLS_CAPTURE,      /**< Stills capture use case */
   MMAL_PARAM_CAMERA_USE_CASE_VIDEO_CAPTURE,       /**< Video encode (camcorder) use case */

   MMAL_PARAM_CAMERA_USE_CASE_MAX = 0x7fffffff
} MMAL_PARAM_CAMERA_USE_CASE_T;

typedef struct MMAL_PARAMETER_CAMERA_USE_CASE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_CAMERA_USE_CASE_T use_case;   /**< Use case */
} MMAL_PARAMETER_CAMERA_USE_CASE_T;

typedef struct MMAL_PARAMETER_FPS_RANGE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RATIONAL_T   fps_low;                /**< Low end of the permitted framerate range */
   MMAL_RATIONAL_T   fps_high;               /**< High end of the permitted framerate range */
} MMAL_PARAMETER_FPS_RANGE_T;

typedef struct MMAL_PARAMETER_ZEROSHUTTERLAG_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T zero_shutter_lag_mode;        /**< Select zero shutter lag mode from sensor */
   MMAL_BOOL_T concurrent_capture;           /**< Activate full zero shutter lag mode and
                                              *  use the last preview raw image for the stills capture
                                              */
} MMAL_PARAMETER_ZEROSHUTTERLAG_T;

typedef struct MMAL_PARAMETER_AWB_GAINS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RATIONAL_T r_gain;                   /**< Red gain */
   MMAL_RATIONAL_T b_gain;                   /**< Blue gain */
} MMAL_PARAMETER_AWB_GAINS_T;

typedef struct MMAL_PARAMETER_CAMERA_SETTINGS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t exposure;
   MMAL_RATIONAL_T analog_gain;
   MMAL_RATIONAL_T digital_gain;
   MMAL_RATIONAL_T awb_red_gain;
   MMAL_RATIONAL_T awb_blue_gain;
   uint32_t focus_position;
} MMAL_PARAMETER_CAMERA_SETTINGS_T;

typedef enum MMAL_PARAM_PRIVACY_INDICATOR_T
{
   MMAL_PARAMETER_PRIVACY_INDICATOR_OFF,        /**< Indicator will be off. */
   MMAL_PARAMETER_PRIVACY_INDICATOR_ON,         /**< Indicator will come on just after a stills capture and
                                                 *   and remain on for 2seconds, or will be on whilst output[1]
                                                 *   is actively producing images.
                                                 */
   MMAL_PARAMETER_PRIVACY_INDICATOR_FORCE_ON,   /**< Turns indicator of for 2s independent of capture status.
                                                 *   Set this mode repeatedly to keep the indicator on for a
                                                 *   longer period.
                                                 */
   MMAL_PARAMETER_PRIVACY_INDICATOR_MAX = 0x7fffffff
} MMAL_PARAM_PRIVACY_INDICATOR_T;

typedef struct MMAL_PARAMETER_PRIVACY_INDICATOR_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_PRIVACY_INDICATOR_T mode;
} MMAL_PARAMETER_PRIVACY_INDICATOR_T;

#define MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN 32
typedef struct MMAL_PARAMETER_CAMERA_ANNOTATE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;
   char text[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN];
   MMAL_BOOL_T show_shutter;
   MMAL_BOOL_T show_analog_gain;
   MMAL_BOOL_T show_lens;
   MMAL_BOOL_T show_caf;
   MMAL_BOOL_T show_motion;
} MMAL_PARAMETER_CAMERA_ANNOTATE_T;

#define MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V2 256
typedef struct MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;
   MMAL_BOOL_T show_shutter;
   MMAL_BOOL_T show_analog_gain;
   MMAL_BOOL_T show_lens;
   MMAL_BOOL_T show_caf;
   MMAL_BOOL_T show_motion;
   MMAL_BOOL_T show_frame_num;
   MMAL_BOOL_T black_text_background;
   char text[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V2];
} MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T;

#define MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3 256
typedef struct MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable;
   MMAL_BOOL_T show_shutter;
   MMAL_BOOL_T show_analog_gain;
   MMAL_BOOL_T show_lens;
   MMAL_BOOL_T show_caf;
   MMAL_BOOL_T show_motion;
   MMAL_BOOL_T show_frame_num;
   MMAL_BOOL_T enable_text_background;
   MMAL_BOOL_T custom_background_colour;
   uint8_t     custom_background_Y;
   uint8_t     custom_background_U;
   uint8_t     custom_background_V;
   uint8_t     dummy1;
   MMAL_BOOL_T custom_text_colour;
   uint8_t     custom_text_Y;
   uint8_t     custom_text_U;
   uint8_t     custom_text_V;
   uint8_t     text_size;
   char text[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3];
} MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T;

typedef enum MMAL_STEREOSCOPIC_MODE_T {
   MMAL_STEREOSCOPIC_MODE_NONE = 0,
   MMAL_STEREOSCOPIC_MODE_SIDE_BY_SIDE = 1,
   MMAL_STEREOSCOPIC_MODE_TOP_BOTTOM = 2,
   MMAL_STEREOSCOPIC_MODE_MAX = 0x7FFFFFFF,
} MMAL_STEREOSCOPIC_MODE_T;

typedef struct MMAL_PARAMETER_STEREOSCOPIC_MODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_STEREOSCOPIC_MODE_T mode;
   MMAL_BOOL_T decimate;
   MMAL_BOOL_T swap_eyes;
} MMAL_PARAMETER_STEREOSCOPIC_MODE_T;

typedef enum MMAL_CAMERA_INTERFACE_T {
   MMAL_CAMERA_INTERFACE_CSI2 = 0,
   MMAL_CAMERA_INTERFACE_CCP2 = 1,
   MMAL_CAMERA_INTERFACE_CPI = 2,
   MMAL_CAMERA_INTERFACE_MAX = 0x7FFFFFFF,
} MMAL_CAMERA_INTERFACE_T;

typedef struct MMAL_PARAMETER_CAMERA_INTERFACE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CAMERA_INTERFACE_T mode;
} MMAL_PARAMETER_CAMERA_INTERFACE_T;

typedef enum MMAL_CAMERA_CLOCKING_MODE_T {
   MMAL_CAMERA_CLOCKING_MODE_STROBE = 0,
   MMAL_CAMERA_CLOCKING_MODE_CLOCK = 1,
   MMAL_CAMERA_CLOCKING_MODE_MAX = 0x7FFFFFFF,
} MMAL_CAMERA_CLOCKING_MODE_T;

typedef struct MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CAMERA_CLOCKING_MODE_T mode;
} MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T;

typedef enum MMAL_CAMERA_RX_CONFIG_DECODE {
   MMAL_CAMERA_RX_CONFIG_DECODE_NONE = 0,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO10 = 1,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO10 = 2,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO10 = 3,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO12 = 4,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO12 = 5,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO12 = 6,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO14 = 7,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO14 = 8,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM12TO16 = 9,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO16 = 10,
   MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO16 = 11,
   MMAL_CAMERA_RX_CONFIG_DECODE_MAX = 0x7FFFFFFF
} MMAL_CAMERA_RX_CONFIG_DECODE;

typedef enum MMAL_CAMERA_RX_CONFIG_ENCODE {
   MMAL_CAMERA_RX_CONFIG_ENCODE_NONE = 0,
   MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM10TO8 = 1,
   MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM12TO8 = 2,
   MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM14TO8 = 3,
   MMAL_CAMERA_RX_CONFIG_ENCODE_MAX = 0x7FFFFFFF
} MMAL_CAMERA_RX_CONFIG_ENCODE;

typedef enum MMAL_CAMERA_RX_CONFIG_UNPACK {
   MMAL_CAMERA_RX_CONFIG_UNPACK_NONE = 0,
   MMAL_CAMERA_RX_CONFIG_UNPACK_6 = 1,
   MMAL_CAMERA_RX_CONFIG_UNPACK_7 = 2,
   MMAL_CAMERA_RX_CONFIG_UNPACK_8 = 3,
   MMAL_CAMERA_RX_CONFIG_UNPACK_10 = 4,
   MMAL_CAMERA_RX_CONFIG_UNPACK_12 = 5,
   MMAL_CAMERA_RX_CONFIG_UNPACK_14 = 6,
   MMAL_CAMERA_RX_CONFIG_UNPACK_16 = 7,
   MMAL_CAMERA_RX_CONFIG_UNPACK_MAX = 0x7FFFFFFF
} MMAL_CAMERA_RX_CONFIG_UNPACK;

typedef enum MMAL_CAMERA_RX_CONFIG_PACK {
   MMAL_CAMERA_RX_CONFIG_PACK_NONE = 0,
   MMAL_CAMERA_RX_CONFIG_PACK_8 = 1,
   MMAL_CAMERA_RX_CONFIG_PACK_10 = 2,
   MMAL_CAMERA_RX_CONFIG_PACK_12 = 3,
   MMAL_CAMERA_RX_CONFIG_PACK_14 = 4,
   MMAL_CAMERA_RX_CONFIG_PACK_16 = 5,
   MMAL_CAMERA_RX_CONFIG_PACK_RAW10 = 6,
   MMAL_CAMERA_RX_CONFIG_PACK_RAW12 = 7,
   MMAL_CAMERA_RX_CONFIG_PACK_MAX = 0x7FFFFFFF
} MMAL_CAMERA_RX_CONFIG_PACK;

typedef struct MMAL_PARAMETER_CAMERA_RX_CONFIG_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CAMERA_RX_CONFIG_DECODE decode;
   MMAL_CAMERA_RX_CONFIG_ENCODE encode;
   MMAL_CAMERA_RX_CONFIG_UNPACK unpack;
   MMAL_CAMERA_RX_CONFIG_PACK pack;
   uint32_t data_lanes;
   uint32_t encode_block_length;
   uint32_t embedded_data_lines;
   uint32_t image_id;
} MMAL_PARAMETER_CAMERA_RX_CONFIG_T;

typedef struct MMAL_PARAMETER_CAMERA_RX_TIMING_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t timing1;
   uint32_t timing2;
   uint32_t timing3;
   uint32_t timing4;
   uint32_t timing5;
   uint32_t term1;
   uint32_t term2;
   uint32_t cpi_timing1;
   uint32_t cpi_timing2;
} MMAL_PARAMETER_CAMERA_RX_TIMING_T;

#endif  /* MMAL_PARAMETERS_CAMERA_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_clock.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_CLOCK_H
#define MMAL_PARAMETERS_CLOCK_H

#include "mmal_clock.h"
#include "mmal_parameters_common.h"

/*************************************************
 * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
 ************************************************/

/** Clock-specific MMAL parameter IDs.
 * @ingroup MMAL_PARAMETER_IDS
 */
enum
{
   MMAL_PARAMETER_CLOCK_REFERENCE           /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
      = MMAL_PARAMETER_GROUP_CLOCK,
   MMAL_PARAMETER_CLOCK_ACTIVE,             /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CLOCK_SCALE,              /**< Takes a MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_CLOCK_TIME,               /**< Takes a MMAL_PARAMETER_INT64_T */
   MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD,   /**< Takes a MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T */
   MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD,  /**< Takes a MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T */
   MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD,  /**< Takes a MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T */
   MMAL_PARAMETER_CLOCK_ENABLE_BUFFER_INFO, /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_CLOCK_FRAME_RATE,         /**< Takes a MMAL_PARAMETER_RATIONAL_T */
   MMAL_PARAMETER_CLOCK_LATENCY,            /**< Takes a MMAL_PARAMETER_CLOCK_LATENCY_T */
};

/** Media-time update thresholds */
typedef struct MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CLOCK_UPDATE_THRESHOLD_T value;
} MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T;

/** Media-time discontinuity settings */
typedef struct MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CLOCK_DISCONT_THRESHOLD_T value;
} MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T;

/** Media-time future frame drop settings */
typedef struct MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CLOCK_REQUEST_THRESHOLD_T value;
} MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T;

/** Clock latency parameter */
typedef struct MMAL_PARAMETER_CLOCK_LATENCY_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_CLOCK_LATENCY_T value;
} MMAL_PARAMETER_CLOCK_LATENCY_T;

#endif /* MMAL_PARAMETERS_CLOCK_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_common.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_COMMON_H
#define MMAL_PARAMETERS_COMMON_H

/** @defgroup MMAL_PARAMETER_IDS Pre-defined MMAL parameter IDs
 * @ingroup MmalParameters
 * @{
 */

/** @name Parameter groups
 * Parameters are divided into groups, and then allocated sequentially within
 * a group using an enum.
 * @{
 */

/** Common parameter ID group, used with many types of component. */
#define MMAL_PARAMETER_GROUP_COMMON            (0<<16)
/** Camera-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_CAMERA            (1<<16)
/** Video-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_VIDEO             (2<<16)
/** Audio-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_AUDIO             (3<<16)
/** Clock-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_CLOCK             (4<<16)
/** Miracast-specific parameter ID group. */
#define MMAL_PARAMETER_GROUP_MIRACAST       (5<<16)


/**@}*/

/** Common MMAL parameter IDs.
 */
enum {
   MMAL_PARAMETER_UNUSED                  /**< Never a valid parameter ID */
         = MMAL_PARAMETER_GROUP_COMMON,
   MMAL_PARAMETER_SUPPORTED_ENCODINGS,    /**< Takes a MMAL_PARAMETER_ENCODING_T */
   MMAL_PARAMETER_URI,                    /**< Takes a MMAL_PARAMETER_URI_T */
   MMAL_PARAMETER_CHANGE_EVENT_REQUEST,   /**< Takes a MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T */
   MMAL_PARAMETER_ZERO_COPY,              /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_BUFFER_REQUIREMENTS,    /**< Takes a MMAL_PARAMETER_BUFFER_REQUIREMENTS_T */
   MMAL_PARAMETER_STATISTICS,             /**< Takes a MMAL_PARAMETER_STATISTICS_T */
   MMAL_PARAMETER_CORE_STATISTICS,        /**< Takes a MMAL_PARAMETER_CORE_STATISTICS_T */
   MMAL_PARAMETER_MEM_USAGE,              /**< Takes a MMAL_PARAMETER_MEM_USAGE_T */
   MMAL_PARAMETER_BUFFER_FLAG_FILTER,     /**< Takes a MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_SEEK,                   /**< Takes a MMAL_PARAMETER_SEEK_T */
   MMAL_PARAMETER_POWERMON_ENABLE,        /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_LOGGING,                /**< Takes a MMAL_PARAMETER_LOGGING_T */
   MMAL_PARAMETER_SYSTEM_TIME,            /**< Takes a MMAL_PARAMETER_UINT64_T */
   MMAL_PARAMETER_NO_IMAGE_PADDING,       /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_LOCKSTEP_ENABLE         /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
};

/**@}*/

/** Parameter header type. All parameter structures need to begin with this type.
 * The \ref id field must be set to a parameter ID, such as one of those listed on
 * the \ref MMAL_PARAMETER_IDS "Pre-defined MMAL parameter IDs" page.
 */
typedef struct MMAL_PARAMETER_HEADER_T
{
   uint32_t id;      /**< Parameter ID. */
   uint32_t size;    /**< Size in bytes of the parameter (including the header) */
} MMAL_PARAMETER_HEADER_T;

/** Change event request parameter type.
 * This is used to control whether a \ref MMAL_EVENT_PARAMETER_CHANGED_T event
 * is issued should a given parameter change.
 */
typedef struct MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t change_id;  /**< ID of parameter that may change, see \ref MMAL_PARAMETER_IDS */
   MMAL_BOOL_T enable;  /**< True if the event is enabled, false if disabled */
} MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T;

/** Buffer requirements parameter.
 * This is mainly used to increase the requirements of a component. */
typedef struct MMAL_PARAMETER_BUFFER_REQUIREMENTS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires */
   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires */
   uint32_t buffer_alignment_min;    /**< Minimum alignment requirement for the buffers.
                                          A value of zero means no special alignment requirements. */
   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal performance.
                                          A value of zero means no special recommendation. */
   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance.
                                          A value of zero means no special recommendation. */
} MMAL_PARAMETER_BUFFER_REQUIREMENTS_T;

/** Seek request parameter type.
 * This is used to issue a seek request to a source component.
 */
typedef struct MMAL_PARAMETER_SEEK_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   int64_t offset;  /**< Offset (in microseconds) to seek to */
   uint32_t flags;  /**< Seeking flags */

#define MMAL_PARAM_SEEK_FLAG_PRECISE 0x1 /**< Choose precise seeking even if slower */
#define MMAL_PARAM_SEEK_FLAG_FORWARD 0x2 /**< Seek to the next keyframe following the specified offset */

} MMAL_PARAMETER_SEEK_T;

/** Port statistics for debugging/test purposes.
 * Ports may support query of this parameter to return statistics for debugging or
 * test purposes. Not all values may be relevant for a given port.
 */
typedef struct MMAL_PARAMETER_STATISTICS_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t buffer_count;           /**< Total number of buffers processed */
   uint32_t frame_count;            /**< Total number of frames processed */
   uint32_t frames_skipped;         /**< Number of frames without expected PTS based on frame rate */
   uint32_t frames_discarded;       /**< Number of frames discarded */
   uint32_t eos_seen;               /**< Set if the end of stream has been reached */
   uint32_t maximum_frame_bytes;    /**< Maximum frame size in bytes */
   int64_t  total_bytes;            /**< Total number of bytes processed */
   uint32_t corrupt_macroblocks;    /**< Number of corrupt macroblocks in the stream */
} MMAL_PARAMETER_STATISTICS_T;

typedef enum
{
   MMAL_CORE_STATS_RX,
   MMAL_CORE_STATS_TX,
   MMAL_CORE_STATS_MAX = 0x7fffffff /* Force 32 bit size for this enum */
} MMAL_CORE_STATS_DIR;

/** MMAL core statistics. These are collected by the core itself.
 */
typedef struct MMAL_PARAMETER_CORE_STATISTICS_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   MMAL_CORE_STATS_DIR dir;
   MMAL_BOOL_T reset;               /**< Reset to zero after reading */
   MMAL_CORE_STATISTICS_T stats;    /**< The statistics */
} MMAL_PARAMETER_CORE_STATISTICS_T;

/**
 * Component memory usage statistics.
 */
typedef struct MMAL_PARAMETER_MEM_USAGE_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   /**< The amount of memory allocated in image pools by the component */
   uint32_t pool_mem_alloc_size;
} MMAL_PARAMETER_MEM_USAGE_T;

/**
 * Logging control.
 */
typedef struct MMAL_PARAMETER_LOGGING_T
{
   MMAL_PARAMETER_HEADER_T hdr;
   uint32_t set;     /**< Logging bits to set */
   uint32_t clear;   /**< Logging bits to clear */
} MMAL_PARAMETER_LOGGING_T;

#endif /* MMAL_PARAMETERS_COMMON_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_video.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_VIDEO_H
#define MMAL_PARAMETERS_VIDEO_H

#include "mmal_parameters_common.h"

/*************************************************
 * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
 ************************************************/

/** Video-specific MMAL parameter IDs.
 * @ingroup MMAL_PARAMETER_IDS
 */
enum {
   MMAL_PARAMETER_DISPLAYREGION           /**< Takes a @ref MMAL_DISPLAYREGION_T */
         = MMAL_PARAMETER_GROUP_VIDEO,
   MMAL_PARAMETER_SUPPORTED_PROFILES,     /**< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T */
   MMAL_PARAMETER_PROFILE,                /**< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T */
   MMAL_PARAMETER_INTRAPERIOD,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_RATECONTROL,            /**< Takes a @ref MMAL_PARAMETER_VIDEO_RATECONTROL_T */
   MMAL_PARAMETER_NALUNITFORMAT,          /**< Takes a @ref MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T */
   MMAL_PARAMETER_MINIMISE_FRAGMENTATION, /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_MB_ROWS_PER_SLICE,      /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
                                           * Setting the value to zero resets to the default (one slice per frame). */
   MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION,  /**< Takes a @ref MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T */
   MMAL_PARAMETER_VIDEO_EEDE_ENABLE,      /**< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T */
   MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE,    /**< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T */
   MMAL_PARAMETER_VIDEO_REQUEST_I_FRAME,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T.
                                           * Request an I-frame. */
   MMAL_PARAMETER_VIDEO_INTRA_REFRESH,    /**< Takes a @ref MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T */
   MMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_BIT_RATE,         /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
                                           * Run-time bit rate control */
   MMAL_PARAMETER_VIDEO_FRAME_RATE,       /**< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T */
   MMAL_PARAMETER_VIDEO_ENCODE_MIN_QUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_MAX_QUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL,  /**< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T. */
   MMAL_PARAMETER_EXTRA_BUFFERS,          /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ALIGN_HORIZ,      /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
                                               Changing this paramater from the default can reduce frame rate
                                               because image buffers need to be re-pitched.*/
   MMAL_PARAMETER_VIDEO_ALIGN_VERT,        /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
                                               Changing this paramater from the default can reduce frame rate
                                               because image buffers need to be re-pitched.*/
   MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAMES,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_INITIAL_QUANT,   /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_QP_P,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_RC_SLICE_DQUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_FRAME_LIMIT_BITS,    /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
   MMAL_PARAMETER_VIDEO_ENCODE_PEAK_RATE,       /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */       

   /*H264 specific parameters*/
   MMAL_PARAMETER_VIDEO_ENCODE_H264_DISABLE_CABAC,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_LATENCY,        /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_AU_DELIMITERS,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_DEBLOCK_IDC,        /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_MB_INTRA_MODE,      /**< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T. */

   MMAL_PARAMETER_VIDEO_ENCODE_HEADER_ON_OPEN,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_ENCODE_PRECODE_FOR_QP,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */

   MMAL_PARAMETER_VIDEO_DRM_INIT_INFO,          /**< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T. */
   MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER,              /**< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T. */

   MMAL_PARAMETER_VIDEO_DECODE_CONFIG_VD3,       /**< Takes a @ref MMAL_PARAMETER_BYTES_T */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_VCL_HRD_PARAMETERS, /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_DELAY_HRD_FLAG, /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_INLINE_HEADER,            /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_SEI_ENABLE,               /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_ENCODE_INLINE_VECTORS,           /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
   MMAL_PARAMETER_VIDEO_RENDER_STATS,           /**< Take a @ref MMAL_PARAMETER_VIDEO_RENDER_STATS_T. */
   MMAL_PARAMETER_VIDEO_INTERLACE_TYPE,           /**< Take a @ref MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T. */
   MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_ENCODE_SPS_TIMING,         /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T */
   MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS,         /**< Take a @ref MMAL_PARAMETER_UINT32_T */
};

/** Display transformations.
 * Although an enumeration, the values correspond to combinations of:
 * \li 1 Reflect in a vertical axis
 * \li 2 180 degree rotation
 * \li 4 Reflect in the leading diagonal
 */
typedef enum MMAL_DISPLAYTRANSFORM_T {
   MMAL_DISPLAY_ROT0 = 0,
   MMAL_DISPLAY_MIRROR_ROT0 = 1,
   MMAL_DISPLAY_MIRROR_ROT180 = 2,
   MMAL_DISPLAY_ROT180 = 3,
   MMAL_DISPLAY_MIRROR_ROT90 = 4,
   MMAL_DISPLAY_ROT270 = 5,
   MMAL_DISPLAY_ROT90 = 6,
   MMAL_DISPLAY_MIRROR_ROT270 = 7,
   MMAL_DISPLAY_DUMMY = 0x7FFFFFFF
} MMAL_DISPLAYTRANSFORM_T;

/** Display modes. */
typedef enum MMAL_DISPLAYMODE_T {
   MMAL_DISPLAY_MODE_FILL = 0,
   MMAL_DISPLAY_MODE_LETTERBOX = 1,
   // these allow a left eye source->dest to be specified and the right eye mapping will be inferred by symmetry
   MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT = 2,
   MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP = 3,
   MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP = 4,
   MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT = 5,
   MMAL_DISPLAY_MODE_DUMMY = 0x7FFFFFFF
} MMAL_DISPLAYMODE_T;

/** Values used to indicate which fields are used when setting the
 * display configuration */
typedef enum MMAL_DISPLAYSET_T {
   MMAL_DISPLAY_SET_NONE = 0,
   MMAL_DISPLAY_SET_NUM = 1,
   MMAL_DISPLAY_SET_FULLSCREEN = 2,
   MMAL_DISPLAY_SET_TRANSFORM = 4,
   MMAL_DISPLAY_SET_DEST_RECT = 8,
   MMAL_DISPLAY_SET_SRC_RECT = 0x10,
   MMAL_DISPLAY_SET_MODE = 0x20,
   MMAL_DISPLAY_SET_PIXEL = 0x40,
   MMAL_DISPLAY_SET_NOASPECT = 0x80,
   MMAL_DISPLAY_SET_LAYER = 0x100,
   MMAL_DISPLAY_SET_COPYPROTECT = 0x200,
   MMAL_DISPLAY_SET_ALPHA = 0x400,
   MMAL_DISPLAY_SET_DUMMY = 0x7FFFFFFF
} MMAL_DISPLAYSET_T;

/**
This config sets the output display device, as well as the region used
on the output display, any display transformation, and some flags to
indicate how to scale the image.
*/

typedef struct MMAL_DISPLAYREGION_T {
   MMAL_PARAMETER_HEADER_T hdr;
   /** Bitfield that indicates which fields are set and should be used. All
    * other fields will maintain their current value.
    * \ref MMAL_DISPLAYSET_T defines the bits that can be combined.
    */
   uint32_t set;
   /** Describes the display output device, with 0 typically being a directly
    * connected LCD display.  The actual values will depend on the hardware.
    * Code using hard-wired numbers (e.g. 2) is certain to fail.
    */
   uint32_t display_num;
   /** Indicates that we are using the full device screen area, rather than
    * a window of the display.  If zero, then dest_rect is used to specify a
    * region of the display to use.
    */
   MMAL_BOOL_T fullscreen;
   /** Indicates any rotation or flipping used to map frames onto the natural
    * display orientation.
    */
   MMAL_DISPLAYTRANSFORM_T transform;
   /** Where to display the frame within the screen, if fullscreen is zero.
    */
   MMAL_RECT_T dest_rect;
   /** Indicates which area of the frame to display. If all values are zero,
    * the whole frame will be used.
    */
   MMAL_RECT_T src_rect;
   /** If set to non-zero, indicates that any display scaling should disregard
    * the aspect ratio of the frame region being displayed.
    */
   MMAL_BOOL_T noaspect;
   /** Indicates how the image should be scaled to fit the display. \code
    * MMAL_DISPLAY_MODE_FILL \endcode indicates that the image should fill the
    * screen by potentially cropping the frames.  Setting \code mode \endcode
    * to \code MMAL_DISPLAY_MODE_LETTERBOX \endcode indicates that all the source
    * region should be displayed and black bars added if necessary.
    */
   MMAL_DISPLAYMODE_T mode;
   /** If non-zero, defines the width of a source pixel relative to \code pixel_y
    * \endcode.  If zero, then pixels default to being square.
    */
   uint32_t pixel_x;
   /** If non-zero, defines the height of a source pixel relative to \code pixel_x
    * \endcode.  If zero, then pixels default to being square.
    */
   uint32_t pixel_y;
   /** Sets the relative depth of the images, with greater values being in front
    * of smaller values.
    */
   int32_t layer;
   /** Set to non-zero to ensure copy protection is used on output.
    */
   MMAL_BOOL_T copyprotect_required;
   /** Level of opacity of the layer, where zero is fully transparent and
    * 255 is fully opaque.
    */
   uint32_t alpha;
} MMAL_DISPLAYREGION_T;

/** Video profiles.
 * Only certain combinations of profile and level will be valid.
 * @ref MMAL_VIDEO_LEVEL_T
 */
typedef enum MMAL_VIDEO_PROFILE_T {
    MMAL_VIDEO_PROFILE_H263_BASELINE,
    MMAL_VIDEO_PROFILE_H263_H320CODING,
    MMAL_VIDEO_PROFILE_H263_BACKWARDCOMPATIBLE,
    MMAL_VIDEO_PROFILE_H263_ISWV2,
    MMAL_VIDEO_PROFILE_H263_ISWV3,
    MMAL_VIDEO_PROFILE_H263_HIGHCOMPRESSION,
    MMAL_VIDEO_PROFILE_H263_INTERNET,
    MMAL_VIDEO_PROFILE_H263_INTERLACE,
    MMAL_VIDEO_PROFILE_H263_HIGHLATENCY,
    MMAL_VIDEO_PROFILE_MP4V_SIMPLE,
    MMAL_VIDEO_PROFILE_MP4V_SIMPLESCALABLE,
    MMAL_VIDEO_PROFILE_MP4V_CORE,
    MMAL_VIDEO_PROFILE_MP4V_MAIN,
    MMAL_VIDEO_PROFILE_MP4V_NBIT,
    MMAL_VIDEO_PROFILE_MP4V_SCALABLETEXTURE,
    MMAL_VIDEO_PROFILE_MP4V_SIMPLEFACE,
    MMAL_VIDEO_PROFILE_MP4V_SIMPLEFBA,
    MMAL_VIDEO_PROFILE_MP4V_BASICANIMATED,
    MMAL_VIDEO_PROFILE_MP4V_HYBRID,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDREALTIME,
    MMAL_VIDEO_PROFILE_MP4V_CORESCALABLE,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCODING,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCORE,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSCALABLE,
    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSIMPLE,
    MMAL_VIDEO_PROFILE_H264_BASELINE,
    MMAL_VIDEO_PROFILE_H264_MAIN,
    MMAL_VIDEO_PROFILE_H264_EXTENDED,
    MMAL_VIDEO_PROFILE_H264_HIGH,
    MMAL_VIDEO_PROFILE_H264_HIGH10,
    MMAL_VIDEO_PROFILE_H264_HIGH422,
    MMAL_VIDEO_PROFILE_H264_HIGH444,
    MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE,
    MMAL_VIDEO_PROFILE_DUMMY = 0x7FFFFFFF
} MMAL_VIDEO_PROFILE_T;

/** Video levels.
 * Only certain combinations of profile and level will be valid.
 * @ref MMAL_VIDEO_PROFILE_T
 */
typedef enum MMAL_VIDEO_LEVEL_T {
    MMAL_VIDEO_LEVEL_H263_10,
    MMAL_VIDEO_LEVEL_H263_20,
    MMAL_VIDEO_LEVEL_H263_30,
    MMAL_VIDEO_LEVEL_H263_40,
    MMAL_VIDEO_LEVEL_H263_45,
    MMAL_VIDEO_LEVEL_H263_50,
    MMAL_VIDEO_LEVEL_H263_60,
    MMAL_VIDEO_LEVEL_H263_70,
    MMAL_VIDEO_LEVEL_MP4V_0,
    MMAL_VIDEO_LEVEL_MP4V_0b,
    MMAL_VIDEO_LEVEL_MP4V_1,
    MMAL_VIDEO_LEVEL_MP4V_2,
    MMAL_VIDEO_LEVEL_MP4V_3,
    MMAL_VIDEO_LEVEL_MP4V_4,
    MMAL_VIDEO_LEVEL_MP4V_4a,
    MMAL_VIDEO_LEVEL_MP4V_5,
    MMAL_VIDEO_LEVEL_MP4V_6,
    MMAL_VIDEO_LEVEL_H264_1,
    MMAL_VIDEO_LEVEL_H264_1b,
    MMAL_VIDEO_LEVEL_H264_11,
    MMAL_VIDEO_LEVEL_H264_12,
    MMAL_VIDEO_LEVEL_H264_13,
    MMAL_VIDEO_LEVEL_H264_2,
    MMAL_VIDEO_LEVEL_H264_21,
    MMAL_VIDEO_LEVEL_H264_22,
    MMAL_VIDEO_LEVEL_H264_3,
    MMAL_VIDEO_LEVEL_H264_31,
    MMAL_VIDEO_LEVEL_H264_32,
    MMAL_VIDEO_LEVEL_H264_4,
    MMAL_VIDEO_LEVEL_H264_41,
    MMAL_VIDEO_LEVEL_H264_42,
    MMAL_VIDEO_LEVEL_H264_5,
    MMAL_VIDEO_LEVEL_H264_51,
    MMAL_VIDEO_LEVEL_DUMMY = 0x7FFFFFFF
} MMAL_VIDEO_LEVEL_T;

/** Video profile and level setting.
 * This is a variable length structure when querying the supported profiles and
 * levels. To get more than one, pass a structure with more profile/level pairs.
 */
typedef struct MMAL_PARAMETER_VIDEO_PROFILE_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   struct
   {
      MMAL_VIDEO_PROFILE_T profile;
      MMAL_VIDEO_LEVEL_T level;
   } profile[1];
} MMAL_PARAMETER_VIDEO_PROFILE_T;

/** Manner of video rate control */
typedef enum MMAL_VIDEO_RATECONTROL_T {
    MMAL_VIDEO_RATECONTROL_DEFAULT,
    MMAL_VIDEO_RATECONTROL_VARIABLE,
    MMAL_VIDEO_RATECONTROL_CONSTANT,
    MMAL_VIDEO_RATECONTROL_VARIABLE_SKIP_FRAMES,
    MMAL_VIDEO_RATECONTROL_CONSTANT_SKIP_FRAMES,
    MMAL_VIDEO_RATECONTROL_DUMMY = 0x7fffffff
} MMAL_VIDEO_RATECONTROL_T;

/** Intra refresh modes */
typedef enum MMAL_VIDEO_INTRA_REFRESH_T {
    MMAL_VIDEO_INTRA_REFRESH_CYCLIC,
    MMAL_VIDEO_INTRA_REFRESH_ADAPTIVE,
    MMAL_VIDEO_INTRA_REFRESH_BOTH,
    MMAL_VIDEO_INTRA_REFRESH_KHRONOSEXTENSIONS = 0x6F000000,
    MMAL_VIDEO_INTRA_REFRESH_VENDORSTARTUNUSED = 0x7F000000,
    MMAL_VIDEO_INTRA_REFRESH_CYCLIC_MROWS,
    MMAL_VIDEO_INTRA_REFRESH_PSEUDO_RAND,
    MMAL_VIDEO_INTRA_REFRESH_MAX,
    MMAL_VIDEO_INTRA_REFRESH_DUMMY         = 0x7FFFFFFF
} MMAL_VIDEO_INTRA_REFRESH_T;

/*Encode RC Models Supported*/
typedef enum MMAL_VIDEO_ENCODE_RC_MODEL_T {
    MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT    = 0,
    MMAL_VIDEO_ENCODER_RC_MODEL_JVT = MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT,
    MMAL_VIDEO_ENCODER_RC_MODEL_VOWIFI,
    MMAL_VIDEO_ENCODER_RC_MODEL_CBR,
    MMAL_VIDEO_ENCODER_RC_MODEL_LAST,
    MMAL_VIDEO_ENCODER_RC_MODEL_DUMMY      = 0x7FFFFFFF
} MMAL_VIDEO_ENCODE_RC_MODEL_T;

typedef struct MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T {
    MMAL_PARAMETER_HEADER_T hdr;
    MMAL_VIDEO_ENCODE_RC_MODEL_T rc_model;
}MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T;

/** Video rate control setting */
typedef struct MMAL_PARAMETER_VIDEO_RATECONTROL_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_VIDEO_RATECONTROL_T control;
} MMAL_PARAMETER_VIDEO_RATECONTROL_T;

/*H264 INTRA MB MODES*/
typedef enum MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T {
    MMAL_VIDEO_ENCODER_H264_MB_4x4_INTRA = 1,
    MMAL_VIDEO_ENCODER_H264_MB_8x8_INTRA = 2,
    MMAL_VIDEO_ENCODER_H264_MB_16x16_INTRA = 4,
    MMAL_VIDEO_ENCODER_H264_MB_INTRA_DUMMY = 0x7fffffff
} MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T;

typedef struct MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T {
    MMAL_PARAMETER_HEADER_T hdr;
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T mb_mode;
}MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T;

/** NAL unit formats */
typedef enum MMAL_VIDEO_NALUNITFORMAT_T {
    MMAL_VIDEO_NALUNITFORMAT_STARTCODES = 1,
    MMAL_VIDEO_NALUNITFORMAT_NALUNITPERBUFFER = 2,
    MMAL_VIDEO_NALUNITFORMAT_ONEBYTEINTERLEAVELENGTH = 4,
    MMAL_VIDEO_NALUNITFORMAT_TWOBYTEINTERLEAVELENGTH = 8,
    MMAL_VIDEO_NALUNITFORMAT_FOURBYTEINTERLEAVELENGTH = 16,
    MMAL_VIDEO_NALUNITFORMAT_DUMMY = 0x7fffffff
} MMAL_VIDEO_NALUNITFORMAT_T;

/** NAL unit format setting */
typedef struct MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_VIDEO_NALUNITFORMAT_T format;
} MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T;

/** H264 Only: Overrides for max macro-blocks per second, max framesize, 
 * and max bitrates. This overrides the default maximums for the configured level.
 */
typedef struct MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t custom_max_mbps;
   uint32_t custom_max_fs;
   uint32_t custom_max_br_and_cpb;
} MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T;

/** H264 Only: Overrides for max macro-blocks per second, max framesize,
 * and max bitrates. This overrides the default maximums for the configured level.
 */
typedef struct MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T {
   MMAL_PARAMETER_HEADER_T hdr;

    MMAL_VIDEO_INTRA_REFRESH_T refresh_mode;
    uint32_t air_mbs;
    uint32_t air_ref;
    uint32_t cir_mbs;
    uint32_t pir_mbs;
} MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T;

/** Structure for enabling EEDE, we keep it like this for now, there could be extra fields in the future */
typedef struct MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t enable;
} MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T;

/** Structure for setting lossrate for EEDE, we keep it like this for now, there could be extra fields in the future */
typedef struct MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t loss_rate;
} MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T;

/** Structure for setting initial DRM parameters */
typedef struct MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t current_time;
   uint32_t ticks_per_sec;
   uint8_t  lhs[32];
} MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T;

/** Structure for requesting a hardware-protected memory buffer **/
typedef struct MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t size_wanted;     /**< Input. Zero size means internal video decoder buffer,
                                 mem_handle and phys_addr not returned in this case */
   uint32_t protect;         /**< Input. 1 = protect, 0 = unprotect */

   uint32_t mem_handle;      /**< Output. Handle for protected buffer */
   void *   phys_addr;       /**< Output. Physical memory address of protected buffer */

} MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T;

typedef struct MMAL_PARAMETER_VIDEO_RENDER_STATS_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T valid;
   uint32_t match;
   uint32_t period;
   uint32_t phase;
   uint32_t pixel_clock_nominal;
   uint32_t pixel_clock;
   uint32_t hvs_status;
   uint32_t dummy[2];
} MMAL_PARAMETER_VIDEO_RENDER_STATS_T;

typedef enum MMAL_INTERLACETYPE_T {
   MMAL_InterlaceProgressive,                    /**< The data is not interlaced, it is progressive scan */
   MMAL_InterlaceFieldSingleUpperFirst,          /**< The data is interlaced, fields sent
                                                     separately in temporal order, with upper field first */
   MMAL_InterlaceFieldSingleLowerFirst,          /**< The data is interlaced, fields sent
                                                     separately in temporal order, with lower field first */
   MMAL_InterlaceFieldsInterleavedUpperFirst,    /**< The data is interlaced, two fields sent together line
                                                     interleaved, with the upper field temporally earlier */
   MMAL_InterlaceFieldsInterleavedLowerFirst,    /**< The data is interlaced, two fields sent together line
                                                     interleaved, with the lower field temporally earlier */
   MMAL_InterlaceMixed,                          /**< The stream may contain a mixture of progressive
                                                     and interlaced frames */
   MMAL_InterlaceKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
   MMAL_InterlaceVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
   MMAL_InterlaceMax = 0x7FFFFFFF
} MMAL_INTERLACETYPE_T;

typedef struct MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_INTERLACETYPE_T eMode;       /**< The interlace type of the content */
   MMAL_BOOL_T bRepeatFirstField;    /**< Whether to repeat the first field */
} MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T;

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PARAMETERS_H
#define MMAL_PARAMETERS_H

#include "mmal_common.h"
#include "mmal_parameters_camera.h"
#include "mmal_parameters_video.h"
#include "mmal_parameters_audio.h"
#include "mmal_parameters_clock.h"

/** \defgroup MmalParameters List of pre-defined parameters
 * This defines a list of standard parameters. Components can define proprietary
 * parameters by creating a new group and defining their own structures. */
/* @{ */

/** Generic unsigned 64-bit integer parameter type. */
typedef struct MMAL_PARAMETER_UINT64_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint64_t value; /**< Parameter value */
} MMAL_PARAMETER_UINT64_T;

/** Generic signed 64-bit integer parameter type. */
typedef struct MMAL_PARAMETER_INT64_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   int64_t value; /**< Parameter value */
} MMAL_PARAMETER_INT64_T;

/** Generic unsigned 32-bit integer parameter type. */
typedef struct MMAL_PARAMETER_UINT32_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t value; /**< Parameter value */
} MMAL_PARAMETER_UINT32_T;

/** Generic signed 32-bit integer parameter type. */
typedef struct MMAL_PARAMETER_INT32_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   int32_t value; /**< Parameter value */
} MMAL_PARAMETER_INT32_T;

/** Generic rational parameter type. */
typedef struct MMAL_PARAMETER_RATIONAL_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RATIONAL_T value; /**< Parameter value */
} MMAL_PARAMETER_RATIONAL_T;

/** Generic boolean parameter type. */
typedef struct MMAL_PARAMETER_BOOLEAN_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_BOOL_T enable; /**< Parameter value */
} MMAL_PARAMETER_BOOLEAN_T;

/** Generic string parameter type. */
typedef struct MMAL_PARAMETER_STRING_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   char str[1];        /**< Null-terminated string */
} MMAL_PARAMETER_STRING_T;

/** Generic array of bytes parameter type. */
typedef struct MMAL_PARAMETER_BYTES_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint8_t data[1];   /**< Array of bytes */
} MMAL_PARAMETER_BYTES_T;

/** The value 1 in 16.16 fixed point form */
#define MMAL_FIXED_16_16_ONE  (1 << 16)

/** Generic two-dimensional scaling factor type. */
typedef struct MMAL_PARAMETER_SCALEFACTOR_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_FIXED_16_16_T scale_x;  /**< Scaling factor in X-axis */
   MMAL_FIXED_16_16_T scale_y;  /**< Scaling factor in Y-axis */
} MMAL_PARAMETER_SCALEFACTOR_T;

/** Valid mirror modes */
typedef enum MMAL_PARAM_MIRROR_T
{
   MMAL_PARAM_MIRROR_NONE,
   MMAL_PARAM_MIRROR_VERTICAL,
   MMAL_PARAM_MIRROR_HORIZONTAL,
   MMAL_PARAM_MIRROR_BOTH,
} MMAL_PARAM_MIRROR_T;

/** Generic mirror parameter type */
typedef struct MMAL_PARAMETER_MIRROR_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_PARAM_MIRROR_T value;   /**< Mirror mode */
} MMAL_PARAMETER_MIRROR_T;

/** URI parameter type.
 * The parameter may hold an arbitrary length, nul-terminated string as long
 * as the size is set appropriately.
 */
typedef struct MMAL_PARAMETER_URI_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   char uri[1];    /**< URI string (null-terminated) */
} MMAL_PARAMETER_URI_T;

/** Generic encoding parameter type.
 * The parameter may hold more than one encoding by overriding the size to
 * include a bigger array.
 */
typedef struct MMAL_PARAMETER_ENCODING_T
{
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t encoding[1];   /**< Array of FourCC encodings, see \ref MmalEncodings */
} MMAL_PARAMETER_ENCODING_T;

/** Generic frame-rate parameter type.
 * Frame rates are specified as a rational number, using a pair of integers.
 * Since there can be many valid pairs for the same ratio, a frame-rate may
 * not contain exactly the same pairs of values when read back as it was
 * when set.
 */
typedef struct MMAL_PARAMETER_FRAME_RATE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   MMAL_RATIONAL_T frame_rate;   /**< Frame-rate value */
} MMAL_PARAMETER_FRAME_RATE_T;

/** Generic configuration-file setup type.
 * Configuration files are transferred in small chunks. The component can
 * save all the chunks into a buffer, then process the entire file later.
 * This parameter initialises a config file to have the given size.
 */
typedef struct MMAL_PARAMETER_CONFIGFILE_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t file_size;           /**< Size of complete file data */
} MMAL_PARAMETER_CONFIGFILE_T;

/** Generic configuration-file chunk data type.
 * Once a config file has been initialised, this parameter can be used to
 * write an arbitrary chunk of the file data (limited by the maximum MMAL
 * message size).
 */
typedef struct MMAL_PARAMETER_CONFIGFILE_CHUNK_T {
   MMAL_PARAMETER_HEADER_T hdr;

   uint32_t size;                /**< Number of bytes being transferred in this chunk */
   uint32_t offset;              /**< Offset of this chunk in the file */
   char data[1];                 /**< Chunk data */
} MMAL_PARAMETER_CONFIGFILE_CHUNK_T;

/* @} */

#endif /* MMAL_PARAMETERS_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_pool.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_POOL_H
#define MMAL_POOL_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalPool Pools of buffer headers
 * A pool of buffer headers is composed of a queue (\ref MMAL_QUEUE_T) and a user
 * specified number of buffer headers (\ref MMAL_BUFFER_HEADER_T). */
/* @{ */

#include "mmal_queue.h"

/** Definition of a pool */
typedef struct MMAL_POOL_T
{
   MMAL_QUEUE_T *queue;             /**< Queue used by the pool */
   uint32_t headers_num;            /**< Number of buffer headers in the pool */
   MMAL_BUFFER_HEADER_T **header;   /**< Array of buffer headers belonging to the pool */
} MMAL_POOL_T;

/** Allocator alloc prototype
 *
 * @param context The context pointer passed in on pool creation.
 * @param size    The size of the allocation required, in bytes.
 * @return The pointer to the newly allocated memory, or NULL on failure.
 */
typedef void *(*mmal_pool_allocator_alloc_t)(void *context, uint32_t size);
/** Allocator free prototype
 *
 * @param context The context pointer passed in on pool creation.
 * @param mem     The pointer to the memory to be released.
 */
typedef void (*mmal_pool_allocator_free_t)(void *context, void *mem);

/** Create a pool of MMAL_BUFFER_HEADER_T.
 * After allocation, all allocated buffer headers will have been added to the queue.
 *
 * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
 * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
 * headers, or the size of the payload buffers, after creation of the pool.
 *
 * The payload buffers may also be allocated independently by the client, and assigned
 * to the buffer headers, but it will be the responsibility of the client to deal with
 * resizing and releasing the memory. It is recommended that mmal_pool_create_with_allocator()
 * is used in this case, supplying allocator function pointers that will be used as
 * necessary by MMAL.
 *
 * @param headers      Number of buffer headers to be allocated with the pool.
 * @param payload_size Size of the payload buffer that will be allocated in 
 *                     each of the buffer headers.
 * @return Pointer to the newly created pool or NULL on failure.
 */
MMAL_POOL_T *mmal_pool_create(unsigned int headers, uint32_t payload_size);

/** Create a pool of MMAL_BUFFER_HEADER_T.
 * After allocation, all allocated buffer headers will have been added to the queue.
 *
 * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
 * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
 * headers, or the size of the payload buffers, after creation of the pool. The allocators
 * passed during creation shall be used when resizing the payload buffers.
 *
 * @param headers      Number of buffer headers to be allocated with the pool.
 * @param payload_size Size of the payload buffer that will be allocated in
 *                     each of the buffer headers.
 * @param allocator_context Pointer to the context of the allocator.
 * @param allocator_alloc   Function pointer for the alloc call of the allocator.
 * @param allocator_free    Function pointer for the free call of the allocator.
 *
 * @return Pointer to the newly created pool or NULL on failure.
 */
MMAL_POOL_T *mmal_pool_create_with_allocator(unsigned int headers, uint32_t payload_size,
                              void *allocator_context, mmal_pool_allocator_alloc_t allocator_alloc,
                              mmal_pool_allocator_free_t allocator_free);

/** Destroy a pool of MMAL_BUFFER_HEADER_T.
 * This will also deallocate all of the memory which was allocated when creating or
 * resizing the pool.
 *
 * If payload buffers have been allocated independently by the client, they should be
 * released prior to calling this function. If the client provided allocator functions,
 * the allocator_free function shall be called for each payload buffer.
 *
 * @param pool  Pointer to a pool
 */
void mmal_pool_destroy(MMAL_POOL_T *pool);

/** Resize a pool of MMAL_BUFFER_HEADER_T.
 * This allows modifying either the number of allocated buffers, the payload size or both at the
 * same time.
 *
 * @param pool         Pointer to the pool
 * @param headers      New number of buffer headers to be allocated in the pool.
 *                     It is not valid to pass zero for the number of buffers.
 * @param payload_size Size of the payload buffer that will be allocated in
 *                     each of the buffer headers.
 *                     If this is set to 0, all payload buffers shall be released.
 * @return MMAL_SUCCESS or an error on failure.
 */
MMAL_STATUS_T mmal_pool_resize(MMAL_POOL_T *pool, unsigned int headers, uint32_t payload_size);

/** Definition of the callback used by a pool to signal back to the user that a buffer header
 * has been released back to the pool.
 *
 * @param pool       Pointer to the pool
 * @param buffer     Buffer header just released
 * @param userdata   User specific data passed in when setting the callback
 * @return True to have the buffer header put back in the pool's queue, false if the buffer
 *          header has been taken within the callback.
 */
typedef MMAL_BOOL_T (*MMAL_POOL_BH_CB_T)(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata);

/** Set a buffer header release callback to the pool.
 * Each time a buffer header is released to the pool, the callback will be triggered.
 *
 * @param pool     Pointer to a pool
 * @param cb       Callback function
 * @param userdata User specific data which will be passed with each callback
 */
void mmal_pool_callback_set(MMAL_POOL_T *pool, MMAL_POOL_BH_CB_T cb, void *userdata);

/** Set a pre-release callback for all buffer headers in the pool.
 * Each time a buffer header is about to be released to the pool, the callback
 * will be triggered.
 *
 * @param pool     Pointer to the pool
 * @param cb       Pre-release callback function
 * @param userdata User-specific data passed back with each callback
 */
void mmal_pool_pre_release_callback_set(MMAL_POOL_T *pool, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_POOL_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_port.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_PORT_H
#define MMAL_PORT_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalPort Ports
 * Definition of a MMAL port and its associated API */
/* @{ */

#include "mmal_types.h"
#include "mmal_format.h"
#include "mmal_buffer.h"
#include "mmal_parameters.h"

/** List of port types */
typedef enum
{
   MMAL_PORT_TYPE_UNKNOWN = 0,          /**< Unknown port type */
   MMAL_PORT_TYPE_CONTROL,              /**< Control port */
   MMAL_PORT_TYPE_INPUT,                /**< Input port */
   MMAL_PORT_TYPE_OUTPUT,               /**< Output port */
   MMAL_PORT_TYPE_CLOCK,                /**< Clock port */
   MMAL_PORT_TYPE_INVALID = 0xffffffff  /**< Dummy value to force 32bit enum */

} MMAL_PORT_TYPE_T;

/** \name Port capabilities
 * \anchor portcapabilities
 * The following flags describe the capabilities advertised by a port */
/* @{ */
/** The port is pass-through and doesn't need buffer headers allocated */
#define MMAL_PORT_CAPABILITY_PASSTHROUGH                       0x01
/** The port wants to allocate the buffer payloads. This signals a preference that
 * payload allocation should be done on this port for efficiency reasons. */
#define MMAL_PORT_CAPABILITY_ALLOCATION                        0x02
/** The port supports format change events. This applies to input ports and is used
 * to let the client know whether the port supports being reconfigured via a format
 * change event (i.e. without having to disable the port). */
#define MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE      0x04
/* @} */

/** Definition of a port.
 * A port is the entity that is exposed by components to receive or transmit
 * buffer headers (\ref MMAL_BUFFER_HEADER_T). A port is defined by its
 * \ref MMAL_ES_FORMAT_T.
 *
 * It may be possible to override the buffer requirements of a port by using
 * the MMAL_PARAMETER_BUFFER_REQUIREMENTS parameter.
 */
typedef struct MMAL_PORT_T
{
   struct MMAL_PORT_PRIVATE_T *priv; /**< Private member used by the framework */
   const char *name;                 /**< Port name. Used for debugging purposes (Read Only) */

   MMAL_PORT_TYPE_T type;            /**< Type of the port (Read Only) */
   uint16_t index;                   /**< Index of the port in its type list (Read Only) */
   uint16_t index_all;               /**< Index of the port in the list of all ports (Read Only) */

   uint32_t is_enabled;              /**< Indicates whether the port is enabled or not (Read Only) */
   MMAL_ES_FORMAT_T *format;         /**< Format of the elementary stream */

   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires (Read Only).
                                          This is set by the component. */
   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires (Read Only).
                                          This is set by the component. */
   uint32_t buffer_alignment_min;    /**< Minimum alignment requirement for the buffers (Read Only).
                                          A value of zero means no special alignment requirements.
                                          This is set by the component. */
   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal performance (Read Only).
                                          A value of zero means no special recommendation.
                                          This is set by the component. */
   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance (Read Only).
                                          A value of zero means no special recommendation.
                                          This is set by the component. */
   uint32_t buffer_num;              /**< Actual number of buffers the port will use.
                                          This is set by the client. */
   uint32_t buffer_size;             /**< Actual maximum size of the buffers that will be sent
                                          to the port. This is set by the client. */

   struct MMAL_COMPONENT_T *component;    /**< Component this port belongs to (Read Only) */
   struct MMAL_PORT_USERDATA_T *userdata; /**< Field reserved for use by the client */

   uint32_t capabilities;            /**< Flags describing the capabilities of a port (Read Only).
                                       * Bitwise combination of \ref portcapabilities "Port capabilities"
                                       * values.
                                       */

} MMAL_PORT_T;

/** Commit format changes on a port.
 *
 * @param port The port for which format changes are to be committed.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_format_commit(MMAL_PORT_T *port);

/** Definition of the callback used by a port to send a \ref MMAL_BUFFER_HEADER_T
 * back to the user.
 *
 * @param port The port sending the buffer header.
 * @param buffer The buffer header being sent.
 */
typedef void (*MMAL_PORT_BH_CB_T)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);

/** Enable processing on a port
 *
 * If this port is connected to another, the given callback must be NULL, while for a
 * disconnected port, the callback must be non-NULL.
 *
 * If this is a connected output port and is successfully enabled:
 * <ul>
 * <li>The port shall be populated with a pool of buffers, allocated as required, according
 * to the buffer_num and buffer_size values.
 * <li>The input port to which it is connected shall be set to the same buffer
 * configuration and then be enabled. Should that fail, the original port shall be
 * disabled.
 * </ul>
 *
 * @param port port to enable
 * @param cb callback use by the port to send a \ref MMAL_BUFFER_HEADER_T back
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb);

/** Disable processing on a port
 *
 * Disabling a port will stop all processing on this port and return all (non-processed)
 * buffer headers to the client.
 *
 * If this is a connected output port, the input port to which it is connected shall
 * also be disabled. Any buffer pool shall be released.
 *
 * @param port port to disable
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_disable(MMAL_PORT_T *port);

/** Ask a port to release all the buffer headers it currently has.
 *
 * Flushing a port will ask the port to send all the buffer headers it currently has
 * to the client. Flushing is an asynchronous request and the flush call will
 * return before all the buffer headers are returned to the client.
 * It is up to the client to keep a count on the buffer headers to know when the
 * flush operation has completed.
 * It is also important to note that flushing will also reset the state of the port
 * and any processing which was buffered by the port will be lost.
 *
 * \attention Flushing a connected port behaviour TBD.
 *
 * @param port The port to flush.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_flush(MMAL_PORT_T *port);

/** Set a parameter on a port.
 *
 * @param port The port to which the request is sent.
 * @param param The pointer to the header of the parameter to set.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_parameter_set(MMAL_PORT_T *port,
   const MMAL_PARAMETER_HEADER_T *param);

/** Get a parameter from a port.
 * The size field must be set on input to the maximum size of the parameter
 * (including the header) and will be set on output to the actual size of the
 * parameter retrieved.
 *
 * \note If MMAL_ENOSPC is returned, the parameter is larger than the size
 * given. The given parameter will have been filled up to its size and then
 * the size field set to the full parameter's size. This can be used to
 * resize the parameter buffer so that a second call should succeed.
 *
 * @param port The port to which the request is sent.
 * @param param The pointer to the header of the parameter to get.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_parameter_get(MMAL_PORT_T *port,
   MMAL_PARAMETER_HEADER_T *param);

/** Send a buffer header to a port.
 *
 * @param port The port to which the buffer header is to be sent.
 * @param buffer The buffer header to send.
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_send_buffer(MMAL_PORT_T *port,
   MMAL_BUFFER_HEADER_T *buffer);

/** Connect an output port to an input port.
 *
 * When connected and enabled, buffers will automatically progress from the
 * output port to the input port when they become available, and released back
 * to the output port when no longer required by the input port.
 *
 * Ports can be given either way around, but one must be an output port and
 * the other must be an input port. Neither can be connected or enabled
 * already. The format of the output port will be applied to the input port
 * on connection.
 *
 * @param port One of the ports to connect.
 * @param other_port The other port to connect.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_port_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port);

/** Disconnect a connected port.
 *
 * If the port is not connected, an error will be returned. Otherwise, if the
 * ports are enabled, they will be disabled and any buffer pool created will be
 * freed.
 *
 * @param port The ports to disconnect.
 * @return MMAL_SUCCESS on success.
 */
MMAL_STATUS_T mmal_port_disconnect(MMAL_PORT_T *port);

/** Allocate a payload buffer.
 * This allows a client to allocate memory for a payload buffer based on the preferences
 * of a port. This for instance will allow the port to allocate memory which can be shared
 * between the host processor and videocore.
 *
 * See \ref mmal_pool_create_with_allocator().
 *
 * @param port         Port responsible for allocating the memory.
 * @param payload_size Size of the payload buffer which will be allocated.
 *
 * @return Pointer to the allocated memory.
 */
uint8_t *mmal_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size);

/** Free a payload buffer.
 * This allows a client to free memory allocated by a previous call to \ref mmal_port_payload_alloc.
 *
 * See \ref mmal_pool_create_with_allocator().
 *
 * @param port         Port responsible for allocating the memory.
 * @param payload      Pointer to the memory to free.
 */
void mmal_port_payload_free(MMAL_PORT_T *port, uint8_t *payload);

/** Get an empty event buffer header from a port
 *
 * @param port The port from which to get the event buffer header.
 * @param buffer The address of a buffer header pointer, which will be set on return.
 * @param event The specific event FourCC required. See the \ref MmalEvents "pre-defined events".
 * @return MMAL_SUCCESS on success
 */
MMAL_STATUS_T mmal_port_event_get(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t event);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_PORT_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_queue.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_QUEUE_H
#define MMAL_QUEUE_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalQueue Queues of buffer headers
 * This provides a thread-safe implementation of a queue of buffer headers
 * (\ref MMAL_BUFFER_HEADER_T). The queue works in a first-in, first-out basis
 * so the buffer headers will be dequeued in the order they have been queued. */
/* @{ */

#include "mmal_buffer.h"

typedef struct MMAL_QUEUE_T MMAL_QUEUE_T;

/** Create a queue of MMAL_BUFFER_HEADER_T
 *
 * @return Pointer to the newly created queue or NULL on failure.
 */
MMAL_QUEUE_T *mmal_queue_create(void);

/** Put a MMAL_BUFFER_HEADER_T into a queue
 *
 * @param queue  Pointer to a queue
 * @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue
 */
void mmal_queue_put(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer);

/** Put a MMAL_BUFFER_HEADER_T back at the start of a queue.
 * This is used when a buffer header was removed from the queue but not
 * fully processed and needs to be put back where it was originally taken.
 *
 * @param queue  Pointer to a queue
 * @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue
 */
void mmal_queue_put_back(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer);

/** Get a MMAL_BUFFER_HEADER_T from a queue
 *
 * @param queue  Pointer to a queue
 *
 * @return pointer to the next MMAL_BUFFER_HEADER_T or NULL if the queue is empty.
 */
MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue);

/** Wait for a MMAL_BUFFER_HEADER_T from a queue.
 * This is the same as a get except that this will block until a buffer header is
 * available.
 *
 * @param queue  Pointer to a queue
 *
 * @return pointer to the next MMAL_BUFFER_HEADER_T.
 */
MMAL_BUFFER_HEADER_T *mmal_queue_wait(MMAL_QUEUE_T *queue);

/** Get the number of MMAL_BUFFER_HEADER_T currently in a queue.
 *
 * @param queue  Pointer to a queue
 *
 * @return length (in elements) of the queue.
 */
unsigned int mmal_queue_length(MMAL_QUEUE_T *queue);

/** Destroy a queue of MMAL_BUFFER_HEADER_T.
 *
 * @param queue  Pointer to a queue
 */
void mmal_queue_destroy(MMAL_QUEUE_T *queue);

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_QUEUE_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_types.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef MMAL_TYPES_H
#define MMAL_TYPES_H

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup MmalTypes Common types
 * Definition for common types */
/* @{ */

#include "mmal_common.h"

/** Status return codes from the API.
 *
 * \internal Please try to keep this similar to the standard POSIX codes
 * rather than making up new ones!
 */
typedef enum
{
   MMAL_SUCCESS = 0,                 /**< Success */
   MMAL_ENOMEM,                      /**< Out of memory */
   MMAL_ENOSPC,                      /**< Out of resources (other than memory) */
   MMAL_EINVAL,                      /**< Argument is invalid */
   MMAL_ENOSYS,                      /**< Function not implemented */
   MMAL_ENOENT,                      /**< No such file or directory */
   MMAL_ENXIO,                       /**< No such device or address */
   MMAL_EIO,                         /**< I/O error */
   MMAL_ESPIPE,                      /**< Illegal seek */
   MMAL_ECORRUPT,                    /**< Data is corrupt \attention FIXME: not POSIX */
   MMAL_ENOTREADY,                   /**< Component is not ready \attention FIXME: not POSIX */
   MMAL_ECONFIG,                     /**< Component is not configured \attention FIXME: not POSIX */
   MMAL_EISCONN,                     /**< Port is already connected */
   MMAL_ENOTCONN,                    /**< Port is disconnected */
   MMAL_EAGAIN,                      /**< Resource temporarily unavailable. Try again later*/
   MMAL_EFAULT,                      /**< Bad address */
   /* Do not add new codes here unless they match something from POSIX */
   MMAL_STATUS_MAX = 0x7FFFFFFF      /**< Force to 32 bit */
} MMAL_STATUS_T;

/** Describes a rectangle */
typedef struct
{
   int32_t x;      /**< x coordinate (from left) */
   int32_t y;      /**< y coordinate (from top) */
   int32_t width;  /**< width */
   int32_t height; /**< height */
} MMAL_RECT_T;

/** Describes a rational number */
typedef struct
{
   int32_t num;    /**< Numerator */
   int32_t den;    /**< Denominator */
} MMAL_RATIONAL_T;

/** \name Special Unknown Time Value
 * Timestamps in MMAL are defined as signed 64 bits integer values representing microseconds.
 * However a pre-defined special value is used to signal that a timestamp is not known. */
/* @{ */
#define MMAL_TIME_UNKNOWN (INT64_C(1)<<63)  /**< Special value signalling that time is not known */
/* @} */

/** Four Character Code type */
typedef uint32_t MMAL_FOURCC_T;

/* @} */

#ifdef __cplusplus
}
#endif

#endif /* MMAL_TYPES_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal.h
================
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/** \file
 * Multi-Media Abstraction Layer API
 */

#ifndef MMAL_H
#define MMAL_H

/**
  *
  * \mainpage Multi-Media Abstraction Layer (MMAL). Draft Version 0.1.
  *
  * \par Contents
  * - \ref intro_sec
  * - \ref features
  * - \ref concepts
  * - \ref comp
  * - \ref create
  * - \ref port
  * - \ref buf
  * - \ref metadata
  * - \ref queue
  * - \ref pool
  * - \ref param
  * - \ref events
  * - \ref version
  * - \ref example
  *
  * \section intro_sec Introduction
  *
  * MMAL (Multi-Media Abstraction Layer) is a framework which is used to provide a host-side,
  * simple and relatively low-level interface to multimedia components running on VideoCore.
  * It also provides a component interface so that new components can be easily created and
  * integrated into the framework.
  *
  * There is no requirement that all the components be running on VideoCore as MMAL doesn't
  * put any restriction on where components live. The current implementation for instance
  * provides some components which can be run on both host-side or VideoCore (e.g. the splitter
  * component).
  *
  * \section features Features
  *
  * The MMAL API has been designed to support all the following features:
  * - Sufficiently generic to support different kinds of multimedia component.
  * - Simple to use from client side (mostly synchronous except where it matters).
  * - Straightforward API for designing components (e.g. avoids multiple data paths, as found in RIL).
  * - Allows for fully-optimised implementation of components (e.g. zero-copy buffer passing).
  * - Portability (API is self-contained).
  * - Supports multiple instances (e.g. of VideoCore).
  * - Extensible without breaking source or binary backward compatibility.
  *
  * \section concepts API concepts
  *
  * The MMAL API is based on the concept of components, ports and buffer headers.
  * Clients create MMAL components which expose ports for each individual
  * elementary stream of data they support (e.g. audio/video). Components expose
  * input ports to receive data from the client, and expose output ports
  * to return data to the client.
  *
  * Data sent to or received from the component needs to be attached to a buffer header.
  * Buffer headers are necessary because they contain buffer specific ancillary data which is
  * necessary for the component and client to do their processing (e.g timestamps).
  *
  * \section comp Components
  *
  * MMAL lets clients create multi-media components (video encoders,
  * video decoders, camera, and so-on) using a common API. Clients exchange
  * data with components using buffer headers. A buffer header
  * has a pointer to the payload data and optional metadata.
  * Buffer headers are sent to and received from ports that are provided by components.
  *
  * A typical decoder component would have a single input port and a
  * single output port, but the same architecture could also be used
  * for components with different layouts (e.g. a camera with a
  * capture and preview port, or a debugging component with just an input port).
  *
  * \subsection create Component Creation
  *
  * Each component is identified by a unique name. To create a specific component
  * the client needs to call \ref mmal_component_create with the desired component's
  * name as an argument.
  * This call will return a context (\ref MMAL_COMPONENT_T) to the component. This
  * context will expose the input and output ports (\ref MMAL_PORT_T) supported
  * by this specific component.
  *
  * \note All VideoCore components have a name starting with the "vc." prefix (this prefix
  * is used to distinguish when a creation request needs to be forwarded to VideoCore).
  *
  * \section port Component Ports
  *
  * A port (\ref MMAL_PORT_T) is the entity which exposes an elementary stream
  * (\ref MMAL_ES_FORMAT_T) on a component. It is also the entity to which buffer headers
  * (\ref MMAL_BUFFER_HEADER_T) are sent or from which they are received.
  *
  * Clients do not need to create ports. They are created automatically by
  * the component when this one is created but the format of a port might need to
  * be set by the client depending on the type of component the client is using.
  *
  * For example, for a video decoding component, one input port and one output port
  * will be available. The format of the input port must be set by the
  * client (using \ref mmal_port_format_commit) while the format of the output port
  * will be automatically set by the component once the component has enough information
  * to find out what its format should be.
  *
  * If the input port format contains enough information for the component to determine
  * the format of the output port straight away, then the output port will be set to the proper
  * format when \ref mmal_port_format_commit returns. Otherwise the output format will be set to
  * \ref MMAL_ENCODING_UNKNOWN until the component is fed enough data to determine the format
  * of the output port.
  * When this happens, the client will receive an event on the output port, signalling
  * that its format has changed.
  *
  * \section buf Buffer Headers
  *
  * Buffer headers (\ref MMAL_BUFFER_HEADER_T) are used to exchange data with components.
  * They do not contain the data directly but instead contain a pointer to the data being
  * transferred.
  *
  * Separating the buffer headers from the payload means that the memory for the data can
  * be allocated outside of MMAL (e.g. if it is supplied by an external library) while still
  * providing a consistent way to exchange data between clients and components.
  *
  * Buffer headers are allocated from pools and are reference counted. The refcount
  * will drop when \ref mmal_buffer_header_release is called and the buffer header
  * will be recycled to its pool when it reaches zero.
  * The client can be notified when the buffer header is recycled so that it can recycle the
  * associated payload memory as well.
  *
  * A pool of buffer headers should be created after committing the format of the port. When
  * the format is changed, the minimum and recommended size and number of buffers may change.
  *
  * \note The current number of buffers and their size (\ref MMAL_PORT_T::buffer_num and \ref
  * MMAL_PORT_T::buffer_size) are not modified by MMAL, and must be updated by the client as
  * required after changes to a port's format.
  *
  * \subsection metadata Buffer Metadata
  *
  * The API provides a way for clients or components to associate metadata with buffer headers.
  * A camera component could for example store information like exposure time or focal length
  * as metadata within the buffer header containing the frame just captured.
  * \note This area needs more work
  *
  * \subsection queue Queues of Buffer Headers
  *
  * Queues (\ref MMAL_QUEUE_T) are a facility that allows thread-safe processing of buffer headers
  * from the client. Callbacks triggered by a MMAL component when it sends a buffer header to the
  * client can simply put the buffer in a queue and let the main processing thread of the client
  * get its data from the queue.
  *
  * \subsection pool Pools of Buffer Headers
  *
  * Pools (\ref MMAL_POOL_T) let clients allocate a fixed number of buffer headers, and 
  * a queue (\ref MMAL_QUEUE_T). They are used for buffer header allocation.
  * Optionally a pool can also allocate the payload memory for the client.
  *
  * Pools can also be resized after creation, for example, if the port format is changed leading
  * to a new number or size of buffers being required.
  *
  * \section param Port Parameters
  *
  * Components support setting and getting component specific parameters using
  * \ref mmal_port_parameter_set and \ref mmal_port_parameter_get. Parameters
  * are identified using an integer index; parameter data is binary. See the \ref MMAL_PARAMETER_IDS
  * "Pre-defined MMAL parameter IDs" page for more information on the pre-defined parameters.
  *
  * \section events Port Events
  *
  * Components can generate events on their ports. Events are sent to clients
  * as buffer headers and thus when the client receives a buffer header on one
  * of the component's port it should check if the buffer header is an event
  * and in which case process it and then release it (\ref mmal_buffer_header_release).
  * The reason for transmitting events in-band with the actual data is that it
  * is often very valuable to know exactly when the event happens relative to the
  * the actual data (e.g. with a focus event, from which video frame are we in focus).\n
  * Buffer headers used to transmit events are allocated internally by the framework
  * so it is important to release the buffer headers with \ref mmal_buffer_header_release
  * so the buffer headers make it back to their actual owner.
  *
  * Event buffer headers are allocated when the component is created, based on the
  * minimum number and size of control port buffers set by the component. Component
  * wide events (not port specific) are sent to the control port callback when that
  * port is enabled. Port events are sent to the port callback, the same as data
  * buffers, but the 'cmd' field is non-zero.
  *
  * \section version Versioning
  *
  * The API requires that the MMAL core be the same or more recent version
  * as the components and clients. Clients and components can be older and
  * the API will still work both at compile-time and run-time.
  *
  * \section example Example Code
  *
  * The following code is a simple example on how to do video decoding using MMAL. Note that
  * the code is intended to be clear and illustrate how to use MMAL at its most fundamental
  * level, not necessarily the most efficient way to achieve the same result. Use of opaque
  * images, tunneling and zero-copy inter-processor buffers can all improve the performance
  * or reduce the load.
  *
  * The \ref MmalConnectionUtility "Port Connection Utility" functions can also be used to
  * replace much of the common "boilerplate" code, especially when a pipeline of several
  * components needs to be processed.
  *
  * \code
  * #include <mmal.h>
  * ...
  * static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
  * {
  *    // The decoder is done with the data, just recycle the buffer header into its pool
  *    mmal_buffer_header_release(buffer);
  * }
  * static void output_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
  * {
  *    MMAL_QUEUE_T *queue = (MMAL_QUEUE_T *)port->userdata;
  *    mmal_queue_put(queue, buffer); // Queue the decoded video frame
  * }
  * ...
  *
  * MMAL_COMPONENT_T *decoder = 0;
  * MMAL_STATUS_T status;
  *
  * // Create the video decoder component on VideoCore
  * status = mmal_component_create("vc.ril.video_decoder", &decoder);
  * ABORT_IF_ERROR(status);
  *
  * // Set format of video decoder input port
  * MMAL_ES_FORMAT_T *format_in = decoder->input[0]->format;
  * format_in->type = MMAL_ES_TYPE_VIDEO;
  * format_in->encoding = MMAL_ENCODING_H264;
  * format_in->es->video.width = 1280;
  * format_in->es->video.height = 720;
  * format_in->es->video.frame_rate.num = 30;
  * format_in->es->video.frame_rate.den = 1;
  * format_in->es->video.par.num = 1;
  * format_in->es->video.par.den = 1;
  * format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
  * status = mmal_format_extradata_alloc(format_in, YOUR_H264_CODEC_HEADER_BYTES_SIZE);
  * ABORT_IF_ERROR(status);
  * format_in->extradata_size = YOUR_H264_CODEC_HEADER_BYTES_SIZE;
  * memcpy(format_in->extradata, YOUR_H264_CODEC_HEADER_BYTES, format_in->extradata_size);
  *
  * status = mmal_port_format_commit(decoder->input[0]);
  * ABORT_IF_ERROR(status);
  *
  * // Once the call to mmal_port_format_commit() on the input port returns, the decoder will
  * // have set the format of the output port.
  * // If the decoder still doesn t have enough information to determine the format of the
  * // output port, the encoding will be set to unknown. As soon as the decoder receives
  * // enough stream data to determine the format of the output port it will send an event
  * // to the client to signal that the format of the port has changed.
  * // However, for the sake of simplicity this example assumes that the decoder was given
  * // all the necessary information right at the start (i.e. video format and codec header bytes)
  * MMAL_FORMAT_T *format_out = decoder->output[0]->format;
  * if (format_out->encoding == MMAL_ENCODING_UNKNOWN)
  *    ABORT();
  *
  * // Now we know the format of both ports and the requirements of the decoder, we can create
  * // our buffer headers and their associated memory buffers. We use the buffer pool API for this.
  * decoder->input[0]->buffer_num = decoder->input[0]->buffer_num_min;
  * decoder->input[0]->buffer_size = decoder->input[0]->buffer_size_min;
  * MMAL_POOL_T *pool_in = mmal_pool_create(decoder->input[0]->buffer_num,
  *                                         decoder->input[0]->buffer_size);
  * decoder->output[0]->buffer_num = decoder->output[0]->buffer_num_min;
  * decoder->output[0]->buffer_size = decoder->output[0]->buffer_size_min;
  * MMAL_POOL_T *pool_out = mmal_pool_create(decoder->output[0]->buffer_num,
  *                                          decoder->output[0]->buffer_size);
  *
  * // Create a queue to store our decoded video frames. The callback we will get when
  * // a frame has been decoded will put the frame into this queue.
  * MMAL_QUEUE_T *queue_decoded_frames = mmal_queue_create();
  * decoder->output[0]->userdata = (void)queue_decoded_frames;
  *
  * // Enable all the input port and the output port.
  * // The callback specified here is the function which will be called when the buffer header
  * // we sent to the component has been processed.
  * status = mmal_port_enable(decoder->input[0], input_callback);
  * ABORT_IF_ERROR(status);
  * status = mmal_port_enable(decoder->output[0], output_callback);
  * ABORT_IF_ERROR(status);
  *
  * // Enable the component. Components will only process data when they are enabled.
  * status = mmal_component_enable(decoder);
  * ABORT_IF_ERROR(status);
  *
  * // Data processing loop
  * while (1)
  * {
  *    MMAL_BUFFER_HEADER_T *header;
  *
  *    // The client needs to implement its own blocking code.
  *    // (e.g. a semaphore which is posted when a buffer header is put in one of the queues)
  *    WAIT_FOR_QUEUES_TO_HAVE_BUFFERS();
  *
  *    // Send empty buffers to the output port of the decoder to allow the decoder to start
  *    // producing frames as soon as it gets input data
  *    while ((buffer = mmal_queue_get(pool_out->queue)) != NULL)
  *    {
  *       status = mmal_port_send_buffer(decoder->output[0], buffer);
  *       ABORT_IF_ERROR(status);
  *    }
  *
  *    // Send data to decode to the input port of the video decoder
  *    if ((buffer = mmal_queue_get(pool_in->queue)) != NULL)
  *    {
  *       READ_DATA_INTO_BUFFER(buffer);
  *
  *       status = mmal_port_send_buffer(decoder->input[0], buffer);
  *       ABORT_IF_ERROR(status);
  *    }
  *
  *    // Get our decoded frames. We also need to cope with events
  *    // generated from the component here.
  *    while ((buffer = mmal_queue_get(queue_decoded_frames)) != NULL)
  *    {
  *       if (buffer->cmd)
  *       {
  *          // This is an event. Do something with it and release the buffer.
  *          mmal_buffer_header_release(buffer);
  *          continue;
  *       }
  *
  *       // We have a frame, do something with it (why not display it for instance?).
  *       // Once we're done with it, we release it. It will magically go back
  *       // to its original pool so it can be reused for a new video frame.
  *       mmal_buffer_header_release(buffer);
  *    }
  * }
  *
  * // Cleanup everything
  * mmal_component_destroy(decoder);
  * mmal_pool_destroy(pool_in);
  * mmal_pool_destroy(pool_out);
  * mmal_queue_destroy(queue_decode_frames);
  *
  * \endcode
  */

#include "mmal_common.h"
#include "mmal_types.h"
#include "mmal_port.h"
#include "mmal_component.h"
#include "mmal_parameters.h"
#include "mmal_metadata.h"
#include "mmal_queue.h"
#include "mmal_pool.h"
#include "mmal_events.h"

/**/
/** \name API Version
 * The following define the version number of the API */
/* @{ */
/** Major version number.
 * This changes when the API breaks in a way which is not backward compatible. */
#define MMAL_VERSION_MAJOR 0
/** Minor version number.
 * This changes each time the API is extended in a way which is still source and
 * binary compatible. */
#define MMAL_VERSION_MINOR 1

#define MMAL_VERSION (MMAL_VERSION_MAJOR << 16 | MMAL_VERSION_MINOR)
#define MMAL_VERSION_TO_MAJOR(a) (a >> 16)
#define MMAL_VERSION_TO_MINOR(a) (a & 0xFFFF)
/* @} */

#endif /* MMAL_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/CMakeLists.txt
================
if (EXISTS /opt/vc/include)
    set(HAS_RASPI ON)
else()
    set(HAS_RASPI OFF)
endif()

MJPG_STREAMER_PLUGIN_OPTION(input_raspicam "Raspberry Pi input camera plugin"
                            ONLYIF HAS_RASPI)

if (PLUGIN_INPUT_RASPICAM)

    include_directories(/opt/vc/include)
    include_directories(/opt/vc/include/interface/vcos)
    include_directories(/opt/vc/include/interface/vcos/pthreads)
    include_directories(/opt/vc/include/interface/vmcs_host)
    include_directories(/opt/vc/include/interface/vmcs_host/linux)

    link_directories(/opt/vc/lib)

    MJPG_STREAMER_PLUGIN_COMPILE(input_raspicam input_raspicam.c)

    target_link_libraries(input_raspicam mmal_core mmal_util mmal_vc_client vcos bcm_host)

endif()

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/input_raspicam.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
 *******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <syslog.h>
#include <time.h>

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "../../mjpg_streamer.h"
#include "../../utils.h"

#include "bcm_host.h"
#include "interface/vcos/vcos.h"

#include "mmal/mmal.h"
#include "mmal/util/mmal_default_components.h"
#include "mmal/util/mmal_connection.h"

#include "RaspiCamControl.c"

#define MMAL_CAMERA_PREVIEW_PORT 0
#define MMAL_CAMERA_VIDEO_PORT 1
#define MMAL_CAMERA_CAPTURE_PORT 2
// Stills format information
#define STILLS_FRAME_RATE_NUM 3
#define STILLS_FRAME_RATE_DEN 1
/// Video render needs at least 2 buffers.
#define VIDEO_OUTPUT_BUFFERS_NUM 3

#define INPUT_PLUGIN_NAME "raspicam input plugin"

// Layer that preview window should be displayed on
#define PREVIEW_LAYER      2
// Frames rates of 0 implies variable, but denominator needs to be 1 to prevent div by 0
#define PREVIEW_FRAME_RATE_NUM 0
#define PREVIEW_FRAME_RATE_DEN 1

/* private functions and variables to this plugin */
static pthread_t   worker;
static globals     *pglobal;
static pthread_mutex_t controls_mutex;
static int plugin_number;

void *worker_thread(void *);
void worker_cleanup(void *);
void help(void);

static int fps = 5;
static int width = 640;
static int height = 480;
static int quality = 85;
static int usestills = 0;
static int wantPreview = 0;
static int wantTimestamp = 0;
static RASPICAM_CAMERA_PARAMETERS c_params;

static struct timeval timestamp;

/** Struct used to pass information in encoder port userdata to callback
 */
typedef struct
{
  FILE *file_handle; /// File handle to write buffer data to.
  VCOS_SEMAPHORE_T complete_semaphore; /// semaphore which is posted when we reach end of frame (indicates end of capture or fault)
  MMAL_POOL_T *pool; /// pointer to our state in case required in callback
  uint32_t offset;
} PORT_USERDATA;



/*** plugin interface functions ***/

/******************************************************************************
  Description.: parse input parameters
  Input Value.: param contains the command line string and a pointer to globals
  Return Value: 0 if everything is ok
 ******************************************************************************/
int input_init(input_parameter *param, int plugin_no)
{
  int i;
  if (pthread_mutex_init(&controls_mutex, NULL) != 0)
  {
    IPRINT("could not initialize mutex variable\n");
    exit(EXIT_FAILURE);
  }

  param->argv[0] = INPUT_PLUGIN_NAME;
  plugin_number = plugin_no;

  //setup the camera control st
  raspicamcontrol_set_defaults(&c_params);

  /* show all parameters for DBG purposes */
  for (i = 0; i < param->argc; i++)
  {
    DBG("argv[%d]=%s\n", i, param->argv[i]);
  }

  reset_getopt();
  while(1) {
    int option_index = 0, c = 0;
    static struct option long_options[] = {
      {"h", no_argument, 0, 0},                       // 0
      {"help", no_argument, 0, 0},                    // 1
      {"x", required_argument, 0, 0},                 // 2
      {"width", required_argument, 0, 0},             // 3
      {"y", required_argument, 0, 0},                 // 4
      {"height", required_argument, 0, 0},            // 5
      {"fps", required_argument, 0, 0},               // 6
      {"framerate", required_argument, 0, 0},         // 7
      {"sh", required_argument, 0, 0},                // 8
      {"co", required_argument, 0, 0},                // 9
      {"br", required_argument, 0, 0},                // 10
      {"sa", required_argument, 0, 0},                // 11
      {"ISO", required_argument, 0, 0},               // 12
      {"vs", no_argument, 0, 0},                      // 13
      {"ev", required_argument, 0, 0},                // 14
      {"ex", required_argument, 0, 0},                // 15
      {"awb", required_argument, 0, 0},               // 16
      {"ifx", required_argument, 0, 0},               // 17
      {"cfx", required_argument, 0, 0},               // 18
      {"mm", required_argument, 0, 0},                // 19
      {"rot", required_argument, 0, 0},               // 20
      {"hf", no_argument, 0, 0},                      // 21
      {"vf", no_argument, 0, 0},                      // 22
      {"quality", required_argument, 0, 0},           // 23
      {"usestills", no_argument, 0, 0},               // 24
      {"preview", no_argument, 0, 0},                 // 25
      {"timestamp", no_argument, 0, 0},               // 26
      {"stats", no_argument, 0, 0},                   // 27
      {"drc", required_argument, 0, 0},               // 28
      {"shutter", required_argument, 0, 0},           // 29
      {"awbgainR", required_argument, 0, 0},          // 30
      {"awbgainB", required_argument, 0, 0},          // 31
      {"roi", required_argument, 0, 0},               // 32
      {0, 0, 0, 0}
    };

    c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

    /* no more options to parse */
    if(c == -1)
      break;

    /* unrecognized option */
    if (c == '?')
    {
      help();
      return 1;
    }

    switch(option_index) {
      /* h, help */
      case 0:
      case 1:
        DBG("case 0,1\n");
        help();
        return 1;
        break;
        /* width */
      case 2:
      case 3:
        DBG("case 2,3\n");
        width = atoi(optarg);
        break;
        /* height */
      case 4:
      case 5:
        DBG("case 4,5\n");
        height = atoi(optarg);
        break;
        /* fps */
      case 6:
      case 7:
        DBG("case 6, 7\n");
        fps = atoi(optarg);
        break;
      case 8:
        //sharpness
        sscanf(optarg, "%d", &c_params.sharpness);
        break;
      case 9:
        //contrast
        sscanf(optarg, "%d", &c_params.contrast);
        break;
      case 10:
        //brightness
        sscanf(optarg, "%d", &c_params.brightness);
        break;
      case 11:
        //saturation
        sscanf(optarg, "%d", &c_params.saturation);
        break;
      case 12:
        //ISO
        sscanf(optarg, "%d", &c_params.ISO);
        break;
      case 13:
        //video stabilisation
        c_params.videoStabilisation = 1;
        break;
      case 14:
        //ev
        sscanf(optarg, "%d", &c_params.exposureCompensation);
        break;
      case 15:
        //exposure
        c_params.exposureMode = exposure_mode_from_string(optarg);
        break;
      case 16:
        //awb mode
        c_params.awbMode = awb_mode_from_string(optarg);
        break;
      case 17:
        //img effect
        c_params.imageEffect = imagefx_mode_from_string(optarg);
        break;
      case 18:
        //color effects
        sscanf(optarg, "%d:%d", &c_params.colourEffects.u, &c_params.colourEffects.v);
        c_params.colourEffects.enable = 1;
        break;
      case 19:
        //metering mode
        c_params.exposureMeterMode = metering_mode_from_string(optarg);
        break;
      case 20:
        //rotation
        sscanf(optarg, "%d", &c_params.rotation);
        break;
      case 21:
        //hflip
        c_params.hflip  = 1;
        break;
      case 22:
        //vflip
        c_params.vflip = 1;
        break;
      case 23:
        //quality
        quality = atoi(optarg);
        break;
      case 24:
        //use stills
        usestills = 1;
        break;
      case 25:
        //display preview
        wantPreview = 1;
        break;
      case 26:
        //timestamp
        wantTimestamp = 1;
        break;
      case 27:
        // use stats
        c_params.stats_pass = MMAL_TRUE;
        break;
      case 28:
        // Dynamic Range Compensation DRC
        c_params.drc_level = drc_mode_from_string(optarg);
        break;
      case 29:
        // shutter speed in microseconds
        sscanf(optarg, "%d", &c_params.shutter_speed);
        break;
      case 30:
        // awb gain red
        sscanf(optarg, "%f", &c_params.awb_gains_r);
        break;
      case 31:
        // awb gain blue
        sscanf(optarg, "%f", &c_params.awb_gains_b);
        break;
      case 32:
        // roi
        sscanf(optarg, "%lf,%lf,%lf,%lf", &c_params.roi.x, &c_params.roi.y, &c_params.roi.w, &c_params.roi.h);
        break;
      default:
        DBG("default case\n");
        help();
        return 1;
    }
  }

  pglobal = param->global;

  IPRINT("fps.............: %i\n", fps);
  IPRINT("resolution........: %i x %i\n", width, height);
  IPRINT("camera parameters..............:\n\n");
  raspicamcontrol_dump_parameters(&c_params);

  return 0;
}

/******************************************************************************
  Description.: stops the execution of the worker thread
  Input Value.: -
  Return Value: 0
 ******************************************************************************/
int input_stop(int id)
{
  DBG("will cancel input thread\n");
  pthread_cancel(worker);

  return 0;
}

/**************************************************
  Print which status
 **************************************************/
void print_mmal_status(MMAL_STATUS_T status)
{
  if (status != MMAL_SUCCESS)
  {
    switch (status)
    {
      case MMAL_ENOMEM : DBG("Out of memory\n"); break;
      case MMAL_ENOSPC : DBG("Out of resources (other than memory)\n"); break;
      case MMAL_EINVAL: DBG("Argument is invalid\n"); break;
      case MMAL_ENOSYS : DBG("Function not implemented\n"); break;
      case MMAL_ENOENT : DBG("No such file or directory\n"); break;
      case MMAL_ENXIO : DBG("No such device or address\n"); break;
      case MMAL_EIO : DBG("I/O error\n"); break;
      case MMAL_ESPIPE : DBG("Illegal seek\n"); break;
      case MMAL_ECORRUPT : DBG("Data is corrupt \attention FIXME: not POSIX\n"); break;
      case MMAL_ENOTREADY :DBG("Component is not ready \attention FIXME: not POSIX\n"); break;
      case MMAL_ECONFIG : DBG("Component is not configured \attention FIXME: not POSIX\n"); break;
      case MMAL_EISCONN : DBG("Port is already connected\n"); break;
      case MMAL_ENOTCONN : DBG("Port is disconnected\n"); break;
      case MMAL_EAGAIN : DBG("Resource temporarily unavailable. Try again later\n"); break;
      case MMAL_EFAULT : DBG("Bad address\n"); break;
      default : DBG("Unknown status error\n"); break;
    }
  }
}

/******************************************************************************
  Callback from mmal JPEG encoder
 ******************************************************************************/
static void encoder_buffer_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
  int complete = 0;

  // We pass our file handle and other stuff in via the userdata field.
  PORT_USERDATA *pData = (PORT_USERDATA *)port->userdata;

  if (pData)
  {
    if (buffer->length)
    {
      mmal_buffer_header_mem_lock(buffer);

      //fprintf(stderr, "The flags are %x of length %i offset %i\n", buffer->flags, buffer->length, pData->offset);

      //Write bytes
      /* copy JPG picture to global buffer */
      if(pData->offset == 0)
        pthread_mutex_lock(&pglobal->in[plugin_number].db);

      memcpy(pData->offset + pglobal->in[plugin_number].buf, buffer->data, buffer->length);
      pData->offset += buffer->length;
      //fwrite(buffer->data, 1, buffer->length, pData->file_handle);
      mmal_buffer_header_mem_unlock(buffer);
    }

    // Now flag if we have completed
    if (buffer->flags & (MMAL_BUFFER_HEADER_FLAG_FRAME_END | MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED))
    {
      //set frame size
      pglobal->in[plugin_number].size = pData->offset;

      //Set frame timestamp
      if(wantTimestamp)
      {
        gettimeofday(&timestamp, NULL);
        pglobal->in[plugin_number].timestamp = timestamp;
      }

      //mark frame complete
      complete = 1;

      pData->offset = 0;
      /* signal fresh_frame */
      pthread_cond_broadcast(&pglobal->in[plugin_number].db_update);
      pthread_mutex_unlock(&pglobal->in[plugin_number].db);
    }
  }
  else
  {
    DBG("Received a encoder buffer callback with no state\n");
  }

  // release buffer back to the pool
  mmal_buffer_header_release(buffer);

  // and send one back to the port (if still open)
  if (port->is_enabled)
  {
    MMAL_STATUS_T status;
    MMAL_BUFFER_HEADER_T *new_buffer;

    new_buffer = mmal_queue_get(pData->pool->queue);

    if (new_buffer)
    {
      status = mmal_port_send_buffer(port, new_buffer);

      if(status != MMAL_SUCCESS)
      {
        DBG("Failed returning a buffer to the encoder port \n");
        print_mmal_status(status);
      }

    }
    else
    {
      DBG("Unable to return a buffer to the encoder port\n");
    }

  }

  if (complete)
    vcos_semaphore_post(&(pData->complete_semaphore));

}

/**
 * buffer header callback function for camera control
 *
 * No actions taken in current version
 *
 * @param port Pointer to port from which callback originated
 * @param buffer mmal buffer header pointer
 */
static void camera_control_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
  if (buffer->cmd == MMAL_EVENT_PARAMETER_CHANGED)
  {
  }
  else
  {
    DBG("Received unexpected camera control callback event");
  }

  mmal_buffer_header_release(buffer);
}

/******************************************************************************
  Description.: starts the worker thread and allocates memory
  Input Value.: -
  Return Value: 0
 ******************************************************************************/
int input_run(int id)
{
  pglobal->in[id].buf = malloc(width * height * 3);
  if (pglobal->in[id].buf == NULL)
  {
    fprintf(stderr, "could not allocate memory\n");
    exit(EXIT_FAILURE);
  }

  if (pthread_create(&worker, 0, worker_thread, NULL) != 0)
  {
    free(pglobal->in[id].buf);
    fprintf(stderr, "could not start worker thread\n");
    exit(EXIT_FAILURE);
  }
  pthread_detach(worker);

  return 0;
}

/**
 * Connect two specific ports together
 *
 * @param output_port Pointer the output port
 * @param input_port Pointer the input port
 * @param Pointer to a mmal connection pointer, reassigned if function successful
 * @return Returns a MMAL_STATUS_T giving result of operation
 *
 */
static MMAL_STATUS_T connect_ports(MMAL_PORT_T *output_port, MMAL_PORT_T *input_port, MMAL_CONNECTION_T **connection)
{
  MMAL_STATUS_T status;

  status = mmal_connection_create(connection, output_port, input_port, MMAL_CONNECTION_FLAG_TUNNELLING | MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT);

  if (status == MMAL_SUCCESS)
  {
    status = mmal_connection_enable(*connection);
    if (status != MMAL_SUCCESS)
    {
      mmal_connection_destroy(*connection);
      DBG("Error enabling mmal connection\n");
    }
  } else {
    DBG("Error creating mmal connection\n");
  }

  return status;
}


/******************************************************************************
  Description.: print help message
  Input Value.: -
  Return Value: -
 ******************************************************************************/
void help(void)
{
  fprintf(stderr, " ---------------------------------------------------------------\n" \
      " Help for input plugin..: "INPUT_PLUGIN_NAME"\n" \
      " ---------------------------------------------------------------\n" \
      " The following parameters can be passed to this plugin:\n\n" \
      " [-fps | --framerate]...: set video framerate, default 5 frame/sec \n"\
      " [-x | --width ]........: width of frame capture, default 640\n" \
      " [-y | --height]........: height of frame capture, default 480 \n"\
      " [-quality].............: set JPEG quality 0-100, default 85 \n"\
      " [-usestills]...........: uses stills mode instead of video mode \n"\
      " [-preview].............: Enable full screen preview\n"\
      " [-timestamp]...........: Get timestamp for each frame\n"
      " \n"\
      " -sh  : Set image sharpness (-100 to 100)\n"\
      " -co  : Set image contrast (-100 to 100)\n"\
      " -br  : Set image brightness (0 to 100)\n"\
      " -sa  : Set image saturation (-100 to 100)\n"\
      " -ISO : Set capture ISO\n"\
      " -vs  : Turn on video stablisation\n"\
      " -ev  : Set EV compensation\n"\
      " -ex  : Set exposure mode (see raspistill notes)\n"\
      " -awb : Set AWB mode (see raspistill notes)\n"\
      " -ifx : Set image effect (see raspistill notes)\n"\
      " -cfx : Set colour effect (U:V)\n"\
      " -mm  : Set metering mode (see raspistill notes)\n"\
      " -rot : Set image rotation (0-359)\n"\
      " -stats : Compute image stats for each picture (reduces noise for -usestills)\n"\
      " -drc : Dynamic range compensation level (see raspistill notes)\n"\
      " -hf  : Set horizontal flip\n"\
      " -vf  : Set vertical flip\n"\
      " ---------------------------------------------------------------\n");

}

/******************************************************************************
  Description.: setup mmal and callback
  Input Value.: arg is not used
  Return Value: NULL
 ******************************************************************************/
void *worker_thread(void *arg)
{
  int i = 0;

  /* set cleanup handler to cleanup allocated resources */
  pthread_cleanup_push(worker_cleanup, NULL);
  //Lets not let this thread be cancelled, it needs to clean up mmal on exit
  if (pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL) != 0)
  {
    fprintf(stderr, "Unable to set cancel state\n");
    exit(EXIT_FAILURE);
  }

  IPRINT("Starting Camera\n");

  //Camera variables
  MMAL_COMPONENT_T *camera = 0;
  MMAL_COMPONENT_T *preview = 0;
  MMAL_ES_FORMAT_T *format;
  MMAL_STATUS_T status;
  MMAL_PORT_T *camera_preview_port = NULL;
  MMAL_PORT_T *camera_video_port = NULL;
  MMAL_PORT_T *camera_still_port = NULL;
  MMAL_PORT_T *preview_input_port = NULL;

  MMAL_CONNECTION_T *camera_preview_connection = 0;

  //Encoder variables
  MMAL_COMPONENT_T *encoder = 0;
  MMAL_PORT_T *encoder_input = NULL;
  MMAL_PORT_T *encoder_output = NULL;
  MMAL_POOL_T *pool;
  MMAL_CONNECTION_T *encoder_connection;

  //fps count
  struct timespec t_start, t_finish;
  double t_elapsed;
  int frames;

  //Create camera code
  bcm_host_init();
  DBG("Host init, starting mmal stuff\n");

  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_CAMERA, &camera);
  if (status != MMAL_SUCCESS)
  {
    fprintf(stderr, "error create camera\n");
    exit(EXIT_FAILURE);
  }

  if (!camera->output_num)
  {
    fprintf(stderr, "Camera doesn't have output ports\n");
    mmal_component_destroy(camera);
    exit(EXIT_FAILURE);
  }

  camera_preview_port = camera->output[MMAL_CAMERA_PREVIEW_PORT];
  camera_video_port = camera->output[MMAL_CAMERA_VIDEO_PORT];
  camera_still_port = camera->output[MMAL_CAMERA_CAPTURE_PORT];

  //Enable camera control port
  // Enable the camera, and tell it its control callback function
  status = mmal_port_enable(camera->control, camera_control_callback);

  if (status)
  {
    fprintf(stderr, "Unable to enable camera port\n");
    mmal_component_destroy(camera);
    exit(EXIT_FAILURE);
  }


  {
    MMAL_PARAMETER_CAMERA_CONFIG_T cam_config = {
      { MMAL_PARAMETER_CAMERA_CONFIG, sizeof (cam_config)},
      .max_stills_w = width,
      .max_stills_h = height,
      .stills_yuv422 = 0,
      .one_shot_stills = (usestills ? 1 : 0),
      .max_preview_video_w = width,
      .max_preview_video_h = height,
      .num_preview_video_frames = 3,
      .stills_capture_circular_buffer_height = 0,
      .fast_preview_resume = 0,
      .use_stc_timestamp = MMAL_PARAM_TIMESTAMP_MODE_RESET_STC
    };
    mmal_port_parameter_set(camera->control, &cam_config.hdr);
  }

  //Set camera parameters
  if (raspicamcontrol_set_all_parameters(camera, &c_params))
    fprintf(stderr, "camera parameters couldn't be set\n");

  // Set the encode format on the Preview port

  format = camera_preview_port->format;
  format->encoding = MMAL_ENCODING_OPAQUE;
  format->es->video.width = VCOS_ALIGN_UP(width, 32);
  format->es->video.height = VCOS_ALIGN_UP(height, 16);
  format->es->video.crop.x = 0;
  format->es->video.crop.y = 0;
  format->es->video.crop.width = width;
  format->es->video.crop.height = height;
  format->es->video.frame_rate.num = PREVIEW_FRAME_RATE_NUM;
  format->es->video.frame_rate.den = PREVIEW_FRAME_RATE_DEN;

  status = mmal_port_format_commit(camera_preview_port);

  // Create preview component
  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER, &preview);

  if (status != MMAL_SUCCESS)
  {
    fprintf(stderr, "Unable to create preview component\n");
    exit(EXIT_FAILURE);
  }

  if (!preview->input_num)
  {
    status = MMAL_ENOSYS;
    fprintf(stderr, "No input ports found on preview component");
    exit(EXIT_FAILURE);
  }

  preview_input_port = preview->input[0];

  MMAL_DISPLAYREGION_T param;
  param.hdr.id = MMAL_PARAMETER_DISPLAYREGION;
  param.hdr.size = sizeof(MMAL_DISPLAYREGION_T);

  param.set = MMAL_DISPLAY_SET_LAYER;
  param.layer = PREVIEW_LAYER;

  param.set |= MMAL_DISPLAY_SET_ALPHA;
  param.alpha = 255;

  param.set |= MMAL_DISPLAY_SET_FULLSCREEN;
  param.fullscreen = 1;

  status = mmal_port_parameter_set(preview_input_port, &param.hdr);

  if (status != MMAL_SUCCESS && status != MMAL_ENOSYS)
  {
   fprintf(stderr, "unable to set preview port parameters (%u)", status);
   exit(EXIT_FAILURE);
  }

  if (!usestills)
  {
    // Set the encode format on the video port
    format = camera_video_port->format;
    format->encoding_variant = MMAL_ENCODING_I420;
    format->encoding = MMAL_ENCODING_I420;
    format->es->video.width = width;
    format->es->video.height = height;
    format->es->video.crop.x = 0;
    format->es->video.crop.y = 0;
    format->es->video.crop.width = width;
    format->es->video.crop.height = height;
    format->es->video.frame_rate.num = fps;
    format->es->video.frame_rate.den = 1;
    status = mmal_port_format_commit(camera_video_port);
    if (status)
      fprintf(stderr, "camera video format couldn't be set");

    // Ensure there are enough buffers to avoid dropping frames
    if (camera_video_port->buffer_num < VIDEO_OUTPUT_BUFFERS_NUM)
      camera_video_port->buffer_num = VIDEO_OUTPUT_BUFFERS_NUM;
  }

  format = camera_still_port->format;

  // Set our stills format on the stills (for encoder) port
  format->encoding = MMAL_ENCODING_OPAQUE;
  format->es->video.width = width;
  format->es->video.height = height;
  format->es->video.crop.x = 0;
  format->es->video.crop.y = 0;
  format->es->video.crop.width = width;
  format->es->video.crop.height = height;
  format->es->video.frame_rate.num = STILLS_FRAME_RATE_NUM;
  format->es->video.frame_rate.den = STILLS_FRAME_RATE_DEN;

  status = mmal_port_format_commit(camera_still_port);

  if (status)
  {
    fprintf(stderr, "format couldn't be set\n");
    mmal_component_destroy(camera);
    exit(EXIT_FAILURE);
  }

  /* Ensure there are enough buffers to avoid dropping frames */
  if (camera_still_port->buffer_num < VIDEO_OUTPUT_BUFFERS_NUM)
    camera_still_port->buffer_num = VIDEO_OUTPUT_BUFFERS_NUM;


  /* Enable component */
  status = mmal_component_enable(camera);
  if (status)
  {
    fprintf(stderr, "camera couldn't be enabled\n");
    mmal_component_destroy(camera);
    exit(EXIT_FAILURE);
  }

  /* Enable component */
  status = mmal_component_enable(preview);
  if (status != MMAL_SUCCESS)
  {
    fprintf(stderr, "Unable to enable preview/null sink component (%u)\n", status);
    mmal_component_destroy(preview);
    mmal_component_destroy(camera);
    exit(EXIT_FAILURE);
  }

  DBG("Camera enabled, creating encoder\n");

  //Create Encoder
  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER, &encoder);

  if (status != MMAL_SUCCESS)
  {
    fprintf(stderr, "Unable to create JPEG encoder component\n");
    mmal_component_destroy(camera);
    if (encoder)
      mmal_component_destroy(encoder);
    exit(EXIT_FAILURE);
  }

  if (!encoder->input_num || !encoder->output_num)
  {
    fprintf(stderr, "Unable to create JPEG encoder input/output ports\n");
    mmal_component_destroy(camera);
    if (encoder)
      mmal_component_destroy(encoder);
    exit(EXIT_FAILURE);
  }

  encoder_input = encoder->input[0];
  encoder_output = encoder->output[0];

  // We want same format on input and output
  mmal_format_copy(encoder_output->format, encoder_input->format);

  // Specify out output format JPEG
  encoder_output->format->encoding = MMAL_ENCODING_JPEG;

  encoder_output->buffer_size = encoder_output->buffer_size_recommended;


  if (encoder_output->buffer_size < encoder_output->buffer_size_min)
    encoder_output->buffer_size = encoder_output->buffer_size_min;

  fprintf(stderr,"Encoder Buffer Size %i\n", encoder_output->buffer_size);

  encoder_output->buffer_num = encoder_output->buffer_num_recommended;

  if (encoder_output->buffer_num < encoder_output->buffer_num_min)
    encoder_output->buffer_num = encoder_output->buffer_num_min;

  // Commit the port changes to the output port
  status = mmal_port_format_commit(encoder_output);

  if (status != MMAL_SUCCESS)
  {
    fprintf(stderr, "Unable to set video format output ports\n");
    mmal_component_destroy(camera);
    if (encoder)
      mmal_component_destroy(encoder);
    exit(EXIT_FAILURE);
  }

  // Set the JPEG quality level
  status = mmal_port_parameter_set_uint32(encoder_output, MMAL_PARAMETER_JPEG_Q_FACTOR, quality);

  if (status != MMAL_SUCCESS)
  {
    fprintf(stderr, "Unable to set JPEG quality\n");
    mmal_component_destroy(camera);
    if (encoder)
      mmal_component_destroy(encoder);
    exit(EXIT_FAILURE);
  }


  // Enable encoder component
  status = mmal_component_enable(encoder);

  if (status)
  {
    fprintf(stderr, "Unable to enable encoder component\n");
    mmal_component_destroy(camera);
    if (encoder)
      mmal_component_destroy(encoder);
    exit(EXIT_FAILURE);
  }


  DBG("Encoder enabled, creating pool and connecting ports\n");

  /* Create pool of buffer headers for the output port to consume */
  pool = mmal_port_pool_create(encoder_output, encoder_output->buffer_num, encoder_output->buffer_size);

  if (!pool)
  {
    fprintf(stderr, "Failed to create buffer header pool for encoder output port\n");
    mmal_component_destroy(camera);
    if (encoder)
      mmal_component_destroy(encoder);
    exit(EXIT_FAILURE);
  }

  if (wantPreview)
  {
    // Connect camera to preview
    status = connect_ports(camera_preview_port, preview_input_port, &camera_preview_connection);

    if (status != MMAL_SUCCESS)
      camera_preview_connection = NULL;
  }

  // Now connect the camera to the encoder
  if(usestills){
    status = connect_ports(camera_still_port, encoder->input[0], &encoder_connection);
  } else {
    status = connect_ports(camera_video_port, encoder->input[0], &encoder_connection);
  }

  if (status)
  {
    fprintf(stderr, "Unable to connect components\n");
    if (camera_preview_connection)
      mmal_connection_destroy(camera_preview_connection);
    if (preview)
      mmal_component_destroy(preview);
    mmal_component_destroy(camera);
    if (encoder)
      mmal_component_destroy(encoder);
    exit(EXIT_FAILURE);
  }

  // Set up our userdata - this is passed though to the callback where we need the information.
  // Null until we open our filename
  PORT_USERDATA callback_data;
  callback_data.file_handle = NULL;
  callback_data.pool = pool;
  callback_data.offset = 0;

  vcos_assert(vcos_semaphore_create(&callback_data.complete_semaphore, "RaspiStill-sem", 0) == VCOS_SUCCESS);

  encoder->output[0]->userdata = (struct MMAL_PORT_USERDATA_T *)&callback_data;



  // Enable the encoder output port and tell it its callback function
  status = mmal_port_enable(encoder->output[0], encoder_buffer_callback);
  if (status)
  {
    fprintf(stderr, "Unable to enable encoder component\n");
    mmal_component_destroy(camera);
    if (encoder)
      mmal_component_destroy(encoder);
    exit(EXIT_FAILURE);
  }

  if(usestills){
    DBG("Starting stills output\n");

    //setup fps
    clock_gettime(CLOCK_MONOTONIC, &t_start);
    frames = 0;
    int delay = (1000 * 1000) / fps;

    while(!pglobal->stop) {
      //Wait the delay
      usleep(delay);

      // Send all the buffers to the encoder output port
      int num = mmal_queue_length(pool->queue);
      int q;
      for (q=0;q<num;q++)
      {
        MMAL_BUFFER_HEADER_T *buffer = mmal_queue_get(pool->queue);

        if (!buffer)
          fprintf(stderr, "Unable to get a required buffer from pool queue");

        if (mmal_port_send_buffer(encoder->output[0], buffer)!= MMAL_SUCCESS)
          fprintf(stderr, "Unable to send a buffer to encoder output port");
      }

      if (mmal_port_parameter_set_boolean(camera_still_port, MMAL_PARAMETER_CAPTURE, 1) != MMAL_SUCCESS)
      {
        fprintf(stderr, "starting captue failed");
      }
      else
      {
        // Wait for capture to complete
        // For some reason using vcos_semaphore_wait_timeout sometimes returns immediately with bad parameter error
        // even though it appears to be all correct, so reverting to untimed one until figure out why its erratic
        vcos_semaphore_wait(&callback_data.complete_semaphore);
        //DBG("Jpeg Captured\n");
        frames++;
      }

      frames++;
      if (frames == 100)
      {
        //calculate fps
        clock_gettime(CLOCK_MONOTONIC, &t_finish);
        t_elapsed = (t_finish.tv_sec - t_start.tv_sec);
        t_elapsed += (t_finish.tv_nsec - t_start.tv_nsec) / 1000000000.0;
        fprintf(stderr, "%i frames captured in %f seconds (%f fps)\n", frames, t_elapsed, (frames / t_elapsed));
        frames = 0;
        clock_gettime(CLOCK_MONOTONIC, &t_start);
      }
    }

  }
  else
  { //if(usestills)
    //Video Mode
    DBG("Starting video output\n");
    // Send all the buffers to the encoder output port
    int num = mmal_queue_length(pool->queue);
    int q;
    for (q=0;q<num;q++)
    {
      MMAL_BUFFER_HEADER_T *buffer = mmal_queue_get(pool->queue);
      if (!buffer)
        fprintf(stderr, "Unable to get a required buffer from pool queue");
      if (mmal_port_send_buffer(encoder->output[0], buffer)!= MMAL_SUCCESS)
        fprintf(stderr, "Unable to send a buffer to encoder output port");
    }
    if (mmal_port_parameter_set_boolean(camera_video_port, MMAL_PARAMETER_CAPTURE, 1) != MMAL_SUCCESS)
      fprintf(stderr, "starting capture failed");

    while(!pglobal->stop) usleep(1000);
  }

  vcos_semaphore_delete(&callback_data.complete_semaphore);

  //Close everything MMAL
  if (usestills)
  {
    if (camera_video_port && camera_video_port->is_enabled)
      mmal_port_disable(camera_video_port);
  }
  else
  {
    if (camera_still_port && camera_still_port->is_enabled)
      mmal_port_disable(camera_still_port);
  }
  if (camera_preview_connection)
    mmal_connection_destroy(camera_preview_connection);

  if (encoder->output[0] && encoder->output[0]->is_enabled)
    mmal_port_disable(encoder->output[0]);

  mmal_connection_destroy(encoder_connection);

  // Disable components
  if (encoder)
    mmal_component_disable(encoder);
  if (preview)
    mmal_component_disable(preview);
  if (camera)
    mmal_component_disable(camera);

  //Destroy encoder component
  // Get rid of any port buffers first
  if (pool)
  {
    mmal_port_pool_destroy(encoder->output[0], pool);
  }

  if (encoder)
  {
    mmal_component_destroy(encoder);
    encoder = NULL;
  }
  if (preview)
  {
    mmal_component_destroy(preview);
    preview = NULL;
  }
  //destroy camera component
  if (camera)
  {
    mmal_component_destroy(camera);
    camera = NULL;
  }

  DBG("mmal cleanup done\n");
  pthread_cleanup_pop(1);

  return NULL;
}

/******************************************************************************
  Description.: this functions cleans up allocated resources
  Input Value.: arg is unused
  Return Value: -
 ******************************************************************************/
void worker_cleanup(void *arg)
{
  static unsigned char first_run = 1;

  if (!first_run)
  {
    DBG("already cleaned up resources\n");
    return;
  }

  first_run = 0;
  DBG("cleaning up resources allocated by input thread\n");

  if(pglobal->in[plugin_number].buf != NULL)
    free(pglobal->in[plugin_number].buf);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c
================
/*
Copyright (c) 2013, Broadcom Europe Ltd
Copyright (c) 2013, James Hughes
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <stdio.h>
#include <memory.h>

#include "interface/vcos/vcos.h"

#include "interface/vmcs_host/vc_vchi_gencmd.h"
#include "mmal/mmal.h"
//#include "mmal/mmal_logging.h"
//#include "mmal/util/mmal_util.h"
//#include "mmal/util/mmal_util_params.h"
#include "mmal/util/mmal_default_components.h"
#include "RaspiCamControl.h"

/// Cross reference structure, mode string against mode id
typedef struct xref_t
{
   char *mode;
   int mmal_mode;
} XREF_T;

typedef struct
{
   int id;
   char *command;
   char *abbrev;
   char *help;
   int num_parameters;
} COMMAND_LIST;

/// Structure to cross reference exposure strings against the MMAL parameter equivalent
static XREF_T  exposure_map[] =
{
   {"off",           MMAL_PARAM_EXPOSUREMODE_OFF},
   {"auto",          MMAL_PARAM_EXPOSUREMODE_AUTO},
   {"night",         MMAL_PARAM_EXPOSUREMODE_NIGHT},
   {"nightpreview",  MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW},
   {"backlight",     MMAL_PARAM_EXPOSUREMODE_BACKLIGHT},
   {"spotlight",     MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT},
   {"sports",        MMAL_PARAM_EXPOSUREMODE_SPORTS},
   {"snow",          MMAL_PARAM_EXPOSUREMODE_SNOW},
   {"beach",         MMAL_PARAM_EXPOSUREMODE_BEACH},
   {"verylong",      MMAL_PARAM_EXPOSUREMODE_VERYLONG},
   {"fixedfps",      MMAL_PARAM_EXPOSUREMODE_FIXEDFPS},
   {"antishake",     MMAL_PARAM_EXPOSUREMODE_ANTISHAKE},
   {"fireworks",     MMAL_PARAM_EXPOSUREMODE_FIREWORKS}
};

static const int exposure_map_size = sizeof(exposure_map) / sizeof(exposure_map[0]);

/// Structure to cross reference awb strings against the MMAL parameter equivalent
static XREF_T awb_map[] =
{
   {"off",           MMAL_PARAM_AWBMODE_OFF},
   {"auto",          MMAL_PARAM_AWBMODE_AUTO},
   {"sun",           MMAL_PARAM_AWBMODE_SUNLIGHT},
   {"cloud",         MMAL_PARAM_AWBMODE_CLOUDY},
   {"shade",         MMAL_PARAM_AWBMODE_SHADE},
   {"tungsten",      MMAL_PARAM_AWBMODE_TUNGSTEN},
   {"fluorescent",   MMAL_PARAM_AWBMODE_FLUORESCENT},
   {"incandescent",  MMAL_PARAM_AWBMODE_INCANDESCENT},
   {"flash",         MMAL_PARAM_AWBMODE_FLASH},
   {"horizon",       MMAL_PARAM_AWBMODE_HORIZON}
};

static const int awb_map_size = sizeof(awb_map) / sizeof(awb_map[0]);

/// Structure to cross reference image effect against the MMAL parameter equivalent
static XREF_T imagefx_map[] =
{
   {"none",          MMAL_PARAM_IMAGEFX_NONE},
   {"negative",      MMAL_PARAM_IMAGEFX_NEGATIVE},
   {"solarise",      MMAL_PARAM_IMAGEFX_SOLARIZE},
   {"sketch",        MMAL_PARAM_IMAGEFX_SKETCH},
   {"denoise",       MMAL_PARAM_IMAGEFX_DENOISE},
   {"emboss",        MMAL_PARAM_IMAGEFX_EMBOSS},
   {"oilpaint",      MMAL_PARAM_IMAGEFX_OILPAINT},
   {"hatch",         MMAL_PARAM_IMAGEFX_HATCH},
   {"gpen",          MMAL_PARAM_IMAGEFX_GPEN},
   {"pastel",        MMAL_PARAM_IMAGEFX_PASTEL},
   {"watercolour",   MMAL_PARAM_IMAGEFX_WATERCOLOUR},
   {"film",          MMAL_PARAM_IMAGEFX_FILM},
   {"blur",          MMAL_PARAM_IMAGEFX_BLUR},
   {"saturation",    MMAL_PARAM_IMAGEFX_SATURATION},
   {"colourswap",    MMAL_PARAM_IMAGEFX_COLOURSWAP},
   {"washedout",     MMAL_PARAM_IMAGEFX_WASHEDOUT},
   {"posterise",     MMAL_PARAM_IMAGEFX_POSTERISE},
   {"colourpoint",   MMAL_PARAM_IMAGEFX_COLOURPOINT},
   {"colourbalance", MMAL_PARAM_IMAGEFX_COLOURBALANCE},
   {"cartoon",       MMAL_PARAM_IMAGEFX_CARTOON}
 };

static const int imagefx_map_size = sizeof(imagefx_map) / sizeof(imagefx_map[0]);

static XREF_T metering_mode_map[] =
{
   {"average",       MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE},
   {"spot",          MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT},
   {"backlit",       MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT},
   {"matrix",        MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX}
};

static const int metering_mode_map_size = sizeof(metering_mode_map)/sizeof(metering_mode_map[0]);

static XREF_T drc_mode_map[] =
{
   {"off",           MMAL_PARAMETER_DRC_STRENGTH_OFF},
   {"low",           MMAL_PARAMETER_DRC_STRENGTH_LOW},
   {"med",           MMAL_PARAMETER_DRC_STRENGTH_MEDIUM},
   {"high",          MMAL_PARAMETER_DRC_STRENGTH_HIGH}
};

static const int drc_mode_map_size = sizeof(drc_mode_map)/sizeof(drc_mode_map[0]);

static XREF_T stereo_mode_map[] =
{
   {"off",           MMAL_STEREOSCOPIC_MODE_NONE},
   {"sbs",           MMAL_STEREOSCOPIC_MODE_SIDE_BY_SIDE},
   {"tb",            MMAL_STEREOSCOPIC_MODE_TOP_BOTTOM},
};

static const int stereo_mode_map_size = sizeof(stereo_mode_map)/sizeof(stereo_mode_map[0]);


#define CommandSharpness   0
#define CommandContrast    1
#define CommandBrightness  2
#define CommandSaturation  3
#define CommandISO         4
#define CommandVideoStab   5
#define CommandEVComp      6
#define CommandExposure    7
#define CommandAWB         8
#define CommandImageFX     9
#define CommandColourFX    10
#define CommandMeterMode   11
#define CommandRotation    12
#define CommandHFlip       13
#define CommandVFlip       14
#define CommandROI         15
#define CommandShutterSpeed 16
#define CommandAwbGains    17
#define CommandDRCLevel    18
#define CommandStatsPass   19
#define CommandAnnotate    20
#define CommandStereoMode  21
#define CommandStereoDecimate 22
#define CommandStereoSwap  23
#define CommandAnnotateExtras 24

static COMMAND_LIST  cmdline_commands[] =
{
   {CommandSharpness,   "-sharpness", "sh", "Set image sharpness (-100 to 100)",  1},
   {CommandContrast,    "-contrast",  "co", "Set image contrast (-100 to 100)",  1},
   {CommandBrightness,  "-brightness","br", "Set image brightness (0 to 100)",  1},
   {CommandSaturation,  "-saturation","sa", "Set image saturation (-100 to 100)", 1},
   {CommandISO,         "-ISO",       "ISO","Set capture ISO",  1},
   {CommandVideoStab,   "-vstab",     "vs", "Turn on video stabilisation", 0},
   {CommandEVComp,      "-ev",        "ev", "Set EV compensation - steps of 1/6 stop",  1},
   {CommandExposure,    "-exposure",  "ex", "Set exposure mode (see Notes)", 1},
   {CommandAWB,         "-awb",       "awb","Set AWB mode (see Notes)", 1},
   {CommandImageFX,     "-imxfx",     "ifx","Set image effect (see Notes)", 1},
   {CommandColourFX,    "-colfx",     "cfx","Set colour effect (U:V)",  1},
   {CommandMeterMode,   "-metering",  "mm", "Set metering mode (see Notes)", 1},
   {CommandRotation,    "-rotation",  "rot","Set image rotation (0-359)", 1},
   {CommandHFlip,       "-hflip",     "hf", "Set horizontal flip", 0},
   {CommandVFlip,       "-vflip",     "vf", "Set vertical flip", 0},
   {CommandROI,         "-roi",       "roi","Set region of interest (x,y,w,d as normalised coordinates [0.0-1.0])", 1},
   {CommandShutterSpeed,"-shutter",   "ss", "Set shutter speed in microseconds", 1},
   {CommandAwbGains,    "-awbgains",  "awbg", "Set AWB gains - AWB mode must be off", 1},
   {CommandDRCLevel,    "-drc",       "drc", "Set DRC Level", 1},
   {CommandStatsPass,   "-stats",     "st", "Force recomputation of statistics on stills capture pass"},
   {CommandAnnotate,    "-annotate",  "a",  "Enable/Set annotate flags or text", 1},
   {CommandStereoMode,  "-stereo",    "3d", "Select stereoscopic mode", 1},
   {CommandStereoDecimate,"-decimate","dec", "Half width/height of stereo image"},
   {CommandStereoSwap,  "-3dswap",    "3dswap", "Swap camera order for stereoscopic"},
   {CommandAnnotateExtras,"-annotateex","ae",  "Set extra annotation parameters (text size, text colour(hex YUV), bg colour(hex YUV))", 2},
};

static int cmdline_commands_size = sizeof(cmdline_commands) / sizeof(cmdline_commands[0]);


#define parameter_reset -99999

/**
 * Update the passed in parameter according to the rest of the parameters
 * passed in.
 *
 *
 * @return 0 if reached end of cycle for this parameter, !0 otherwise
 */
static int update_cycle_parameter(int *option, int min, int max, int increment)
{
   vcos_assert(option);
   if (!option)
      return 0;

   if (*option == parameter_reset)
      *option = min - increment;

   *option += increment;

   if (*option > max)
   {
      *option = parameter_reset;
      return 0;
   }
   else
      return 1;
}


/**
 * Test/Demo code to cycle through a bunch of camera settings
 * This code is pretty hacky so please don't complain!!
 * It only does stuff that should have a visual impact (hence demo!)
 * This will override any user supplied parameters
 *
 * Each call of this function will move on to the next setting
 *
 * @param camera Pointer to the camera to change settings on.
 * @return 0 if reached end of complete sequence, !0 otherwise
 */

int raspicamcontrol_cycle_test(MMAL_COMPONENT_T *camera)
{
   static int parameter = 0;
   static int parameter_option = parameter_reset; // which value the parameter currently has

   vcos_assert(camera);

   // We are going to cycle through all the relevant entries in the parameter block
   // and send options to the camera.
   if (parameter == 0)
   {
      // sharpness
      if (update_cycle_parameter(&parameter_option, -100, 100, 10))
         raspicamcontrol_set_sharpness(camera, parameter_option);
      else
      {
         raspicamcontrol_set_sharpness(camera, 0);
         parameter++;
      }
   }
   else
   if (parameter == 1)
   {
      // contrast
      if (update_cycle_parameter(&parameter_option, -100, 100, 10))
         raspicamcontrol_set_contrast(camera, parameter_option);
      else
      {
         raspicamcontrol_set_contrast(camera, 0);
         parameter++;
      }
   }
   else
   if (parameter == 2)
   {
      // brightness
      if (update_cycle_parameter(&parameter_option, 0, 100, 10))
         raspicamcontrol_set_brightness(camera, parameter_option);
      else
      {
         raspicamcontrol_set_brightness(camera, 50);
         parameter++;
      }
   }
   else
   if (parameter == 3)
   {
      // contrast
      if (update_cycle_parameter(&parameter_option, -100, 100, 10))
         raspicamcontrol_set_saturation(camera, parameter_option);
      else
      {
         parameter++;
         raspicamcontrol_set_saturation(camera, 0);
      }
   }
   else
   if (parameter == 4)
   {
      // EV
      if (update_cycle_parameter(&parameter_option, -10, 10, 4))
         raspicamcontrol_set_exposure_compensation(camera, parameter_option);
      else
      {
         raspicamcontrol_set_exposure_compensation(camera, 0);
         parameter++;
      }
   }
   else
   if (parameter == 5)
   {
      // MMAL_PARAM_EXPOSUREMODE_T
      if (update_cycle_parameter(&parameter_option, 0, exposure_map_size, 1))
         raspicamcontrol_set_exposure_mode(camera, exposure_map[parameter_option].mmal_mode);
      else
      {
         raspicamcontrol_set_exposure_mode(camera, MMAL_PARAM_EXPOSUREMODE_AUTO);
         parameter++;
      }
   }
   else
   if (parameter == 6)
   {
      // MMAL_PARAM_AWB_T
      if (update_cycle_parameter(&parameter_option, 0, awb_map_size, 1))
         raspicamcontrol_set_awb_mode(camera, awb_map[parameter_option].mmal_mode);
      else
      {
         raspicamcontrol_set_awb_mode(camera, MMAL_PARAM_AWBMODE_AUTO);
         parameter++;
      }
   }
   if (parameter == 7)
   {
      // MMAL_PARAM_IMAGEFX_T
      if (update_cycle_parameter(&parameter_option, 0, imagefx_map_size, 1))
         raspicamcontrol_set_imageFX(camera, imagefx_map[parameter_option].mmal_mode);
      else
      {
         raspicamcontrol_set_imageFX(camera, MMAL_PARAM_IMAGEFX_NONE);
         parameter++;
      }
   }
   if (parameter == 8)
   {
      MMAL_PARAM_COLOURFX_T colfx = {0,0,0};
      switch (parameter_option)
      {
         case parameter_reset :
            parameter_option = 1;
            colfx.u = 128;
            colfx.v = 128;
            break;
         case 1 :
            parameter_option = 2;
            colfx.u = 100;
            colfx.v = 200;
            break;
         case 2 :
            parameter_option = parameter_reset;
            colfx.enable = 0;
            parameter++;
            break;
      }
      raspicamcontrol_set_colourFX(camera, &colfx);
   }

   // Orientation
   if (parameter == 9)
   {
      switch (parameter_option)
      {
      case parameter_reset:
         raspicamcontrol_set_rotation(camera, 90);
         parameter_option = 1;
         break;

      case 1 :
         raspicamcontrol_set_rotation(camera, 180);
         parameter_option = 2;
         break;

      case 2 :
         raspicamcontrol_set_rotation(camera, 270);
         parameter_option = 3;
         break;

      case 3 :
      {
         raspicamcontrol_set_rotation(camera, 0);
         raspicamcontrol_set_flips(camera, 1,0);
         parameter_option = 4;
         break;
      }
      case 4 :
      {
         raspicamcontrol_set_flips(camera, 0,1);
         parameter_option = 5;
         break;
      }
      case 5 :
      {
         raspicamcontrol_set_flips(camera, 1, 1);
         parameter_option = 6;
         break;
      }
      case 6 :
      {
         raspicamcontrol_set_flips(camera, 0, 0);
         parameter_option = parameter_reset;
         parameter++;
         break;
      }
      }
   }

   if (parameter == 10)
   {
      parameter = 1;
      return 0;
   }

   return 1;
}


/**
 * Function to take a string, a mapping, and return the int equivalent
 * @param str Incoming string to match
 * @param map Mapping data
 * @param num_refs The number of items in the mapping data
 * @return The integer match for the string, or -1 if no match
 */
static int map_xref(const char *str, const XREF_T *map, int num_refs)
{
	int i;

   for (i=0;i<num_refs;i++)
   {
      if (!strcasecmp(str, map[i].mode))
      {
         return map[i].mmal_mode;
      }
   }
   return -1;
}

/**
 * Function to take a mmal enum (as int) and return the string equivalent
 * @param en Incoming int to match
 * @param map Mapping data
 * @param num_refs The number of items in the mapping data
 * @return const pointer to string, or NULL if no match
 */
static const char *unmap_xref(const int en, XREF_T *map, int num_refs)
{
   int i;

   for (i=0;i<num_refs;i++)
   {
      if (en == map[i].mmal_mode)
      {
         return map[i].mode;
      }
   }
   return NULL;
}

/**
 * Convert string to the MMAL parameter for exposure mode
 * @param str Incoming string to match
 * @return MMAL parameter matching the string, or the AUTO option if no match found
 */
static MMAL_PARAM_EXPOSUREMODE_T exposure_mode_from_string(const char *str)
{
   int i = map_xref(str, exposure_map, exposure_map_size);

   if( i != -1)
      return (MMAL_PARAM_EXPOSUREMODE_T)i;

   fprintf(stderr,"Unknown exposure mode: %s", str);
   return MMAL_PARAM_EXPOSUREMODE_AUTO;
}

/**
 * Convert string to the MMAL parameter for AWB mode
 * @param str Incoming string to match
 * @return MMAL parameter matching the string, or the AUTO option if no match found
 */
static MMAL_PARAM_AWBMODE_T awb_mode_from_string(const char *str)
{
   int i = map_xref(str, awb_map, awb_map_size);

   if( i != -1)
      return (MMAL_PARAM_AWBMODE_T)i;

   fprintf(stderr,"Unknown awb mode: %s", str);
   return MMAL_PARAM_AWBMODE_AUTO;
}

/**
 * Convert string to the MMAL parameter for image effects mode
 * @param str Incoming string to match
 * @return MMAL parameter matching the strong, or the AUTO option if no match found
 */
MMAL_PARAM_IMAGEFX_T imagefx_mode_from_string(const char *str)
{
   int i = map_xref(str, imagefx_map, imagefx_map_size);

   if( i != -1)
     return (MMAL_PARAM_IMAGEFX_T)i;

   fprintf(stderr,"Unknown image fx: %s", str);
   return MMAL_PARAM_IMAGEFX_NONE;
}

/**
 * Convert string to the MMAL parameter for exposure metering mode
 * @param str Incoming string to match
 * @return MMAL parameter matching the string, or the AUTO option if no match found
 */
static MMAL_PARAM_EXPOSUREMETERINGMODE_T metering_mode_from_string(const char *str)
{
   int i = map_xref(str, metering_mode_map, metering_mode_map_size);

   if( i != -1)
      return (MMAL_PARAM_EXPOSUREMETERINGMODE_T)i;

   fprintf(stderr,"Unknown metering mode: %s", str);
   return MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE;
}

 /**
 * Convert string to the MMAL parameter for DRC level
 * @param str Incoming string to match
 * @return MMAL parameter matching the string, or the AUTO option if no match found
 */
static MMAL_PARAMETER_DRC_STRENGTH_T drc_mode_from_string(const char *str)
{
   int i = map_xref(str, drc_mode_map, drc_mode_map_size);

   if( i != -1)
      return (MMAL_PARAMETER_DRC_STRENGTH_T)i;

   fprintf(stderr,"Unknown DRC level: %s", str);
   return MMAL_PARAMETER_DRC_STRENGTH_OFF;
}

/**
 * Convert string to the MMAL parameter for exposure metering mode
 * @param str Incoming string to match
 * @return MMAL parameter matching the string, or the AUTO option if no match found
 */
static MMAL_STEREOSCOPIC_MODE_T stereo_mode_from_string(const char *str)
{
   int i = map_xref(str, stereo_mode_map, stereo_mode_map_size);

   if( i != -1)
      return (MMAL_STEREOSCOPIC_MODE_T)i;

   fprintf(stderr,"Unknown metering mode: %s", str);
   return MMAL_STEREOSCOPIC_MODE_NONE;
}








/**
 * Dump contents of camera parameter structure to stderr for debugging/verbose logging
 *
 * @param params Const pointer to parameters structure to dump
 */
void raspicamcontrol_dump_parameters(const RASPICAM_CAMERA_PARAMETERS *params)
{
   const char *exp_mode = unmap_xref(params->exposureMode, exposure_map, exposure_map_size);
   const char *awb_mode = unmap_xref(params->awbMode, awb_map, awb_map_size);
   const char *image_effect = unmap_xref(params->imageEffect, imagefx_map, imagefx_map_size);
   const char *metering_mode = unmap_xref(params->exposureMeterMode, metering_mode_map, metering_mode_map_size);

   fprintf(stderr, "Sharpness %d, Contrast %d, Brightness %d\n", params->sharpness, params->contrast, params->brightness);
   fprintf(stderr, "Saturation %d, ISO %d, Video Stabilisation %s, Exposure compensation %d\n", params->saturation, params->ISO, params->videoStabilisation ? "Yes": "No", params->exposureCompensation);
   fprintf(stderr, "Exposure Mode '%s', AWB Mode '%s', Image Effect '%s'\n", exp_mode, awb_mode, image_effect);
   fprintf(stderr, "Metering Mode '%s', Colour Effect Enabled %s with U = %d, V = %d\n", metering_mode, params->colourEffects.enable ? "Yes":"No", params->colourEffects.u, params->colourEffects.v);
   fprintf(stderr, "Rotation %d, hflip %s, vflip %s\n", params->rotation, params->hflip ? "Yes":"No",params->vflip ? "Yes":"No");
   fprintf(stderr, "ROI x %lf, y %f, w %f h %f\n", params->roi.x, params->roi.y, params->roi.w, params->roi.h);
}

/**
 * Convert a MMAL status return value to a simple boolean of success
 * ALso displays a fault if code is not success
 *
 * @param status The error code to convert
 * @return 0 if status is success, 1 otherwise
 */
int mmal_status_to_int(MMAL_STATUS_T status)
{
   if (status == MMAL_SUCCESS)
      return 0;
   else
   {
      switch (status)
      {
      case MMAL_ENOMEM :   fprintf(stderr,"Out of memory"); break;
      case MMAL_ENOSPC :   fprintf(stderr,"Out of resources (other than memory)"); break;
      case MMAL_EINVAL:    fprintf(stderr,"Argument is invalid"); break;
      case MMAL_ENOSYS :   fprintf(stderr,"Function not implemented"); break;
      case MMAL_ENOENT :   fprintf(stderr,"No such file or directory"); break;
      case MMAL_ENXIO :    fprintf(stderr,"No such device or address"); break;
      case MMAL_EIO :      fprintf(stderr,"I/O error"); break;
      case MMAL_ESPIPE :   fprintf(stderr,"Illegal seek"); break;
      case MMAL_ECORRUPT : fprintf(stderr,"Data is corrupt \attention FIXME: not POSIX"); break;
      case MMAL_ENOTREADY :fprintf(stderr,"Component is not ready \attention FIXME: not POSIX"); break;
      case MMAL_ECONFIG :  fprintf(stderr,"Component is not configured \attention FIXME: not POSIX"); break;
      case MMAL_EISCONN :  fprintf(stderr,"Port is already connected "); break;
      case MMAL_ENOTCONN : fprintf(stderr,"Port is disconnected"); break;
      case MMAL_EAGAIN :   fprintf(stderr,"Resource temporarily unavailable. Try again later"); break;
      case MMAL_EFAULT :   fprintf(stderr,"Bad address"); break;
      default :            fprintf(stderr,"Unknown status error"); break;
      }

      return 1;
   }
}

/**
 * Give the supplied parameter block a set of default values
 * @params Pointer to parameter block
 */
void raspicamcontrol_set_defaults(RASPICAM_CAMERA_PARAMETERS *params)
{
   vcos_assert(params);

   params->sharpness = 0;
   params->contrast = 0;
   params->brightness = 50;
   params->saturation = 0;
   params->ISO = 0;                    // 0 = auto
   params->videoStabilisation = 0;
   params->exposureCompensation = 0;
   params->exposureMode = MMAL_PARAM_EXPOSUREMODE_AUTO;
   params->exposureMeterMode = MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE;
   params->awbMode = MMAL_PARAM_AWBMODE_AUTO;
   params->imageEffect = MMAL_PARAM_IMAGEFX_NONE;
   params->colourEffects.enable = 0;
   params->colourEffects.u = 128;
   params->colourEffects.v = 128;
   params->rotation = 0;
   params->hflip = params->vflip = 0;
   params->roi.x = params->roi.y = 0.0;
   params->roi.w = params->roi.h = 1.0;
   params->shutter_speed = 0;          // 0 = auto
   params->awb_gains_r = 0;      // Only have any function if AWB OFF is used.
   params->awb_gains_b = 0;
   params->drc_level = MMAL_PARAMETER_DRC_STRENGTH_OFF;
   params->stats_pass = MMAL_FALSE;
   params->enable_annotate = 0;
   params->annotate_string[0] = '\0';
   params->annotate_text_size = 0;	//Use firmware default
   params->annotate_text_colour = -1;   //Use firmware default
   params->annotate_bg_colour = -1;     //Use firmware default
   params->stereo_mode.mode = MMAL_STEREOSCOPIC_MODE_NONE;
   params->stereo_mode.decimate = MMAL_FALSE;
   params->stereo_mode.swap_eyes = MMAL_FALSE;
}

/**
 * Get all the current camera parameters from specified camera component
 * @param camera Pointer to camera component
 * @param params Pointer to parameter block to accept settings
 * @return 0 if successful, non-zero if unsuccessful
 */
int raspicamcontrol_get_all_parameters(MMAL_COMPONENT_T *camera, RASPICAM_CAMERA_PARAMETERS *params)
{
   vcos_assert(camera);
   vcos_assert(params);

   if (!camera || !params)
      return 1;

/* TODO : Write these get functions
   params->sharpness = raspicamcontrol_get_sharpness(camera);
   params->contrast = raspicamcontrol_get_contrast(camera);
   params->brightness = raspicamcontrol_get_brightness(camera);
   params->saturation = raspicamcontrol_get_saturation(camera);
   params->ISO = raspicamcontrol_get_ISO(camera);
   params->videoStabilisation = raspicamcontrol_get_video_stabilisation(camera);
   params->exposureCompensation = raspicamcontrol_get_exposure_compensation(camera);
   params->exposureMode = raspicamcontrol_get_exposure_mode(camera);
   params->awbMode = raspicamcontrol_get_awb_mode(camera);
   params->imageEffect = raspicamcontrol_get_image_effect(camera);
   params->colourEffects = raspicamcontrol_get_colour_effect(camera);
   params->thumbnailConfig = raspicamcontrol_get_thumbnail_config(camera);
*/
   return 0;
}

/**
 * Set the specified camera to all the specified settings
 * @param camera Pointer to camera component
 * @param params Pointer to parameter block containing parameters
 * @return 0 if successful, none-zero if unsuccessful.
 */
int raspicamcontrol_set_all_parameters(MMAL_COMPONENT_T *camera, const RASPICAM_CAMERA_PARAMETERS *params)
{
   int result;

   result  = raspicamcontrol_set_saturation(camera, params->saturation);
   result += raspicamcontrol_set_sharpness(camera, params->sharpness);
   result += raspicamcontrol_set_contrast(camera, params->contrast);
   result += raspicamcontrol_set_brightness(camera, params->brightness);
   result += raspicamcontrol_set_ISO(camera, params->ISO);
   result += raspicamcontrol_set_video_stabilisation(camera, params->videoStabilisation);
   result += raspicamcontrol_set_exposure_compensation(camera, params->exposureCompensation);
   result += raspicamcontrol_set_exposure_mode(camera, params->exposureMode);
   result += raspicamcontrol_set_metering_mode(camera, params->exposureMeterMode);
   result += raspicamcontrol_set_awb_mode(camera, params->awbMode);
   result += raspicamcontrol_set_awb_gains(camera, params->awb_gains_r, params->awb_gains_b);
   result += raspicamcontrol_set_imageFX(camera, params->imageEffect);
   result += raspicamcontrol_set_colourFX(camera, &params->colourEffects);
   //result += raspicamcontrol_set_thumbnail_parameters(camera, &params->thumbnailConfig);  TODO Not working for some reason
   result += raspicamcontrol_set_rotation(camera, params->rotation);
   result += raspicamcontrol_set_flips(camera, params->hflip, params->vflip);
   result += raspicamcontrol_set_ROI(camera, params->roi);
   result += raspicamcontrol_set_shutter_speed(camera, params->shutter_speed);
   result += raspicamcontrol_set_DRC(camera, params->drc_level);
   result += raspicamcontrol_set_stats_pass(camera, params->stats_pass);

   return result;
}

/**
 * Adjust the saturation level for images
 * @param camera Pointer to camera component
 * @param saturation Value to adjust, -100 to 100
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_saturation(MMAL_COMPONENT_T *camera, int saturation)
{
   int ret = 0;

   if (!camera)
      return 1;

   if (saturation >= -100 && saturation <= 100)
   {
      MMAL_RATIONAL_T value = {saturation, 100};
      ret = mmal_status_to_int(mmal_port_parameter_set_rational(camera->control, MMAL_PARAMETER_SATURATION, value));
   }
   else
   {
      fprintf(stderr,"Invalid saturation value");
      ret = 1;
   }

   return ret;
}

/**
 * Set the sharpness of the image
 * @param camera Pointer to camera component
 * @param sharpness Sharpness adjustment -100 to 100
 */
int raspicamcontrol_set_sharpness(MMAL_COMPONENT_T *camera, int sharpness)
{
   int ret = 0;

   if (!camera)
      return 1;

   if (sharpness >= -100 && sharpness <= 100)
   {
      MMAL_RATIONAL_T value = {sharpness, 100};
      ret = mmal_status_to_int(mmal_port_parameter_set_rational(camera->control, MMAL_PARAMETER_SHARPNESS, value));
   }
   else
   {
      fprintf(stderr,"Invalid sharpness value");
      ret = 1;
   }

   return ret;
}

/**
 * Set the contrast adjustment for the image
 * @param camera Pointer to camera component
 * @param contrast Contrast adjustment -100 to  100
 * @return
 */
int raspicamcontrol_set_contrast(MMAL_COMPONENT_T *camera, int contrast)
{
   int ret = 0;

   if (!camera)
      return 1;

   if (contrast >= -100 && contrast <= 100)
   {
      MMAL_RATIONAL_T value = {contrast, 100};
      ret = mmal_status_to_int(mmal_port_parameter_set_rational(camera->control, MMAL_PARAMETER_CONTRAST, value));
   }
   else
   {
      fprintf(stderr,"Invalid contrast value");
      ret = 1;
   }

   return ret;
}

/**
 * Adjust the brightness level for images
 * @param camera Pointer to camera component
 * @param brightness Value to adjust, 0 to 100
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_brightness(MMAL_COMPONENT_T *camera, int brightness)
{
   int ret = 0;

   if (!camera)
      return 1;

   if (brightness >= 0 && brightness <= 100)
   {
      MMAL_RATIONAL_T value = {brightness, 100};
      ret = mmal_status_to_int(mmal_port_parameter_set_rational(camera->control, MMAL_PARAMETER_BRIGHTNESS, value));
   }
   else
   {
      fprintf(stderr,"Invalid brightness value");
      ret = 1;
   }

   return ret;
}

/**
 * Adjust the ISO used for images
 * @param camera Pointer to camera component
 * @param ISO Value to set TODO :
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_ISO(MMAL_COMPONENT_T *camera, int ISO)
{
   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set_uint32(camera->control, MMAL_PARAMETER_ISO, ISO));
}

/**
 * Adjust the metering mode for images
 * @param camera Pointer to camera component
 * @param saturation Value from following
 *   - MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE,
 *   - MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT,
 *   - MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT,
 *   - MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_metering_mode(MMAL_COMPONENT_T *camera, MMAL_PARAM_EXPOSUREMETERINGMODE_T m_mode )
{
   MMAL_PARAMETER_EXPOSUREMETERINGMODE_T meter_mode = {{MMAL_PARAMETER_EXP_METERING_MODE,sizeof(meter_mode)},
                                                      m_mode};
   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &meter_mode.hdr));
}


/**
 * Set the video stabilisation flag. Only used in video mode
 * @param camera Pointer to camera component
 * @param saturation Flag 0 off 1 on
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_video_stabilisation(MMAL_COMPONENT_T *camera, int vstabilisation)
{
   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set_boolean(camera->control, MMAL_PARAMETER_VIDEO_STABILISATION, vstabilisation));
}

/**
 * Adjust the exposure compensation for images (EV)
 * @param camera Pointer to camera component
 * @param exp_comp Value to adjust, -10 to +10
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_exposure_compensation(MMAL_COMPONENT_T *camera, int exp_comp)
{
   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set_int32(camera->control, MMAL_PARAMETER_EXPOSURE_COMP , exp_comp));
}


/**
 * Set exposure mode for images
 * @param camera Pointer to camera component
 * @param mode Exposure mode to set from
 *   - MMAL_PARAM_EXPOSUREMODE_OFF,
 *   - MMAL_PARAM_EXPOSUREMODE_AUTO,
 *   - MMAL_PARAM_EXPOSUREMODE_NIGHT,
 *   - MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW,
 *   - MMAL_PARAM_EXPOSUREMODE_BACKLIGHT,
 *   - MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT,
 *   - MMAL_PARAM_EXPOSUREMODE_SPORTS,
 *   - MMAL_PARAM_EXPOSUREMODE_SNOW,
 *   - MMAL_PARAM_EXPOSUREMODE_BEACH,
 *   - MMAL_PARAM_EXPOSUREMODE_VERYLONG,
 *   - MMAL_PARAM_EXPOSUREMODE_FIXEDFPS,
 *   - MMAL_PARAM_EXPOSUREMODE_ANTISHAKE,
 *   - MMAL_PARAM_EXPOSUREMODE_FIREWORKS,
 *
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_exposure_mode(MMAL_COMPONENT_T *camera, MMAL_PARAM_EXPOSUREMODE_T mode)
{
   MMAL_PARAMETER_EXPOSUREMODE_T exp_mode = {{MMAL_PARAMETER_EXPOSURE_MODE,sizeof(exp_mode)}, mode};

   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &exp_mode.hdr));
}


/**
 * Set the aWB (auto white balance) mode for images
 * @param camera Pointer to camera component
 * @param awb_mode Value to set from
 *   - MMAL_PARAM_AWBMODE_OFF,
 *   - MMAL_PARAM_AWBMODE_AUTO,
 *   - MMAL_PARAM_AWBMODE_SUNLIGHT,
 *   - MMAL_PARAM_AWBMODE_CLOUDY,
 *   - MMAL_PARAM_AWBMODE_SHADE,
 *   - MMAL_PARAM_AWBMODE_TUNGSTEN,
 *   - MMAL_PARAM_AWBMODE_FLUORESCENT,
 *   - MMAL_PARAM_AWBMODE_INCANDESCENT,
 *   - MMAL_PARAM_AWBMODE_FLASH,
 *   - MMAL_PARAM_AWBMODE_HORIZON,
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_awb_mode(MMAL_COMPONENT_T *camera, MMAL_PARAM_AWBMODE_T awb_mode)
{
   MMAL_PARAMETER_AWBMODE_T param = {{MMAL_PARAMETER_AWB_MODE,sizeof(param)}, awb_mode};

   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &param.hdr));
}

int raspicamcontrol_set_awb_gains(MMAL_COMPONENT_T *camera, float r_gain, float b_gain)
{
   MMAL_PARAMETER_AWB_GAINS_T param = {{MMAL_PARAMETER_CUSTOM_AWB_GAINS,sizeof(param)}, {0,0}, {0,0}};

   if (!camera)
      return 1;

   if (!r_gain || !b_gain)
      return 0;

   param.r_gain.num = (unsigned int)(r_gain * 65536);
   param.b_gain.num = (unsigned int)(b_gain * 65536);
   param.r_gain.den = param.b_gain.den = 65536;
   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &param.hdr));
}

/**
 * Set the image effect for the images
 * @param camera Pointer to camera component
 * @param imageFX Value from
 *   - MMAL_PARAM_IMAGEFX_NONE,
 *   - MMAL_PARAM_IMAGEFX_NEGATIVE,
 *   - MMAL_PARAM_IMAGEFX_SOLARIZE,
 *   - MMAL_PARAM_IMAGEFX_POSTERIZE,
 *   - MMAL_PARAM_IMAGEFX_WHITEBOARD,
 *   - MMAL_PARAM_IMAGEFX_BLACKBOARD,
 *   - MMAL_PARAM_IMAGEFX_SKETCH,
 *   - MMAL_PARAM_IMAGEFX_DENOISE,
 *   - MMAL_PARAM_IMAGEFX_EMBOSS,
 *   - MMAL_PARAM_IMAGEFX_OILPAINT,
 *   - MMAL_PARAM_IMAGEFX_HATCH,
 *   - MMAL_PARAM_IMAGEFX_GPEN,
 *   - MMAL_PARAM_IMAGEFX_PASTEL,
 *   - MMAL_PARAM_IMAGEFX_WATERCOLOUR,
 *   - MMAL_PARAM_IMAGEFX_FILM,
 *   - MMAL_PARAM_IMAGEFX_BLUR,
 *   - MMAL_PARAM_IMAGEFX_SATURATION,
 *   - MMAL_PARAM_IMAGEFX_COLOURSWAP,
 *   - MMAL_PARAM_IMAGEFX_WASHEDOUT,
 *   - MMAL_PARAM_IMAGEFX_POSTERISE,
 *   - MMAL_PARAM_IMAGEFX_COLOURPOINT,
 *   - MMAL_PARAM_IMAGEFX_COLOURBALANCE,
 *   - MMAL_PARAM_IMAGEFX_CARTOON,
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_imageFX(MMAL_COMPONENT_T *camera, MMAL_PARAM_IMAGEFX_T imageFX)
{
   MMAL_PARAMETER_IMAGEFX_T imgFX = {{MMAL_PARAMETER_IMAGE_EFFECT,sizeof(imgFX)}, imageFX};

   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &imgFX.hdr));
}

/* TODO :what to do with the image effects parameters?
   MMAL_PARAMETER_IMAGEFX_PARAMETERS_T imfx_param = {{MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS,sizeof(imfx_param)},
                              imageFX, 0, {0}};
mmal_port_parameter_set(camera->control, &imfx_param.hdr);
                             */

/**
 * Set the colour effect  for images (Set UV component)
 * @param camera Pointer to camera component
 * @param colourFX  Contains enable state and U and V numbers to set (e.g. 128,128 = Black and white)
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_colourFX(MMAL_COMPONENT_T *camera, const MMAL_PARAM_COLOURFX_T *colourFX)
{
   MMAL_PARAMETER_COLOURFX_T colfx = {{MMAL_PARAMETER_COLOUR_EFFECT,sizeof(colfx)}, 0, 0, 0};

   if (!camera)
      return 1;

   colfx.enable = colourFX->enable;
   colfx.u = colourFX->u;
   colfx.v = colourFX->v;

   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &colfx.hdr));

}


/**
 * Set the rotation of the image
 * @param camera Pointer to camera component
 * @param rotation Degree of rotation (any number, but will be converted to 0,90,180 or 270 only)
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_rotation(MMAL_COMPONENT_T *camera, int rotation)
{
   int ret;
   int my_rotation = ((rotation % 360 ) / 90) * 90;

   ret = mmal_port_parameter_set_int32(camera->output[0], MMAL_PARAMETER_ROTATION, my_rotation);
   mmal_port_parameter_set_int32(camera->output[1], MMAL_PARAMETER_ROTATION, my_rotation);
   mmal_port_parameter_set_int32(camera->output[2], MMAL_PARAMETER_ROTATION, my_rotation);

   return ret;
}

/**
 * Set the flips state of the image
 * @param camera Pointer to camera component
 * @param hflip If true, horizontally flip the image
 * @param vflip If true, vertically flip the image
 *
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_flips(MMAL_COMPONENT_T *camera, int hflip, int vflip)
{
   MMAL_PARAMETER_MIRROR_T mirror = {{MMAL_PARAMETER_MIRROR, sizeof(MMAL_PARAMETER_MIRROR_T)}, MMAL_PARAM_MIRROR_NONE};

   if (hflip && vflip)
      mirror.value = MMAL_PARAM_MIRROR_BOTH;
   else
   if (hflip)
      mirror.value = MMAL_PARAM_MIRROR_HORIZONTAL;
   else
   if (vflip)
      mirror.value = MMAL_PARAM_MIRROR_VERTICAL;

   mmal_port_parameter_set(camera->output[0], &mirror.hdr);
   mmal_port_parameter_set(camera->output[1], &mirror.hdr);
   return mmal_port_parameter_set(camera->output[2], &mirror.hdr);
}

/**
 * Set the ROI of the sensor to use for captures/preview
 * @param camera Pointer to camera component
 * @param rect   Normalised coordinates of ROI rectangle
 *
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_ROI(MMAL_COMPONENT_T *camera, PARAM_FLOAT_RECT_T rect)
{
   MMAL_PARAMETER_INPUT_CROP_T crop = {{MMAL_PARAMETER_INPUT_CROP, sizeof(MMAL_PARAMETER_INPUT_CROP_T)}};

   crop.rect.x = (65536 * rect.x);
   crop.rect.y = (65536 * rect.y);
   crop.rect.width = (65536 * rect.w);
   crop.rect.height = (65536 * rect.h);

   return mmal_port_parameter_set(camera->control, &crop.hdr);
}

/**
 * Adjust the exposure time used for images
 * @param camera Pointer to camera component
 * @param shutter speed in microseconds
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_shutter_speed(MMAL_COMPONENT_T *camera, int speed)
{
   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set_uint32(camera->control, MMAL_PARAMETER_SHUTTER_SPEED, speed));
}

/**
 * Adjust the Dynamic range compression level
 * @param camera Pointer to camera component
 * @param strength Strength of DRC to apply
 *        MMAL_PARAMETER_DRC_STRENGTH_OFF
 *        MMAL_PARAMETER_DRC_STRENGTH_LOW
 *        MMAL_PARAMETER_DRC_STRENGTH_MEDIUM
 *        MMAL_PARAMETER_DRC_STRENGTH_HIGH
 *
 * @return 0 if successful, non-zero if any parameters out of range
 */
int raspicamcontrol_set_DRC(MMAL_COMPONENT_T *camera, MMAL_PARAMETER_DRC_STRENGTH_T strength)
{
   MMAL_PARAMETER_DRC_T drc = {{MMAL_PARAMETER_DYNAMIC_RANGE_COMPRESSION, sizeof(MMAL_PARAMETER_DRC_T)}, strength};

   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set(camera->control, &drc.hdr));
}

int raspicamcontrol_set_stats_pass(MMAL_COMPONENT_T *camera, int stats_pass)
{
   if (!camera)
      return 1;

   return mmal_status_to_int(mmal_port_parameter_set_boolean(camera->control, MMAL_PARAMETER_CAPTURE_STATS_PASS, stats_pass));
}



int raspicamcontrol_set_stereo_mode(MMAL_PORT_T *port, MMAL_PARAMETER_STEREOSCOPIC_MODE_T *stereo_mode)
{
   MMAL_PARAMETER_STEREOSCOPIC_MODE_T stereo = { {MMAL_PARAMETER_STEREOSCOPIC_MODE, sizeof(stereo)},
                               MMAL_STEREOSCOPIC_MODE_NONE, MMAL_FALSE, MMAL_FALSE };
   if (stereo_mode->mode != MMAL_STEREOSCOPIC_MODE_NONE)
   {
      stereo.mode = stereo_mode->mode;
      stereo.decimate = stereo_mode->decimate;
      stereo.swap_eyes = stereo_mode->swap_eyes;
   }
   return mmal_status_to_int(mmal_port_parameter_set(port, &stereo.hdr));
}

/**
 * Asked GPU how much memory it has allocated
 *
 * @return amount of memory in MB
 */
static int raspicamcontrol_get_mem_gpu(void)
{
   char response[80] = "";
   int gpu_mem = 0;
   if (vc_gencmd(response, sizeof response, "get_mem gpu") == 0)
      vc_gencmd_number_property(response, "gpu", &gpu_mem);
   return gpu_mem;
}

/**
 * Ask GPU about its camera abilities
 * @param supported None-zero if software supports the camera 
 * @param detected  None-zero if a camera has been detected
 */
static void raspicamcontrol_get_camera(int *supported, int *detected)
{
   char response[80] = "";
   if (vc_gencmd(response, sizeof response, "get_camera") == 0)
   {
      if (supported)
         vc_gencmd_number_property(response, "supported", supported);
      if (detected)
         vc_gencmd_number_property(response, "detected", detected);
   }
}

/**
 * Check to see if camera is supported, and we have allocated enough meooryAsk GPU about its camera abilities
 * @param supported None-zero if software supports the camera 
 * @param detected  None-zero if a camera has been detected
 */
void raspicamcontrol_check_configuration(int min_gpu_mem)
{
   int gpu_mem = raspicamcontrol_get_mem_gpu();
   int supported = 0, detected = 0;
   raspicamcontrol_get_camera(&supported, &detected);
   if (!supported)
      fprintf(stderr,"Camera is not enabled in this build. Try running \"sudo raspi-config\" and ensure that \"camera\" has been enabled\n");
   else if (gpu_mem < min_gpu_mem)
      fprintf(stderr,"Only %dM of gpu_mem is configured. Try running \"sudo raspi-config\" and ensure that \"memory_split\" has a value of %d or greater\n", gpu_mem, min_gpu_mem);
   else if (!detected)
      fprintf(stderr,"Camera is not detected. Please check carefully the camera module is installed correctly\n");
   else
      fprintf(stderr,"Failed to run camera app. Please check for firmware updates\n");
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.h
================
/*
Copyright (c) 2013, Broadcom Europe Ltd
Copyright (c) 2013, James Hughes
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef RASPICAMCONTROL_H_
#define RASPICAMCONTROL_H_

/* Various parameters
 *
 * Exposure Mode
 *          MMAL_PARAM_EXPOSUREMODE_OFF,
            MMAL_PARAM_EXPOSUREMODE_AUTO,
            MMAL_PARAM_EXPOSUREMODE_NIGHT,
            MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW,
            MMAL_PARAM_EXPOSUREMODE_BACKLIGHT,
            MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT,
            MMAL_PARAM_EXPOSUREMODE_SPORTS,
            MMAL_PARAM_EXPOSUREMODE_SNOW,
            MMAL_PARAM_EXPOSUREMODE_BEACH,
            MMAL_PARAM_EXPOSUREMODE_VERYLONG,
            MMAL_PARAM_EXPOSUREMODE_FIXEDFPS,
            MMAL_PARAM_EXPOSUREMODE_ANTISHAKE,
            MMAL_PARAM_EXPOSUREMODE_FIREWORKS,
 *
 * AWB Mode
 *          MMAL_PARAM_AWBMODE_OFF,
            MMAL_PARAM_AWBMODE_AUTO,
            MMAL_PARAM_AWBMODE_SUNLIGHT,
            MMAL_PARAM_AWBMODE_CLOUDY,
            MMAL_PARAM_AWBMODE_SHADE,
            MMAL_PARAM_AWBMODE_TUNGSTEN,
            MMAL_PARAM_AWBMODE_FLUORESCENT,
            MMAL_PARAM_AWBMODE_INCANDESCENT,
            MMAL_PARAM_AWBMODE_FLASH,
            MMAL_PARAM_AWBMODE_HORIZON,
 *
 * Image FX
            MMAL_PARAM_IMAGEFX_NONE,
            MMAL_PARAM_IMAGEFX_NEGATIVE,
            MMAL_PARAM_IMAGEFX_SOLARIZE,
            MMAL_PARAM_IMAGEFX_POSTERIZE,
            MMAL_PARAM_IMAGEFX_WHITEBOARD,
            MMAL_PARAM_IMAGEFX_BLACKBOARD,
            MMAL_PARAM_IMAGEFX_SKETCH,
            MMAL_PARAM_IMAGEFX_DENOISE,
            MMAL_PARAM_IMAGEFX_EMBOSS,
            MMAL_PARAM_IMAGEFX_OILPAINT,
            MMAL_PARAM_IMAGEFX_HATCH,
            MMAL_PARAM_IMAGEFX_GPEN,
            MMAL_PARAM_IMAGEFX_PASTEL,
            MMAL_PARAM_IMAGEFX_WATERCOLOUR,
            MMAL_PARAM_IMAGEFX_FILM,
            MMAL_PARAM_IMAGEFX_BLUR,
            MMAL_PARAM_IMAGEFX_SATURATION,
            MMAL_PARAM_IMAGEFX_COLOURSWAP,
            MMAL_PARAM_IMAGEFX_WASHEDOUT,
            MMAL_PARAM_IMAGEFX_POSTERISE,
            MMAL_PARAM_IMAGEFX_COLOURPOINT,
            MMAL_PARAM_IMAGEFX_COLOURBALANCE,
            MMAL_PARAM_IMAGEFX_CARTOON,

 */

/// Annotate bitmask options
/// Supplied by user on command line
#define ANNOTATE_USER_TEXT          1
/// Supplied by app using this module
#define ANNOTATE_APP_TEXT           2
/// Insert current date
#define ANNOTATE_DATE_TEXT          4
// Insert current time
#define ANNOTATE_TIME_TEXT          8

#define ANNOTATE_SHUTTER_SETTINGS   16
#define ANNOTATE_CAF_SETTINGS       32
#define ANNOTATE_GAIN_SETTINGS      64
#define ANNOTATE_LENS_SETTINGS      128
#define ANNOTATE_MOTION_SETTINGS    256
#define ANNOTATE_FRAME_NUMBER       512
#define ANNOTATE_BLACK_BACKGROUND   1024


// There isn't actually a MMAL structure for the following, so make one
typedef struct
{
   int enable;       /// Turn colourFX on or off
   int u,v;          /// U and V to use
} MMAL_PARAM_COLOURFX_T;

typedef struct
{
   int enable;
   int width,height;
   int quality;
} MMAL_PARAM_THUMBNAIL_CONFIG_T;

typedef struct
{
   double x;
   double y;
   double w;
   double h;
} PARAM_FLOAT_RECT_T;

/// struct contain camera settings
typedef struct
{
   int sharpness;             /// -100 to 100
   int contrast;              /// -100 to 100
   int brightness;            ///  0 to 100
   int saturation;            ///  -100 to 100
   int ISO;                   ///  TODO : what range?
   int videoStabilisation;    /// 0 or 1 (false or true)
   int exposureCompensation;  /// -10 to +10 ?
   MMAL_PARAM_EXPOSUREMODE_T exposureMode;
   MMAL_PARAM_EXPOSUREMETERINGMODE_T exposureMeterMode;
   MMAL_PARAM_AWBMODE_T awbMode;
   MMAL_PARAM_IMAGEFX_T imageEffect;
   MMAL_PARAMETER_IMAGEFX_PARAMETERS_T imageEffectsParameters;
   MMAL_PARAM_COLOURFX_T colourEffects;
   int rotation;              /// 0-359
   int hflip;                 /// 0 or 1
   int vflip;                 /// 0 or 1
   PARAM_FLOAT_RECT_T  roi;   /// region of interest to use on the sensor. Normalised [0,1] values in the rect
   int shutter_speed;         /// 0 = auto, otherwise the shutter speed in ms
   float awb_gains_r;         /// AWB red gain
   float awb_gains_b;         /// AWB blue gain
   MMAL_PARAMETER_DRC_STRENGTH_T drc_level;  // Strength of Dynamic Range compression to apply
   MMAL_BOOL_T stats_pass;    /// Stills capture statistics pass on/off
   int enable_annotate;       /// Flag to enable the annotate, 0 = disabled, otherwise a bitmask of what needs to be displayed
   char annotate_string[MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V2]; /// String to use for annotate - overrides certain bitmask settings
   int annotate_text_size;    // Text size for annotation
   int annotate_text_colour;  // Text colour for annotation
   int annotate_bg_colour;    // Background colour for annotation
   MMAL_PARAMETER_STEREOSCOPIC_MODE_T stereo_mode;
} RASPICAM_CAMERA_PARAMETERS;


void raspicamcontrol_check_configuration(int min_gpu_mem);

int raspicamcontrol_parse_cmdline(RASPICAM_CAMERA_PARAMETERS *params, const char *arg1, const char *arg2);
void raspicamcontrol_display_help();
int raspicamcontrol_cycle_test(MMAL_COMPONENT_T *camera);

int raspicamcontrol_set_all_parameters(MMAL_COMPONENT_T *camera, const RASPICAM_CAMERA_PARAMETERS *params);
int raspicamcontrol_get_all_parameters(MMAL_COMPONENT_T *camera, RASPICAM_CAMERA_PARAMETERS *params);
void raspicamcontrol_dump_parameters(const RASPICAM_CAMERA_PARAMETERS *params);

void raspicamcontrol_set_defaults(RASPICAM_CAMERA_PARAMETERS *params);

void raspicamcontrol_check_configuration(int min_gpu_mem);

// Individual setting functions
int raspicamcontrol_set_saturation(MMAL_COMPONENT_T *camera, int saturation);
int raspicamcontrol_set_sharpness(MMAL_COMPONENT_T *camera, int sharpness);
int raspicamcontrol_set_contrast(MMAL_COMPONENT_T *camera, int contrast);
int raspicamcontrol_set_brightness(MMAL_COMPONENT_T *camera, int brightness);
int raspicamcontrol_set_ISO(MMAL_COMPONENT_T *camera, int ISO);
int raspicamcontrol_set_metering_mode(MMAL_COMPONENT_T *camera, MMAL_PARAM_EXPOSUREMETERINGMODE_T mode);
int raspicamcontrol_set_video_stabilisation(MMAL_COMPONENT_T *camera, int vstabilisation);
int raspicamcontrol_set_exposure_compensation(MMAL_COMPONENT_T *camera, int exp_comp);
int raspicamcontrol_set_exposure_mode(MMAL_COMPONENT_T *camera, MMAL_PARAM_EXPOSUREMODE_T mode);
int raspicamcontrol_set_awb_mode(MMAL_COMPONENT_T *camera, MMAL_PARAM_AWBMODE_T awb_mode);
int raspicamcontrol_set_awb_gains(MMAL_COMPONENT_T *camera, float r_gain, float b_gain);
int raspicamcontrol_set_imageFX(MMAL_COMPONENT_T *camera, MMAL_PARAM_IMAGEFX_T imageFX);
int raspicamcontrol_set_colourFX(MMAL_COMPONENT_T *camera, const MMAL_PARAM_COLOURFX_T *colourFX);
int raspicamcontrol_set_rotation(MMAL_COMPONENT_T *camera, int rotation);
int raspicamcontrol_set_flips(MMAL_COMPONENT_T *camera, int hflip, int vflip);
int raspicamcontrol_set_ROI(MMAL_COMPONENT_T *camera, PARAM_FLOAT_RECT_T rect);
int raspicamcontrol_set_shutter_speed(MMAL_COMPONENT_T *camera, int speed_ms);
int raspicamcontrol_set_DRC(MMAL_COMPONENT_T *camera, MMAL_PARAMETER_DRC_STRENGTH_T strength);
int raspicamcontrol_set_stats_pass(MMAL_COMPONENT_T *camera, int stats_pass);
int raspicamcontrol_set_annotate(MMAL_COMPONENT_T *camera, const int bitmask, const char *string,
                                 const int text_size, const int text_colour, const int bg_colour);
int raspicamcontrol_set_stereo_mode(MMAL_PORT_T *port, MMAL_PARAMETER_STEREOSCOPIC_MODE_T *stereo_mode);

//Individual getting functions
int raspicamcontrol_get_saturation(MMAL_COMPONENT_T *camera);
int raspicamcontrol_get_sharpness(MMAL_COMPONENT_T *camera);
int raspicamcontrol_get_contrast(MMAL_COMPONENT_T *camera);
int raspicamcontrol_get_brightness(MMAL_COMPONENT_T *camera);
int raspicamcontrol_get_ISO(MMAL_COMPONENT_T *camera);
MMAL_PARAM_EXPOSUREMETERINGMODE_T raspicamcontrol_get_metering_mode(MMAL_COMPONENT_T *camera);
int raspicamcontrol_get_video_stabilisation(MMAL_COMPONENT_T *camera);
int raspicamcontrol_get_exposure_compensation(MMAL_COMPONENT_T *camera);
MMAL_PARAM_THUMBNAIL_CONFIG_T raspicamcontrol_get_thumbnail_parameters(MMAL_COMPONENT_T *camera);
MMAL_PARAM_EXPOSUREMODE_T raspicamcontrol_get_exposure_mode(MMAL_COMPONENT_T *camera);
MMAL_PARAM_AWBMODE_T raspicamcontrol_get_awb_mode(MMAL_COMPONENT_T *camera);
MMAL_PARAM_IMAGEFX_T raspicamcontrol_get_imageFX(MMAL_COMPONENT_T *camera);
MMAL_PARAM_COLOURFX_T raspicamcontrol_get_colourFX(MMAL_COMPONENT_T *camera);


#endif /* RASPICAMCONTROL_H_ */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/README.md
================
mjpg-streamer input plugin: input_raspicam
==========================================

MJPEG Streamer with raspicam input plugin (based on raspistill mmal source code)   

Discussion / Questions / Help
=============================

Probably best in this thread
http://www.raspberrypi.org/phpBB3/viewtopic.php?f=43&t=45178


Instructions
============

If you ran the basic build, you can run from the mjpeg streamer experimental
folder with:
```
export LD_LIBRARY_PATH=.
./mjpg_streamer -o "output_http.so -w ./www" -i "input_raspicam.so"
```

You can specify options, like in raspivid:
```
export LD_LIBRARY_PATH=.
./mjpg_streamer -o "output_http.so -w ./www" -i "input_raspicam.so -x 1280 -y 720 -fps 15 -ex night"
```

It does support upto 1080p 30fps, but the bandwidth produced would be more than the usb bus (and therefore ethernet port / wifi dongle) can provide. 720p 15fps is a good compromise.

Here's some help for this input plugin:
```
 ---------------------------------------------------------------
 Help for input plugin..: raspicam input plugin
 ---------------------------------------------------------------
 The following parameters can be passed to this plugin:

 [-fps | --framerate]...: set video framerate, default 5 frame/sec
 [-x | --width ]........: width of frame capture, default 640
 [-y | --height]........: height of frame capture, default 480
 [-quality].............: set JPEG quality 0-100, default 85
 [-usestills]...........: uses stills mode instead of video mode
 [-preview].............: enable full screen preview
 
 -sh : Set image sharpness (-100 to 100)
 -co : Set image contrast (-100 to 100)
 -br : Set image brightness (0 to 100)
 -sa : Set image saturation (-100 to 100)
 -ISO : Set capture ISO
 -vs : Turn on video stabilisation
 -ev : Set EV compensation
 -ex : Set exposure mode (see raspistill notes)
 -awb : Set AWB mode (see raspistill notes)
 -ifx : Set image effect (see raspistill notes)
 -cfx : Set colour effect (U:V)
 -mm : Set metering mode (see raspistill notes)
 -rot : Set image rotation (0-359)
-stats : Compute image stats for each picture (reduces noise)
 -drc : Dynamic range compensation level (see raspistill notes)
 -hf : Set horizontal flip
 -vf : Set vertical flip
 ---------------------------------------------------------------

```
Some of the camera options like ISO may not work due to it not working in the mmal-libs.

Video mode is the default as it allows much smoother video (higher framerates).
Stills mode allows you to use the full-frame of the sensor, but has a max framerate of around 8fps, probably less.
Use stills mode with low FPS (e.g. 1 or 2).

In order to have preview output shown on the raspi screen add the -preview option.

This should run indefinitely. ctrl-c closes mjpeg streamer and raspicam gracefully.

Based on https://github.com/raspberrypi/userland/blob/master/host_applications/linux/apps/raspicam/RaspiStill.c
modified mmal header and source files from https://github.com/raspberrypi/userland/tree/master/interface/mmal

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_testpicture/input_testpicture.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <syslog.h>

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "../../mjpg_streamer.h"
#include "../../utils.h"

#include "testpictures.h"

#define INPUT_PLUGIN_NAME "TESTPICTURE input plugin"

/* private functions and variables to this plugin */
static pthread_t   worker;
static globals     *pglobal;
static pthread_mutex_t controls_mutex;
static int plugin_number;

void *worker_thread(void *);
void worker_cleanup(void *);
void help(void);

static int delay = 1000;

/* details of converted JPG pictures */
struct pic {
    const unsigned char *data;
    const int size;
};

/* lookup pictures by resolution */
#define ENTRY(res, pic1, pic2) { res, { { pic1, sizeof(pic1) }, { pic2, sizeof(pic2) } } }
static struct pictures {
    const char *resolution;
    struct pic sequence[2];
} picture_lookup[] = {
    ENTRY("960x720", PIC_960x720_1, PIC_960x720_2),
    ENTRY("640x480", PIC_640x480_1, PIC_640x480_2),
    ENTRY("320x240", PIC_320x240_1, PIC_320x240_2),
    ENTRY("160x120", PIC_160x120_1, PIC_160x120_2)
};

struct pictures *pics;

/*** plugin interface functions ***/

/******************************************************************************
Description.: parse input parameters
Input Value.: param contains the command line string and a pointer to globals
Return Value: 0 if everything is ok
******************************************************************************/
int input_init(input_parameter *param, int plugin_no)
{
    int i;

    pics = &picture_lookup[1];

    if(pthread_mutex_init(&controls_mutex, NULL) != 0) {
        IPRINT("could not initialize mutex variable\n");
        exit(EXIT_FAILURE);
    }

    param->argv[0] = INPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"d", required_argument, 0, 0},
            {"delay", required_argument, 0, 0},
            {"r", required_argument, 0, 0},
            {"resolution", required_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

            /* d, delay */
        case 2:
        case 3:
            DBG("case 2,3\n");
            delay = atoi(optarg);
            break;

            /* r, resolution */
        case 4:
        case 5:
            DBG("case 4,5\n");
            for(i = 0; i < LENGTH_OF(picture_lookup); i++) {
                if(strcmp(picture_lookup[i].resolution, optarg) == 0) {
                    pics = &picture_lookup[i];
                    break;
                }
            }
            break;

        default:
            DBG("default case\n");
            help();
            return 1;
        }
    }

    pglobal = param->global;

    IPRINT("delay.............: %i\n", delay);
    IPRINT("resolution........: %s\n", pics->resolution);

    return 0;
}

/******************************************************************************
Description.: stops the execution of the worker thread
Input Value.: -
Return Value: 0
******************************************************************************/
int input_stop(int id)
{
    DBG("will cancel input thread\n");
    pthread_cancel(worker);

    return 0;
}

/******************************************************************************
Description.: starts the worker thread and allocates memory
Input Value.: -
Return Value: 0
******************************************************************************/
int input_run(int id)
{
    pglobal->in[id].buf = malloc(256 * 1024);
    if(pglobal->in[id].buf == NULL) {
        fprintf(stderr, "could not allocate memory\n");
        exit(EXIT_FAILURE);
    }

    if(pthread_create(&worker, 0, worker_thread, NULL) != 0) {
        free(pglobal->in[id].buf);
        fprintf(stderr, "could not start worker thread\n");
        exit(EXIT_FAILURE);
    }
    pthread_detach(worker);

    return 0;
}

/******************************************************************************
Description.: print help message
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
    " Help for input plugin..: "INPUT_PLUGIN_NAME"\n" \
    " ---------------------------------------------------------------\n" \
    " The following parameters can be passed to this plugin:\n\n" \
    " [-d | --delay ]........: delay to pause between frames\n" \
    " [-r | --resolution]....: can be 960x720, 640x480, 320x240, 160x120\n"
    " ---------------------------------------------------------------\n");
}

/******************************************************************************
Description.: copy a picture from testpictures.h and signal this to all output
              plugins, afterwards switch to the next frame of the animation.
Input Value.: arg is not used
Return Value: NULL
******************************************************************************/
void *worker_thread(void *arg)
{
    int i = 0;

    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, NULL);

    while(!pglobal->stop) {

        /* copy JPG picture to global buffer */
        pthread_mutex_lock(&pglobal->in[plugin_number].db);

        i = (i + 1) % LENGTH_OF(pics->sequence);
        pglobal->in[plugin_number].size = pics->sequence[i].size;
        memcpy(pglobal->in[plugin_number].buf, pics->sequence[i].data, pglobal->in[plugin_number].size);

        /* signal fresh_frame */
        pthread_cond_broadcast(&pglobal->in[plugin_number].db_update);
        pthread_mutex_unlock(&pglobal->in[plugin_number].db);

        usleep(1000 * delay);
    }

    IPRINT("leaving input thread, calling cleanup function now\n");
    pthread_cleanup_pop(1);

    return NULL;
}

/******************************************************************************
Description.: this functions cleans up allocated resources
Input Value.: arg is unused
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
    DBG("cleaning up resources allocated by input thread\n");

    if(pglobal->in[plugin_number].buf != NULL) free(pglobal->in[plugin_number].buf);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_testpicture/Makefile
================
###############################################################
#
# Purpose: Makefile for "M-JPEG Streamer"
# Author.: Tom Stoeveken (TST)
# Version: 0.3
# License: GPL
#
###############################################################

CC = gcc

OTHER_HEADERS = ../../mjpg_streamer.h ../../utils.h ../output.h ../input.h

CFLAGS += -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC
#CFLAGS += -DDEBUG
LFLAGS += -lpthread -ldl

all: input_testpicture.so

clean:
	rm -f *.a *.o core *~ *.so *.lo

# pictures will not get cleaned automatically, it may be possible
# that other users do not have the required tools for re-building installed
# required tools are:
#  * convert (ImageMagick)
#  * od, sed, tr
clean_pictures:
	rm -f testpictures.h
	rm -f pictures/160x120_1.jpg pictures/160x120_2.jpg
	rm -f pictures/320x240_1.jpg pictures/320x240_2.jpg
	rm -f pictures/640x480_1.jpg pictures/640x480_2.jpg

input_testpicture.so: $(OTHER_HEADERS) input_testpicture.c testpictures.h
	$(CC) $(CFLAGS) -o $@ input_testpicture.c

# converts multiple JPG files to a single C header file
testpictures.h: pictures/960x720_1.jpg pictures/640x480_1.jpg pictures/320x240_1.jpg pictures/160x120_1.jpg pictures/160x120_2.jpg pictures/320x240_2.jpg pictures/640x480_2.jpg pictures/960x720_2.jpg
	@echo "/* automatically generated content, do not edit manually!" > testpictures.h.tmp
	@echo " */ " >> testpictures.h.tmp
	@FILES="160x120_1 320x240_1 640x480_1 960x720_1 160x120_2 320x240_2 640x480_2 960x720_2" && \
	  for file in $$FILES; do \
	    echo "converting file: $$file.jpg"; \
	    echo "static const unsigned char PIC_$$file[] = { " >> testpictures.h.tmp; \
	    od -An -v -t x1 pictures/$$file.jpg | sed -e "s/\ \([0-9a-fA-F]*\)/\ 0x\1,/g" >> testpictures.h.tmp; \
	    echo "};" >> testpictures.h.tmp; \
	  done;
	@cat testpictures.h.tmp | tr '\n' 'N' | sed -e "s/,N};/};/g" | tr 'N' '\n' > testpictures.h
	@rm testpictures.h.tmp

pictures/160x120_1.jpg: pictures/960x720_1.jpg
	convert pictures/960x720_1.jpg -resize 160x120! pictures/160x120_1.jpg

pictures/160x120_2.jpg: pictures/960x720_2.jpg
	convert pictures/960x720_2.jpg -resize 160x120! pictures/160x120_2.jpg

pictures/320x240_1.jpg: pictures/960x720_1.jpg
	convert pictures/960x720_1.jpg -resize 320x240! pictures/320x240_1.jpg

pictures/320x240_2.jpg: pictures/960x720_2.jpg
	convert pictures/960x720_2.jpg -resize 320x240! pictures/320x240_2.jpg

pictures/640x480_1.jpg: pictures/960x720_1.jpg
	convert pictures/960x720_1.jpg -resize 640x480! pictures/640x480_1.jpg

pictures/640x480_2.jpg: pictures/960x720_2.jpg
	convert pictures/960x720_2.jpg -resize 640x480! pictures/640x480_2.jpg

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_testpicture/testpictures.h
================
/* automatically generated content, do not edit manually!
 */ 
static const unsigned char PIC_160x120_1[] = { 
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x17, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
 0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65, 0x20, 0x47, 0x49, 0x4d, 0x50, 0xff, 0xe1, 0x00,
 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x05, 0x03, 0x04, 0x04, 0x04, 0x03,
 0x05, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0c, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0f,
 0x0b, 0x0b, 0x09, 0x0c, 0x11, 0x0f, 0x12, 0x12, 0x11, 0x0f, 0x11, 0x11, 0x13, 0x16, 0x1c, 0x17,
 0x13, 0x14, 0x1a, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1a, 0x1d, 0x1d, 0x1f, 0x1f, 0x1f, 0x13,
 0x17, 0x22, 0x24, 0x22, 0x1e, 0x24, 0x1c, 0x1e, 0x1f, 0x1e, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x05,
 0x05, 0x05, 0x07, 0x06, 0x07, 0x0e, 0x08, 0x08, 0x0e, 0x1e, 0x14, 0x11, 0x14, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0xff,
 0xc0, 0x00, 0x11, 0x08, 0x00, 0x78, 0x00, 0xa0, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03,
 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1d, 0x00, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x04, 0x07, 0x03, 0x05, 0x08, 0x02, 0x09,
 0x01, 0xff, 0xc4, 0x00, 0x44, 0x10, 0x00, 0x01, 0x02, 0x04, 0x01, 0x0a, 0x04, 0x02, 0x06, 0x07,
 0x07, 0x05, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x00, 0x04, 0x05, 0x11, 0x06, 0x07, 0x12,
 0x13, 0x15, 0x21, 0x31, 0x51, 0x61, 0x62, 0xa1, 0x22, 0x41, 0x52, 0x91, 0x08, 0x71, 0x14, 0x32,
 0x42, 0x81, 0x92, 0xd1, 0x16, 0x23, 0x25, 0x53, 0x55, 0x94, 0xc1, 0x33, 0x34, 0x43, 0x72, 0x93,
 0xb1, 0xd2, 0x44, 0x82, 0xa3, 0xc2, 0xe1, 0xff, 0xc4, 0x00, 0x1c, 0x01, 0x01, 0x01, 0x00, 0x02,
 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x05,
 0x01, 0x02, 0x06, 0x07, 0x08, 0xff, 0xc4, 0x00, 0x2f, 0x11, 0x00, 0x02, 0x02, 0x01, 0x03, 0x02,
 0x03, 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
 0x05, 0x12, 0x21, 0x31, 0x41, 0x51, 0x81, 0x13, 0x32, 0x61, 0x71, 0xa1, 0xe1, 0x06, 0x14, 0x15,
 0x42, 0x43, 0xc1, 0x22, 0x91, 0xf0, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
 0x11, 0x00, 0x3f, 0x00, 0x44, 0x76, 0x5b, 0x7e, 0xc8, 0x88, 0xec, 0xb7, 0x28, 0x73, 0x9c, 0xa5,
 0x6f, 0xf0, 0xc6, 0xaa, 0x66, 0x9e, 0xb4, 0xdf, 0x64, 0x7b, 0xea, 0xf5, 0x09, 0x9f, 0x2b, 0xaf,
 0x52, 0x98, 0xae, 0xec, 0xb7, 0x28, 0x8a, 0xec, 0xb7, 0x28, 0x63, 0x7a, 0x58, 0x8d, 0xe9, 0x88,
 0xae, 0xcb, 0x72, 0x8a, 0xa3, 0x71, 0x5c, 0x2e, 0x17, 0x1d, 0x96, 0xe5, 0x11, 0x5d, 0x96, 0xe5,
 0x0c, 0x4e, 0xcb, 0x72, 0x88, 0xae, 0xcb, 0x72, 0x8a, 0x23, 0x69, 0x4c, 0x2e, 0x17, 0x5d, 0x96,
 0xe5, 0x11, 0x5d, 0x96, 0xe5, 0x0c, 0x4e, 0xcb, 0x72, 0x88, 0xae, 0xcb, 0x72, 0x8a, 0x23, 0x69,
 0x44, 0x2e, 0x17, 0x9c, 0x60, 0x88, 0xc2, 0xa4, 0x28, 0x79, 0x46, 0xf5, 0xd9, 0x7e, 0x51, 0x15,
 0xd9, 0x7e, 0x51, 0x44, 0x6d, 0x28, 0x8d, 0xb9, 0x35, 0x50, 0x44, 0xb7, 0x25, 0xf9, 0x46, 0x05,
 0xb4, 0xa4, 0xc6, 0x55, 0x24, 0xcc, 0xaa, 0x49, 0x98, 0xe0, 0x80, 0x82, 0x37, 0xc1, 0x1c, 0x9c,
 0x84, 0x10, 0x41, 0x00, 0x10, 0x41, 0x04, 0x00, 0x41, 0x04, 0x10, 0x07, 0x5f, 0x4f, 0x51, 0xd4,
 0x9b, 0xdd, 0x11, 0xa4, 0x9c, 0xa5, 0x6f, 0xf0, 0xc5, 0xe9, 0x50, 0xc3, 0x28, 0x79, 0x05, 0x72,
 0xaa, 0x43, 0xc9, 0xe5, 0xbe, 0x15, 0x6a, 0x78, 0x75, 0x48, 0x24, 0x16, 0xc8, 0x3f, 0x28, 0xf9,
 0x4e, 0x9f, 0x71, 0x52, 0xec, 0xcf, 0x1d, 0xaa, 0xd9, 0xf5, 0x7a, 0x47, 0xdb, 0xa1, 0x4e, 0x4e,
 0x52, 0xb7, 0xf8, 0x63, 0x51, 0x35, 0x4c, 0x52, 0x49, 0xb0, 0x8b, 0x1e, 0xa1, 0xaa, 0x10, 0xb5,
 0x21, 0x55, 0x6a, 0x60, 0x52, 0x49, 0x04, 0x19, 0xc6, 0xee, 0x0f, 0x0f, 0xad, 0x1a, 0x49, 0xb5,
 0xd1, 0xcd, 0xed, 0x55, 0xa7, 0x7f, 0x36, 0xdf, 0xfc, 0xa3, 0x6f, 0x4e, 0xb9, 0x79, 0x92, 0xc2,
 0xdb, 0xa0, 0xf1, 0x28, 0xbf, 0xf4, 0x20, 0xbf, 0x26, 0xa4, 0xde, 0xe9, 0x88, 0x6e, 0xcb, 0x72,
 0x87, 0xe9, 0x9a, 0x62, 0x1c, 0x40, 0x5b, 0x65, 0x2b, 0x42, 0x85, 0xd2, 0xa4, 0x9b, 0x82, 0x38,
 0x82, 0x37, 0xc6, 0xa2, 0x6e, 0x96, 0x45, 0xec, 0x98, 0xd8, 0xd7, 0xaa, 0x4c, 0xb2, 0xbd, 0x52,
 0x7d, 0xc4, 0xe7, 0x65, 0xb7, 0xec, 0x88, 0xce, 0xcb, 0x72, 0x86, 0x69, 0x89, 0x15, 0xa7, 0xca,
 0x20, 0xbb, 0x2d, 0x63, 0xba, 0x2c, 0x85, 0xc5, 0x90, 0xbb, 0x22, 0xe3, 0xb2, 0xdc, 0xa2, 0x2b,
 0xb2, 0xfc, 0xa1, 0x89, 0xd9, 0x6d, 0xfb, 0x22, 0x2b, 0xb2, 0xdc, 0xa2, 0x98, 0xda, 0x53, 0x1b,
 0x85, 0xd7, 0x65, 0xf9, 0x44, 0x57, 0x65, 0xb9, 0x43, 0x13, 0xb2, 0xdc, 0xa2, 0x2b, 0xb2, 0xfc,
 0xa2, 0x88, 0xdc, 0x53, 0x1b, 0x85, 0xd7, 0x65, 0xb9, 0x44, 0x67, 0x18, 0x23, 0x74, 0x30, 0xbb,
 0x2d, 0xca, 0x22, 0xbb, 0x2f, 0xca, 0x28, 0x8d, 0xa5, 0x11, 0xb8, 0xd1, 0x94, 0x91, 0xbc, 0x47,
 0xe4, 0x6c, 0xdd, 0x96, 0xe5, 0x11, 0x5c, 0x97, 0x3e, 0x42, 0x33, 0x29, 0xa6, 0x66, 0x53, 0x4c,
 0x8d, 0x04, 0x7b, 0x53, 0x6a, 0x11, 0x89, 0x2a, 0x4a, 0xaf, 0x9a, 0xa4, 0xaa, 0xdb, 0xec, 0x6f,
 0x1d, 0xb9, 0x23, 0xba, 0xea, 0x7a, 0x82, 0x08, 0x23, 0x90, 0x77, 0x95, 0x23, 0x13, 0xad, 0xb2,
 0x08, 0x74, 0x8f, 0xbe, 0x1b, 0x29, 0xd8, 0x86, 0x56, 0x71, 0x6d, 0xa2, 0x6d, 0xb4, 0x2e, 0xea,
 0x1e, 0x2f, 0x3d, 0xf1, 0xcf, 0x52, 0x15, 0xb2, 0x2d, 0xe3, 0xef, 0x0c, 0x74, 0xaa, 0xf1, 0x0e,
 0xb7, 0xe3, 0xfb, 0x43, 0xcf, 0x9c, 0x7e, 0x72, 0x85, 0xee, 0x3d, 0x99, 0x6d, 0x7a, 0xd4, 0xd6,
 0x25, 0xd5, 0x1c, 0xcb, 0x93, 0x0c, 0x9d, 0x4b, 0x65, 0x43, 0x2d, 0xb5, 0xac, 0x32, 0xf5, 0x51,
 0x74, 0xc6, 0xf3, 0xa7, 0x66, 0x52, 0xf2, 0x1a, 0x4b, 0x84, 0xe6, 0x3b, 0xb1, 0x36, 0x24, 0x6f,
 0xce, 0xed, 0x16, 0xec, 0xff, 0x00, 0xc2, 0x0c, 0x94, 0xa9, 0x37, 0xc5, 0xf3, 0xe7, 0x9f, 0xd0,
 0x11, 0xff, 0x00, 0x38, 0xa2, 0x70, 0x3f, 0xe9, 0xab, 0xb9, 0x52, 0xa9, 0xab, 0x01, 0x54, 0x1c,
 0x91, 0xab, 0x95, 0xcc, 0x9d, 0x2a, 0x1f, 0x4b, 0x47, 0x47, 0x9f, 0xe2, 0x19, 0xca, 0xd9, 0xc3,
 0x64, 0x5d, 0x58, 0x65, 0xbf, 0x89, 0xa1, 0x5b, 0xa7, 0xae, 0xa1, 0x8b, 0x26, 0x5e, 0x90, 0x44,
 0xd3, 0x4a, 0x99, 0x6d, 0x55, 0x56, 0x54, 0x14, 0xd0, 0x58, 0x2b, 0x16, 0xde, 0x7c, 0x37, 0xd9,
 0x1b, 0xf9, 0x5c, 0xa1, 0x2e, 0xad, 0x1b, 0x1d, 0x44, 0x5c, 0xd6, 0x21, 0x67, 0x17, 0xe9, 0xfd,
 0x96, 0x0d, 0x5a, 0x4e, 0x89, 0x93, 0xfc, 0x21, 0x4e, 0x6a, 0xb7, 0x54, 0x6e, 0x5a, 0x4a, 0x51,
 0xb6, 0xa4, 0x91, 0x32, 0xf2, 0x08, 0xd2, 0x28, 0x22, 0xc3, 0x62, 0x41, 0xb1, 0x21, 0x24, 0xc2,
 0xa5, 0x73, 0x1b, 0x60, 0x49, 0x01, 0x26, 0x66, 0xb1, 0x14, 0xa2, 0x44, 0xeb, 0x41, 0xe6, 0x2c,
 0x85, 0xaa, 0xe8, 0x3b, 0x02, 0x8d, 0x93, 0x74, 0x83, 0x63, 0xbe, 0xd0, 0xc5, 0xf1, 0xd1, 0x31,
 0x4e, 0x9a, 0xc8, 0xd4, 0xbb, 0xb2, 0x88, 0xd1, 0xba, 0x6b, 0x6c, 0x6c, 0x1b, 0xad, 0xa3, 0x7b,
 0xff, 0x00, 0x90, 0x9b, 0xf0, 0xf5, 0x90, 0x2c, 0x37, 0x8a, 0xf2, 0x51, 0x4d, 0xc6, 0x15, 0xd6,
 0x27, 0x27, 0x27, 0x67, 0x5f, 0x5b, 0x8d, 0x14, 0xcc, 0x14, 0xa5, 0xa6, 0xda, 0x70, 0xa1, 0x29,
 0xcd, 0xdc, 0x6f, 0x98, 0x6f, 0x7f, 0x23, 0x61, 0x68, 0xb6, 0x9d, 0xc5, 0xb8, 0xa6, 0x8f, 0x27,
 0x67, 0xe1, 0x8a, 0x61, 0x17, 0x75, 0x92, 0x93, 0x79, 0x7e, 0xee, 0x3f, 0xb4, 0x4d, 0xc5, 0xd5,
 0x2a, 0x06, 0x1e, 0x93, 0x6a, 0x6e, 0xb1, 0x52, 0x62, 0x51, 0xa7, 0x85, 0xd9, 0xce, 0xb9, 0x53,
 0x82, 0xd7, 0xba, 0x52, 0x01, 0x27, 0x78, 0xf2, 0xf3, 0x85, 0x19, 0x3c, 0x67, 0x82, 0xaa, 0xb3,
 0x68, 0x95, 0x94, 0xad, 0x36, 0x1e, 0x70, 0xe6, 0xa1, 0x2f, 0x34, 0xb6, 0x82, 0x89, 0xdc, 0x01,
 0x50, 0x03, 0xbc, 0x33, 0x65, 0xf3, 0x06, 0x64, 0xee, 0x4f, 0x19, 0x4a, 0xe2, 0x0c, 0x73, 0x8b,
 0x66, 0x25, 0x5c, 0x28, 0x46, 0x6d, 0x24, 0x27, 0x3f, 0x48, 0xd2, 0x6f, 0xb1, 0x29, 0x40, 0xcf,
 0x4a, 0x49, 0xbd, 0xcf, 0x99, 0xbe, 0xde, 0x14, 0x36, 0x56, 0xea, 0x38, 0x06, 0xa2, 0xb9, 0x45,
 0xe0, 0x7a, 0x2c, 0xd4, 0x8a, 0x1b, 0x52, 0xd0, 0xfb, 0xca, 0x6c, 0xb6, 0xd3, 0xdb, 0x06, 0x68,
 0x09, 0x2a, 0x3b, 0x46, 0xde, 0x1b, 0xe3, 0x60, 0xb7, 0x2b, 0x23, 0xd5, 0x63, 0x06, 0x0d, 0xbf,
 0x67, 0xae, 0xd5, 0x18, 0x4d, 0x4f, 0x93, 0xee, 0xf0, 0x94, 0x53, 0xf2, 0xeb, 0xdf, 0xd0, 0xb7,
 0xf1, 0x01, 0x93, 0xa3, 0xc9, 0xaa, 0x72, 0xa3, 0x30, 0x89, 0x69, 0x70, 0xa0, 0x92, 0xb5, 0x83,
 0x60, 0x4e, 0xe1, 0xb0, 0x42, 0xfd, 0x43, 0x11, 0x61, 0xe9, 0x59, 0x36, 0x26, 0xde, 0xaa, 0x30,
 0x1a, 0x98, 0x05, 0x4d, 0x10, 0x14, 0x4a, 0xc0, 0x24, 0x5c, 0x24, 0x0b, 0xda, 0xe0, 0x8b, 0xda,
 0x27, 0xe5, 0x85, 0x87, 0x15, 0x90, 0xba, 0x7c, 0xf3, 0xa4, 0xa9, 0xc7, 0x5b, 0x91, 0x5a, 0x94,
 0x7c, 0xca, 0x91, 0x72, 0x61, 0x77, 0x25, 0x59, 0x3e, 0xa3, 0x57, 0x30, 0x1e, 0xb6, 0xa9, 0xcb,
 0xae, 0x66, 0x62, 0x65, 0x4e, 0xa1, 0xb5, 0x29, 0xc5, 0x0d, 0x0a, 0x50, 0x4a, 0x46, 0x68, 0x07,
 0x7d, 0xee, 0x63, 0x62, 0xb7, 0x2b, 0x5c, 0xf8, 0x56, 0x97, 0x6c, 0xf5, 0x31, 0xe9, 0xa9, 0xd3,
 0xc7, 0x4b, 0xf9, 0x8b, 0xe4, 0xfa, 0x4b, 0x8f, 0x4c, 0x7f, 0x66, 0xc3, 0x5b, 0x51, 0x9d, 0xa5,
 0xaa, 0xa8, 0x8a, 0x8c, 0xb9, 0x93, 0x49, 0xcd, 0x2e, 0x95, 0x58, 0x03, 0xc0, 0x8d, 0xf7, 0xe5,
 0x6b, 0xc4, 0x3a, 0x6d, 0x62, 0x8b, 0x56, 0x75, 0x4c, 0xd3, 0xe7, 0x9a, 0x79, 0xd0, 0x2f, 0x99,
 0x62, 0x95, 0x11, 0xc4, 0x02, 0x05, 0xfe, 0xe8, 0x46, 0xc9, 0x2e, 0x1d, 0x97, 0xc4, 0x35, 0xd9,
 0x89, 0x69, 0xe0, 0xb7, 0x65, 0x65, 0x99, 0x2f, 0x16, 0x82, 0x88, 0x0b, 0x56, 0x70, 0x48, 0xbd,
 0xbe, 0x66, 0x32, 0xe2, 0x4a, 0x5b, 0x38, 0x7b, 0x2a, 0x72, 0x52, 0xb4, 0xe4, 0x16, 0x1b, 0x2f,
 0x4b, 0xad, 0x28, 0x04, 0x9c, 0xdc, 0xf2, 0x01, 0x02, 0xfe, 0x5b, 0xfd, 0xe3, 0xb4, 0x37, 0x6b,
 0xf8, 0x46, 0xc7, 0x15, 0xc7, 0x38, 0x7d, 0xf2, 0x6d, 0x5e, 0xdf, 0xa7, 0x8d, 0xd3, 0xd3, 0xa9,
 0xbe, 0x69, 0x65, 0x76, 0xc7, 0xc9, 0x8f, 0x53, 0xc9, 0x66, 0x59, 0x85, 0xbf, 0x30, 0xe2, 0x1a,
 0x69, 0x02, 0xea, 0x5a, 0xcd, 0x80, 0x85, 0xf4, 0xe2, 0x2a, 0x03, 0xcf, 0x68, 0x91, 0x50, 0x40,
 0x51, 0x36, 0x05, 0x48, 0x52, 0x52, 0x7e, 0xf2, 0x2d, 0x10, 0x32, 0xd1, 0x34, 0xe2, 0x2a, 0x32,
 0x54, 0xb0, 0xb2, 0x86, 0x43, 0x7a, 0x65, 0x8e, 0x24, 0xa8, 0x80, 0x4f, 0xc8, 0x03, 0xef, 0x1a,
 0xca, 0xd2, 0xf0, 0x32, 0xe8, 0x4b, 0x62, 0x9c, 0xa7, 0x44, 0xeb, 0x68, 0x05, 0xa7, 0x4b, 0x4a,
 0x05, 0x6a, 0xf3, 0xce, 0x27, 0x66, 0xdd, 0xbf, 0x28, 0xa2, 0xfd, 0xda, 0xc8, 0x59, 0x28, 0xd7,
 0xc5, 0x28, 0xf9, 0xbe, 0xff, 0x00, 0x04, 0x76, 0xd2, 0x68, 0x63, 0x2a, 0xa1, 0x39, 0xf2, 0x7c,
 0xbc, 0x97, 0x6f, 0x98, 0xe4, 0xe4, 0xbd, 0xc5, 0xf7, 0x88, 0x8a, 0xec, 0xb7, 0x28, 0xc1, 0x93,
 0x57, 0xdc, 0x9e, 0xc3, 0x85, 0xb7, 0x49, 0x51, 0x96, 0x74, 0xb4, 0x92, 0x4f, 0xd9, 0xb0, 0x23,
 0xdb, 0x6c, 0x6f, 0xdd, 0x96, 0xdf, 0xb2, 0x37, 0x9a, 0x5d, 0x5a, 0xba, 0xa8, 0xd8, 0xbc, 0x48,
 0xed, 0xcd, 0x16, 0xca, 0xb7, 0xe0, 0x57, 0x78, 0x86, 0xaa, 0x43, 0xee, 0xd3, 0xa4, 0x5a, 0x5a,
 0x9f, 0x4d, 0xd2, 0xb5, 0xdb, 0xea, 0xdb, 0x7d, 0xbf, 0x38, 0x87, 0x83, 0x1b, 0xd2, 0x09, 0xbe,
 0x59, 0x9f, 0xd6, 0x1e, 0x6a, 0x14, 0xd9, 0x76, 0x25, 0x27, 0xdf, 0x69, 0x84, 0x21, 0xc7, 0x5a,
 0x71, 0x4b, 0x58, 0x1b, 0x54, 0x73, 0x4f, 0x9c, 0x29, 0x64, 0xed, 0xbd, 0x22, 0x67, 0xb9, 0x68,
 0xff, 0x00, 0xf6, 0x8d, 0x4b, 0xf6, 0xd1, 0xdc, 0xe9, 0x9d, 0xb2, 0xce, 0x79, 0x61, 0x78, 0x25,
 0x87, 0xff, 0x00, 0x33, 0x6f, 0x5d, 0xf0, 0x96, 0x92, 0x7c, 0x16, 0x31, 0x8f, 0x53, 0x60, 0xb6,
 0x54, 0x98, 0xc6, 0x41, 0x1b, 0xc4, 0x6e, 0x9d, 0x97, 0xe5, 0x11, 0x5d, 0x96, 0xe5, 0x1e, 0xae,
 0x36, 0xe4, 0x86, 0x36, 0xa6, 0x58, 0x52, 0x75, 0x94, 0x8b, 0x5d, 0xd4, 0x8f, 0xfb, 0x84, 0x6f,
 0x29, 0xd5, 0xb4, 0x67, 0xa3, 0xf5, 0xc8, 0xde, 0x3e, 0xd0, 0x8e, 0xcc, 0xd1, 0xd1, 0x7c, 0xa9,
 0x72, 0x1f, 0xcb, 0xa3, 0xf2, 0x8f, 0x49, 0x4d, 0x1f, 0x38, 0x7e, 0xcd, 0x91, 0xdf, 0xfb, 0x84,
 0x7e, 0x51, 0xf0, 0x25, 0xb4, 0x49, 0x7e, 0xff, 0x00, 0xa7, 0xdc, 0xbe, 0x3b, 0x2c, 0xe3, 0xfc,
 0x9f, 0x4f, 0xb9, 0xf3, 0x6f, 0x22, 0x73, 0x82, 0x5b, 0x2b, 0x53, 0xb3, 0x05, 0x40, 0x02, 0xd4,
 0xce, 0xd2, 0x78, 0xa8, 0x47, 0x49, 0x53, 0xeb, 0xe9, 0x16, 0xfd, 0x72, 0x7f, 0x14, 0x5b, 0x18,
 0x31, 0x54, 0xd3, 0x8b, 0x1f, 0x0a, 0x91, 0x94, 0x29, 0xcd, 0x7b, 0x66, 0x85, 0x3e, 0xaf, 0x94,
 0x3e, 0x05, 0xd2, 0xc6, 0xe9, 0x19, 0x4f, 0xf4, 0x53, 0xf9, 0x45, 0x7a, 0x8d, 0x0c, 0xad, 0x9f,
 0x2e, 0x58, 0x36, 0x17, 0x68, 0xe7, 0x64, 0xf9, 0x29, 0x60, 0xe2, 0xff, 0x00, 0x8a, 0x4a, 0xb0,
 0x9d, 0xc9, 0x6c, 0xbb, 0x21, 0xc0, 0xab, 0x55, 0x19, 0x55, 0xaf, 0xd0, 0xe4, 0x59, 0x5f, 0x0b,
 0x98, 0x89, 0x52, 0x19, 0x16, 0xc3, 0x72, 0xe9, 0x78, 0x27, 0x31, 0xa7, 0x76, 0x5f, 0x8b, 0xee,
 0x18, 0xb8, 0xf2, 0x8a, 0xaa, 0x62, 0xe8, 0x08, 0x49, 0x91, 0x93, 0x50, 0xfa, 0x42, 0x36, 0x16,
 0x12, 0x7c, 0x95, 0xc4, 0x44, 0xec, 0x14, 0xf5, 0x3d, 0xbc, 0x31, 0x24, 0x94, 0xc9, 0xca, 0xa4,
 0x04, 0xab, 0x62, 0x5a, 0x48, 0x1f, 0x58, 0xf0, 0x11, 0xdd, 0x68, 0xe4, 0xaa, 0x55, 0xf2, 0xf1,
 0xc9, 0x9e, 0x14, 0xce, 0x30, 0x51, 0xe5, 0xd4, 0xe1, 0xac, 0xb3, 0x54, 0x1b, 0xa0, 0xfc, 0x54,
 0xab, 0x17, 0x63, 0x6a, 0x2b, 0x95, 0xac, 0x3e, 0xf4, 0xdb, 0x73, 0x28, 0x60, 0x80, 0x50, 0xfc,
 0xb8, 0x6c, 0x24, 0x25, 0x37, 0xf0, 0x92, 0x82, 0x3e, 0xa9, 0xd8, 0x4a, 0x76, 0xec, 0x31, 0x1b,
 0xe2, 0x53, 0x1d, 0x49, 0x65, 0x06, 0x8d, 0x4b, 0x9c, 0xc2, 0x18, 0x62, 0xa5, 0x21, 0x85, 0x29,
 0x73, 0x0a, 0x64, 0xce, 0xcc, 0xcb, 0xa5, 0xa4, 0xb9, 0x32, 0xea, 0x76, 0x21, 0x29, 0x41, 0x29,
 0x16, 0x4b, 0x67, 0xcc, 0x9e, 0x36, 0xd9, 0x7e, 0xc7, 0xc4, 0xaf, 0x4a, 0x55, 0xb1, 0x6e, 0xae,
 0x9f, 0x4c, 0xb3, 0x72, 0xa8, 0x74, 0x21, 0xb0, 0xe3, 0x49, 0x29, 0x40, 0xb5, 0xf3, 0x80, 0x22,
 0xd7, 0x3c, 0x63, 0x1e, 0x2c, 0x91, 0x95, 0xa5, 0x53, 0xe5, 0xe4, 0x5a, 0x53, 0x4f, 0xd3, 0x1c,
 0x59, 0x5a, 0x25, 0xdc, 0x65, 0x05, 0x28, 0x5a, 0x46, 0xf0, 0x2d, 0x6f, 0x3f, 0x28, 0xaa, 0x11,
 0x71, 0x49, 0x36, 0x64, 0x74, 0xc6, 0x52, 0x8c, 0xa4, 0xba, 0xa3, 0x9d, 0xb2, 0xcf, 0x2c, 0xd3,
 0xdf, 0x09, 0xb8, 0x7e, 0xad, 0x2e, 0x42, 0x9a, 0x79, 0x8a, 0x68, 0x0a, 0x1b, 0xae, 0x10, 0x52,
 0xa1, 0xf3, 0x05, 0x24, 0x7d, 0xd1, 0x37, 0xe1, 0xda, 0x9a, 0x66, 0x32, 0x2b, 0x4b, 0x7e, 0xc0,
 0xdd, 0xc9, 0xae, 0xce, 0xaa, 0x3a, 0x4f, 0x11, 0x2a, 0x9c, 0x8c, 0x9d, 0xca, 0x49, 0xa6, 0x4e,
 0x57, 0x40, 0x90, 0xc9, 0x0d, 0xe8, 0x53, 0x98, 0x09, 0xda, 0x4e, 0x6d, 0xad, 0xbc, 0x93, 0x1b,
 0x1c, 0x09, 0x31, 0x22, 0xd6, 0x15, 0x97, 0x6d, 0x12, 0xd2, 0xe8, 0x48, 0x53, 0x9e, 0x14, 0xb4,
 0x90, 0x3e, 0xb1, 0xf2, 0x02, 0x28, 0xae, 0xd9, 0x42, 0x5c, 0x8d, 0x26, 0xaf, 0x60, 0x85, 0xfa,
 0x67, 0xa7, 0x84, 0xb1, 0xfe, 0x5c, 0x8e, 0x02, 0xf8, 0x61, 0x96, 0x13, 0x18, 0xa6, 0xb6, 0x93,
 0x6f, 0x0c, 0x90, 0x3f, 0xf9, 0x53, 0x11, 0xf2, 0xb5, 0x2e, 0x1b, 0xcb, 0xad, 0x31, 0x91, 0x6b,
 0x17, 0x24, 0xbc, 0xf8, 0xa8, 0x47, 0x72, 0x64, 0xd1, 0x54, 0xd6, 0xaa, 0xb3, 0x85, 0x12, 0x32,
 0x68, 0x25, 0x81, 0xb5, 0x2c, 0x21, 0x3f, 0x6b, 0x90, 0x8f, 0xcc, 0x52, 0x69, 0xab, 0xc7, 0x72,
 0xcb, 0x32, 0x12, 0x6a, 0x21, 0x4c, 0x6d, 0x2c, 0x20, 0x9d, 0xfc, 0x6d, 0x19, 0x15, 0xed, 0x56,
 0xa1, 0xe4, 0xf2, 0x67, 0xfd, 0x2e, 0x5f, 0x9e, 0x9e, 0xab, 0x9f, 0x49, 0x47, 0x18, 0xc7, 0xcb,
 0xae, 0x73, 0xf0, 0x38, 0xbb, 0x2f, 0x78, 0x4e, 0x75, 0xcf, 0xa2, 0xd7, 0xe9, 0xec, 0x97, 0xfe,
 0x8c, 0x92, 0xd4, 0xc2, 0x50, 0x33, 0x8a, 0x53, 0x9d, 0x9c, 0x95, 0xdb, 0xcc, 0x02, 0x48, 0x3f,
 0x74, 0x2d, 0x4f, 0xe3, 0xfa, 0x73, 0xf4, 0x94, 0x22, 0x9f, 0x42, 0x69, 0x15, 0x45, 0xe6, 0x83,
 0x9e, 0xc3, 0x6a, 0x68, 0x1f, 0x32, 0x3c, 0xcd, 0xfc, 0x85, 0xbc, 0xe3, 0xe8, 0x46, 0x3e, 0xac,
 0xcb, 0xcb, 0xe8, 0x64, 0x24, 0xe5, 0xe5, 0xdb, 0x5b, 0xc0, 0xa9, 0xc5, 0x25, 0xb4, 0x83, 0x6b,
 0xd8, 0x00, 0x6d, 0xb2, 0xfb, 0x63, 0x5e, 0xf6, 0x11, 0xa7, 0x31, 0x26, 0x99, 0x89, 0x44, 0xc8,
 0xaa, 0x7d, 0x24, 0x28, 0xa4, 0x30, 0xd2, 0x05, 0xfc, 0xec, 0xab, 0x5c, 0x11, 0xc6, 0x33, 0x4b,
 0x5d, 0x35, 0x39, 0x4a, 0x1d, 0x39, 0x77, 0x1a, 0x5d, 0xab, 0x85, 0x30, 0xaa, 0xf9, 0x72, 0xe3,
 0xdb, 0xba, 0xf4, 0x7d, 0x7a, 0x9c, 0x77, 0x85, 0x9a, 0x9f, 0x5d, 0x11, 0xb7, 0xea, 0xb2, 0x92,
 0x92, 0x73, 0x2e, 0x92, 0xa2, 0xd3, 0x2d, 0x86, 0xec, 0x9f, 0x2c, 0xe1, 0xea, 0x89, 0xae, 0xb2,
 0x8f, 0x52, 0x7f, 0x10, 0x8e, 0xe0, 0xa1, 0x68, 0x45, 0x39, 0x08, 0xa9, 0xc9, 0x53, 0xdc, 0x98,
 0x49, 0x20, 0xad, 0x0d, 0xa1, 0x59, 0xc3, 0xc8, 0x9b, 0x0d, 0xf1, 0x3a, 0xd4, 0x8f, 0xe1, 0xd2,
 0x5f, 0xe8, 0x27, 0xf2, 0x8d, 0x9d, 0x5b, 0xe7, 0xb3, 0x8a, 0x8f, 0x0c, 0xe3, 0xe3, 0xf6, 0x22,
 0x9e, 0xc1, 0x39, 0xcd, 0xcb, 0xda, 0x25, 0x9f, 0x87, 0xdc, 0xf9, 0xfd, 0x5a, 0x69, 0x02, 0x95,
 0x38, 0x73, 0x93, 0xfd, 0xdd, 0xcf, 0x31, 0xe9, 0x30, 0x87, 0x92, 0xb4, 0x25, 0x49, 0xa8, 0xe7,
 0x14, 0x8b, 0x68, 0xf7, 0x9f, 0xf3, 0x47, 0xd3, 0x4a, 0x92, 0x69, 0x1a, 0xba, 0x6b, 0xf6, 0x74,
 0x97, 0xf6, 0x2b, 0xff, 0x00, 0x01, 0x1e, 0x93, 0xca, 0x15, 0x32, 0x66, 0x8a, 0x46, 0x6c, 0xf6,
 0x75, 0x36, 0x43, 0x73, 0x7f, 0xf4, 0xe8, 0x1e, 0xae, 0x51, 0x8a, 0xcd, 0xe1, 0x4f, 0x51, 0x0b,
 0xb8, 0x7b, 0xb9, 0xf1, 0xf3, 0xf4, 0x2c, 0xa7, 0x69, 0x95, 0x74, 0x4e, 0xae, 0x7e, 0xf6, 0x3c,
 0x3c, 0xbd, 0x4e, 0x26, 0x75, 0x94, 0x7a, 0xd1, 0xf8, 0x84, 0x46, 0x75, 0xa4, 0x7a, 0xd1, 0xf8,
 0x84, 0x7d, 0x14, 0xcc, 0xa3, 0x7f, 0x0c, 0x91, 0xfe, 0x5d, 0x1f, 0x94, 0x1a, 0x3a, 0x2f, 0xf0,
 0xc9, 0x0f, 0xe5, 0xd1, 0xf9, 0x46, 0xc1, 0x7e, 0x26, 0x4b, 0xf8, 0xfe, 0xbf, 0x63, 0x0a, 0xd9,
 0x66, 0xbf, 0x7f, 0xd3, 0xee, 0x25, 0x6b, 0x8e, 0xa8, 0xfd, 0x15, 0x9f, 0x10, 0xf1, 0x79, 0xf1,
 0x8a, 0xe7, 0x5c, 0xf5, 0xc0, 0x2b, 0x3b, 0x47, 0x8f, 0xce, 0x3c, 0x99, 0xe8, 0x0f, 0x74, 0xfa,
 0xdc, 0xec, 0xb5, 0x61, 0xe7, 0x69, 0xe8, 0xd2, 0x3d, 0x75, 0x8c, 0xdc, 0xdc, 0xed, 0x84, 0xed,
 0xd9, 0x1b, 0xa6, 0x31, 0x56, 0x25, 0x53, 0xed, 0xa5, 0xc9, 0x5b, 0x20, 0xac, 0x05, 0x1d, 0x01,
 0xd8, 0x2f, 0xb7, 0xce, 0x2b, 0x0a, 0x6e, 0x20, 0x44, 0x85, 0x59, 0xd9, 0x85, 0x85, 0x2c, 0x5d,
 0x69, 0xb2, 0x48, 0xbe, 0xd3, 0x1b, 0x8f, 0xd3, 0xa9, 0x7f, 0xdc, 0xbd, 0xf8, 0x84, 0x01, 0x60,
 0xe3, 0xaa, 0xb6, 0x75, 0x19, 0x23, 0x3b, 0xfc, 0x74, 0xff, 0x00, 0xb1, 0x8c, 0x18, 0x67, 0x17,
 0xc9, 0x4b, 0x52, 0x5a, 0x95, 0x98, 0x7c, 0xb6, 0xe3, 0x6a, 0x29, 0x02, 0xc4, 0xdc, 0x13, 0x70,
 0x7b, 0xc2, 0xab, 0xb5, 0x29, 0x7a, 0x94, 0x9b, 0x7a, 0x74, 0x95, 0x36, 0xab, 0x2c, 0x24, 0xaa,
 0xd6, 0xd9, 0xcb, 0xe7, 0x18, 0x1d, 0x14, 0xd7, 0x02, 0x33, 0x99, 0xfa, 0x89, 0xcd, 0x16, 0x59,
 0x17, 0x1c, 0xf8, 0xc0, 0x0e, 0xb8, 0x8a, 0xb7, 0x45, 0x76, 0xa0, 0x89, 0x6a, 0x8b, 0x0e, 0xe9,
 0x2c, 0x06, 0x9d, 0x3e, 0x1b, 0x24, 0xf3, 0xf3, 0x1f, 0x74, 0x2f, 0xd7, 0xa6, 0xe9, 0xf2, 0xe9,
 0x6d, 0x12, 0x15, 0x05, 0xcc, 0x24, 0xdc, 0x94, 0x15, 0xe7, 0x04, 0x7d, 0xf1, 0x06, 0x76, 0x66,
 0x52, 0x71, 0x09, 0x4c, 0xc2, 0x02, 0xb3, 0x47, 0x84, 0xde, 0xc4, 0x7d, 0xf1, 0x19, 0x86, 0xe9,
 0x8c, 0xb8, 0x1c, 0x0d, 0x95, 0x90, 0x6e, 0x33, 0xd6, 0x48, 0xf6, 0x80, 0x1d, 0xb1, 0x1d, 0x50,
 0x8c, 0x22, 0xc3, 0x65, 0x56, 0x20, 0x32, 0x08, 0xfb, 0xa3, 0x1e, 0x17, 0xc5, 0x92, 0x72, 0xb4,
 0x53, 0x2f, 0x31, 0x30, 0x1a, 0x71, 0xa2, 0xa2, 0x01, 0xfb, 0x40, 0xed, 0x16, 0xe3, 0x0b, 0x53,
 0x95, 0x06, 0x66, 0xd9, 0x2c, 0xcc, 0x0c, 0xf4, 0x12, 0x0d, 0xae, 0x46, 0xd1, 0xf2, 0x88, 0xae,
 0xea, 0xe7, 0x1a, 0x6d, 0xa5, 0x32, 0x2c, 0xd8, 0xb2, 0x48, 0x51, 0x04, 0x0e, 0x17, 0x80, 0x37,
 0x78, 0x43, 0x11, 0x33, 0x21, 0x52, 0x71, 0x73, 0x0e, 0x68, 0xdb, 0x75, 0xbc, 0xdc, 0xe3, 0xb8,
 0x1b, 0xdc, 0x5e, 0x32, 0x54, 0xeb, 0x8d, 0xcf, 0x62, 0xe6, 0x1d, 0x96, 0x70, 0x38, 0x8d, 0x23,
 0x49, 0x0a, 0x1b, 0x8d, 0x8e, 0xd8, 0xd2, 0x25, 0xe9, 0x04, 0xca, 0x19, 0x50, 0xc2, 0x34, 0x44,
 0xdc, 0x83, 0xbc, 0x9e, 0x37, 0xdf, 0x78, 0xf3, 0x24, 0xe4, 0x8c, 0x9b, 0xba, 0x56, 0x1b, 0xb2,
 0xf7, 0x05, 0x29, 0x44, 0x91, 0xf2, 0xbc, 0x00, 0xc9, 0x8f, 0x27, 0x94, 0xa9, 0xc9, 0x79, 0xbb,
 0x92, 0xd9, 0x46, 0x8c, 0xfc, 0xc1, 0x26, 0xde, 0xc6, 0x23, 0xd4, 0x26, 0xb0, 0xea, 0x29, 0x8a,
 0x7e, 0x56, 0x65, 0xd5, 0xbe, 0xa4, 0xfe, 0xad, 0x05, 0xcb, 0x90, 0x79, 0x8b, 0x79, 0x46, 0xb6,
 0x62, 0xa6, 0xd3, 0xed, 0x29, 0xa7, 0x82, 0x5c, 0x42, 0xb7, 0xa5, 0x5b, 0xa3, 0x5e, 0x86, 0x69,
 0x68, 0x73, 0x3f, 0x44, 0x55, 0xe7, 0x9a, 0xa5, 0x92, 0x3d, 0xa0, 0x07, 0xcc, 0x11, 0x3e, 0xa9,
 0x7a, 0x42, 0x9c, 0x51, 0xb6, 0x99, 0xc2, 0xb1, 0xf2, 0x02, 0xc0, 0xff, 0x00, 0xbc, 0x6f, 0x75,
 0xcf, 0x57, 0x78, 0xae, 0x45, 0x60, 0x00, 0x00, 0x50, 0x00, 0x6c, 0x00, 0x47, 0xee, 0xb9, 0xeb,
 0x80, 0x1e, 0xe6, 0xeb, 0xcc, 0xbb, 0x27, 0x38, 0xdb, 0x6f, 0xa1, 0x4a, 0x43, 0x6b, 0x4a, 0xd2,
 0x15, 0xb5, 0x27, 0x34, 0xef, 0x10, 0xbd, 0x93, 0xea, 0xae, 0x60, 0x9c, 0xf1, 0x6f, 0x08, 0xfe,
 0xb0, 0x8b, 0x59, 0x2e, 0xa5, 0xe7, 0x6a, 0x12, 0x4f, 0xaf, 0x48, 0xab, 0x97, 0x11, 0x7d, 0xa4,
 0x1d, 0xf6, 0xfc, 0xa3, 0xce, 0x0d, 0xab, 0x66, 0x7d, 0x2a, 0xcb, 0xdf, 0x99, 0xfd, 0x60, 0x0b,
 0x9f, 0x5c, 0x75, 0x41, 0xae, 0x7a, 0xa2, 0xba, 0xd7, 0x3d, 0x70, 0x6b, 0x9e, 0xb8, 0x02, 0xb9,
 0xd7, 0x3d, 0x5d, 0xe0, 0xd7, 0x3d, 0x5d, 0xe2, 0xba, 0xd7, 0x1d, 0x50, 0x6b, 0x9e, 0xae, 0xf0,
 0x05, 0x80, 0x67, 0xe5, 0x89, 0xb9, 0x65, 0xa2, 0x7f, 0xc8, 0x20, 0xfa, 0x7c, 0xb7, 0xee, 0x59,
 0xfc, 0x02, 0x2b, 0xfd, 0x71, 0xd5, 0x06, 0xb8, 0xea, 0x80, 0x2c, 0x54, 0xd5, 0xc2, 0x40, 0x48,
 0x20, 0x01, 0xb0, 0x01, 0x06, 0xb9, 0xea, 0xef, 0x15, 0xd6, 0xb8, 0xeb, 0x83, 0x5c, 0xf5, 0x40,
 0x16, 0x2e, 0xb9, 0xea, 0xef, 0x06, 0xb8, 0xea, 0x8a, 0xeb, 0x5c, 0x75, 0x41, 0xae, 0x3a, 0xa0,
 0x0b, 0x17, 0x5c, 0xf5, 0x77, 0x83, 0x5c, 0xf5, 0x77, 0x8a, 0xeb, 0x5c, 0xf5, 0x41, 0xae, 0x3a,
 0xa0, 0x0b, 0x17, 0x5c, 0xf5, 0x77, 0x83, 0x5c, 0xf5, 0xf7, 0x8a, 0xeb, 0x5c, 0x75, 0x41, 0xae,
 0x3a, 0xa0, 0x0b, 0x17, 0x5c, 0xf5, 0x77, 0x83, 0x5c, 0xf5, 0xf7, 0x8a, 0xeb, 0x5c, 0x75, 0x41,
 0xae, 0x7a, 0xa0, 0x0b, 0x17, 0x5c, 0xf5, 0xf7, 0x83, 0x5c, 0xf5, 0x77, 0x8a, 0xeb, 0x5c, 0x75,
 0xc1, 0xae, 0x7a, 0xa0, 0x0b, 0x17, 0x5c, 0xf5, 0x77, 0x8f, 0x0d, 0xd5, 0x1a, 0x6e, 0xfa, 0x34,
 0xa1, 0x17, 0xdf, 0x9a, 0x00, 0xbc, 0x57, 0xba, 0xe7, 0xab, 0xbc, 0x1a, 0xe7, 0xaa, 0x00, 0xb1,
 0x75, 0xcf, 0x57, 0x78, 0x35, 0xcf, 0x57, 0x78, 0xae, 0xb5, 0xcf, 0x54, 0x1a, 0xe7, 0xae, 0x00,
 0xae, 0x75, 0xcf, 0x5f, 0x78, 0x35, 0xcf, 0x5f, 0x78, 0x55, 0xb9, 0xe3, 0x05, 0xcf, 0x18, 0x01,
 0xab, 0x5c, 0xf5, 0xf7, 0x83, 0x5c, 0xf5, 0xf7, 0x85, 0x5b, 0x9e, 0x30, 0x5c, 0xf1, 0x80, 0x1a,
 0xb5, 0xcf, 0x5f, 0x78, 0x35, 0xcf, 0x5f, 0x78, 0x55, 0xb9, 0xe3, 0x05, 0xcf, 0x18, 0x01, 0xab,
 0x5c, 0xf5, 0xf7, 0x83, 0x5c, 0xf5, 0xf7, 0x85, 0x5b, 0x9e, 0x30, 0x5c, 0xf1, 0x80, 0x1a, 0xb5,
 0xcf, 0x5f, 0x78, 0x35, 0xcf, 0x5f, 0x78, 0x55, 0xb9, 0xe3, 0x05, 0xcf, 0x18, 0x01, 0xab, 0x5c,
 0xf5, 0xf7, 0x83, 0x5c, 0xf5, 0xf7, 0x85, 0x5b, 0x9e, 0x30, 0x5c, 0xf1, 0x80, 0x1a, 0xb5, 0xcf,
 0x5f, 0x78, 0x35, 0xcf, 0x5f, 0x78, 0x55, 0xb9, 0xe3, 0x05, 0xcf, 0x18, 0x01, 0xab, 0x5c, 0xf5,
 0xf7, 0x83, 0x5c, 0xf5, 0xf7, 0x85, 0x5b, 0x9e, 0x30, 0x5c, 0xf1, 0x80, 0x1a, 0xb5, 0xcf, 0x5f,
 0x78, 0x35, 0xcf, 0x5f, 0x78, 0x55, 0xb9, 0xe3, 0x05, 0xcf, 0x18, 0x01, 0xab, 0x5c, 0xf5, 0xf7,
 0x83, 0x5c, 0xf5, 0xf7, 0x85, 0x5b, 0x9e, 0x30, 0x5c, 0xf1, 0x80, 0x3d, 0x68, 0xdc, 0xf4, 0x2b,
 0xd8, 0xc1, 0xa3, 0x73, 0xd0, 0xaf, 0x63, 0x04, 0x11, 0xd7, 0x27, 0x4e, 0x4c, 0x34, 0x6e, 0x7a,
 0x15, 0xec, 0x60, 0xd1, 0xb9, 0xe8, 0x57, 0xb1, 0x82, 0x08, 0x64, 0x72, 0x61, 0xa3, 0x73, 0xd0,
 0xaf, 0x63, 0x06, 0x8d, 0xcf, 0x42, 0xbd, 0x8c, 0x10, 0x43, 0x23, 0x93, 0x0d, 0x1b, 0x9e, 0x85,
 0x7b, 0x18, 0x34, 0x6e, 0x7a, 0x15, 0xec, 0x60, 0x82, 0x19, 0x1c, 0x98, 0x68, 0xdc, 0xf4, 0x2b,
 0xd8, 0xc1, 0xa3, 0x73, 0xd0, 0xaf, 0x63, 0x04, 0x10, 0xc8, 0xe4, 0xc3, 0x46, 0xe7, 0xa1, 0x5e,
 0xc6, 0x0d, 0x1b, 0x9e, 0x85, 0x7b, 0x18, 0x20, 0x86, 0x47, 0x26, 0x1a, 0x37, 0x3d, 0x0a, 0xf6,
 0x30, 0x68, 0xdc, 0xf4, 0x2b, 0xd8, 0xc1, 0x04, 0x32, 0x39, 0x30, 0xd1, 0xb9, 0xe8, 0x57, 0xb1,
 0x83, 0x46, 0xe7, 0xa1, 0x5e, 0xc6, 0x08, 0x21, 0x91, 0xc9, 0x86, 0x8d, 0xcf, 0x42, 0xbd, 0x8c,
 0x1a, 0x37, 0x3d, 0x0a, 0xf6, 0x30, 0x41, 0x0c, 0x8e, 0x4c, 0x34, 0x6e, 0x7a, 0x15, 0xec, 0x60,
 0xd1, 0xb9, 0xe8, 0x57, 0xb1, 0x82, 0x08, 0x64, 0xe7, 0x91, 0xff, 0xd9};
static const unsigned char PIC_320x240_1[] = { 
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x17, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
 0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65, 0x20, 0x47, 0x49, 0x4d, 0x50, 0xff, 0xe1, 0x00,
 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x05, 0x03, 0x04, 0x04, 0x04, 0x03,
 0x05, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0c, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0f,
 0x0b, 0x0b, 0x09, 0x0c, 0x11, 0x0f, 0x12, 0x12, 0x11, 0x0f, 0x11, 0x11, 0x13, 0x16, 0x1c, 0x17,
 0x13, 0x14, 0x1a, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1a, 0x1d, 0x1d, 0x1f, 0x1f, 0x1f, 0x13,
 0x17, 0x22, 0x24, 0x22, 0x1e, 0x24, 0x1c, 0x1e, 0x1f, 0x1e, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x05,
 0x05, 0x05, 0x07, 0x06, 0x07, 0x0e, 0x08, 0x08, 0x0e, 0x1e, 0x14, 0x11, 0x14, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0xff,
 0xc0, 0x00, 0x11, 0x08, 0x00, 0xf0, 0x01, 0x40, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03,
 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1d, 0x00, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x05, 0x01, 0x04, 0x07, 0x08, 0x02,
 0x09, 0xff, 0xc4, 0x00, 0x56, 0x10, 0x00, 0x00, 0x04, 0x05, 0x01, 0x05, 0x03, 0x05, 0x0a, 0x09,
 0x07, 0x0a, 0x07, 0x01, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x11, 0x14, 0x61, 0x06,
 0x12, 0x21, 0x31, 0x41, 0x51, 0x07, 0x13, 0x22, 0x08, 0x53, 0x71, 0x91, 0x92, 0x16, 0x32, 0x43,
 0x52, 0x81, 0x94, 0xa1, 0xb1, 0xd1, 0xd2, 0x15, 0x23, 0x42, 0x54, 0x56, 0x62, 0xa3, 0xb2, 0xc1,
 0x26, 0x44, 0x45, 0x72, 0x84, 0xa2, 0xb3, 0x09, 0x24, 0x25, 0x33, 0x55, 0x63, 0x64, 0x93, 0x95,
 0xe1, 0x34, 0x35, 0x65, 0x82, 0x83, 0x85, 0xc2, 0xc3, 0xff, 0xc4, 0x00, 0x1c, 0x01, 0x01, 0x01,
 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
 0x02, 0x04, 0x05, 0x01, 0x06, 0x07, 0x08, 0xff, 0xc4, 0x00, 0x31, 0x11, 0x00, 0x02, 0x01, 0x03,
 0x02, 0x04, 0x04, 0x04, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,
 0x04, 0x11, 0x05, 0x12, 0x13, 0x21, 0x31, 0x51, 0x06, 0x41, 0x71, 0x81, 0x61, 0xa1, 0xb1, 0xc1,
 0x14, 0x22, 0x23, 0x32, 0x91, 0xd1, 0x15, 0x52, 0xe1, 0x72, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01,
 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xe7, 0xeb, 0x6c, 0x44, 0xb6, 0xf0, 0x2c, 0x96,
 0xd6, 0x04, 0x2b, 0x6f, 0x03, 0xf4, 0x35, 0x33, 0xf3, 0x15, 0x32, 0xb9, 0x6d, 0xe0, 0x44, 0xa6,
 0xc5, 0x8a, 0xdb, 0x11, 0x2d, 0xbc, 0x0a, 0x29, 0x94, 0x53, 0x2b, 0x96, 0xde, 0x04, 0x4a, 0x6f,
 0x02, 0xc5, 0x6d, 0x88, 0x96, 0xde, 0x05, 0x14, 0xca, 0x29, 0x95, 0xca, 0x6c, 0x44, 0xa6, 0xf0,
 0x2c, 0x56, 0xd8, 0x89, 0x6d, 0xe0, 0x51, 0x4c, 0xaa, 0x99, 0x5c, 0xa6, 0xc4, 0x4a, 0x6c, 0x58,
 0xad, 0xb1, 0x12, 0x9b, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x29, 0xb1, 0x12, 0xdb, 0xc0, 0xb1, 0x5b,
 0x78, 0x11, 0x29, 0xbc, 0x0a, 0x29, 0x94, 0x53, 0x2b, 0x94, 0xd8, 0x89, 0x4d, 0xe0, 0x58, 0xa9,
 0xb1, 0x12, 0x9b, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x2d, 0xb1, 0x12, 0x9b, 0xc0, 0xb1, 0x53, 0x62,
 0x25, 0xb6, 0x28, 0xa6, 0x55, 0x4c, 0xae, 0x52, 0x07, 0xc9, 0x91, 0x90, 0xde, 0x53, 0x78, 0x11,
 0x29, 0xb1, 0x45, 0x33, 0x35, 0x23, 0x54, 0x02, 0x55, 0x36, 0x23, 0x34, 0x99, 0x0c, 0x93, 0x33,
 0xc9, 0x80, 0x00, 0x03, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x1d, 0xdd, 0xe8, 0x5c, 0x0d, 0x37, 0x61, 0x8c, 0xb9, 0x06, 0xa7, 0xa1, 0x30, 0x34,
 0x9e, 0x84, 0xc0, 0xf8, 0xb8, 0x57, 0x3e, 0x2a, 0x15, 0xc5, 0x97, 0x19, 0x32, 0xe4, 0x21, 0x5b,
 0x78, 0x0c, 0x0f, 0x42, 0xe0, 0x69, 0xbb, 0x0a, 0x7b, 0xe8, 0x43, 0x66, 0x35, 0x53, 0x36, 0x23,
 0x59, 0x32, 0x99, 0x6d, 0x88, 0x96, 0xd0, 0xb3, 0x71, 0x83, 0x2e, 0x42, 0x05, 0xb4, 0x2c, 0xa6,
 0x5d, 0x4c, 0xae, 0x53, 0x62, 0x25, 0xb6, 0x2c, 0x56, 0xd8, 0x89, 0x6d, 0x0a, 0x29, 0x94, 0x53,
 0x2b, 0x96, 0xde, 0x04, 0x4b, 0x6b, 0x02, 0xc5, 0x6d, 0x88, 0x96, 0xd8, 0xa2, 0x99, 0x55, 0x32,
 0xb9, 0x6d, 0xe0, 0x44, 0xa6, 0xc5, 0x8a, 0xdb, 0xc0, 0x89, 0x6d, 0x8a, 0x29, 0x94, 0x53, 0x2b,
 0x94, 0xd8, 0x89, 0x4d, 0x8b, 0x15, 0xb7, 0x81, 0x12, 0xdb, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x29,
 0xbc, 0x08, 0x94, 0xd8, 0xb1, 0x53, 0x62, 0x25, 0x36, 0x28, 0xa6, 0x51, 0x4c, 0xae, 0x53, 0x62,
 0x25, 0x36, 0x2c, 0x54, 0xde, 0x04, 0x4a, 0x6c, 0x51, 0x4c, 0xaa, 0x99, 0x5c, 0xa6, 0xf0, 0x22,
 0x53, 0x62, 0xc5, 0x4d, 0xe0, 0x44, 0xa6, 0xc5, 0x14, 0xca, 0x29, 0x95, 0xca, 0x6f, 0x70, 0x8d,
 0x48, 0x3e, 0x42, 0xc1, 0x4d, 0xe0, 0x44, 0xa6, 0xc5, 0x14, 0xca, 0x29, 0x9a, 0x26, 0x46, 0x40,
 0x1b, 0x2a, 0x6f, 0x02, 0x25, 0x36, 0x33, 0x52, 0x33, 0x52, 0xc9, 0x18, 0x06, 0x4d, 0x26, 0x43,
 0x03, 0x2c, 0x9e, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7a, 0xc9, 0xe8, 0x4c, 0x0d, 0x37,
 0xa1, 0x30, 0x1b, 0xe2, 0x25, 0xe6, 0x55, 0xdc, 0x2b, 0xdf, 0x83, 0x32, 0xae, 0xe1, 0xf9, 0x9c,
 0x2b, 0x9f, 0x9b, 0x3d, 0xf4, 0xfa, 0xa1, 0x4d, 0xe8, 0x5c, 0x0d, 0x37, 0xa1, 0x30, 0x1a, 0x9e,
 0x84, 0xc0, 0xd3, 0x7a, 0x13, 0x03, 0x6e, 0x15, 0xca, 0xc2, 0xb8, 0xaa, 0xf4, 0x26, 0xee, 0x03,
 0x49, 0xe8, 0x4c, 0x06, 0xb7, 0xe1, 0x30, 0x34, 0x9e, 0x84, 0xc0, 0xd9, 0x85, 0x73, 0x6a, 0x15,
 0xc5, 0x67, 0x61, 0x8c, 0xb9, 0x0d, 0x75, 0xb2, 0x65, 0xc8, 0x32, 0x3d, 0x0b, 0x81, 0xa6, 0xf4,
 0x26, 0x06, 0xd4, 0x6b, 0x64, 0xda, 0x85, 0x62, 0x85, 0x6d, 0xe0, 0x44, 0xb6, 0xc5, 0xbb, 0xb0,
 0xa6, 0x5c, 0x86, 0xb3, 0x8c, 0x19, 0x72, 0x17, 0x8d, 0x44, 0xcb, 0xc6, 0xa6, 0x4a, 0xc5, 0xb7,
 0x81, 0x12, 0x9b, 0xc0, 0xb1, 0x5b, 0x78, 0x11, 0x2d, 0xb1, 0x55, 0x32, 0xca, 0x65, 0x72, 0xdb,
 0xc0, 0x89, 0x4d, 0x8b, 0x15, 0xb7, 0x81, 0x12, 0xdb, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x2d, 0xbc,
 0x08, 0x96, 0xde, 0x05, 0x8a, 0xdb, 0xc0, 0x89, 0x6d, 0xe0, 0x51, 0x4c, 0xa2, 0x99, 0x5c, 0xb6,
 0xf0, 0x22, 0x53, 0x62, 0xc5, 0x6d, 0x88, 0x96, 0xde, 0x05, 0x14, 0xca, 0x29, 0x95, 0xca, 0x6f,
 0x02, 0x25, 0x37, 0x81, 0x62, 0xb6, 0xc4, 0x4a, 0x6f, 0x02, 0x8a, 0x65, 0x54, 0xca, 0xe5, 0x36,
 0x22, 0x53, 0x62, 0xc5, 0x4d, 0x88, 0x94, 0xde, 0x05, 0x14, 0xca, 0x29, 0x95, 0xca, 0x6f, 0x02,
 0x25, 0x36, 0x2c, 0x56, 0xd8, 0x89, 0x4d, 0xf5, 0x21, 0x45, 0x32, 0x8a, 0x65, 0x72, 0x9a, 0x11,
 0x29, 0xb1, 0x62, 0xa6, 0xc4, 0x4a, 0x6f, 0x02, 0x8a, 0x65, 0x14, 0xca, 0xf3, 0x41, 0x90, 0xf9,
 0x32, 0xa0, 0xdd, 0x5b, 0x62, 0x25, 0x37, 0x81, 0x9a, 0x91, 0x45, 0x23, 0x5c, 0x03, 0xed, 0x4d,
 0x8f, 0x83, 0x23, 0x21, 0x96, 0x4c, 0xb2, 0x00, 0x00, 0x07, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x05, 0x8c, 0x96, 0x29, 0x26, 0x75, 0x40,
 0xaa, 0x89, 0x97, 0xf1, 0xf0, 0x8e, 0x8e, 0x97, 0x20, 0x23, 0x13, 0x45, 0x11, 0x21, 0x47, 0xea,
 0x1a, 0x91, 0x92, 0x44, 0xad, 0x26, 0xa6, 0xa8, 0xa2, 0xea, 0x43, 0xf1, 0x2a, 0x57, 0xa9, 0x90,
 0xbc, 0xf0, 0xfe, 0x79, 0xc3, 0x99, 0xcc, 0x22, 0x65, 0xfc, 0x7c, 0x22, 0xba, 0x22, 0x04, 0xca,
 0xbb, 0x87, 0x43, 0x8d, 0x94, 0x2d, 0x06, 0x75, 0x45, 0x45, 0x44, 0x54, 0xbb, 0x79, 0xf8, 0x47,
 0x42, 0x9d, 0xce, 0x4f, 0x96, 0xba, 0xd1, 0xe5, 0x07, 0xd3, 0x02, 0x23, 0xd0, 0x94, 0xae, 0xe1,
 0xa4, 0xf4, 0x26, 0x05, 0xa4, 0xcf, 0x53, 0xe8, 0xc8, 0x58, 0xa7, 0xa1, 0x22, 0x75, 0x5c, 0x89,
 0x88, 0x86, 0x56, 0x6d, 0xba, 0xd3, 0x91, 0xed, 0xa5, 0x68, 0x51, 0x1d, 0x0d, 0x26, 0x46, 0x75,
 0x23, 0x23, 0xe4, 0x2a, 0xdf, 0xd5, 0xba, 0x27, 0xf2, 0x75, 0x7e, 0x9f, 0x3f, 0xfe, 0xc1, 0xaf,
 0xb4, 0x6e, 0x42, 0xe5, 0x77, 0x39, 0xf2, 0xb0, 0xba, 0xa7, 0xd2, 0x0d, 0xfb, 0x33, 0x49, 0xe8,
 0x4f, 0xd5, 0x1a, 0x6f, 0x42, 0x60, 0x6d, 0xbd, 0xaa, 0xf4, 0x6f, 0x2d, 0x57, 0x22, 0x3f, 0xed,
 0xed, 0x7d, 0xa3, 0x51, 0xdd, 0x53, 0xa3, 0xcf, 0x86, 0xa9, 0x92, 0x7c, 0xf9, 0xbf, 0xb4, 0x6d,
 0x42, 0xe6, 0x3d, 0xcf, 0x63, 0x46, 0xe5, 0x75, 0xa7, 0x2f, 0xe1, 0x9a, 0x6f, 0x42, 0x60, 0x69,
 0x3d, 0x09, 0x80, 0xc7, 0x0c, 0xa8, 0x49, 0x84, 0x22, 0x22, 0xe0, 0x22, 0x18, 0x8a, 0x87, 0x72,
 0xbb, 0x0e, 0xb2, 0xb2, 0x5a, 0x15, 0x43, 0xa1, 0xd0, 0xcb, 0x71, 0xef, 0x21, 0x13, 0xd0, 0x98,
 0x1b, 0x74, 0xeb, 0xe4, 0xca, 0x35, 0x5c, 0x5e, 0x1f, 0x51, 0x55, 0xe8, 0x5c, 0x0d, 0x47, 0x21,
 0xcc, 0xb9, 0x06, 0x97, 0xe1, 0x38, 0xee, 0x1a, 0x4f, 0x42, 0x60, 0x6d, 0x42, 0xb1, 0xb3, 0x0a,
 0xe2, 0xe2, 0xda, 0xc0, 0x85, 0x6d, 0xe0, 0x5e, 0xbd, 0x09, 0x81, 0xa6, 0xec, 0x29, 0x97, 0x21,
 0xb1, 0x1a, 0xa9, 0x9b, 0x31, 0xaa, 0x99, 0x52, 0xb6, 0xc4, 0x4b, 0x6c, 0x59, 0x38, 0xc9, 0x97,
 0x21, 0x0a, 0x9b, 0xc0, 0xb2, 0x99, 0x65, 0x32, 0xb9, 0x6d, 0x88, 0x96, 0xde, 0x05, 0x8a, 0xdb,
 0x11, 0x2d, 0xb1, 0x45, 0x32, 0x8a, 0x65, 0x72, 0xda, 0xc0, 0x89, 0x4d, 0xe0, 0x58, 0xad, 0xb1,
 0x12, 0xdb, 0xc0, 0xa2, 0x99, 0x45, 0x32, 0xb9, 0x4d, 0x88, 0x96, 0xde, 0x05, 0x8a, 0xdb, 0x11,
 0x29, 0xbc, 0x0a, 0x29, 0x95, 0x53, 0x2b, 0x94, 0xd8, 0x89, 0x6d, 0xe0, 0x58, 0xad, 0xb1, 0x12,
 0x9b, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x29, 0xa1, 0x12, 0x9b, 0x16, 0x2a, 0x6c, 0x44, 0xa6, 0xc5,
 0x14, 0xca, 0x29, 0x95, 0xca, 0x6f, 0x02, 0x25, 0x37, 0x81, 0x62, 0xb6, 0xf0, 0x22, 0x53, 0x42,
 0x8a, 0x65, 0x54, 0xca, 0xe5, 0x36, 0x22, 0x53, 0x62, 0xc5, 0x4d, 0xe0, 0x44, 0xb6, 0xc5, 0x14,
 0xca, 0x29, 0x95, 0xca, 0x6c, 0x46, 0x69, 0x32, 0x16, 0x0a, 0x6c, 0x44, 0xb6, 0xc5, 0x14, 0xca,
 0x29, 0x9a, 0x60, 0x13, 0xa9, 0xbd, 0xdc, 0x04, 0x6a, 0x41, 0x90, 0xcd, 0x48, 0xc9, 0x33, 0xe0,
 0x02, 0x13, 0x8b, 0x85, 0x23, 0xa5, 0xcb, 0x35, 0xfe, 0xb9, 0x09, 0x86, 0x30, 0xab, 0x09, 0xfe,
 0xd6, 0x99, 0x9b, 0x8b, 0x8f, 0x54, 0x00, 0x00, 0x06, 0x66, 0x20, 0x00, 0x00, 0x01, 0xef, 0xe8,
 0x39, 0xa9, 0x91, 0x95, 0x14, 0x2f, 0x20, 0x27, 0x4a, 0x4d, 0x28, 0xb3, 0x2f, 0x94, 0x73, 0x18,
 0x69, 0x87, 0x0f, 0x10, 0xb4, 0x85, 0x98, 0xf0, 0xf1, 0x0f, 0xe7, 0x48, 0xcc, 0xeb, 0x53, 0xb8,
 0x3a, 0xa3, 0x13, 0x38, 0x68, 0x92, 0xd9, 0x7d, 0x09, 0x33, 0x3e, 0x64, 0x07, 0xa5, 0xb0, 0xd1,
 0x25, 0x56, 0x54, 0x93, 0x33, 0xe5, 0xcc, 0x20, 0x42, 0x4c, 0xcc, 0xa9, 0xe2, 0x17, 0x50, 0x33,
 0x75, 0x25, 0x49, 0xf1, 0x9f, 0x12, 0x1b, 0x10, 0xaf, 0x28, 0xf4, 0x2b, 0x2e, 0x15, 0x65, 0x89,
 0xa3, 0xf3, 0x8f, 0xb6, 0x64, 0x77, 0x5d, 0xae, 0xeb, 0x06, 0xbe, 0x24, 0xf2, 0x31, 0x3e, 0xa7,
 0x94, 0x29, 0xa5, 0xba, 0x7a, 0x7f, 0x32, 0x85, 0xba, 0x97, 0x49, 0x26, 0x51, 0x8c, 0x6d, 0x1a,
 0x7b, 0xd6, 0x21, 0x1c, 0x71, 0x15, 0x2e, 0x25, 0x54, 0x91, 0x95, 0x77, 0x90, 0xb8, 0xed, 0x91,
 0x66, 0xef, 0x6b, 0x5a, 0xbd, 0xc3, 0xfc, 0xb9, 0xdc, 0x62, 0xbd, 0x6f, 0x28, 0x7b, 0x3b, 0xc8,
 0x51, 0xb6, 0x1e, 0xec, 0x23, 0x61, 0x6e, 0xec, 0x2f, 0xf0, 0xc4, 0x57, 0x3a, 0x7e, 0x4b, 0x43,
 0xb1, 0x2a, 0x8a, 0x11, 0x52, 0x66, 0xdc, 0xb7, 0x46, 0x1f, 0x91, 0x1e, 0x20, 0x3d, 0x23, 0xaa,
 0xcb, 0x8e, 0x99, 0x9d, 0x17, 0xf6, 0x07, 0x7e, 0xe8, 0xc7, 0xb9, 0x3d, 0x50, 0x47, 0xbf, 0x4d,
 0xce, 0x0b, 0xfb, 0x0b, 0xbf, 0x74, 0x7e, 0xa4, 0x47, 0xc9, 0x9c, 0xa1, 0xa9, 0x0b, 0x59, 0x97,
 0x52, 0x51, 0x8a, 0x38, 0xc9, 0x6b, 0xc9, 0xad, 0x4d, 0x7e, 0xb3, 0x19, 0x42, 0xa4, 0x25, 0xe6,
 0x71, 0xee, 0x35, 0x2b, 0xaa, 0x3d, 0x69, 0x7c, 0xff, 0x00, 0xe1, 0xc0, 0x7b, 0x0a, 0x95, 0xc5,
 0x43, 0x76, 0x4d, 0x25, 0x66, 0x32, 0x15, 0xe8, 0x77, 0xd2, 0x4f, 0x6d, 0x36, 0xeb, 0x66, 0x85,
 0x27, 0xf1, 0xcb, 0xe2, 0x47, 0xbc, 0x36, 0x3d, 0x09, 0xc7, 0xc2, 0x1e, 0xa2, 0xa5, 0xe6, 0x66,
 0x66, 0x64, 0x66, 0x79, 0x1c, 0x63, 0xb4, 0xfe, 0xd7, 0xb4, 0xfe, 0x87, 0xd5, 0x8f, 0xe9, 0xd9,
 0x84, 0x9e, 0x67, 0x13, 0x10, 0xd3, 0x4d, 0xb8, 0x6e, 0x30, 0xa6, 0xc9, 0x06, 0x4b, 0x49, 0x28,
 0xb8, 0x9d, 0x79, 0x8e, 0x95, 0x3b, 0x85, 0x14, 0x91, 0xf9, 0xfd, 0x7d, 0x3a, 0xea, 0xf2, 0xe6,
 0x73, 0xa5, 0x1c, 0xb9, 0x36, 0xf1, 0xea, 0xff, 0x00, 0xe8, 0xc0, 0xf4, 0x26, 0x06, 0x9b, 0xd0,
 0x98, 0x14, 0x50, 0xbd, 0xac, 0xe9, 0x68, 0x9d, 0x09, 0x11, 0xab, 0xdf, 0x62, 0x32, 0x0e, 0x19,
 0xb8, 0xb5, 0x41, 0xb5, 0x0c, 0xe6, 0xc2, 0x9e, 0x7d, 0xd2, 0x4a, 0x55, 0x44, 0x11, 0x1d, 0x29,
 0x45, 0x15, 0x4c, 0xf8, 0x7a, 0x82, 0x33, 0x3e, 0x50, 0x72, 0xb7, 0x22, 0xcd, 0x31, 0x3a, 0x5e,
 0x29, 0xb8, 0x6a, 0xfb, 0xf6, 0xe2, 0x92, 0xb5, 0xd3, 0xfa, 0xa6, 0x92, 0x2f, 0xa4, 0x6c, 0xc6,
 0xf2, 0x0b, 0xab, 0x3c, 0xa3, 0xa2, 0xea, 0x53, 0xdd, 0xb6, 0x93, 0xe5, 0xd7, 0xa7, 0xf7, 0xcf,
 0xd8, 0xe9, 0x4f, 0x42, 0x71, 0xdc, 0x34, 0x9e, 0x84, 0xc0, 0x62, 0x41, 0xb2, 0xfc, 0xb5, 0xb9,
 0x81, 0x92, 0x98, 0x61, 0xc6, 0x49, 0xfa, 0xbc, 0x5b, 0x06, 0x84, 0x9a, 0x76, 0xbc, 0x55, 0xe1,
 0x42, 0xe3, 0xd0, 0x72, 0x1d, 0x57, 0xdb, 0x4e, 0x9e, 0x80, 0x8a, 0x72, 0x1a, 0x4f, 0x00, 0xfc,
 0xd4, 0xd0, 0x74, 0xef, 0x8d, 0x7d, 0xd3, 0x46, 0x7f, 0xab, 0x52, 0x33, 0x32, 0xcd, 0x08, 0x6d,
 0xfe, 0x2e, 0x10, 0x59, 0x93, 0x31, 0xb2, 0xb5, 0xb9, 0xbb, 0x93, 0x8d, 0x18, 0x36, 0xd7, 0x5f,
 0x87, 0xbf, 0x41, 0xc1, 0xe8, 0x4c, 0x0d, 0x37, 0x61, 0x69, 0xc8, 0x73, 0x63, 0xed, 0xc5, 0xf5,
 0x2b, 0xc5, 0xa6, 0x61, 0xf6, 0x71, 0x16, 0xaa, 0xfe, 0xe8, 0x64, 0xd2, 0x7d, 0xa7, 0x69, 0xf9,
 0xfc, 0x5b, 0x70, 0x31, 0x2c, 0xbb, 0x2b, 0x8a, 0x74, 0xc9, 0x2d, 0xf7, 0xca, 0x25, 0x36, 0xb5,
 0x1f, 0x02, 0x25, 0x95, 0x28, 0x7e, 0x92, 0x2f, 0x48, 0xad, 0x2d, 0x46, 0x94, 0x9e, 0x37, 0x1d,
 0x5a, 0x9a, 0x45, 0xfd, 0x08, 0xef, 0x95, 0x3e, 0x4b, 0xb3, 0x4f, 0xe8, 0x5d, 0xb9, 0x0e, 0x65,
 0xc8, 0x6b, 0xad, 0xac, 0x06, 0x37, 0xa1, 0x38, 0xee, 0x08, 0xba, 0xe3, 0x58, 0xcb, 0xb4, 0xbc,
 0xd1, 0xb8, 0x08, 0xc8, 0x18, 0xa7, 0xdc, 0x71, 0x92, 0x74, 0x94, 0xd1, 0xa4, 0x88, 0x88, 0xcc,
 0xca, 0x9b, 0xfd, 0x03, 0x7a, 0x57, 0x50, 0xa7, 0x1d, 0xd3, 0x78, 0x46, 0xbd, 0xac, 0x6a, 0x5c,
 0xcf, 0x65, 0x35, 0x96, 0x59, 0x2d, 0xb1, 0x12, 0xdb, 0xc0, 0xac, 0x91, 0x6a, 0xf9, 0x4c, 0xde,
 0x55, 0x1b, 0x33, 0x52, 0x5c, 0x81, 0x86, 0x83, 0x52, 0x52, 0xe2, 0xa2, 0x14, 0x5b, 0xcd, 0x44,
 0x66, 0x54, 0xa7, 0x13, 0xdd, 0xc0, 0x2d, 0x4c, 0x7b, 0x50, 0x97, 0xb6, 0xf1, 0xa2, 0x0a, 0x58,
 0xfc, 0x42, 0x08, 0xe9, 0xb6, 0xe3, 0x84, 0xdd, 0x7d, 0x05, 0x43, 0x07, 0xa8, 0xdb, 0xc2, 0x2a,
 0x4e, 0x5c, 0x99, 0xd0, 0xa5, 0xa7, 0xdd, 0x4e, 0x6e, 0x11, 0x83, 0xca, 0xea, 0x39, 0xad, 0xb1,
 0x12, 0xdb, 0x14, 0xba, 0x67, 0x5b, 0x4a, 0x67, 0x91, 0x29, 0x83, 0x36, 0xdc, 0x83, 0x8a, 0x5e,
 0xe4, 0x21, 0xc3, 0x23, 0x4a, 0xcf, 0xa1, 0x28, 0xb9, 0xe0, 0xc4, 0xfa, 0xa7, 0x54, 0x4a, 0x64,
 0x2a, 0xee, 0xa2, 0x14, 0xa7, 0xa2, 0x4c, 0xaa, 0x4c, 0x35, 0x43, 0x51, 0x17, 0x55, 0x1f, 0x02,
 0x16, 0x8d, 0xf5, 0x17, 0x4f, 0x89, 0xb9, 0x60, 0x7e, 0x12, 0xe2, 0x35, 0x78, 0x4e, 0x0f, 0x71,
 0xbc, 0xb6, 0xf0, 0x22, 0x5b, 0x41, 0x39, 0xbe, 0xd2, 0xe1, 0x94, 0xed, 0x1c, 0x94, 0x3a, 0x96,
 0xfa, 0xa5, 0xf2, 0x33, 0xf5, 0x50, 0x83, 0x74, 0x96, 0x69, 0x01, 0x3a, 0x83, 0xba, 0x80, 0x77,
 0x6d, 0x24, 0x74, 0x5a, 0x4c, 0xa8, 0xa4, 0x1f, 0x43, 0x21, 0x9d, 0xbd, 0xfd, 0x0a, 0xef, 0x14,
 0xe5, 0x96, 0x56, 0xb5, 0x9d, 0xc5, 0xba, 0xdd, 0x52, 0x38, 0x47, 0xca, 0xdb, 0xc0, 0x89, 0x4d,
 0x8b, 0x15, 0xb7, 0x81, 0x55, 0x3f, 0x9a, 0xcb, 0xe4, 0xd0, 0xe4, 0xec, 0x73, 0xbb, 0x26, 0xaa,
 0xec, 0x36, 0x92, 0xaa, 0xd7, 0xe8, 0x2f, 0xe2, 0x36, 0xe5, 0x5a, 0x34, 0xe3, 0xba, 0x4f, 0x09,
 0x12, 0xa7, 0xba, 0xa4, 0x94, 0x62, 0xb2, 0xcc, 0x2d, 0xbc, 0x08, 0x94, 0xd8, 0x53, 0x88, 0xed,
 0x00, 0x8d, 0xc3, 0x26, 0x25, 0x64, 0x68, 0xe4, 0x6b, 0x7b, 0x7f, 0xd0, 0x43, 0x6e, 0x5b, 0xad,
 0xa5, 0xf1, 0x2e, 0x13, 0x71, 0x90, 0xeb, 0x84, 0x33, 0xfc, 0xba, 0xed, 0xa3, 0xe5, 0xe6, 0x43,
 0x52, 0x9e, 0xb3, 0x69, 0x29, 0x6d, 0x53, 0xfa, 0x9d, 0x27, 0xa7, 0x5d, 0x46, 0x3b, 0x9c, 0x3e,
 0x85, 0xe2, 0x9b, 0xc0, 0x89, 0x4d, 0x8b, 0x02, 0x4a, 0x56, 0x82, 0x5a, 0x14, 0x95, 0xa5, 0x45,
 0x54, 0xa8, 0x8e, 0xa4, 0x65, 0xd4, 0x84, 0x6a, 0x6c, 0x75, 0x63, 0x3c, 0x9a, 0x8a, 0x65, 0x72,
 0x9a, 0xc0, 0x89, 0x4d, 0x8b, 0x15, 0x37, 0x81, 0x12, 0xdb, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x29,
 0xbc, 0x0a, 0x1d, 0x47, 0x32, 0x6e, 0x11, 0xa5, 0x43, 0x32, 0xa2, 0x38, 0x85, 0x15, 0x0e, 0x9f,
 0x90, 0x5f, 0x68, 0x35, 0x8c, 0xd6, 0x32, 0x0e, 0x2e, 0xca, 0x1d, 0x64, 0xda, 0x4d, 0xb2, 0x51,
 0xac, 0x8b, 0xc5, 0xbe, 0xbb, 0xab, 0xc8, 0x2d, 0x43, 0x41, 0xc4, 0xc5, 0xb4, 0xfc, 0x42, 0x10,
 0x66, 0xdb, 0x49, 0x35, 0xb8, 0xb3, 0xe1, 0xeb, 0xe6, 0x63, 0xe7, 0x35, 0x4d, 0x6e, 0x79, 0x95,
 0xb5, 0xba, 0x7b, 0xbc, 0xdf, 0xd7, 0x1f, 0xdf, 0x91, 0xdb, 0xb2, 0xb3, 0x4d, 0x2a, 0xb5, 0x1f,
 0x2f, 0x23, 0x58, 0xb8, 0x90, 0x7d, 0x36, 0xf7, 0x04, 0x24, 0xfb, 0xe2, 0xf4, 0x8e, 0x92, 0x6d,
 0xee, 0x13, 0xf0, 0x9b, 0xc7, 0x17, 0xdb, 0xee, 0x57, 0x55, 0x78, 0xd9, 0xef, 0xf6, 0x34, 0x0d,
 0x26, 0x43, 0x03, 0x6d, 0x4d, 0x88, 0x94, 0xde, 0x07, 0xd9, 0xa9, 0x1c, 0xa5, 0x24, 0x42, 0x01,
 0xf4, 0x68, 0x32, 0x1f, 0x23, 0x2c, 0x99, 0x1e, 0xa2, 0x62, 0x3b, 0x87, 0x88, 0x58, 0xc3, 0xc7,
 0x64, 0x25, 0x31, 0x1b, 0x91, 0xbc, 0xc4, 0x6f, 0xeb, 0x0f, 0xe6, 0xa5, 0x33, 0x08, 0x56, 0x1e,
 0x21, 0xa3, 0xff, 0x00, 0x58, 0x5a, 0x42, 0x4c, 0x4e, 0xa5, 0xe2, 0xe6, 0x10, 0xe1, 0xe3, 0xb8,
 0x6f, 0x16, 0x30, 0xd1, 0xdb, 0xcb, 0x78, 0xcd, 0x4c, 0xd9, 0x85, 0x73, 0xc7, 0xbd, 0xa9, 0xab,
 0x6f, 0xb4, 0xbd, 0x4c, 0xbf, 0x8d, 0x36, 0x8a, 0x3f, 0xda, 0xa8, 0x39, 0x76, 0x57, 0xdb, 0xc6,
 0xaf, 0xec, 0xeb, 0x4c, 0x7b, 0x9f, 0x92, 0x40, 0xc9, 0xdf, 0x85, 0xb8, 0x5c, 0x46, 0xd4, 0x53,
 0x2e, 0x29, 0x7b, 0x4b, 0x24, 0x91, 0x95, 0x52, 0xb2, 0x2a, 0x78, 0x4b, 0x90, 0x47, 0xed, 0x19,
 0x5b, 0x5a, 0xff, 0x00, 0x50, 0x2b, 0xac, 0xca, 0x20, 0xff, 0x00, 0x68, 0xa1, 0xd2, 0x7b, 0x1c,
 0xec, 0x8e, 0x43, 0xad, 0x74, 0x81, 0x4e, 0x66, 0x33, 0x69, 0x8c, 0x2b, 0xd7, 0x4e, 0x33, 0xdd,
 0xb0, 0x94, 0x1a, 0x68, 0x92, 0x4d, 0x0f, 0xc4, 0x55, 0xae, 0xf1, 0xf4, 0x95, 0x27, 0x4e, 0x34,
 0x93, 0xa9, 0xd0, 0xef, 0xca, 0x71, 0x84, 0x13, 0x90, 0xc8, 0xc7, 0x96, 0x17, 0x69, 0x8c, 0x95,
 0x13, 0x29, 0xd3, 0x06, 0x5d, 0x0e, 0x19, 0xe3, 0xff, 0x00, 0xfa, 0x86, 0x7e, 0xcc, 0xbc, 0xa9,
 0x35, 0xd6, 0xae, 0xed, 0x1f, 0x4f, 0x69, 0xc9, 0xa4, 0x9b, 0x4c, 0xb5, 0x07, 0x32, 0x98, 0xb3,
 0x0c, 0xfb, 0x8c, 0x43, 0x3c, 0x4e, 0x25, 0x0b, 0x51, 0x11, 0x9a, 0x4c, 0xdd, 0x32, 0x23, 0xf4,
 0x91, 0x8a, 0xf6, 0x7c, 0x9b, 0xf4, 0x8a, 0xf8, 0xea, 0x39, 0xd9, 0x7f, 0xf1, 0xb5, 0xf6, 0x06,
 0x2d, 0x11, 0xd8, 0x0e, 0x96, 0xd3, 0x9a, 0xaa, 0x57, 0xa8, 0x61, 0x75, 0x04, 0xe1, 0xd8, 0x89,
 0x74, 0x52, 0x22, 0x5b, 0x6d, 0xc4, 0x34, 0x49, 0x52, 0x90, 0x75, 0x22, 0x3a, 0x15, 0x68, 0x35,
 0xbf, 0x11, 0x6c, 0x97, 0xe5, 0x26, 0xeb, 0xd2, 0x9a, 0xc1, 0xea, 0x58, 0x99, 0x43, 0x2f, 0xa4,
 0xd4, 0xca, 0x92, 0xaf, 0x40, 0xfc, 0xfd, 0xf2, 0xcf, 0x87, 0x38, 0x5e, 0xde, 0x26, 0x4c, 0x9f,
 0x28, 0x38, 0x4f, 0xf0, 0x52, 0x3d, 0xcd, 0x03, 0x39, 0x52, 0x69, 0x45, 0x98, 0xf0, 0xdf, 0x96,
 0xa4, 0x45, 0xd7, 0x6f, 0x53, 0x17, 0x8c, 0xeb, 0x58, 0x28, 0x3f, 0xf0, 0x52, 0x32, 0xb4, 0xae,
 0xe6, 0xf6, 0xb3, 0x0a, 0x34, 0x28, 0xc6, 0xa7, 0x12, 0x0b, 0x0c, 0xe7, 0xfd, 0x9d, 0xe9, 0x5d,
 0x43, 0xaf, 0xe7, 0xb0, 0xba, 0x5a, 0x4c, 0x64, 0xbd, 0x9e, 0xf1, 0xf3, 0x37, 0x56, 0x64, 0xd4,
 0x3a, 0x7c, 0x3b, 0x6e, 0x2b, 0xa7, 0x04, 0x96, 0xe2, 0xa9, 0x9d, 0x08, 0x76, 0x18, 0x6f, 0x26,
 0x39, 0xec, 0xbf, 0x50, 0x4a, 0x5d, 0x7a, 0x71, 0x2e, 0x98, 0xcb, 0x4a, 0x29, 0xb3, 0x8e, 0x4a,
 0x12, 0xb6, 0xd6, 0x96, 0xc8, 0xea, 0xaa, 0x12, 0xb7, 0x2a, 0xb4, 0xa7, 0x1a, 0xef, 0xe0, 0x1a,
 0xbf, 0xc9, 0xe3, 0x25, 0x87, 0x8c, 0x5e, 0xb2, 0x99, 0x3b, 0xb1, 0xde, 0xa1, 0x10, 0x90, 0xcd,
 0x99, 0xf1, 0x22, 0x51, 0xb8, 0xb5, 0x17, 0xf7, 0x53, 0xea, 0x1e, 0xa6, 0x8f, 0x91, 0xa9, 0x35,
 0x32, 0x48, 0xdb, 0xe3, 0x41, 0x4b, 0x6b, 0x34, 0xf5, 0x19, 0x5e, 0x45, 0xfe, 0x8f, 0xed, 0x3c,
 0xd7, 0xe5, 0x19, 0x26, 0xd5, 0xf3, 0x1d, 0x1e, 0xdc, 0xa7, 0x49, 0xca, 0x5f, 0x8c, 0x28, 0xa7,
 0x8e, 0xf7, 0xb8, 0x52, 0x48, 0xd2, 0xd2, 0x4a, 0xa4, 0x82, 0x23, 0x32, 0x33, 0x25, 0x1d, 0x38,
 0x72, 0x4d, 0x39, 0x8f, 0x3e, 0xe8, 0x2e, 0xc9, 0xb5, 0x34, 0xff, 0x00, 0x54, 0x7e, 0x0a, 0x9b,
 0x4b, 0xe3, 0xe4, 0xb0, 0xed, 0x20, 0xdd, 0x88, 0x7e, 0x22, 0x19, 0x49, 0x32, 0x49, 0x1d, 0x28,
 0x8a, 0xd0, 0x94, 0xa3, 0x33, 0xeb, 0xd4, 0xf9, 0x0f, 0x74, 0x6b, 0x18, 0xa9, 0x4e, 0x98, 0x92,
 0xc4, 0xce, 0x67, 0xf1, 0x8c, 0xc0, 0x40, 0x43, 0x95, 0x5c, 0x79, 0xde, 0x1b, 0xf8, 0x11, 0x17,
 0x13, 0x51, 0xf0, 0x22, 0x2d, 0xe6, 0x3c, 0xdd, 0xab, 0xfc, 0xa5, 0xe5, 0x8d, 0xbc, 0xb6, 0x34,
 0xce, 0x9b, 0x7a, 0x2d, 0x04, 0x66, 0x49, 0x7e, 0x3d, 0xee, 0xed, 0x27, 0x92, 0x6d, 0x35, 0x3f,
 0x5a, 0x88, 0x6c, 0xef, 0x8c, 0xde, 0xe9, 0x33, 0x81, 0xa7, 0xab, 0xfb, 0x6b, 0x79, 0x5b, 0xda,
 0xd3, 0x5e, 0x7f, 0x9b, 0xe2, 0xfc, 0xf9, 0xf2, 0x66, 0xac, 0xcb, 0xc9, 0xe6, 0x40, 0x70, 0x8a,
 0x44, 0x04, 0xe6, 0x66, 0xd4, 0x56, 0xcd, 0x10, 0xb7, 0xb6, 0x16, 0x83, 0x57, 0x2a, 0x91, 0x11,
 0x1d, 0x3d, 0x06, 0x3c, 0xe9, 0x1d, 0x0c, 0xec, 0x1c, 0x73, 0xd0, 0x8f, 0x11, 0x25, 0xd6, 0x5c,
 0x53, 0x6b, 0x22, 0xe4, 0xa4, 0x9d, 0x0f, 0xe9, 0x21, 0xd3, 0xa6, 0xfd, 0xb5, 0xf6, 0x8b, 0x3f,
 0x78, 0xa1, 0x65, 0xce, 0xb3, 0x02, 0xa7, 0x0e, 0x89, 0x6a, 0x5d, 0x0b, 0x57, 0x0f, 0x04, 0x67,
 0xb4, 0xaa, 0xfa, 0x07, 0x31, 0x8d, 0x38, 0x93, 0x8d, 0x78, 0xe3, 0x3b, 0xdb, 0x9e, 0xf1, 0x5d,
 0xef, 0x79, 0x5d, 0xbd, 0xba, 0xf8, 0xb6, 0xab, 0xbe, 0xb5, 0xad, 0x6a, 0x15, 0x25, 0x07, 0x8d,
 0xab, 0x07, 0x73, 0x46, 0xa1, 0xa8, 0xd1, 0x52, 0xfc, 0x6d, 0x45, 0x2c, 0xe3, 0x1d, 0xd7, 0xc9,
 0x1e, 0xb3, 0xd0, 0x2f, 0x3b, 0x35, 0xd0, 0x92, 0x59, 0x83, 0xe6, 0x6b, 0x75, 0xe8, 0x34, 0x77,
 0x8a, 0x3e, 0x2a, 0x51, 0x78, 0x4c, 0xfe, 0x81, 0xc5, 0x7c, 0xa4, 0x5b, 0xee, 0xb5, 0xac, 0x1a,
 0x7f, 0xf4, 0xf4, 0x1f, 0xed, 0x16, 0x3b, 0xaf, 0x63, 0x10, 0xdb, 0x7d, 0x94, 0x69, 0xd5, 0xd3,
 0x8c, 0x29, 0xff, 0x00, 0x88, 0xb1, 0xc5, 0x7c, 0xa9, 0x5b, 0xee, 0xb5, 0xec, 0x0a, 0x69, 0xfd,
 0x1a, 0x83, 0xfd, 0xa3, 0x83, 0x7e, 0xe2, 0xae, 0xeb, 0x74, 0xbd, 0x0f, 0x97, 0xd0, 0xe4, 0x96,
 0xb3, 0x52, 0x0b, 0xa2, 0xdd, 0xf5, 0x10, 0x34, 0x8c, 0xa2, 0x69, 0xa9, 0x66, 0x4d, 0x48, 0x60,
 0x1c, 0xa2, 0x1c, 0x51, 0xbc, 0xbd, 0xa3, 0x3d, 0x84, 0x12, 0x4b, 0x7a, 0xcc, 0xb0, 0x47, 0x4f,
 0x96, 0x9c, 0xc7, 0x43, 0x9c, 0xf6, 0x3c, 0xdc, 0x34, 0x9d, 0xe7, 0xa0, 0xa6, 0x8f, 0xbd, 0x18,
 0xd3, 0x66, 0xb2, 0x4a, 0xda, 0x22, 0x43, 0x86, 0x45, 0x53, 0x22, 0xa1, 0xd4, 0xbe, 0x91, 0xf5,
 0xe4, 0xc5, 0x0a, 0x97, 0xe7, 0x93, 0x97, 0x8d, 0x24, 0x6a, 0x6e, 0x0d, 0x09, 0x23, 0xe9, 0xb4,
 0xbd, 0xff, 0x00, 0x50, 0xed, 0xd1, 0x50, 0x75, 0x6d, 0x65, 0xb3, 0xc5, 0x26, 0x5f, 0x40, 0xca,
 0xce, 0xde, 0x94, 0xe9, 0xe6, 0x6b, 0x2d, 0x9b, 0xfa, 0xd6, 0xb7, 0x71, 0x6b, 0x7b, 0xc2, 0xa4,
 0xf0, 0x96, 0x33, 0xf1, 0xcf, 0x33, 0xc6, 0x4d, 0xad, 0x4d, 0xb8, 0x95, 0xa1, 0x46, 0x95, 0x24,
 0xc8, 0xd2, 0x64, 0x7b, 0xc8, 0xc3, 0xb6, 0x8e, 0xd1, 0x91, 0xba, 0xad, 0x2e, 0xce, 0x26, 0x31,
 0x8e, 0x34, 0xc2, 0xdc, 0x32, 0xef, 0x29, 0xb4, 0xe3, 0xca, 0xe6, 0x7b, 0xf9, 0x64, 0x24, 0xac,
 0xa8, 0xe1, 0x96, 0x47, 0xa5, 0x3b, 0x39, 0x81, 0x4b, 0x7a, 0x06, 0x4b, 0xb2, 0x92, 0x22, 0x54,
 0x29, 0x2c, 0xfd, 0x2a, 0x33, 0x33, 0xfa, 0xc4, 0x74, 0xea, 0x30, 0xab, 0x53, 0x13, 0xe8, 0x8e,
 0xd6, 0xb9, 0x7d, 0x3b, 0x3a, 0x0a, 0x54, 0xf9, 0x36, 0xf1, 0x9f, 0x99, 0xc5, 0xbb, 0x40, 0xd1,
 0xe7, 0xa6, 0xbb, 0x87, 0xd8, 0x89, 0x54, 0x44, 0x2b, 0xea, 0x34, 0x11, 0xad, 0x34, 0x52, 0x54,
 0x5b, 0xe8, 0x74, 0xdc, 0x7b, 0x87, 0xcf, 0x65, 0x71, 0x8e, 0x43, 0xea, 0xd6, 0x21, 0xd2, 0xa3,
 0xee, 0xe2, 0x92, 0xa6, 0xd6, 0x5c, 0x8f, 0x71, 0x99, 0x7d, 0x24, 0x3a, 0x17, 0x6f, 0x50, 0xe4,
 0xde, 0x93, 0x85, 0x5d, 0x37, 0x94, 0x6a, 0x48, 0xbd, 0x85, 0x8e, 0x6b, 0xd9, 0xa1, 0x6d, 0x6b,
 0x99, 0x51, 0x17, 0x37, 0x4f, 0xf7, 0x4c, 0x56, 0xa4, 0x23, 0x42, 0xfa, 0x2a, 0x9f, 0x25, 0x94,
 0x61, 0x6b, 0x71, 0x2b, 0xbd, 0x32, 0x53, 0xab, 0xcd, 0xe1, 0xfc, 0x8e, 0xcb, 0x1c, 0xb6, 0xe1,
 0x61, 0x5d, 0x89, 0x78, 0xf6, 0x5a, 0x69, 0x0a, 0x5a, 0xcf, 0x04, 0x55, 0x31, 0xc1, 0xa7, 0xb3,
 0x38, 0x89, 0xbc, 0xcd, 0xe8, 0xe8, 0x85, 0x78, 0x96, 0x7e, 0x14, 0xf2, 0x42, 0x79, 0x24, 0xb0,
 0x43, 0xb4, 0xf6, 0x94, 0x6a, 0x63, 0x44, 0xcc, 0x96, 0x9d, 0xc6, 0x6d, 0xa5, 0x1f, 0x21, 0xad,
 0x24, 0x63, 0x85, 0xb2, 0xbe, 0xed, 0xe4, 0x39, 0xb2, 0x4a, 0xd9, 0x51, 0x2a, 0x87, 0xc0, 0xe9,
 0xc8, 0x6d, 0x6b, 0x75, 0xdb, 0x94, 0x69, 0xe7, 0x97, 0x52, 0x1e, 0x1d, 0xa4, 0x9d, 0x39, 0xd5,
 0xf3, 0xce, 0x07, 0xf9, 0x17, 0x67, 0xad, 0xbd, 0x00, 0xdc, 0x44, 0xd6, 0x25, 0xe6, 0xdd, 0x71,
 0x24, 0xa2, 0x69, 0xaa, 0x16, 0xc1, 0x1f, 0x02, 0x33, 0x3a, 0xef, 0x0b, 0xfa, 0xcf, 0x4c, 0x3b,
 0x20, 0x75, 0xb7, 0x10, 0xe9, 0xbd, 0x0a, 0xe9, 0x99, 0x21, 0x66, 0x54, 0x52, 0x54, 0x5c, 0x8f,
 0xed, 0x17, 0x2a, 0xed, 0x2e, 0x62, 0x7f, 0xd1, 0x90, 0x45, 0xff, 0x00, 0xb9, 0x7f, 0x68, 0xaa,
 0xd4, 0xda, 0xc2, 0x26, 0x7b, 0x2e, 0x28, 0x37, 0xe0, 0xa1, 0x9a, 0x49, 0x38, 0x4e, 0x12, 0x90,
 0x6a, 0xa9, 0x19, 0x11, 0x97, 0x33, 0xc8, 0x95, 0xc3, 0xd3, 0xdd, 0x0d, 0xb4, 0xff, 0x00, 0x72,
 0xf3, 0xe6, 0x6d, 0x5b, 0xad, 0x45, 0x57, 0xdd, 0x57, 0xf6, 0xbf, 0x2e, 0x5c, 0x8b, 0x5e, 0xcc,
 0x66, 0x8b, 0x5a, 0xdc, 0x94, 0x3c, 0xa3, 0x34, 0x92, 0x4d, 0xc6, 0x2b, 0xca, 0x9e, 0xf9, 0x3e,
 0x8e, 0x7e, 0xb0, 0xf0, 0xa6, 0xc7, 0x26, 0xd0, 0xae, 0x9b, 0x5a, 0xb6, 0x5c, 0x64, 0x7e, 0xf9,
 0xed, 0x83, 0xf4, 0x28, 0x8c, 0xbf, 0x88, 0xec, 0xaa, 0x6c, 0x76, 0x74, 0x3b, 0x89, 0x4e, 0xdf,
 0x6c, 0xbc, 0x9e, 0x3d, 0x8e, 0x5e, 0xb3, 0x4d, 0x52, 0xb8, 0xca, 0xf3, 0x59, 0x2b, 0x96, 0xd8,
 0x89, 0x6d, 0xe0, 0x58, 0xad, 0xb1, 0x12, 0xdb, 0xc0, 0xee, 0x29, 0x9c, 0xb5, 0x31, 0x62, 0x67,
 0xa7, 0x20, 0xe3, 0xe6, 0x65, 0x1b, 0x14, 0xa7, 0x16, 0x44, 0x82, 0x49, 0x34, 0x47, 0x42, 0x3a,
 0x75, 0x3e, 0x3c, 0xc6, 0x27, 0xb0, 0xcd, 0x31, 0xa7, 0x23, 0x1b, 0x65, 0xb4, 0xb6, 0xda, 0x58,
 0x55, 0x12, 0x92, 0xa1, 0x10, 0x63, 0x5b, 0x42, 0xa7, 0x54, 0x22, 0x9a, 0x7a, 0x60, 0x74, 0xe0,
 0xc2, 0x86, 0xb5, 0x5a, 0x34, 0xa9, 0xd2, 0xa9, 0x38, 0xac, 0x36, 0x9e, 0x5f, 0xb1, 0xbd, 0x46,
 0xe2, 0x73, 0x9c, 0x23, 0x27, 0xc9, 0x34, 0x72, 0x54, 0xfb, 0xe2, 0xf4, 0x8e, 0xa8, 0x6d, 0xee,
 0xe1, 0xc8, 0x72, 0xb4, 0xfb, 0xf2, 0xf4, 0x8e, 0xc2, 0x6d, 0xf8, 0x4b, 0x70, 0xe2, 0xf8, 0x5d,
 0xe3, 0x8b, 0xed, 0xf7, 0x3b, 0x1a, 0xcc, 0xb1, 0xb3, 0xdf, 0xec, 0x57, 0x29, 0xb1, 0x12, 0x9b,
 0xc0, 0xb1, 0x53, 0x62, 0x25, 0x36, 0x3e, 0xbd, 0x4c, 0xe3, 0x29, 0x95, 0xca, 0x6c, 0x44, 0xa6,
 0xf0, 0x2c, 0x54, 0xde, 0x04, 0x4b, 0x6c, 0x51, 0x4c, 0xa2, 0x99, 0xd2, 0x19, 0x8c, 0xe1, 0xbc,
 0x6f, 0x31, 0x19, 0x90, 0xa2, 0xcc, 0x61, 0x73, 0x59, 0x7a, 0xc6, 0xe3, 0x31, 0xa8, 0xf3, 0x89,
 0xf6, 0x88, 0x7f, 0x35, 0x29, 0x1a, 0x31, 0xaa, 0x38, 0x31, 0x19, 0x91, 0xbf, 0x0f, 0x1b, 0xbc,
 0xb7, 0x84, 0xd6, 0x23, 0x93, 0xe7, 0x13, 0xed, 0x10, 0xde, 0x62, 0x39, 0x3b, 0xbf, 0x18, 0x9f,
 0x68, 0x86, 0x6a, 0x45, 0xe3, 0x58, 0xf3, 0xe6, 0xbb, 0x3d, 0xad, 0x6b, 0x3b, 0x57, 0x59, 0x83,
 0xe7, 0xfd, 0xf3, 0x1d, 0xff, 0x00, 0xc9, 0xb6, 0x2b, 0xb9, 0xec, 0xe8, 0x91, 0x5a, 0x7f, 0x9f,
 0x3c, 0x7f, 0x42, 0x07, 0x9f, 0x35, 0x8a, 0xb6, 0xb5, 0x5c, 0xd9, 0x45, 0xbe, 0xb1, 0xae, 0x9f,
 0xf7, 0xcc, 0x76, 0x9e, 0xc1, 0xe2, 0x92, 0xce, 0x86, 0x24, 0x1a, 0xc8, 0xbf, 0xcf, 0x1d, 0x3e,
 0x38, 0x48, 0xfa, 0x0b, 0xf7, 0x8b, 0x65, 0xec, 0x7d, 0x35, 0xec, 0xb6, 0xdb, 0xa7, 0xe8, 0x77,
 0x18, 0x78, 0xfe, 0x1e, 0x21, 0x65, 0x0d, 0x30, 0xe1, 0xe2, 0x08, 0xac, 0x47, 0xa7, 0x77, 0xe3,
 0x13, 0xeb, 0x16, 0x10, 0xf3, 0x04, 0xee, 0xfc, 0x62, 0x7d, 0x63, 0x8a, 0xa6, 0x72, 0x61, 0x58,
 0x7d, 0x85, 0x98, 0xf0, 0xf1, 0x0f, 0x20, 0xf9, 0x57, 0x3b, 0xdf, 0xf6, 0xc9, 0x1c, 0xe5, 0x6b,
 0x58, 0x48, 0x5f, 0xf0, 0x92, 0x3d, 0x25, 0x0f, 0x30, 0x4e, 0xef, 0xc6, 0x17, 0xac, 0x79, 0x83,
 0xca, 0x49, 0xce, 0xfb, 0xb5, 0x48, 0xc7, 0x08, 0xc8, 0xeb, 0x0d, 0x0f, 0xcf, 0xfd, 0xd9, 0x0e,
 0x96, 0x9d, 0x2c, 0xd5, 0x7e, 0x87, 0x52, 0xc6, 0xae, 0xe9, 0xe0, 0xed, 0x5e, 0x41, 0x91, 0x96,
 0x92, 0x1d, 0x53, 0x43, 0xa1, 0xaa, 0x2e, 0x1b, 0xe8, 0x43, 0x83, 0xd5, 0x90, 0x13, 0xc3, 0xa1,
 0x25, 0x4a, 0x25, 0x17, 0x43, 0x1e, 0x36, 0xf2, 0x36, 0x8a, 0x28, 0x79, 0x26, 0xa2, 0x2d, 0xa2,
 0x2a, 0xc5, 0x43, 0xf3, 0xfd, 0x45, 0x8f, 0x45, 0x42, 0xcc, 0xcb, 0x77, 0x8c, 0xbd, 0x61, 0x75,
 0x3c, 0x56, 0x65, 0xe7, 0x5f, 0x6d, 0x46, 0x8e, 0x07, 0xfe, 0x50, 0x6d, 0x4f, 0x13, 0x17, 0xaa,
 0x34, 0xee, 0x99, 0x65, 0x4a, 0x6e, 0x01, 0x88, 0x13, 0x8f, 0x5a, 0x08, 0xfc, 0x2b, 0x79, 0x6b,
 0x52, 0x08, 0xcf, 0xfa, 0xa9, 0x45, 0x0b, 0xa6, 0xd1, 0xf5, 0x09, 0xbe, 0x47, 0x7d, 0x9c, 0x69,
 0xde, 0xd0, 0xb5, 0xa4, 0xd4, 0xb5, 0x13, 0x65, 0x16, 0xcc, 0xae, 0x0d, 0x31, 0x0d, 0x41, 0x1a,
 0xcd, 0x29, 0x79, 0x4a, 0x59, 0x26, 0xaa, 0xa6, 0xf3, 0x4a, 0x7a, 0x73, 0x33, 0x2a, 0xee, 0xdc,
 0x7d, 0x27, 0xca, 0xc3, 0x42, 0x47, 0xeb, 0x29, 0x4c, 0x06, 0xa4, 0x91, 0x32, 0x71, 0x73, 0x19,
 0x5b, 0x6a, 0x69, 0xf8, 0x66, 0xf7, 0xad, 0xd6, 0x0c, 0xf6, 0xaa, 0x92, 0xe6, 0xa4, 0x9d, 0x77,
 0x71, 0x32, 0x51, 0xd3, 0x80, 0xf2, 0xfe, 0x90, 0xd4, 0xda, 0x8b, 0x45, 0x6a, 0x36, 0xa7, 0x7a,
 0x76, 0x65, 0x11, 0x2b, 0x99, 0xc3, 0x19, 0xa4, 0x9c, 0x46, 0xe3, 0xa1, 0xee, 0x52, 0x54, 0x93,
 0xdc, 0xa2, 0x3e, 0x69, 0x32, 0x32, 0x1d, 0x1b, 0x79, 0xa9, 0xd2, 0x5b, 0x5f, 0x32, 0xf1, 0xc5,
 0x48, 0x61, 0x72, 0x3f, 0x46, 0xe1, 0xf4, 0xac, 0x8f, 0x4b, 0xc2, 0x29, 0x70, 0x12, 0xc9, 0x74,
 0xa6, 0x0e, 0x1d, 0x26, 0xe3, 0x8a, 0x61, 0x84, 0x32, 0x94, 0x21, 0x3b, 0xd4, 0xa3, 0x32, 0x22,
 0xdc, 0x44, 0x46, 0x75, 0x31, 0xf9, 0xb5, 0xa9, 0xe2, 0xda, 0x98, 0x6a, 0x59, 0x9c, 0x7b, 0x26,
 0x66, 0xd4, 0x4c, 0x63, 0xaf, 0x20, 0xcf, 0xe2, 0xa9, 0x66, 0x65, 0xf4, 0x18, 0xe9, 0xf3, 0x5e,
 0xd2, 0xfb, 0x6a, 0xed, 0x9d, 0xc6, 0xf4, 0x92, 0x63, 0xe2, 0xe6, 0x6d, 0xbe, 0x64, 0x4b, 0x82,
 0x80, 0x86, 0x43, 0x0d, 0xaf, 0x2e, 0x9a, 0x08, 0x8b, 0x64, 0xb8, 0xf8, 0xcf, 0x64, 0x82, 0x27,
 0x69, 0xba, 0x36, 0x67, 0xa0, 0x75, 0x9c, 0x66, 0x97, 0x9b, 0x38, 0xcb, 0xb1, 0x50, 0xa9, 0x6d,
 0x4a, 0x71, 0x93, 0x33, 0x6d, 0x64, 0xb4, 0x25, 0x64, 0x69, 0x33, 0xa5, 0x4b, 0xc5, 0x4a, 0xe0,
 0xc5, 0xe3, 0x27, 0xd2, 0x4f, 0x99, 0xad, 0x69, 0x63, 0x1b, 0x69, 0xca, 0x69, 0xe5, 0xb3, 0xd7,
 0xdd, 0x83, 0x41, 0x93, 0xbd, 0x8c, 0x69, 0x87, 0x08, 0xab, 0x58, 0x45, 0x7f, 0x8a, 0xb1, 0xc0,
 0xfc, 0xaf, 0x99, 0xee, 0x3b, 0x47, 0x97, 0xa2, 0x94, 0xac, 0xa9, 0xb3, 0xfd, 0xab, 0x83, 0xd0,
 0xbe, 0x48, 0x31, 0x6c, 0xcf, 0xbb, 0x0e, 0x81, 0x87, 0x69, 0x69, 0x5c, 0x44, 0xaa, 0x25, 0xe8,
 0x47, 0xd1, 0x5d, 0xe9, 0xaa, 0x8d, 0xc4, 0x1f, 0xa0, 0xd2, 0xbf, 0xa0, 0xc7, 0x0c, 0xf2, 0xdf,
 0x87, 0x38, 0x7e, 0xd5, 0x65, 0xad, 0x99, 0x50, 0xff, 0x00, 0x03, 0x34, 0x7f, 0xb5, 0x74, 0x59,
 0xd5, 0xcc, 0x76, 0x9c, 0x1b, 0x0d, 0x3d, 0xd1, 0xd5, 0x67, 0x55, 0xae, 0xbb, 0xbe, 0x6c, 0x83,
 0xc9, 0x25, 0xae, 0xf6, 0x6b, 0xa8, 0x4a, 0x95, 0xa4, 0x2b, 0x3f, 0xbe, 0x63, 0xbd, 0xc4, 0xc2,
 0x78, 0x15, 0xbb, 0x91, 0xfd, 0x43, 0x8b, 0x79, 0x15, 0xb0, 0x4f, 0xce, 0x75, 0x31, 0x1d, 0x37,
 0x41, 0xb0, 0x7f, 0xb4, 0x31, 0xe8, 0xc8, 0xc8, 0x02, 0x24, 0x2f, 0x87, 0xbd, 0x3f, 0xa8, 0x6e,
 0x5b, 0xd6, 0xdb, 0x1c, 0x1f, 0x39, 0xe2, 0x7a, 0x33, 0xff, 0x00, 0x23, 0x29, 0xc7, 0xa7, 0x2f,
 0xa2, 0x3f, 0x3c, 0x5c, 0xff, 0x00, 0x5a, 0xaf, 0xeb, 0x18, 0xf5, 0x87, 0x66, 0xd0, 0xdb, 0x5d,
 0x9d, 0xc8, 0x15, 0x4e, 0x30, 0x0d, 0x98, 0xf2, 0x7b, 0x85, 0xf8, 0xe5, 0x70, 0xf7, 0xc7, 0xf5,
 0x8f, 0x64, 0xf6, 0x59, 0x0e, 0x4a, 0xec, 0xc7, 0x4d, 0xab, 0x76, 0xf9, 0x73, 0x67, 0xf5, 0x8f,
 0x2c, 0x27, 0xb2, 0x6c, 0xfa, 0x0f, 0x18, 0x4f, 0x65, 0xb5, 0x3f, 0xfd, 0x7d, 0x99, 0xcd, 0x3c,
 0xa3, 0x98, 0xee, 0xf4, 0x54, 0x2a, 0xa9, 0xfd, 0x20, 0x82, 0xfe, 0xe2, 0xc7, 0x27, 0xec, 0x9d,
 0x3b, 0x7d, 0xa1, 0xc9, 0xd3, 0xd5, 0xe3, 0xfd, 0xc5, 0x0e, 0xd5, 0xe5, 0x42, 0xc9, 0x37, 0xa0,
 0xa0, 0xcc, 0xa9, 0xff, 0x00, 0x99, 0x20, 0xb8, 0xff, 0x00, 0xbb, 0x70, 0x71, 0xbe, 0xc6, 0x93,
 0xb5, 0xda, 0x6c, 0x8d, 0x27, 0x4d, 0xef, 0x9f, 0x3f, 0xd4, 0x50, 0xca, 0xbc, 0xf3, 0x73, 0x17,
 0xe8, 0x53, 0x45, 0x9e, 0xed, 0x1a, 0x6f, 0xe1, 0x23, 0xb3, 0xf6, 0x83, 0x28, 0x5c, 0x7e, 0x8d,
 0x9a, 0x43, 0x34, 0x83, 0x53, 0x87, 0x0e, 0x6b, 0x41, 0x17, 0x33, 0x49, 0x92, 0xa9, 0xf4, 0x0f,
 0x37, 0x43, 0x38, 0x96, 0xa2, 0x1b, 0x71, 0x48, 0x25, 0xa5, 0x2b, 0x25, 0x1a, 0x4f, 0x81, 0x91,
 0x1f, 0x01, 0xec, 0x97, 0x61, 0x93, 0x4e, 0x29, 0x1e, 0x7b, 0xed, 0x57, 0xb3, 0x98, 0xe9, 0x3c,
 0xc1, 0xf9, 0xac, 0x9e, 0x19, 0x51, 0x12, 0xb7, 0x54, 0x6b, 0x34, 0x34, 0x5b, 0x4a, 0x87, 0x33,
 0xe2, 0x46, 0x45, 0xbf, 0x67, 0xa1, 0xf2, 0xe0, 0x63, 0x6b, 0x52, 0x84, 0xaa, 0x62, 0xa4, 0x7c,
 0x8d, 0x4f, 0x0c, 0xea, 0x54, 0xa3, 0xba, 0xde, 0xa3, 0xc6, 0x79, 0xaf, 0xe8, 0x7b, 0x85, 0x92,
 0xe9, 0xd8, 0xd8, 0x36, 0xa3, 0x21, 0xa5, 0x32, 0xd7, 0x18, 0x7d, 0x04, 0xb6, 0xd4, 0x98, 0x74,
 0x50, 0xc8, 0xfe, 0x41, 0x4d, 0xaa, 0x57, 0xa4, 0xb4, 0xea, 0x61, 0xce, 0x3e, 0x4d, 0x08, 0xa3,
 0x7d, 0x46, 0x49, 0x4b, 0x50, 0xa8, 0x33, 0x22, 0x2e, 0x27, 0x43, 0xa6, 0xee, 0x43, 0x96, 0x49,
 0x35, 0x3c, 0xfa, 0x4a, 0xca, 0x98, 0x96, 0xcc, 0x5d, 0x65, 0xa3, 0x3a, 0x9b, 0x67, 0x45, 0x26,
 0xbd, 0x68, 0xa2, 0x32, 0x21, 0xaf, 0x19, 0x15, 0x36, 0x9f, 0xcc, 0x89, 0x71, 0x0e, 0x44, 0x47,
 0x45, 0xb9, 0x44, 0xa4, 0x88, 0xb6, 0x95, 0xe8, 0x22, 0x2e, 0x05, 0xe8, 0x1e, 0xcb, 0x54, 0x83,
 0xa7, 0x88, 0x43, 0xf3, 0x7a, 0x2c, 0x1d, 0x3a, 0x5a, 0x35, 0x68, 0xd5, 0x6e, 0xa5, 0x57, 0xb3,
 0xd5, 0xe4, 0xea, 0xd2, 0x19, 0x86, 0x8b, 0x99, 0x47, 0x34, 0xd4, 0xb2, 0x1a, 0x11, 0x11, 0x75,
 0xda, 0x6d, 0x36, 0x7b, 0x0b, 0x23, 0x22, 0xad, 0x48, 0xe9, 0x4f, 0xa4, 0x32, 0xad, 0xb0, 0xb9,
 0xd9, 0xae, 0x8e, 0x72, 0x45, 0x0e, 0xb9, 0x84, 0xc4, 0x90, 0x51, 0xef, 0xa7, 0x64, 0x9b, 0xda,
 0x23, 0xee, 0x51, 0xd3, 0xfa, 0xc7, 0xcf, 0xa7, 0x00, 0xdc, 0xb4, 0xa7, 0xe3, 0x27, 0xd6, 0x3b,
 0x96, 0x33, 0xa8, 0xe9, 0x66, 0x69, 0x26, 0xfb, 0x72, 0x38, 0x17, 0xf3, 0xa4, 0xab, 0x38, 0xd2,
 0x93, 0x92, 0x5e, 0x6d, 0xe7, 0xf8, 0xf8, 0x15, 0xeb, 0x6c, 0x44, 0xb6, 0xf0, 0x2c, 0x16, 0x94,
 0xfc, 0x64, 0xfa, 0xc4, 0x4b, 0x4a, 0x3e, 0x32, 0x7d, 0x63, 0x79, 0x4c, 0xd6, 0x53, 0x2b, 0xd6,
 0xd0, 0xa7, 0xd5, 0xad, 0xd3, 0x4d, 0x4c, 0x4f, 0xfe, 0x1d, 0x41, 0x8d, 0x69, 0x47, 0xc6, 0x4f,
 0xac, 0x85, 0x36, 0xb1, 0x4a, 0x7d, 0xcb, 0xcc, 0xcc, 0x94, 0x9f, 0xfc, 0x32, 0xb9, 0x8c, 0x6e,
 0x25, 0xfa, 0x33, 0xf4, 0x7f, 0x43, 0x6a, 0xda, 0x7f, 0xad, 0x0f, 0x55, 0xf5, 0x38, 0x8a, 0x7d,
 0xf9, 0x7a, 0x47, 0x6c, 0x36, 0xfc, 0x25, 0xbb, 0x90, 0xe2, 0x89, 0x2f, 0x19, 0x70, 0xe2, 0x3b,
 0xb1, 0xa5, 0x1b, 0x25, 0xe3, 0x4f, 0x0e, 0xa3, 0x87, 0xe1, 0xc7, 0x8e, 0x27, 0xb7, 0xdc, 0xfa,
 0x1d, 0x76, 0x58, 0xe1, 0xfb, 0xfd, 0x8d, 0x05, 0x36, 0x22, 0x53, 0x62, 0xc1, 0x69, 0x47, 0xc6,
 0x47, 0xb4, 0x42, 0x25, 0xa5, 0x1f, 0x1d, 0x3e, 0xb2, 0x1f, 0x54, 0xa6, 0x70, 0x54, 0xca, 0xf5,
 0xb7, 0x81, 0x12, 0x9b, 0x16, 0x0b, 0x4a, 0x3e, 0x32, 0x3d, 0x64, 0x22, 0x5a, 0x51, 0xf1, 0xd3,
 0xeb, 0x21, 0x45, 0x32, 0x8a, 0x67, 0xe8, 0x8f, 0xb9, 0x4d, 0x1f, 0xfa, 0x31, 0x23, 0xff, 0x00,
 0xa7, 0xb5, 0xf7, 0x46, 0x7d, 0xcb, 0x69, 0x12, 0xe1, 0xa6, 0x64, 0x9f, 0x30, 0x6b, 0xee, 0x8f,
 0x8b, 0xdc, 0x82, 0xf7, 0x23, 0xf2, 0x7e, 0x1c, 0x7b, 0x1f, 0x71, 0xc3, 0x87, 0x64, 0x48, 0x5a,
 0x63, 0x49, 0x72, 0xd3, 0x52, 0x5f, 0x98, 0x35, 0xf7, 0x47, 0xd1, 0x69, 0xad, 0x28, 0x5c, 0x34,
 0xe4, 0x98, 0xbf, 0xb0, 0xb5, 0xf7, 0x44, 0x37, 0xb9, 0x05, 0xee, 0x43, 0x87, 0x1e, 0xc3, 0x87,
 0x0e, 0xc7, 0x31, 0x9d, 0xca, 0x24, 0x48, 0x9c, 0xc6, 0xa5, 0x12, 0x79, 0x69, 0x24, 0xa2, 0x16,
 0x44, 0x45, 0x08, 0xdf, 0x0d, 0xa3, 0xc0, 0x75, 0xec, 0xfe, 0x47, 0xa7, 0x5c, 0x90, 0x6d, 0xb9,
 0x23, 0x95, 0xad, 0x5d, 0xfa, 0xca, 0xa7, 0x06, 0xdd, 0x79, 0x60, 0x21, 0x4f, 0x22, 0xab, 0x3a,
 0x8e, 0xdf, 0xfc, 0xe1, 0x7f, 0xbc, 0x61, 0xd7, 0xb3, 0xf8, 0xcd, 0x9d, 0x3f, 0x4a, 0xfc, 0x3a,
 0xff, 0x00, 0x80, 0xf7, 0x6c, 0x7b, 0x1e, 0xec, 0x8f, 0x61, 0xac, 0xa4, 0x3a, 0x6c, 0xb8, 0x48,
 0x65, 0x5f, 0x33, 0x6f, 0xec, 0x19, 0xfc, 0x07, 0xa7, 0x4b, 0x84, 0x92, 0x58, 0x5f, 0xd9, 0x1b,
 0xfb, 0x06, 0xa5, 0xee, 0x41, 0x7b, 0x90, 0xd9, 0x1e, 0xc3, 0x64, 0x7b, 0x1b, 0x85, 0x26, 0xd3,
 0xe5, 0xc2, 0x4d, 0x2d, 0xf9, 0xaa, 0x3e, 0xc1, 0xcc, 0x7b, 0x42, 0xd3, 0xfa, 0x65, 0xcd, 0x50,
 0xf2, 0xdc, 0xd3, 0xf2, 0x77, 0x15, 0xdd, 0xb7, 0xe2, 0x5c, 0x0b, 0x4a, 0x3f, 0x7b, 0xd4, 0xd2,
 0x3a, 0x15, 0xee, 0x47, 0x3a, 0xd7, 0x71, 0x55, 0xd4, 0x8f, 0x1d, 0x7e, 0x0d, 0xbf, 0xdd, 0x05,
 0x14, 0xba, 0x23, 0xd5, 0x14, 0xba, 0x21, 0x83, 0xb2, 0xa9, 0x26, 0x9e, 0x62, 0x16, 0x60, 0x4c,
 0xc9, 0x25, 0x6c, 0x91, 0xba, 0x8a, 0x93, 0x70, 0x6d, 0xa6, 0xbe, 0x13, 0xe8, 0x41, 0xd8, 0xa5,
 0xd2, 0x72, 0xe1, 0x2c, 0x82, 0x2f, 0xec, 0xe8, 0xfb, 0x02, 0x0f, 0x66, 0xd1, 0x74, 0x85, 0x8e,
 0x2a, 0xfc, 0x22, 0x3e, 0xa3, 0x0d, 0xb7, 0xb9, 0x07, 0x14, 0xfc, 0x86, 0xd4, 0x57, 0xeb, 0x68,
 0xd9, 0x7c, 0xae, 0x1d, 0xb8, 0x78, 0x38, 0x18, 0x34, 0x44, 0xbc, 0x46, 0x7b, 0x64, 0xc2, 0x6a,
 0x84, 0x97, 0x32, 0xdd, 0xc6, 0xa3, 0x9a, 0xaf, 0x4f, 0x48, 0xe6, 0x71, 0xea, 0x5b, 0x9a, 0x7a,
 0x59, 0x1b, 0x16, 0xfa, 0xaa, 0xa5, 0x2e, 0x05, 0xa7, 0x1c, 0x70, 0xfa, 0x99, 0x9a, 0x6a, 0x67,
 0x93, 0x0c, 0x5d, 0xa3, 0xba, 0xbf, 0xc2, 0x10, 0xd1, 0x1b, 0xfb, 0xb5, 0x35, 0xb0, 0x47, 0x92,
 0x33, 0x3a, 0x7d, 0x23, 0x5b, 0x41, 0xcd, 0xa0, 0xe0, 0xe6, 0x6f, 0x5d, 0x38, 0x96, 0xcd, 0xc6,
 0xf6, 0x5b, 0x5a, 0x8e, 0x84, 0x47, 0x5d, 0xe5, 0x5e, 0x55, 0xfe, 0x03, 0xd4, 0x92, 0xe8, 0x12,
 0x48, 0x25, 0xb2, 0xa7, 0xb4, 0x8d, 0x5d, 0x82, 0x92, 0xc3, 0xcb, 0x1b, 0x70, 0xc8, 0xdc, 0x26,
 0xa1, 0x10, 0x86, 0xdc, 0x3e, 0x44, 0xa2, 0x49, 0x50, 0xfe, 0x5d, 0xe3, 0x43, 0x53, 0x43, 0x48,
 0xf5, 0x04, 0xdd, 0xc9, 0x9c, 0xc2, 0x43, 0x2a, 0x79, 0xe5, 0xa5, 0x28, 0x23, 0x76, 0x11, 0xb7,
 0x0c, 0x92, 0x92, 0xa1, 0x15, 0x54, 0x9a, 0xd3, 0x8f, 0xac, 0x74, 0xd5, 0xc4, 0xb3, 0x12, 0xc2,
 0x9b, 0x5e, 0xc3, 0xac, 0xb8, 0x5b, 0x2a, 0x2e, 0x24, 0x64, 0x63, 0x92, 0x44, 0xbc, 0x4d, 0x44,
 0xba, 0xd1, 0x1e, 0xe4, 0x38, 0xa4, 0x97, 0xc8, 0x74, 0x0c, 0x2e, 0xa7, 0xa7, 0x4f, 0xec, 0xbe,
 0x4b, 0x26, 0x94, 0x69, 0xd3, 0x72, 0x02, 0x59, 0x03, 0x06, 0x71, 0x8e, 0x1b, 0x8e, 0x14, 0x3c,
 0x3a, 0x1b, 0xda, 0xa7, 0x85, 0x35, 0xd9, 0x22, 0xad, 0x0a, 0xbe, 0xb0, 0xb5, 0xda, 0xb4, 0xa2,
 0x45, 0x1d, 0xa8, 0x58, 0x76, 0x36, 0x4f, 0x2d, 0x8a, 0x70, 0xa1, 0x52, 0x92, 0x5b, 0xf0, 0x8d,
 0xb8, 0xa2, 0x2d, 0xa5, 0x6e, 0xaa, 0x88, 0xce, 0x82, 0xff, 0x00, 0x48, 0xc6, 0x6c, 0xe9, 0xb8,
 0x12, 0xaf, 0xc1, 0x9f, 0xef, 0x18, 0x57, 0xed, 0x12, 0x2a, 0xb3, 0xa6, 0x77, 0xff, 0x00, 0x37,
 0x2f, 0xde, 0x50, 0xf4, 0x60, 0xb1, 0xec, 0x9a, 0x51, 0x22, 0x83, 0x8e, 0x98, 0x2a, 0x12, 0x4d,
 0x2d, 0x86, 0x35, 0x34, 0x82, 0x51, 0xb3, 0x08, 0xda, 0x36, 0x8b, 0x68, 0xf8, 0xec, 0x91, 0x54,
 0x74, 0x05, 0x42, 0x4b, 0x0d, 0x27, 0x58, 0x18, 0x53, 0xdd, 0xe6, 0x53, 0xf6, 0x0e, 0x6b, 0xd9,
 0xb4, 0x5e, 0xcc, 0x5c, 0x6e, 0xff, 0x00, 0x82, 0x47, 0xef, 0x18, 0x75, 0x38, 0xdf, 0x09, 0xef,
 0xe4, 0x06, 0x0e, 0x9c, 0x64, 0xf2, 0xd1, 0xc7, 0xcf, 0x4e, 0x69, 0x6d, 0xa3, 0xfe, 0x4d, 0xc9,
 0x38, 0xff, 0x00, 0xb3, 0xd9, 0xfb, 0xa3, 0xaf, 0x69, 0x39, 0x54, 0x91, 0x1a, 0x66, 0x5a, 0x84,
 0x4a, 0xa0, 0x10, 0x84, 0xc3, 0xa4, 0x92, 0x94, 0xc3, 0x20, 0x88, 0x8b, 0xa1, 0x15, 0x37, 0x0e,
 0x42, 0x71, 0x3e, 0x23, 0xdf, 0xcc, 0x75, 0x1d, 0x35, 0x19, 0x4d, 0x3d, 0x00, 0x55, 0xf8, 0x04,
 0x86, 0x4f, 0x65, 0x08, 0xcf, 0x94, 0x96, 0x4d, 0x4e, 0xd3, 0xe4, 0xda, 0x7d, 0xf9, 0x0b, 0x28,
 0x7a, 0x4b, 0x2c, 0x75, 0x37, 0x29, 0x3d, 0x97, 0x21, 0x1b, 0x51, 0x57, 0x65, 0x5c, 0x8c, 0x82,
 0x7e, 0x8c, 0xd3, 0xda, 0x65, 0xbd, 0x53, 0x2f, 0x53, 0x7a, 0x7a, 0x4e, 0x85, 0x13, 0xa7, 0x45,
 0x26, 0x01, 0xa2, 0x32, 0xf0, 0x9f, 0x32, 0x48, 0x66, 0xed, 0x12, 0x2f, 0x6a, 0x4a, 0xce, 0xff,
 0x00, 0xe7, 0x05, 0xfb, 0xaa, 0x0a, 0xfa, 0x46, 0x2a, 0x9a, 0x92, 0x04, 0xeb, 0xf0, 0x9f, 0xfe,
 0x4c, 0x32, 0x14, 0x22, 0x96, 0xd4, 0xb9, 0x1d, 0x6b, 0xf0, 0x3c, 0x84, 0xff, 0x00, 0xa1, 0xe5,
 0xdf, 0x35, 0x47, 0xd8, 0x10, 0xf5, 0x5c, 0x7c, 0xa1, 0x51, 0x4b, 0x83, 0x96, 0x4a, 0xe5, 0xcd,
 0x34, 0xd9, 0x9a, 0x56, 0xf2, 0x21, 0x51, 0xb4, 0xb3, 0xe7, 0x43, 0xa6, 0xe2, 0xfa, 0xc3, 0x04,
 0xfe, 0x6a, 0xa8, 0x49, 0x2c, 0x5c, 0x42, 0x15, 0x45, 0xa5, 0xa3, 0x24, 0x9e, 0x4f, 0x71, 0x7d,
 0x63, 0x97, 0x34, 0xf6, 0xdb, 0x89, 0x6c, 0x95, 0x43, 0x52, 0x89, 0x35, 0xf4, 0x9d, 0x06, 0x5b,
 0xa5, 0xdc, 0xc3, 0x81, 0x4f, 0xfd, 0x57, 0xf0, 0x6c, 0x43, 0xe9, 0x09, 0x2c, 0xc1, 0x6b, 0x5b,
 0x1a, 0x4e, 0x59, 0x14, 0xaa, 0xd5, 0x6a, 0x4c, 0xb5, 0xa5, 0x6f, 0xc9, 0xec, 0xf1, 0x19, 0x87,
 0x91, 0xc9, 0xe5, 0x11, 0x86, 0xa6, 0x24, 0x12, 0xd8, 0x28, 0x84, 0xee, 0x56, 0xcc, 0x03, 0x48,
 0x57, 0xa0, 0xfc, 0x3b, 0xc8, 0x74, 0xe8, 0x18, 0x88, 0x48, 0x28, 0x46, 0xe1, 0x58, 0x71, 0xa4,
 0xb6, 0xd9, 0x50, 0x88, 0x96, 0x5b, 0xf3, 0xe9, 0x31, 0x5f, 0xa8, 0x61, 0x20, 0x67, 0x26, 0xca,
 0x9d, 0x8b, 0x4b, 0x2b, 0x6a, 0xa5, 0xb6, 0x93, 0x49, 0x99, 0xa4, 0xf9, 0x6f, 0x3e, 0xa3, 0xcc,
 0xe3, 0x99, 0x46, 0x93, 0x58, 0x67, 0xde, 0x90, 0x2d, 0x35, 0x37, 0x61, 0x4c, 0xc4, 0xe9, 0xf9,
 0x3a, 0x62, 0xda, 0x2a, 0xaa, 0x90, 0x4d, 0xd1, 0x69, 0xf8, 0xc5, 0xbb, 0xd6, 0x42, 0xfb, 0xdc,
 0xf6, 0x97, 0xfd, 0x1e, 0x94, 0x7c, 0xc9, 0xbf, 0xba, 0x16, 0xe4, 0xd2, 0xc9, 0x54, 0xb6, 0x2d,
 0x11, 0x10, 0xf1, 0x2e, 0x2d, 0xf2, 0x23, 0x22, 0x35, 0x3c, 0x5b, 0xeb, 0xc7, 0x71, 0x0b, 0xcb,
 0xdc, 0x8c, 0xb8, 0x92, 0xee, 0x61, 0xc2, 0xa7, 0xfe, 0xa8, 0x9f, 0xdc, 0xe6, 0x97, 0xfd, 0x1d,
 0x93, 0xfc, 0xc5, 0xbf, 0xba, 0x31, 0xee, 0x73, 0x4b, 0x7e, 0x8e, 0xc9, 0xfe, 0x62, 0xdf, 0xdd,
 0x10, 0xde, 0xe4, 0x17, 0xb9, 0x0e, 0x24, 0xfb, 0x8e, 0x14, 0x3b, 0x22, 0x6f, 0x73, 0x7a, 0x57,
 0xf4, 0x72, 0x4f, 0xf3, 0x16, 0xbe, 0xe8, 0xad, 0xd5, 0x1a, 0x6b, 0x4a, 0xfb, 0x9d, 0x98, 0x19,
 0x69, 0xc9, 0x37, 0xfa, 0x85, 0x7f, 0x31, 0x6b, 0xee, 0x8d, 0xcb, 0xdc, 0x8a, 0xfd, 0x4b, 0x19,
 0x5d, 0x3d, 0x1e, 0x55, 0xf8, 0x05, 0x0f, 0x37, 0xcb, 0xb9, 0xef, 0x0e, 0x0b, 0xc8, 0xe5, 0xa5,
 0xa7, 0x34, 0xb6, 0xd1, 0x7f, 0x26, 0xe4, 0x9c, 0x7f, 0xd9, 0xec, 0xfd, 0xd1, 0xd9, 0x8b, 0x4c,
 0x69, 0x3d, 0x92, 0xfe, 0x4d, 0xc9, 0xb8, 0x7e, 0x60, 0xd7, 0xdd, 0x1c, 0x68, 0xa2, 0x7c, 0x45,
 0xbf, 0x98, 0xec, 0x29, 0x8d, 0xdc, 0x5b, 0xf9, 0x0f, 0x14, 0x9c, 0x7a, 0x33, 0xd7, 0x15, 0x2e,
 0xa8, 0x93, 0xdc, 0xc6, 0x92, 0xfd, 0x1a, 0x92, 0xfc, 0xc1, 0xaf, 0xba, 0x31, 0xee, 0x5f, 0x48,
 0xfe, 0x8c, 0xc9, 0x7e, 0x60, 0xd7, 0xdd, 0x1f, 0x17, 0xb9, 0x05, 0xee, 0x46, 0x5c, 0x49, 0xf7,
 0x67, 0x9c, 0x38, 0x76, 0x3e, 0xfd, 0xcb, 0x69, 0x1f, 0xd1, 0x89, 0x27, 0xcc, 0x1a, 0xfb, 0xa0,
 0xf7, 0x2b, 0xa4, 0x3f, 0x46, 0x24, 0x7f, 0xf4, 0xf6, 0xbe, 0xe8, 0xf8, 0xbd, 0xc8, 0x2f, 0x72,
 0x1c, 0x59, 0xf7, 0x63, 0x87, 0x0e, 0xc2, 0xed, 0xe6, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x90, 0x5e,
 0x64, 0x60, 0x66, 0x31, 0xde, 0x64, 0x17, 0x9f, 0xac, 0x17, 0x2f, 0x32, 0x0b, 0xcc, 0x80, 0x14,
 0xe7, 0x31, 0x5f, 0xe9, 0x88, 0xc3, 0xaf, 0xc3, 0xaf, 0xeb, 0x31, 0x7d, 0xa6, 0x35, 0x3c, 0x0c,
 0xb6, 0x57, 0x6d, 0x10, 0x6f, 0x6d, 0xf7, 0x8a, 0x57, 0x85, 0x15, 0x2a, 0x1d, 0x32, 0x11, 0xe6,
 0xf1, 0x55, 0x9a, 0xc5, 0xef, 0xf8, 0x65, 0xfd, 0x66, 0x25, 0x80, 0x81, 0x8e, 0x8d, 0x63, 0xbf,
 0x87, 0x42, 0x14, 0x8d, 0xa3, 0x4d, 0x4d, 0x64, 0x5b, 0xc8, 0x01, 0xd1, 0xfd, 0xdb, 0x4a, 0xba,
 0xc4, 0xff, 0x00, 0xca, 0xff, 0x00, 0xb8, 0x92, 0x17, 0x58, 0x4b, 0x62, 0x62, 0x5b, 0x87, 0x6c,
 0xdf, 0xdb, 0x71, 0x44, 0x94, 0xd5, 0xba, 0x15, 0x4f, 0xe5, 0x1c, 0xef, 0xf0, 0x34, 0xd7, 0xcd,
 0x37, 0xff, 0x00, 0x34, 0x86, 0xcc, 0xae, 0x59, 0x32, 0x87, 0x99, 0x43, 0x3e, 0xe3, 0x6d, 0x92,
 0x1b, 0x70, 0x94, 0xa3, 0x27, 0x08, 0xf7, 0x10, 0x03, 0xaa, 0x5e, 0x64, 0x73, 0xfd, 0x6b, 0x15,
 0x5d, 0x40, 0xe9, 0xd7, 0xe0, 0xd1, 0xf5, 0x0b, 0xdb, 0xcc, 0x84, 0x6d, 0x61, 0x15, 0x59, 0xeb,
 0xa7, 0x5f, 0xc8, 0x47, 0xd4, 0x00, 0x6f, 0xec, 0xf6, 0x38, 0x93, 0x7a, 0xd6, 0xd6, 0xf3, 0xd8,
 0x57, 0xd6, 0x41, 0xb6, 0xf3, 0x23, 0x8c, 0x4a, 0x27, 0x0f, 0x4b, 0x62, 0xca, 0x25, 0xa2, 0x25,
 0x11, 0x91, 0xa5, 0x49, 0x3e, 0x0a, 0x2e, 0x82, 0xfd, 0x1a, 0xd0, 0x9c, 0x89, 0x65, 0x05, 0x0d,
 0xdd, 0xb6, 0xa5, 0x91, 0x38, 0xa5, 0x2e, 0xa6, 0x44, 0x7d, 0x00, 0x1d, 0x02, 0x60, 0x50, 0xf1,
 0xf0, 0xaa, 0x87, 0x8a, 0x4e, 0xda, 0x0f, 0x7f, 0x1a, 0x19, 0x1f, 0x52, 0x3e, 0x46, 0x15, 0x23,
 0x74, 0xd3, 0xc9, 0x33, 0x38, 0x38, 0xb6, 0xdc, 0x4f, 0x24, 0xb8, 0x5b, 0x27, 0xeb, 0x2d, 0xc2,
 0x2d, 0x4d, 0x35, 0x8e, 0x83, 0x82, 0x4b, 0xf0, 0x6b, 0x49, 0x11, 0x2a, 0x8e, 0x19, 0xa6, 0xa6,
 0x44, 0x7c, 0x0f, 0xd7, 0xf5, 0x85, 0xf9, 0x5e, 0xac, 0x8c, 0x66, 0x37, 0xbc, 0x8d, 0x79, 0xc7,
 0xd9, 0x51, 0x51, 0x49, 0xdd, 0xe1, 0xc9, 0x10, 0x02, 0xd4, 0xe1, 0x67, 0xb2, 0xe5, 0x77, 0x8d,
 0x22, 0x21, 0x14, 0xfc, 0xa6, 0x17, 0x52, 0xfa, 0x05, 0x53, 0x91, 0x6b, 0x5b, 0x8a, 0x5a, 0xd4,
 0x66, 0xa3, 0x33, 0x35, 0x19, 0xf1, 0xaf, 0x31, 0x76, 0xe6, 0xb1, 0x96, 0xa1, 0xb3, 0x53, 0x66,
 0xf3, 0x8b, 0x2e, 0x09, 0xd8, 0xa6, 0xff, 0x00, 0x49, 0x84, 0xb7, 0x63, 0x4d, 0xc7, 0x56, 0xea,
 0x8f, 0x7a, 0xd4, 0x6a, 0x3f, 0x94, 0xea, 0x00, 0xeb, 0xda, 0x5a, 0x2e, 0x9a, 0x7a, 0x08, 0xab,
 0xf0, 0x7f, 0xc4, 0xc2, 0xd6, 0xbe, 0x8b, 0xda, 0x9c, 0x34, 0x75, 0xf8, 0x02, 0xfd, 0xe3, 0x1b,
 0x12, 0x37, 0xd4, 0xcc, 0x9e, 0x11, 0xb5, 0x6e, 0x32, 0x68, 0xaa, 0x5e, 0x9d, 0xff, 0x00, 0xc4,
 0x2d, 0x6b, 0x88, 0xaa, 0xcd, 0x5a, 0x3a, 0xfc, 0x01, 0x7d, 0x66, 0x00, 0x62, 0xec, 0xf6, 0x30,
 0x93, 0x1b, 0x16, 0x9a, 0xef, 0x36, 0x92, 0x7e, 0xa5, 0x7f, 0xdc, 0x39, 0x2a, 0x33, 0xc2, 0x7b,
 0xf9, 0x0e, 0x33, 0x28, 0x9b, 0xbb, 0x2e, 0x8c, 0x4c, 0x53, 0x65, 0xb4, 0x9f, 0x7a, 0xa4, 0x9f,
 0x05, 0x11, 0xf2, 0xa8, 0x63, 0x8b, 0xd6, 0x70, 0xa7, 0x08, 0xb2, 0x61, 0xb7, 0xbb, 0xe5, 0x24,
 0xc8, 0x89, 0x44, 0x44, 0x44, 0x67, 0xce, 0xb5, 0x00, 0x55, 0x1c, 0x4f, 0x88, 0xf7, 0xf3, 0x1d,
 0x23, 0x4d, 0x47, 0x11, 0xc8, 0x60, 0xa8, 0xae, 0x0d, 0x11, 0x7a, 0xb7, 0x0e, 0x3a, 0x51, 0x3c,
 0x88, 0xea, 0x2f, 0xf4, 0xf6, 0xa7, 0xfc, 0x1c, 0xc9, 0xc1, 0xc5, 0xa1, 0x66, 0xda, 0x54, 0x66,
 0x93, 0x4f, 0xbe, 0x41, 0xf3, 0x23, 0x23, 0x00, 0x39, 0x6b, 0xe8, 0xca, 0xca, 0x1a, 0x2a, 0xfc,
 0x39, 0x7e, 0xe9, 0x85, 0xad, 0x2d, 0x15, 0x4d, 0x43, 0x04, 0x75, 0xf8, 0x4f, 0xe0, 0x62, 0xbb,
 0x53, 0x6a, 0x26, 0xe6, 0x44, 0xd3, 0x2c, 0x25, 0x69, 0x69, 0xb3, 0x35, 0x19, 0xaf, 0x71, 0xa8,
 0xf8, 0x70, 0x10, 0xe9, 0x37, 0x14, 0xe4, 0xf1, 0x95, 0x97, 0x06, 0x88, 0xd6, 0xa3, 0xe9, 0xba,
 0x9f, 0x59, 0x80, 0x3a, 0x4e, 0xac, 0x8a, 0x35, 0xe9, 0xe8, 0xb2, 0x23, 0xe0, 0x94, 0x9f, 0xa9,
 0x44, 0x39, 0xe2, 0x5f, 0x35, 0x2c, 0x92, 0x46, 0x55, 0x33, 0xa6, 0xf0, 0xe3, 0x12, 0xf2, 0x62,
 0x21, 0xdc, 0x61, 0xc3, 0xf0, 0xb8, 0x83, 0x49, 0xfc, 0xa4, 0x39, 0xc4, 0x59, 0xbb, 0x0b, 0x12,
 0xb8, 0x77, 0x6a, 0x4b, 0x41, 0xd0, 0xf3, 0x90, 0x03, 0x8f, 0xb9, 0xd9, 0xa7, 0xfc, 0x2f, 0xfc,
 0xcf, 0xfb, 0x0d, 0x59, 0x9c, 0xae, 0x32, 0x5d, 0x0d, 0x71, 0x11, 0xdc, 0x6c, 0x6d, 0x12, 0x7c,
 0x2b, 0xa9, 0xd4, 0xfe, 0x41, 0xf5, 0x2c, 0xd6, 0x30, 0xe7, 0x0c, 0x94, 0x46, 0xed, 0xa1, 0xd4,
 0x95, 0x0d, 0x49, 0x4e, 0xd1, 0x2b, 0x38, 0x31, 0x55, 0xa9, 0x75, 0x11, 0x4c, 0x8d, 0x0c, 0xb2,
 0x95, 0x25, 0x86, 0xcf, 0x6b, 0xc5, 0xc5, 0x47, 0xd7, 0x00, 0x0b, 0x0d, 0x34, 0xf6, 0xdc, 0xfa,
 0x08, 0x88, 0x8b, 0x73, 0xa4, 0xaf, 0x56, 0xf1, 0xd2, 0x6f, 0x32, 0x39, 0x86, 0x89, 0x42, 0x8e,
 0x21, 0x71, 0xeb, 0x2a, 0x21, 0x04, 0x68, 0x6c, 0xfa, 0x99, 0xf1, 0x3f, 0x90, 0xbe, 0xb0, 0xdb,
 0x79, 0x90, 0x03, 0x1d, 0xe6, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x91, 0x8b, 0xcc, 0x80, 0x19, 0x2f,
 0x32, 0x34, 0x35, 0x14, 0x65, 0x64, 0x31, 0xc5, 0x5f, 0x81, 0x50, 0x5d, 0x8a, 0xd4, 0x30, 0x70,
 0xb1, 0xa5, 0x09, 0x10, 0xe1, 0xb4, 0xb3, 0x49, 0x28, 0x94, 0x65, 0xe1, 0xdf, 0x9e, 0x43, 0x13,
 0xc8, 0xd4, 0xae, 0x47, 0x18, 0x69, 0x59, 0x29, 0x2a, 0x64, 0xe8, 0x64, 0x75, 0x23, 0x00, 0x2c,
 0x14, 0x4f, 0x88, 0xb7, 0xf3, 0x1d, 0x60, 0xa3, 0x37, 0x16, 0xfe, 0x43, 0x86, 0x94, 0x4f, 0x88,
 0xb7, 0xf3, 0x1d, 0x3c, 0xa3, 0x37, 0x16, 0xfe, 0x40, 0x06, 0x4b, 0xcc, 0x82, 0xf3, 0x21, 0x72,
 0xf3, 0x20, 0xbc, 0xc8, 0x01, 0x8e, 0xf3, 0x20, 0xbc, 0xc8, 0x5c, 0xbc, 0xc8, 0x2f, 0x32, 0x00,
 0x5c, 0xbd, 0xc8, 0x2f, 0x72, 0x17, 0x6f, 0x32, 0x31, 0x7b, 0x90, 0x03, 0x1d, 0xee, 0x41, 0x79,
 0x90, 0xb9, 0x7b, 0x90, 0x5e, 0xe4, 0x01, 0x49, 0x34, 0x89, 0xff, 0x00, 0x49, 0xc5, 0x1d, 0x7e,
 0x19, 0x5f, 0x59, 0x86, 0x6d, 0x23, 0x19, 0x49, 0x45, 0x2b, 0xf0, 0xaa, 0xfe, 0x03, 0x9f, 0x4c,
 0xa2, 0x6b, 0x30, 0x88, 0x3a, 0xfc, 0x2a, 0xbe, 0xb0, 0x31, 0x35, 0x8b, 0x61, 0xbe, 0xed, 0x98,
 0x97, 0x1b, 0x45, 0x6b, 0x44, 0x9d, 0x0a, 0xa0, 0x0e, 0xb3, 0x7a, 0x5d, 0x41, 0x7a, 0x5d, 0x47,
 0x2a, 0xfc, 0x39, 0x31, 0xfc, 0xf5, 0xff, 0x00, 0x68, 0x1f, 0x87, 0x26, 0x3f, 0x9e, 0xbf, 0xed,
 0x00, 0x3a, 0xad, 0xee, 0x45, 0x2c, 0xda, 0x5c, 0x51, 0xf1, 0xaa, 0x89, 0xbb, 0xee, 0xf6, 0x92,
 0x45, 0xb3, 0xb1, 0x5e, 0x05, 0xe9, 0x15, 0x52, 0x49, 0x83, 0x8e, 0xcb, 0x19, 0x5b, 0xae, 0xa9,
 0x6b, 0x3a, 0xd5, 0x4a, 0x3d, 0xe7, 0xbc, 0xc6, 0xed, 0xe6, 0x40, 0x1b, 0x0d, 0xca, 0xd8, 0xfc,
 0x1a, 0xa8, 0x47, 0x5f, 0x35, 0x2b, 0xbc, 0x35, 0xa1, 0xc2, 0x4d, 0x0d, 0x26, 0x64, 0x45, 0x4a,
 0x74, 0xdc, 0x34, 0x53, 0x23, 0x77, 0x6e, 0x8b, 0x8c, 0x6c, 0x91, 0xd5, 0x28, 0x3a, 0x89, 0x6f,
 0x32, 0x0b, 0xdc, 0x80, 0x2f, 0xfb, 0xf4, 0x9c, 0x39, 0x32, 0xe1, 0xf7, 0x89, 0xd8, 0xd9, 0x56,
 0xd7, 0xe5, 0x15, 0x29, 0xbc, 0x50, 0x46, 0x49, 0x12, 0x6b, 0x35, 0x42, 0x44, 0x92, 0x08, 0xff,
 0x00, 0x21, 0xc2, 0xad, 0x3e, 0x52, 0x05, 0xee, 0x46, 0x6f, 0x32, 0x00, 0xd4, 0x29, 0x2c, 0x65,
 0x77, 0xbf, 0x0f, 0x4f, 0x49, 0xfd, 0x83, 0x7e, 0x5d, 0x28, 0x61, 0x97, 0x52, 0xec, 0x53, 0xdd,
 0xf9, 0xa7, 0x79, 0x20, 0x8a, 0x89, 0xf9, 0x7a, 0x88, 0xaf, 0x32, 0x0b, 0xcc, 0x80, 0x18, 0xef,
 0x72, 0x2a, 0x27, 0x30, 0x45, 0x31, 0x8a, 0x4b, 0xf7, 0x3d, 0xd6, 0xca, 0x09, 0x34, 0xd8, 0xaf,
 0x33, 0x3e, 0xb9, 0x1a, 0x97, 0x99, 0x18, 0xbd, 0xc8, 0x03, 0x72, 0x02, 0x5e, 0xc3, 0x10, 0x8f,
 0xc3, 0x44, 0x39, 0xdf, 0xa1, 0xd5, 0x12, 0xbd, 0xee, 0xc9, 0xa4, 0xc8, 0xb8, 0x90, 0xd0, 0x7e,
 0x46, 0xad, 0xb3, 0xee, 0x23, 0x13, 0xb1, 0xc8, 0x96, 0x9d, 0xe5, 0xea, 0x12, 0x5e, 0x64, 0x62,
 0xf3, 0x20, 0x0d, 0x89, 0x5c, 0xad, 0x88, 0x57, 0x92, 0xfb, 0xee, 0xf7, 0xee, 0x24, 0xea, 0x92,
 0x22, 0xa2, 0x48, 0xfa, 0xe4, 0x4d, 0x36, 0x80, 0x86, 0x8f, 0x59, 0xbc, 0x95, 0x9b, 0x2f, 0x1f,
 0x15, 0x11, 0x54, 0x95, 0xe9, 0x2f, 0xe2, 0x34, 0xaf, 0x72, 0x0b, 0xcc, 0x80, 0x21, 0x4c, 0x8d,
 0xed, 0xaf, 0x14, 0x63, 0x44, 0x9c, 0x24, 0xea, 0x2f, 0x25, 0x6d, 0x43, 0xcb, 0x99, 0x34, 0x33,
 0x53, 0x52, 0xbd, 0xfa, 0xd5, 0xc5, 0x42, 0xa6, 0xf7, 0x77, 0x11, 0x8b, 0xdc, 0x80, 0x18, 0xef,
 0x72, 0x34, 0x66, 0xac, 0x43, 0x4c, 0x50, 0x5d, 0xed, 0x52, 0xe2, 0x4a, 0x89, 0x71, 0x3c, 0x4b,
 0x19, 0x21, 0x56, 0x51, 0x99, 0x18, 0xbd, 0xc8, 0x03, 0x5d, 0xc9, 0x24, 0x51, 0x2b, 0xf1, 0x71,
 0x2c, 0x29, 0x3d, 0x4e, 0xa4, 0x63, 0x62, 0x0e, 0x48, 0x94, 0xac, 0x95, 0x17, 0x12, 0x4b, 0x22,
 0xfc, 0x86, 0xca, 0x95, 0xf9, 0x41, 0x7b, 0x91, 0x9b, 0xcc, 0x80, 0x18, 0x1a, 0x88, 0x6d, 0xa6,
 0xd2, 0xdb, 0x49, 0x24, 0x21, 0x25, 0x44, 0xa4, 0xb8, 0x11, 0x0f, 0xab, 0xdc, 0x85, 0xcb, 0xdc,
 0x82, 0xf7, 0x20, 0x06, 0x3b, 0xdc, 0x82, 0xf7, 0x21, 0x76, 0xf3, 0x23, 0x05, 0x19, 0x90, 0x07,
 0xc6, 0xab, 0x44, 0x53, 0xd1, 0x77, 0x6d, 0xb6, 0x6b, 0x68, 0x9b, 0x22, 0x33, 0x4e, 0xf3, 0x2a,
 0x57, 0x90, 0xa8, 0x86, 0x9c, 0x44, 0x31, 0x0a, 0xf4, 0x2a, 0x5c, 0xda, 0x65, 0xd4, 0x1a, 0x4d,
 0x06, 0x7b, 0x8a, 0xbc, 0xcb, 0xa0, 0xbb, 0xbc, 0xc8, 0xa3, 0x9f, 0x42, 0xb6, 0xe2, 0x15, 0x15,
 0x0c, 0x44, 0x97, 0x0b, 0x7a, 0xd2, 0x5c, 0x14, 0x5d, 0x7d, 0x20, 0x0d, 0x72, 0x8a, 0xde, 0x5b,
 0xf9, 0x8e, 0x8c, 0x51, 0xbb, 0x8b, 0x78, 0xe3, 0xe5, 0x13, 0xbc, 0xb7, 0x87, 0xd2, 0x8c, 0xdc,
 0x5b, 0xc0, 0x0c, 0x77, 0xb9, 0x05, 0xe6, 0x42, 0xe5, 0xee, 0x41, 0x7b, 0x90, 0x03, 0x1d, 0xee,
 0x41, 0x7b, 0x90, 0xb9, 0x7b, 0x90, 0x5e, 0xe4, 0x00, 0xbb, 0x79, 0x91, 0x8b, 0xcc, 0x85, 0xdb,
 0xdc, 0x82, 0xf3, 0x20, 0x06, 0x2b, 0xcc, 0x82, 0xf3, 0x21, 0x76, 0xf3, 0x20, 0xbc, 0xc8, 0x02,
 0xe1, 0x6d, 0x41, 0x2d, 0x6a, 0x5a, 0xe1, 0xd0, 0x6a, 0x51, 0xd4, 0xce, 0xa7, 0xbc, 0xc6, 0x3b,
 0x88, 0x0f, 0xcd, 0x9b, 0xf5, 0x98, 0xa8, 0xbc, 0xc8, 0x2f, 0x32, 0x00, 0xb7, 0xee, 0x20, 0x3f,
 0x36, 0x47, 0xac, 0xc1, 0xdc, 0x40, 0x7e, 0x6c, 0xdf, 0xac, 0xc5, 0x45, 0xe6, 0x41, 0x79, 0x90,
 0x03, 0x03, 0x2f, 0xb6, 0xcb, 0x64, 0xdb, 0x44, 0x48, 0x42, 0x78, 0x11, 0x72, 0x1f, 0x57, 0x99,
 0x0b, 0xb7, 0x99, 0x05, 0xe6, 0x40, 0x0c, 0x77, 0x87, 0xd4, 0x17, 0x87, 0xd7, 0xe9, 0x0b, 0x97,
 0xb9, 0x05, 0xee, 0x40, 0x0c, 0x77, 0x99, 0x18, 0xbc, 0xc8, 0x5d, 0xbc, 0xc8, 0x2f, 0x32, 0x00,
 0x62, 0xbc, 0xc8, 0xcd, 0xe6, 0x42, 0xe5, 0xe6, 0x41, 0x79, 0x90, 0x03, 0x1d, 0xe6, 0x41, 0x79,
 0x90, 0xb9, 0x79, 0x90, 0x5e, 0x64, 0x00, 0xc7, 0x78, 0x7d, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x90,
 0x5e, 0x64, 0x00, 0xc7, 0x79, 0x90, 0x5e, 0x1f, 0x50, 0xb9, 0x79, 0x90, 0x5e, 0x64, 0x00, 0xc7,
 0x79, 0x90, 0x5e, 0x64, 0x2e, 0x5e, 0x64, 0x17, 0x99, 0x00, 0x31, 0xde, 0x64, 0x62, 0xf3, 0x21,
 0x76, 0xf3, 0x20, 0xbc, 0xc8, 0x01, 0x8e, 0xf3, 0x20, 0xbc, 0xc8, 0x5c, 0xbc, 0xc8, 0x2f, 0x32,
 0x00, 0x63, 0xbc, 0x3e, 0xa3, 0x17, 0x99, 0x0b, 0xb7, 0x99, 0x05, 0xe6, 0x40, 0x0c, 0x77, 0x99,
 0x18, 0xbc, 0xc8, 0x5d, 0xbc, 0xc8, 0x2f, 0x32, 0x00, 0x63, 0xbc, 0xc8, 0x2f, 0x32, 0x17, 0x2f,
 0x72, 0x0b, 0xcc, 0x80, 0x2d, 0xfb, 0x88, 0x0a, 0xd6, 0xd9, 0xbf, 0x59, 0xfd, 0xa3, 0x6e, 0xf3,
 0x21, 0x76, 0xf3, 0x20, 0xbc, 0xc8, 0x01, 0x8a, 0xf3, 0x20, 0xbc, 0xc8, 0x5d, 0xbc, 0xc8, 0x2f,
 0x32, 0x00, 0x63, 0xbc, 0x3e, 0xa3, 0x17, 0x99, 0x0b, 0xb7, 0xb9, 0x05, 0xe6, 0x40, 0x0b, 0x97,
 0xb9, 0x05, 0xe6, 0x42, 0xed, 0xe1, 0xf5, 0x05, 0xe6, 0x40, 0x0c, 0x57, 0xb9, 0x05, 0xe6, 0x42,
 0xe5, 0xe6, 0x41, 0x79, 0x90, 0x03, 0x1d, 0xee, 0x41, 0x7b, 0x90, 0xbb, 0x78, 0x7d, 0x46, 0x2f,
 0x0f, 0xa8, 0x01, 0x8e, 0xf7, 0x20, 0xbc, 0xc8, 0x5d, 0xbc, 0xc8, 0xc5, 0xe6, 0x40, 0x0c, 0x77,
 0xb9, 0x05, 0xe6, 0x42, 0xe5, 0xe6, 0x46, 0x6f, 0x32, 0x00, 0x62, 0xbd, 0xc9, 0x82, 0xf3, 0x21,
 0x72, 0xf3, 0x20, 0xbc, 0xc8, 0x01, 0x8e, 0xf3, 0x20, 0xbd, 0xc8, 0x5d, 0xbc, 0x3e, 0xa0, 0xbc,
 0xc8, 0x01, 0x8a, 0xf7, 0x20, 0xbc, 0xc8, 0x5d, 0xbc, 0x3e, 0xa0, 0xbc, 0xcf, 0xd2, 0x00, 0x62,
 0xbd, 0xc8, 0x2f, 0x32, 0x17, 0x2f, 0x32, 0x33, 0x79, 0x90, 0x03, 0x15, 0xee, 0x41, 0x7b, 0x90,
 0xbb, 0x78, 0x7d, 0x7e, 0x90, 0x5e, 0x1f, 0x5f, 0xa4, 0x00, 0xc5, 0x7b, 0x90, 0x5e, 0xe4, 0x2e,
 0xde, 0x1f, 0x5f, 0xa4, 0x62, 0xf3, 0x20, 0x06, 0x3b, 0xdc, 0x82, 0xf3, 0x21, 0x72, 0xf3, 0x23,
 0x37, 0x99, 0x00, 0x31, 0x5e, 0x64, 0x17, 0x99, 0x0b, 0x97, 0x99, 0x19, 0xbc, 0xc8, 0x01, 0x8a,
 0xf7, 0x20, 0xbc, 0xc8, 0x5c, 0xbd, 0xc8, 0x2f, 0x32, 0x00, 0x63, 0xbd, 0xc8, 0x2f, 0x72, 0x17,
 0x2f, 0x72, 0x33, 0x78, 0x7d, 0x7e, 0x90, 0x03, 0x15, 0xee, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x90,
 0x5e, 0x64, 0x00, 0xc7, 0x7b, 0x90, 0x5e, 0xe4, 0x2e, 0x5e, 0x64, 0x17, 0x99, 0x00, 0x31, 0xde,
 0x64, 0x17, 0xb9, 0x0b, 0xb7, 0x87, 0xd4, 0x17, 0x99, 0x00, 0x31, 0x5e, 0xe4, 0x17, 0x99, 0x0b,
 0x97, 0x99, 0x05, 0xe6, 0x40, 0x0c, 0x77, 0x99, 0x05, 0xe6, 0x42, 0xe5, 0xe6, 0x41, 0x79, 0x90,
 0x02, 0xed, 0xe6, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x90, 0x5e, 0x64, 0x00, 0xc7, 0x79, 0x90, 0x5e,
 0x64, 0x2e, 0x5e, 0x64, 0x17, 0x99, 0x00, 0x31, 0xde, 0x64, 0x17, 0x99, 0x0b, 0x97, 0xb9, 0x05,
 0xe1, 0x75, 0x00, 0x31, 0xde, 0xe4, 0x17, 0x99, 0x0b, 0x97, 0x99, 0x05, 0xe6, 0x40, 0x0c, 0x77,
 0x99, 0x05, 0xe6, 0x42, 0xe5, 0xee, 0x41, 0x7b, 0x90, 0x03, 0x1d, 0xe6, 0x41, 0x79, 0x90, 0xb9,
 0x79, 0x90, 0x5e, 0xe4, 0x00, 0xc7, 0x79, 0x90, 0x5e, 0x64, 0x2e, 0x5e, 0x64, 0x17, 0x99, 0x00,
 0x31, 0xde, 0x64, 0x17, 0x99, 0x0b, 0x97, 0x99, 0x05, 0xe6, 0x4c, 0x00, 0xc7, 0x79, 0x90, 0x5e,
 0x64, 0x2e, 0x5e, 0xe4, 0x17, 0xb9, 0x30, 0x03, 0x1d, 0xe6, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x93,
 0x05, 0xe6, 0x40, 0x0c, 0x77, 0x99, 0x05, 0xe6, 0x42, 0xe5, 0xe6, 0x41, 0x79, 0x90, 0x03, 0x1d,
 0xe6, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x90, 0x5e, 0x64, 0x00, 0xc5, 0x79, 0x91, 0x9b, 0xcc, 0x85,
 0xcb, 0xcf, 0xd6, 0x05, 0xe6, 0x40, 0x0c, 0x57, 0x99, 0x19, 0xbc, 0xc8, 0x5c, 0xbc, 0xc9, 0x82,
 0xf3, 0x20, 0x06, 0x3b, 0xcc, 0x82, 0xf3, 0x21, 0x72, 0xf7, 0x20, 0xbd, 0xc8, 0x01, 0x8e, 0xf3,
 0x20, 0xbc, 0xc8, 0x5c, 0xbd, 0xc8, 0x2f, 0x32, 0x00, 0x62, 0xbc, 0xc8, 0xcd, 0xe6, 0x42, 0xe5,
 0xe6, 0x41, 0x79, 0x90, 0x03, 0x1d, 0xe6, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x90, 0x5e, 0xe4, 0x00,
 0xc7, 0x79, 0x91, 0x8b, 0xcc, 0x85, 0xdb, 0xcc, 0x82, 0xf3, 0x20, 0x06, 0x2b, 0xcc, 0x8c, 0xde,
 0x64, 0x2e, 0x5e, 0xe4, 0x17, 0x9f, 0xac, 0x60, 0x0a, 0x7a, 0x9f, 0x53, 0x05, 0x4f, 0xa8, 0xc0,
 0x00, 0x19, 0xa9, 0xf5, 0x30, 0x54, 0xfa, 0x8c, 0x00, 0x01, 0x9a, 0x9f, 0x53, 0x05, 0x4f, 0xa9,
 0x8c, 0x00, 0x01, 0x9a, 0x9f, 0x53, 0x05, 0x4f, 0xa8, 0xc0, 0x00, 0x19, 0xa9, 0xf5, 0x30, 0x54,
 0xfa, 0x98, 0xc0, 0x00, 0x19, 0xa9, 0xf5, 0x30, 0x54, 0xfa, 0x98, 0xc0, 0x00, 0x19, 0xa9, 0xf5,
 0x30, 0x54, 0xfa, 0x98, 0xc0, 0x00, 0x19, 0xa9, 0xf5, 0x05, 0x4f, 0xa9, 0x8c, 0x00, 0x01, 0x9a,
 0x9f, 0x50, 0x54, 0xfa, 0x98, 0xc0, 0x00, 0x19, 0xa9, 0xf5, 0x30, 0x54, 0xfa, 0x98, 0xc0, 0x00,
 0x19, 0xa9, 0xf5, 0x30, 0x54, 0xfa, 0x98, 0xc0, 0x00, 0x19, 0xa9, 0xf5, 0x05, 0x4f, 0xa9, 0x8c,
 0x00, 0x01, 0x9a, 0x9f, 0x53, 0x05, 0x4f, 0xa9, 0x8c, 0x00, 0x01, 0x9a, 0x9f, 0x53, 0x05, 0x4f,
 0xa9, 0x8c, 0x00, 0x01, 0x9a, 0x9f, 0x53, 0x05, 0x4f, 0xa9, 0x8c, 0x00, 0x01, 0x9a, 0x9f, 0x53,
 0x05, 0x4f, 0xa9, 0x8c, 0x00, 0x01, 0x9a, 0x9f, 0x50, 0x54, 0xfa, 0x98, 0xc0, 0x00, 0x19, 0xa9,
 0xf5, 0x30, 0x54, 0xfa, 0x98, 0xc0, 0x00, 0x19, 0xa9, 0xf5, 0x05, 0x4f, 0xa8, 0xc0, 0x00, 0x19,
 0xa9, 0xf5, 0x30, 0x54, 0xfa, 0x98, 0xc0, 0x00, 0x00, 0x04, 0xb6, 0xef, 0xf9, 0x97, 0x3d, 0x83,
 0x05, 0xbb, 0xfe, 0x65, 0xcf, 0x60, 0xc7, 0x99, 0x47, 0x9b, 0x91, 0x10, 0x04, 0xb6, 0xef, 0xf9,
 0x97, 0x3d, 0x83, 0x05, 0xbb, 0xfe, 0x65, 0xcf, 0x60, 0xc3, 0x28, 0x6e, 0x44, 0x40, 0x12, 0xdb,
 0xbf, 0xe6, 0x5c, 0xf6, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3d, 0x83, 0x0c, 0xa1, 0xb9, 0x11, 0x00,
 0x4b, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xd8, 0x30, 0x5b, 0xbf, 0xe6, 0x5c, 0xf6, 0x0c, 0x32, 0x86,
 0xe4, 0x44, 0x01, 0x2d, 0xbb, 0xfe, 0x65, 0xcf, 0x60, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xd8,
 0x30, 0xca, 0x1b, 0x91, 0x10, 0x04, 0xb6, 0xef, 0xf9, 0x97, 0x3d, 0x83, 0x05, 0xbb, 0xfe, 0x65,
 0xcf, 0x60, 0xc3, 0x28, 0x6e, 0x44, 0x40, 0x12, 0xdb, 0xbf, 0xe6, 0x5c, 0xf6, 0x0c, 0x16, 0xef,
 0xf9, 0x97, 0x3d, 0x83, 0x0c, 0xa1, 0xb9, 0x11, 0x00, 0x4b, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xd8,
 0x30, 0x5b, 0xbf, 0xe6, 0x5c, 0xf6, 0x0c, 0x32, 0x86, 0xe4, 0x44, 0x01, 0x2d, 0xbb, 0xfe, 0x65,
 0xcf, 0x60, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xd8, 0x30, 0xca, 0x1b, 0x91, 0x10, 0x04, 0xb6,
 0xef, 0xf9, 0x97, 0x3d, 0x83, 0x05, 0xbb, 0xfe, 0x65, 0xcf, 0x60, 0xc3, 0x28, 0x6e, 0x44, 0x40,
 0x12, 0xdb, 0xbf, 0xe6, 0x5c, 0xf6, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3d, 0x83, 0x0c, 0xa1, 0xb9,
 0x11, 0x00, 0x4b, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xd8, 0x30, 0x5b, 0xbf, 0xe6, 0x5c, 0xf6, 0x0c,
 0x32, 0x86, 0xe4, 0x44, 0x01, 0x2d, 0xbb, 0xfe, 0x65, 0xcf, 0x60, 0xc1, 0x6e, 0xff, 0x00, 0x99,
 0x73, 0xd8, 0x30, 0xca, 0x1b, 0x91, 0x10, 0x04, 0xb6, 0xef, 0xf9, 0x97, 0x3d, 0x83, 0x05, 0xbb,
 0xfe, 0x65, 0xcf, 0x60, 0xc3, 0x28, 0x6e, 0x44, 0x40, 0x12, 0xdb, 0xbf, 0xe6, 0x5c, 0xf6, 0x0c,
 0x16, 0xef, 0xf9, 0x97, 0x3d, 0x83, 0x0c, 0xa1, 0xb9, 0x11, 0x00, 0x4b, 0x6e, 0xff, 0x00, 0x99,
 0x73, 0xd8, 0x30, 0x5b, 0xbf, 0xe6, 0x5c, 0xf6, 0x0c, 0x32, 0x86, 0xe4, 0x44, 0x01, 0x2d, 0xbb,
 0xfe, 0x65, 0xcf, 0x60, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xd8, 0x30, 0xca, 0x1b, 0x91, 0x10,
 0x04, 0xb6, 0xef, 0xf9, 0x97, 0x3d, 0x83, 0x05, 0xbb, 0xfe, 0x65, 0xcf, 0x60, 0xc3, 0x28, 0x6e,
 0x44, 0x40, 0x12, 0xdb, 0xbf, 0xe6, 0x5c, 0xf6, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3d, 0x83, 0x0c,
 0xa1, 0xb9, 0x11, 0x00, 0x4b, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xd8, 0x30, 0x5b, 0x44, 0x79, 0x87,
 0x7d, 0x83, 0x0c, 0xa1, 0xb9, 0x1f, 0xff, 0xd9};
static const unsigned char PIC_640x480_1[] = { 
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x17, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
 0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65, 0x20, 0x47, 0x49, 0x4d, 0x50, 0xff, 0xe1, 0x00,
 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x05, 0x03, 0x04, 0x04, 0x04, 0x03,
 0x05, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0c, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0f,
 0x0b, 0x0b, 0x09, 0x0c, 0x11, 0x0f, 0x12, 0x12, 0x11, 0x0f, 0x11, 0x11, 0x13, 0x16, 0x1c, 0x17,
 0x13, 0x14, 0x1a, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1a, 0x1d, 0x1d, 0x1f, 0x1f, 0x1f, 0x13,
 0x17, 0x22, 0x24, 0x22, 0x1e, 0x24, 0x1c, 0x1e, 0x1f, 0x1e, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x05,
 0x05, 0x05, 0x07, 0x06, 0x07, 0x0e, 0x08, 0x08, 0x0e, 0x1e, 0x14, 0x11, 0x14, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0xff,
 0xc0, 0x00, 0x11, 0x08, 0x01, 0xe0, 0x02, 0x80, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03,
 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1d, 0x00, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x02, 0x04, 0x03, 0x06, 0x07, 0x01, 0x08,
 0x09, 0xff, 0xc4, 0x00, 0x5e, 0x10, 0x00, 0x01, 0x02, 0x04, 0x03, 0x04, 0x04, 0x05, 0x0f, 0x05,
 0x09, 0x0f, 0x03, 0x05, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x13, 0x61, 0x05, 0x06, 0x11,
 0x07, 0x12, 0x21, 0x31, 0x41, 0x51, 0x93, 0xd1, 0x08, 0x15, 0x22, 0x54, 0x71, 0x14, 0x16, 0x17,
 0x32, 0x43, 0x52, 0x56, 0x81, 0x91, 0xa1, 0xb1, 0xb2, 0xb3, 0xc1, 0xe1, 0x25, 0x42, 0x72, 0x92,
 0x94, 0x26, 0x33, 0x46, 0x62, 0x63, 0x64, 0x73, 0x82, 0xb4, 0x23, 0x24, 0x34, 0x44, 0x53, 0x55,
 0x65, 0x74, 0x84, 0xa2, 0xa3, 0xc2, 0xd2, 0xd3, 0xf0, 0x09, 0x36, 0x45, 0x35, 0x75, 0x83, 0x85,
 0x95, 0xff, 0xc4, 0x00, 0x1c, 0x01, 0x01, 0x01, 0x00, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0xff,
 0xc4, 0x00, 0x39, 0x11, 0x01, 0x00, 0x02, 0x02, 0x01, 0x02, 0x03, 0x07, 0x00, 0x07, 0x07, 0x05,
 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x12, 0x51, 0x05, 0x21, 0x91, 0x06,
 0x13, 0x14, 0x31, 0x41, 0x52, 0x71, 0x22, 0x33, 0x61, 0x81, 0xa1, 0xb1, 0xc1, 0x23, 0x24, 0x32,
 0x42, 0x72, 0xe1, 0xf0, 0x15, 0x16, 0x53, 0x62, 0xd1, 0x43, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01,
 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xe7, 0xca, 0xd2, 0x2a, 0xd2, 0xca, 0xb4, 0xc6,
 0xe6, 0x9f, 0x45, 0x89, 0x7c, 0xca, 0x25, 0x5d, 0x58, 0x45, 0xcd, 0x2c, 0xab, 0x48, 0x2b, 0x4c,
 0xed, 0x51, 0x65, 0x65, 0x69, 0x15, 0x69, 0x61, 0x5a, 0x45, 0xcd, 0x2a, 0x25, 0x7b, 0x56, 0x56,
 0x11, 0x73, 0x4b, 0x0a, 0xd2, 0x2a, 0xd2, 0xb6, 0xcc, 0x4a, 0xb2, 0xb4, 0x82, 0xb4, 0xb2, 0xac,
 0x20, 0xe6, 0x17, 0x16, 0x5c, 0x4a, 0xba, 0xb4, 0x83, 0x9a, 0x59, 0x56, 0x10, 0x56, 0x99, 0xda,
 0xa2, 0xca, 0xea, 0xd2, 0x0a, 0xd2, 0xca, 0xb4, 0x82, 0xb0, 0xb8, 0x95, 0x75, 0x2b, 0xab, 0x08,
 0xb9, 0xa5, 0x85, 0x6f, 0x12, 0x0a, 0xd3, 0x31, 0x2a, 0x89, 0x57, 0xdd, 0x22, 0xad, 0x2c, 0x2b,
 0x48, 0x2b, 0x4b, 0x8b, 0x2e, 0x2c, 0xae, 0xad, 0x22, 0xad, 0x2c, 0x6e, 0xf1, 0x20, 0xe6, 0x99,
 0xda, 0xa2, 0xca, 0xea, 0xd2, 0x2a, 0xd2, 0xc2, 0xb4, 0x82, 0xb4, 0xa8, 0x95, 0x6d, 0x5d, 0x5a,
 0x41, 0x5a, 0x58, 0x56, 0x91, 0x56, 0x95, 0xb5, 0x45, 0x95, 0xd5, 0xa4, 0x15, 0xa5, 0x95, 0x69,
 0x05, 0x69, 0x71, 0x65, 0x44, 0xab, 0xab, 0x48, 0x39, 0xa5, 0x95, 0x69, 0x15, 0x69, 0x9d, 0xaa,
 0x25, 0x55, 0x5a, 0x45, 0x5a, 0x59, 0x56, 0x91, 0x73, 0x4b, 0xda, 0xa2, 0x55, 0x95, 0xa4, 0x55,
 0xbd, 0x45, 0x85, 0x69, 0x05, 0x61, 0x9d, 0xab, 0x6a, 0xea, 0xd2, 0x2a, 0x9a, 0x16, 0x15, 0xa4,
 0x15, 0xa5, 0xc4, 0xaa, 0x25, 0x88, 0x09, 0xb9, 0xa4, 0x74, 0x33, 0xb6, 0x5e, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x01, 0xd7, 0x9c, 0xd2, 0x2a, 0xd2, 0xd3, 0x99, 0xa1, 0x8d, 0xcd, 0x3c, 0xcc,
 0x59, 0xe5, 0xe2, 0x55, 0xd5, 0x84, 0x15, 0xa5, 0x85, 0x69, 0x05, 0x69, 0x5b, 0x54, 0x4a, 0xba,
 0xb4, 0x82, 0xb4, 0xb4, 0xad, 0x31, 0xb9, 0xa6, 0x62, 0x55, 0x16, 0x57, 0x56, 0x91, 0x56, 0x96,
 0x15, 0x84, 0x15, 0xa5, 0x6d, 0x7b, 0x57, 0x56, 0x90, 0x73, 0x4b, 0x2a, 0xd2, 0x0a, 0xd2, 0xe2,
 0x55, 0x12, 0xc0, 0xac, 0x42, 0x0a, 0xd2, 0xc2, 0xb4, 0x83, 0x9a, 0x67, 0x6a, 0x89, 0x57, 0x56,
 0x91, 0x56, 0x96, 0x15, 0x08, 0x39, 0xa5, 0x44, 0xab, 0x6c, 0x0a, 0xd2, 0x0a, 0xd2, 0xc2, 0xb4,
 0x83, 0x9a, 0x54, 0x59, 0x51, 0x65, 0x75, 0x69, 0x05, 0x69, 0x65, 0x5a, 0x41, 0xcd, 0x2a, 0x25,
 0x51, 0x2a, 0xea, 0xde, 0x24, 0x55, 0xa5, 0x85, 0x69, 0x05, 0x69, 0x5b, 0x54, 0x4a, 0xba, 0xb0,
 0x82, 0xb4, 0xb2, 0xad, 0x20, 0xad, 0x2a, 0x25, 0x71, 0x65, 0x75, 0x69, 0x07, 0x34, 0xb2, 0xad,
 0x20, 0xad, 0x2b, 0x6c, 0xed, 0x5d, 0x59, 0xa1, 0x05, 0x69, 0x65, 0x5a, 0x45, 0x5a, 0x5c, 0x4a,
 0xba, 0x95, 0x95, 0xa4, 0x55, 0xa5, 0x85, 0x69, 0x07, 0x34, 0xce, 0xd7, 0xb5, 0x75, 0x69, 0x05,
 0x69, 0x65, 0x5a, 0x45, 0x5a, 0x5c, 0x59, 0x51, 0x2a, 0xca, 0xd2, 0x0a, 0xd2, 0xca, 0xb4, 0x8a,
 0xb4, 0xce, 0xd5, 0x12, 0xac, 0xac, 0x20, 0xad, 0x2c, 0xab, 0x48, 0x2b, 0x4a, 0x89, 0x54, 0x4a,
 0xba, 0xb4, 0x8a, 0xb4, 0xb0, 0xad, 0x20, 0xad, 0x2b, 0x6a, 0x89, 0x57, 0x56, 0x91, 0x56, 0x96,
 0x15, 0xba, 0x10, 0x56, 0x95, 0x12, 0xae, 0xa6, 0x05, 0x4d, 0x00, 0xca, 0xad, 0x20, 0xad, 0x2b,
 0x6a, 0x89, 0x44, 0x03, 0x40, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xba, 0x3e, 0x09, 0x81, 0xf0, 0x93, 0xa8, 0x6a, 0xe8, 0x46,
 0x18, 0x90, 0x6c, 0x78, 0xf8, 0xbb, 0xc6, 0xd6, 0xe5, 0x4e, 0x87, 0x63, 0x1b, 0x98, 0x32, 0x7c,
 0x1b, 0x18, 0x5f, 0x04, 0xdb, 0x17, 0x6d, 0x8b, 0xa8, 0x2b, 0x48, 0x2b, 0x4b, 0xae, 0x84, 0x62,
 0x74, 0x35, 0x42, 0xe2, 0xcd, 0x91, 0x65, 0x65, 0x69, 0x05, 0x69, 0x65, 0xcd, 0x31, 0xb9, 0xa5,
 0xc4, 0xaa, 0x25, 0x81, 0xcd, 0x20, 0xad, 0x2c, 0x39, 0xa4, 0x55, 0xa5, 0x6d, 0x71, 0x2a, 0xca,
 0xd2, 0x0a, 0xd2, 0xd3, 0x9a, 0x41, 0x5a, 0x54, 0x4a, 0xba, 0x95, 0x95, 0xa4, 0x55, 0xa5, 0x85,
 0x69, 0x07, 0x34, 0xad, 0xaa, 0x25, 0x5d, 0x5a, 0x41, 0x5a, 0x5a, 0x56, 0x90, 0x56, 0x95, 0x12,
 0xa8, 0x95, 0x75, 0x69, 0x8d, 0x5a, 0x59, 0x56, 0x90, 0x73, 0x4a, 0xda, 0xa2, 0x55, 0xd5, 0xa4,
 0x55, 0xa5, 0x85, 0x61, 0x17, 0x34, 0xcc, 0x59, 0x51, 0x65, 0x65, 0x69, 0x07, 0x34, 0xb2, 0xad,
 0x22, 0xad, 0x2f, 0x6a, 0x8b, 0x2b, 0x2b, 0x48, 0xab, 0x4b, 0x0a, 0xce, 0x24, 0x1c, 0xd2, 0xa2,
 0x57, 0x12, 0xae, 0xac, 0x20, 0xe6, 0x96, 0x55, 0xa4, 0x15, 0xa5, 0x6d, 0x5b, 0x57, 0x56, 0x91,
 0x56, 0x96, 0x1c, 0xc2, 0x0a, 0xc2, 0xa2, 0xca, 0x8b, 0x2b, 0xab, 0x48, 0x39, 0xa5, 0x95, 0x69,
 0x17, 0x34, 0xcc, 0x4a, 0xa2, 0x55, 0x95, 0xa4, 0x15, 0xa5, 0x95, 0x69, 0x07, 0x34, 0xb8, 0xb2,
 0xb6, 0xae, 0xad, 0x20, 0xad, 0x2c, 0x2b, 0x48, 0xab, 0x4a, 0xda, 0xa2, 0x55, 0xd5, 0xa4, 0x55,
 0xa5, 0x85, 0x69, 0x07, 0x34, 0xa8, 0x95, 0x44, 0xab, 0xab, 0x48, 0x39, 0xa5, 0x95, 0x69, 0x05,
 0x69, 0x5b, 0x5c, 0x59, 0x5d, 0x5a, 0x41, 0x5a, 0x59, 0x56, 0x90, 0x56, 0x95, 0x12, 0xce, 0xd5,
 0xd5, 0xbc, 0x48, 0x39, 0xa5, 0x95, 0x69, 0x15, 0x69, 0x5b, 0x5e, 0xd5, 0x95, 0xa7, 0x86, 0x75,
 0x69, 0x05, 0x69, 0x98, 0x96, 0x62, 0x58, 0xc0, 0x92, 0xb4, 0xf1, 0x51, 0x50, 0xa6, 0x5e, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x48, 0xbe, 0x12, 0x75, 0x18, 0x5f,
 0x08, 0x6a, 0xf8, 0x56, 0x30, 0x3e, 0x09, 0xe0, 0xe3, 0x23, 0xc0, 0xc6, 0x42, 0xa7, 0xc2, 0xb1,
 0x89, 0xf0, 0xac, 0x34, 0x7c, 0x2b, 0x18, 0x5f, 0x04, 0xdb, 0x5b, 0xb6, 0xd6, 0xe5, 0x4f, 0x85,
 0x63, 0x0b, 0xe1, 0x58, 0x6a, 0xf8, 0x5a, 0xf4, 0x18, 0x5f, 0x0a, 0xc6, 0xd8, 0xbb, 0x6c, 0x5c,
 0xa9, 0xd0, 0xac, 0x62, 0x74, 0x3d, 0x3a, 0x06, 0x8f, 0x83, 0x63, 0x03, 0xe0, 0xd8, 0xdb, 0x5b,
 0xb6, 0xd6, 0xe5, 0xce, 0x69, 0x07, 0x34, 0xbc, 0xf8, 0x56, 0x30, 0xbe, 0x12, 0x9b, 0x22, 0xcd,
 0xb1, 0x75, 0x45, 0x69, 0x15, 0x69, 0x65, 0xcc, 0x52, 0x0a, 0xc2, 0xe2, 0xca, 0x89, 0x57, 0x73,
 0x48, 0x2b, 0x4b, 0x0a, 0xd2, 0x2a, 0xd2, 0xb6, 0xb8, 0x95, 0x77, 0x34, 0xc6, 0xad, 0x2d, 0x2b,
 0x48, 0x2b, 0x4a, 0x8b, 0x2a, 0x2c, 0xac, 0xad, 0x20, 0xe6, 0x96, 0x5c, 0xd2, 0x2a, 0xd2, 0xb6,
 0xad, 0xab, 0x2b, 0x48, 0xab, 0x4b, 0x0a, 0xd2, 0x2e, 0x69, 0x9d, 0xaa, 0x25, 0x5d, 0xcd, 0x31,
 0xb9, 0xa5, 0x95, 0x69, 0x15, 0x69, 0x7b, 0x56, 0xd5, 0x95, 0xa4, 0x1c, 0xd2, 0xd2, 0xb4, 0xc6,
 0xad, 0x33, 0xb5, 0x45, 0x95, 0xd5, 0xa4, 0x15, 0xa5, 0x95, 0x69, 0x07, 0x34, 0xae, 0xa5, 0xf5,
 0x2b, 0xab, 0x48, 0x2b, 0x4b, 0x2a, 0xd2, 0x2a, 0xd2, 0xf6, 0xcc, 0x4a, 0xb2, 0xb7, 0x52, 0x2a,
 0xd2, 0xc2, 0xb4, 0x82, 0xb4, 0xad, 0xae, 0x25, 0x5d, 0x5a, 0x45, 0x5a, 0x58, 0x56, 0x90, 0x73,
 0x4c, 0xc4, 0xaa, 0x2c, 0xae, 0xad, 0x22, 0xac, 0x33, 0xab, 0x48, 0xab, 0x4b, 0xda, 0xa2, 0xca,
 0xea, 0xd2, 0x2a, 0xd2, 0xc2, 0xb4, 0x83, 0x9a, 0x54, 0x59, 0x51, 0x2a, 0xea, 0xd2, 0x0e, 0x69,
 0x65, 0x5a, 0x41, 0x5a, 0x56, 0xd5, 0x12, 0xae, 0xac, 0x20, 0xad, 0x2c, 0xab, 0x78, 0x91, 0x73,
 0x4a, 0x8b, 0x2b, 0x6a, 0xca, 0xd2, 0x2a, 0xd2, 0xc2, 0xb0, 0x8b, 0x9a, 0x54, 0x4a, 0xe2, 0xca,
 0xaa, 0xd2, 0x2a, 0xd2, 0xca, 0xb4, 0x8a, 0xb4, 0xa8, 0x96, 0x76, 0xac, 0xad, 0x22, 0xad, 0x2c,
 0x2b, 0x48, 0x2b, 0x4a, 0x89, 0x57, 0x52, 0xba, 0xb4, 0x8a, 0xb4, 0xb0, 0xad, 0x20, 0xad, 0x2a,
 0x2c, 0xbd, 0xb0, 0x81, 0x91, 0x5a, 0x45, 0x5a, 0x67, 0x6c, 0xed, 0x10, 0x0d, 0x00, 0xc8, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0xfa, 0xbd, 0xf0, 0x4c, 0x2f, 0x83, 0x61, 0xab, 0xe1, 0x58, 0xc2, 0xf8, 0x36, 0x3e,
 0x6f, 0x17, 0x7c, 0xd2, 0xb7, 0x29, 0x7c, 0x2b, 0x18, 0x5f, 0x0a, 0xc3, 0x67, 0xc1, 0x30, 0xbe,
 0x11, 0xb6, 0xb7, 0x6d, 0x8c, 0x85, 0x31, 0x21, 0x70, 0x30, 0x3e, 0x15, 0x86, 0xcf, 0x84, 0xbd,
 0x46, 0x07, 0xc2, 0xb1, 0xb6, 0xb7, 0x6e, 0xae, 0x42, 0xa7, 0xc1, 0xb1, 0x85, 0xf0, 0x6c, 0x35,
 0x7c, 0x2b, 0x18, 0x5f, 0x0a, 0xc6, 0xd8, 0xbb, 0x6d, 0x72, 0x15, 0xbe, 0x15, 0x8c, 0x11, 0x21,
 0x58, 0x6a, 0xf8, 0x56, 0x30, 0xc4, 0x85, 0x63, 0x6c, 0x5d, 0xb6, 0x2e, 0x52, 0xf8, 0x56, 0x31,
 0x3e, 0x10, 0xd5, 0xf0, 0xac, 0x60, 0x7c, 0x2b, 0x1b, 0x6b, 0x76, 0xd8, 0xb9, 0x5b, 0xa1, 0xaa,
 0x18, 0xdc, 0xd1, 0x9b, 0xe1, 0x59, 0x0c, 0x0f, 0x85, 0x63, 0x6c, 0x5d, 0xb2, 0x2e, 0xa2, 0xad,
 0x20, 0xad, 0x2e, 0x3a, 0x1a, 0x98, 0x9c, 0xc2, 0xe2, 0xcd, 0x91, 0x65, 0x75, 0x69, 0x05, 0x69,
 0x61, 0xcc, 0x20, 0xad, 0x2e, 0x2c, 0xbe, 0xa6, 0x05, 0x69, 0x05, 0x69, 0x61, 0x5a, 0x45, 0xcd,
 0x33, 0xb5, 0x75, 0x2b, 0xb9, 0xa4, 0x15, 0xa5, 0x95, 0x69, 0x8d, 0xcc, 0x52, 0xa2, 0x57, 0x16,
 0x57, 0x56, 0x91, 0x56, 0x96, 0x15, 0xa4, 0x15, 0xa5, 0x44, 0xb3, 0x12, 0xc0, 0xad, 0x20, 0xad,
 0x2c, 0xb9, 0xa6, 0x37, 0x34, 0xa8, 0x95, 0x75, 0x2b, 0xab, 0x48, 0x2b, 0x4b, 0x2a, 0xd2, 0x0e,
 0x69, 0x51, 0x2b, 0x89, 0x57, 0x56, 0x90, 0x73, 0x4b, 0x2a, 0xc2, 0x0a, 0xd2, 0xa2, 0xcc, 0xc5,
 0x95, 0xd5, 0x84, 0x15, 0xa5, 0x95, 0x69, 0x15, 0x69, 0x51, 0x2b, 0x8b, 0x2b, 0x2b, 0x48, 0xab,
 0x4b, 0x0a, 0xd2, 0x0a, 0xd2, 0xa2, 0x55, 0x12, 0xae, 0xac, 0xd0, 0x82, 0xb4, 0xb2, 0xad, 0x22,
 0xad, 0x2b, 0x6a, 0x89, 0x56, 0x56, 0x91, 0x56, 0x96, 0x15, 0x84, 0x1c, 0xd2, 0xa2, 0x55, 0x16,
 0x57, 0x56, 0x90, 0x73, 0x4b, 0x2a, 0xd2, 0x2a, 0xd2, 0xa2, 0x55, 0xb5, 0x65, 0x69, 0x15, 0x69,
 0x61, 0x5a, 0x84, 0x15, 0x85, 0x45, 0x95, 0x16, 0x57, 0x56, 0x91, 0x56, 0x96, 0x15, 0xa4, 0x1c,
 0xd2, 0xb6, 0xb8, 0x95, 0x75, 0x6f, 0x12, 0x2e, 0x69, 0x61, 0x5a, 0x41, 0xcd, 0x2a, 0x25, 0x5b,
 0x57, 0x56, 0x90, 0x56, 0xf0, 0x2c, 0xab, 0x48, 0xb9, 0xa5, 0x6d, 0x5b, 0x55, 0x56, 0x91, 0x56,
 0x96, 0x55, 0xa4, 0x15, 0xa5, 0x44, 0xaa, 0x25, 0x5d, 0x5a, 0x41, 0x5a, 0x59, 0x56, 0x90, 0x56,
 0x95, 0xb5, 0x44, 0xb0, 0x68, 0xa7, 0x86, 0x65, 0x69, 0x15, 0x69, 0x51, 0x2a, 0xdb, 0x18, 0x1e,
 0xaa, 0x1e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x1f, 0x67, 0xc5, 0x97, 0x5e, 0xa2, 0xbb, 0xe0, 0xd8, 0x7f, 0x12, 0x5f, 0x4e, 0x82, 0xac,
 0x59, 0x7b, 0x1f, 0x2a, 0xae, 0x47, 0xce, 0xaf, 0xc5, 0x98, 0xf9, 0x12, 0x3e, 0x15, 0x8c, 0x0f,
 0x85, 0x61, 0xcc, 0x48, 0x16, 0x2b, 0xc4, 0x82, 0xa9, 0xd0, 0x6e, 0xae, 0x47, 0x1e, 0x62, 0xd5,
 0xf9, 0x94, 0x3e, 0x0d, 0x8c, 0x0f, 0x83, 0x61, 0xb3, 0xe0, 0xd8, 0xc2, 0xf8, 0x4b, 0xd4, 0x6d,
 0xad, 0xca, 0xdc, 0xa5, 0xf0, 0x6c, 0x61, 0x7c, 0x21, 0xb3, 0xe1, 0x58, 0xc0, 0xf8, 0x26, 0xd8,
 0xbb, 0x6c, 0x64, 0x2a, 0x7c, 0x24, 0xea, 0x30, 0x3e, 0x15, 0x86, 0xcf, 0x85, 0x63, 0x03, 0xe1,
 0x58, 0xdb, 0x5b, 0xb6, 0xd7, 0x21, 0x53, 0xe1, 0x58, 0xc2, 0xf8, 0x56, 0x1a, 0xbe, 0x15, 0x8c,
 0x2f, 0x84, 0x6d, 0x8b, 0xb7, 0x57, 0x21, 0x53, 0xe1, 0x58, 0xc2, 0xf8, 0x56, 0x51, 0xab, 0xe1,
 0x58, 0xc0, 0xf8, 0x56, 0x36, 0xc5, 0xdb, 0x62, 0xe5, 0x4f, 0x85, 0x63, 0x0b, 0xe1, 0x58, 0x6c,
 0xf8, 0x56, 0x30, 0xbe, 0x15, 0x8d, 0xb5, 0xbb, 0x6d, 0x6e, 0x54, 0xf8, 0x4b, 0xd4, 0x62, 0x74,
 0x35, 0x4e, 0x81, 0x9b, 0xe0, 0xd8, 0xc2, 0xf8, 0x56, 0x36, 0xc5, 0xdb, 0x62, 0xe5, 0xca, 0xdb,
 0x11, 0x56, 0x17, 0x5f, 0x08, 0xc2, 0xe8, 0x6a, 0x85, 0xc5, 0x9b, 0x22, 0xca, 0xaa, 0xd2, 0x2a,
 0xd2, 0xcb, 0x9b, 0xd6, 0x63, 0x73, 0x4b, 0x89, 0x5c, 0x4b, 0x03, 0x9a, 0x41, 0x5a, 0x59, 0x56,
 0x90, 0x73, 0x4a, 0x89, 0x54, 0x4a, 0xb2, 0xb4, 0x83, 0x9a, 0x5a, 0x73, 0x54, 0xc6, 0xad, 0x2b,
 0x6a, 0x89, 0x57, 0x56, 0x90, 0x56, 0x96, 0x95, 0xa4, 0x15, 0xa5, 0x44, 0xaf, 0x6a, 0xea, 0xd2,
 0x0a, 0xd2, 0xc2, 0xb4, 0x82, 0xb4, 0xad, 0xb3, 0x12, 0xae, 0xac, 0x20, 0xe6, 0x96, 0x5c, 0xd2,
 0x2a, 0xd2, 0xa2, 0x55, 0x12, 0xac, 0xad, 0x20, 0xad, 0x2c, 0xab, 0x48, 0x39, 0xa5, 0x75, 0x2e,
 0x2c, 0xae, 0xac, 0x20, 0xe6, 0x96, 0x55, 0xaa, 0x41, 0x5a, 0x57, 0x52, 0xa2, 0x55, 0xd5, 0xbc,
 0x48, 0x39, 0xa5, 0x95, 0x69, 0x05, 0x69, 0x5b, 0x54, 0x4a, 0xba, 0xb5, 0x08, 0xab, 0x4b, 0x0a,
 0xd2, 0x0a, 0xd2, 0xa2, 0x55, 0x12, 0xae, 0xad, 0xe2, 0x41, 0xcd, 0x2c, 0xab, 0x48, 0x2b, 0x4a,
 0x8b, 0x2a, 0x25, 0x5d, 0x5a, 0x41, 0x58, 0x59, 0x56, 0xf1, 0x20, 0xe6, 0x95, 0x12, 0xa8, 0x95,
 0x75, 0x69, 0x05, 0x69, 0x65, 0x5a, 0x41, 0x5a, 0x54, 0x4a, 0xe2, 0x55, 0xd5, 0xa4, 0x1c, 0xd4,
 0x2c, 0xab, 0x08, 0x2b, 0x4a, 0x89, 0x67, 0x6a, 0xea, 0xdb, 0x11, 0x56, 0x96, 0x15, 0xa4, 0x1c,
 0xd2, 0xa2, 0xcb, 0xda, 0xba, 0xb4, 0x83, 0x9a, 0x59, 0x56, 0x90, 0x56, 0x95, 0x12, 0xa8, 0xb2,
 0xba, 0xb0, 0x82, 0xb4, 0xb2, 0xad, 0x22, 0xe6, 0x95, 0x12, 0xad, 0xab, 0x2b, 0x48, 0x2b, 0x4b,
 0x2a, 0xd2, 0x0a, 0xc2, 0xa2, 0x59, 0x8b, 0x2b, 0xab, 0x54, 0xf1, 0x51, 0x50, 0xce, 0xad, 0x20,
 0xad, 0x2b, 0xa9, 0x7b, 0x62, 0x02, 0x6e, 0x69, 0x1d, 0x0c, 0xed, 0x97, 0x80, 0x00, 0x64, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xdf, 0xb1, 0x65, 0xac, 0x55, 0x89, 0x2f, 0x63, 0x67, 0x98,
 0x90, 0x54, 0x5e, 0x08, 0x51, 0x8d, 0x2a, 0xa9, 0xaf, 0x05, 0x3e, 0x35, 0x5c, 0xbb, 0x74, 0xb9,
 0xf8, 0x13, 0x1f, 0x38, 0x6b, 0xb1, 0x65, 0xec, 0x55, 0x89, 0x2f, 0x63, 0x61, 0x89, 0x2f, 0xc7,
 0x91, 0x56, 0x2c, 0xbd, 0x8d, 0xf5, 0xc8, 0xea, 0xf2, 0xf0, 0xda, 0xfc, 0x59, 0x7b, 0x15, 0x62,
 0x4b, 0xaf, 0x51, 0xb0, 0x44, 0x97, 0x4e, 0xa2, 0xb4, 0x49, 0x64, 0xea, 0x37, 0x57, 0x23, 0xae,
 0xc9, 0xc3, 0xd1, 0x0b, 0xe0, 0xd8, 0xc0, 0xf8, 0x36, 0x1e, 0x44, 0x97, 0xb1, 0x56, 0x2c, 0x0b,
 0x1b, 0xab, 0x91, 0xc3, 0xb6, 0x2b, 0x54, 0x9d, 0xf0, 0xac, 0x61, 0x7c, 0x21, 0xb3, 0xe0, 0xd8,
 0xc0, 0xf8, 0x2b, 0xd4, 0x6e, 0xad, 0xd1, 0x16, 0x98, 0x2a, 0x7c, 0x13, 0x03, 0xe1, 0x58, 0x6c,
 0xf8, 0x56, 0x30, 0x3e, 0x15, 0x8d, 0xb1, 0x76, 0xca, 0xe4, 0x2a, 0x7c, 0x13, 0x03, 0xe0, 0x8d,
 0x9f, 0x04, 0xc0, 0xf8, 0x56, 0x36, 0xd6, 0xed, 0xb5, 0xc8, 0x54, 0xf8, 0x56, 0x30, 0xbe, 0x12,
 0x75, 0x0d, 0x9f, 0x0a, 0xc6, 0x07, 0xc2, 0xb1, 0xb6, 0x2e, 0xdb, 0x17, 0x2a, 0x7c, 0x2e, 0xb4,
 0x30, 0xbe, 0x12, 0x75, 0x0d, 0x5f, 0x06, 0xc6, 0x07, 0xc2, 0xb1, 0xb6, 0x2e, 0xdd, 0x17, 0x2b,
 0x7c, 0x1b, 0x18, 0x5f, 0x0a, 0xc3, 0x47, 0xc1, 0xb1, 0x85, 0xf0, 0xac, 0x6d, 0xad, 0xdb, 0x6b,
 0x72, 0xb7, 0xc2, 0xe3, 0xc8, 0xc2, 0xf8, 0x5c, 0x79, 0x0d, 0x1f, 0x0a, 0xc6, 0x17, 0xc1, 0xb1,
 0xb6, 0x2e, 0xdb, 0x5b, 0x96, 0x39, 0x8a, 0x41, 0x5a, 0x30, 0x7c, 0x2b, 0x18, 0x5f, 0x08, 0xd9,
 0x16, 0x6d, 0x8b, 0xa9, 0x39, 0xa4, 0x55, 0xa5, 0xa7, 0x43, 0x54, 0x31, 0xb9, 0xbd, 0x65, 0xc5,
 0x97, 0x16, 0x56, 0x73, 0x48, 0xab, 0x4b, 0x0a, 0xc5, 0x20, 0xad, 0x2e, 0x25, 0x51, 0x2c, 0x0e,
 0x69, 0x8d, 0x5a, 0x5a, 0x56, 0x98, 0xdc, 0xd5, 0x2b, 0x6b, 0xda, 0xba, 0xb4, 0x8b, 0x9a, 0x58,
 0x56, 0x90, 0x56, 0x99, 0x89, 0x66, 0x2c, 0xc0, 0xad, 0x31, 0xb9, 0xa5, 0x95, 0x69, 0x15, 0x69,
 0x7b, 0x5c, 0x4a, 0xba, 0xb4, 0x82, 0xb4, 0xb0, 0xad, 0x20, 0xad, 0x33, 0xb5, 0x44, 0xab, 0xab,
 0x78, 0x91, 0x56, 0x96, 0x5c, 0xd3, 0x1a, 0xb4, 0xb8, 0x95, 0x44, 0xab, 0xab, 0x48, 0xab, 0x4b,
 0x0e, 0x69, 0x05, 0x69, 0x98, 0x95, 0x45, 0x95, 0xd5, 0xa4, 0x15, 0xa5, 0x95, 0x42, 0x0e, 0x69,
 0x71, 0x65, 0xc5, 0x95, 0xd5, 0xa4, 0x55, 0xa5, 0x85, 0x69, 0x05, 0x69, 0x98, 0x96, 0x76, 0xae,
 0xad, 0x20, 0xad, 0x2c, 0xab, 0x48, 0x39, 0xa5, 0xed, 0x5d, 0x4a, 0xea, 0xd2, 0x2a, 0xd2, 0xc2,
 0xb0, 0x82, 0xb4, 0xcc, 0x4a, 0xe2, 0x55, 0xd5, 0x84, 0x15, 0xa5, 0x95, 0x69, 0x15, 0x69, 0x7b,
 0x54, 0x4a, 0xb2, 0xb4, 0x8a, 0xb4, 0xb0, 0xad, 0x20, 0xad, 0x33, 0x12, 0xa8, 0x95, 0x75, 0x61,
 0x05, 0x69, 0x65, 0x5a, 0x45, 0x5a, 0x5e, 0xd5, 0x12, 0xad, 0xba, 0x45, 0x5a, 0x58, 0x56, 0x90,
 0x56, 0x95, 0x12, 0xa8, 0x95, 0x75, 0x61, 0x05, 0x69, 0x65, 0x5a, 0x45, 0x5a, 0x56, 0xd5, 0x12,
 0xac, 0xad, 0x22, 0xad, 0x2c, 0x2b, 0x48, 0x2b, 0x0c, 0xc5, 0x95, 0x12, 0xae, 0xad, 0xe2, 0x45,
 0x5a, 0xa5, 0x85, 0x69, 0x05, 0x69, 0x7b, 0x54, 0x59, 0x83, 0x45, 0x03, 0x2a, 0xb4, 0x8a, 0xb4,
 0xcc, 0x4a, 0xb6, 0x80, 0x1e, 0xaa, 0x2a, 0x1e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfa, 0x87, 0x12, 0x52, 0x1c,
 0x54, 0xd6, 0x1a, 0xa2, 0x8b, 0xe6, 0x70, 0xfe, 0x7e, 0x49, 0x5e, 0x5a, 0x7d, 0x53, 0x4d, 0x1c,
 0x33, 0x81, 0x88, 0x35, 0xe9, 0xba, 0xfd, 0x1c, 0x87, 0xc0, 0x69, 0x9a, 0x61, 0xe8, 0x2f, 0xc7,
 0xc5, 0x94, 0x8a, 0x62, 0x43, 0x45, 0x5d, 0x10, 0x5f, 0x1a, 0x4d, 0xc9, 0xf9, 0xa6, 0xe9, 0xb9,
 0x2f, 0x1d, 0x3c, 0x95, 0x44, 0x5e, 0xa5, 0x2a, 0xcc, 0xc8, 0x70, 0xf6, 0xa7, 0x2f, 0x1f, 0x22,
 0x1d, 0x5f, 0x23, 0xc2, 0xb7, 0xf2, 0x69, 0x31, 0x65, 0xd7, 0xa8, 0xab, 0x12, 0x5e, 0xc6, 0xdb,
 0x33, 0x87, 0xf3, 0xf2, 0x45, 0xd1, 0xe4, 0x55, 0x35, 0xd1, 0x0e, 0x55, 0x33, 0x44, 0xba, 0x3e,
 0x47, 0x87, 0x5a, 0xbf, 0x46, 0xb5, 0x12, 0x5a, 0xc5, 0x58, 0x92, 0xf6, 0x36, 0x28, 0xd2, 0xaa,
 0x9c, 0xda, 0x54, 0x8b, 0x2f, 0xa7, 0x41, 0xc8, 0xae, 0x47, 0x53, 0x97, 0x87, 0xfb, 0x1a, 0xfc,
 0x59, 0x75, 0xea, 0x2a, 0xc4, 0x97, 0x5e, 0xa1, 0x3e, 0x6d, 0xda, 0x96, 0xcf, 0xb2, 0xc6, 0x3b,
 0x31, 0x81, 0xe3, 0x98, 0xfa, 0x4a, 0x62, 0x12, 0xfb, 0xb5, 0x60, 0xfa, 0x96, 0x33, 0xf7, 0x77,
 0x9a, 0x8e, 0x4e, 0x2d, 0x62, 0xa7, 0x25, 0x45, 0xe0, 0xbd, 0x22, 0x47, 0xed, 0xb7, 0x65, 0x4b,
 0xcb, 0x34, 0xb7, 0xf6, 0x29, 0x8f, 0xfa, 0x0d, 0xb5, 0xcd, 0x0e, 0x3d, 0xfc, 0x17, 0x93, 0x78,
 0xdd, 0x71, 0xcc, 0xfe, 0xe6, 0xd5, 0x12, 0x06, 0x9d, 0x06, 0x07, 0xc1, 0xb1, 0xaa, 0xc4, 0xdb,
 0x4e, 0xcb, 0x57, 0x96, 0x68, 0x6f, 0xec, 0x51, 0xff, 0x00, 0xe8, 0x30, 0x3f, 0x6c, 0xbb, 0x30,
 0x5e, 0x59, 0x9d, 0xbf, 0xb1, 0xc7, 0xff, 0x00, 0xa0, 0xdd, 0x5c, 0xf5, 0xee, 0xe1, 0xdb, 0xc0,
 0xf9, 0xb1, 0xf2, 0xc5, 0x6f, 0x49, 0x6d, 0x4f, 0x83, 0x63, 0x0b, 0xe1, 0x58, 0xd5, 0x1d, 0xb6,
 0x2d, 0x99, 0x2a, 0xf0, 0xcc, 0xad, 0xfd, 0x8e, 0x3f, 0xfd, 0x06, 0x27, 0x6d, 0x83, 0x66, 0xcb,
 0xcb, 0x32, 0x37, 0xf6, 0x48, 0xdf, 0xf4, 0x1b, 0x63, 0x3d, 0x3b, 0xb5, 0xff, 0x00, 0xd2, 0x7c,
 0x42, 0x3f, 0xfc, 0x6d, 0xe9, 0x2d, 0xa9, 0xf0, 0xac, 0x60, 0x7c, 0x2b, 0x1a, 0xbb, 0xb6, 0xbb,
 0xb3, 0x85, 0x5f, 0xfd, 0xc6, 0xdf, 0xd9, 0x63, 0x7f, 0xd0, 0x63, 0x76, 0xd6, 0xf6, 0x74, 0xbf,
 0xc2, 0x36, 0xfe, 0xcb, 0x1b, 0xfe, 0x83, 0x6c, 0x72, 0x29, 0xdd, 0x71, 0xe1, 0x7c, 0xff, 0x00,
 0xfc, 0x36, 0xf4, 0x96, 0xcd, 0x12, 0x0d, 0x8c, 0x2f, 0x83, 0x62, 0xbe, 0x56, 0xcd, 0x19, 0x7b,
 0x35, 0x36, 0x61, 0xd8, 0x06, 0x20, 0x93, 0x89, 0x2d, 0xba, 0x91, 0xb4, 0x84, 0xf6, 0x6e, 0xef,
 0x6b, 0xa7, 0xb6, 0x44, 0xea, 0x5f, 0x90, 0x6c, 0xf8, 0x3a, 0xf4, 0x1b, 0xe9, 0x96, 0x2d, 0x1b,
 0x86, 0x8c, 0x95, 0xc9, 0x86, 0xf3, 0x4c, 0x91, 0xa9, 0x8f, 0xa4, 0x95, 0x3e, 0x15, 0x8c, 0x2f,
 0x85, 0x61, 0xab, 0xe1, 0x58, 0xc2, 0xf8, 0x56, 0x37, 0x45, 0xd9, 0x8c, 0x85, 0x4f, 0x85, 0x63,
 0x03, 0xe1, 0x58, 0x6d, 0x12, 0x15, 0x8c, 0x0f, 0x82, 0x6d, 0x8b, 0xb6, 0xc5, 0xca, 0x9f, 0x06,
 0xc6, 0x17, 0xc2, 0x4e, 0xa1, 0xab, 0xe1, 0x58, 0xc2, 0xf8, 0x4b, 0xd4, 0x6d, 0xad, 0xdb, 0x6b,
 0x72, 0xa7, 0xc2, 0xb1, 0x85, 0xf0, 0x93, 0xa8, 0x6a, 0xf8, 0x56, 0x30, 0xbe, 0x15, 0x8d, 0xb1,
 0x76, 0xda, 0xdc, 0xa9, 0xf0, 0xb4, 0x31, 0xb9, 0x83, 0x37, 0xc1, 0x30, 0x3e, 0x0d, 0x8d, 0xb1,
 0x7d, 0xb6, 0xc5, 0xd4, 0x55, 0xa6, 0x37, 0x34, 0xba, 0xf8, 0x4a, 0x62, 0x74, 0x35, 0x4e, 0x82,
 0xe2, 0xcd, 0x91, 0x65, 0x65, 0x69, 0x05, 0x61, 0x61, 0xcc, 0x22, 0xac, 0x2f, 0x6a, 0x89, 0x57,
 0x73, 0x4c, 0x6e, 0x69, 0x69, 0x5a, 0x41, 0x5a, 0x56, 0xd7, 0x16, 0x56, 0x56, 0x90, 0x56, 0x96,
 0x9c, 0xd2, 0x0a, 0xd3, 0x3b, 0x54, 0x59, 0x59, 0x5a, 0x45, 0x5a, 0x59, 0x56, 0x98, 0xdc, 0xd2,
 0xe2, 0x55, 0x12, 0xc0, 0xad, 0x20, 0xad, 0x2c, 0x2b, 0x48, 0x2b, 0x0a, 0xda, 0xa2, 0x55, 0xd5,
 0xa4, 0x15, 0xa5, 0xa5, 0x69, 0x8d, 0xcd, 0x33, 0x12, 0xa8, 0xb2, 0xba, 0xb4, 0x82, 0xb4, 0xb2,
 0xac, 0x20, 0xac, 0x2b, 0x6a, 0x89, 0x57, 0x56, 0x90, 0x73, 0x4b, 0x2a, 0xd2, 0x2a, 0xd2, 0xe2,
 0xca, 0x89, 0x56, 0x56, 0x91, 0x73, 0x4b, 0x0e, 0x69, 0x07, 0x35, 0x4a, 0x89, 0x5e, 0xd5, 0xd5,
 0xa4, 0x1c, 0xd2, 0xca, 0xb4, 0x82, 0xb4, 0xa8, 0xb2, 0xa2, 0xca, 0xea, 0xde, 0x24, 0x15, 0xa5,
 0x95, 0x69, 0x05, 0x69, 0x9d, 0xaa, 0x2c, 0xae, 0xad, 0x42, 0x2a, 0xd2, 0xc2, 0xb4, 0x82, 0xb4,
 0xb8, 0xb2, 0xa2, 0x55, 0xd5, 0xa4, 0x15, 0xa5, 0x95, 0x69, 0x05, 0x69, 0x9d, 0xaa, 0x25, 0x5d,
 0x5a, 0x45, 0x58, 0x58, 0x56, 0x10, 0x56, 0x97, 0x16, 0x54, 0x4a, 0xba, 0xb6, 0xc4, 0x55, 0xa5,
 0x85, 0x69, 0x07, 0x34, 0xad, 0xaa, 0x2c, 0xae, 0xad, 0x20, 0xe6, 0x96, 0x15, 0xa4, 0x55, 0xa5,
 0x44, 0xab, 0x6a, 0xea, 0xd2, 0x0a, 0xd2, 0xca, 0xb4, 0x82, 0xb4, 0xce, 0xd5, 0x12, 0xae, 0xad,
 0x22, 0xe6, 0x96, 0x15, 0x84, 0x15, 0xa5, 0x45, 0x95, 0x12, 0xae, 0xad, 0x3c, 0xd0, 0xce, 0xad,
 0x22, 0xad, 0x2f, 0x6a, 0xdb, 0x10, 0x15, 0x1f, 0x8a, 0x61, 0xcd, 0x72, 0xb5, 0x66, 0x13, 0x54,
 0x5d, 0x3d, 0xaa, 0x91, 0xf1, 0xae, 0x1e, 0xab, 0xc2, 0x61, 0x3f, 0x55, 0x7b, 0x8e, 0x1f, 0xfd,
 0x47, 0x8b, 0xbd, 0x7b, 0xc8, 0xf5, 0x6f, 0xf8, 0x7c, 0x9f, 0x6c, 0xae, 0x80, 0x74, 0x01, 0xcd,
 0x89, 0xdb, 0x50, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x41, 0xe0,
 0xcd, 0xdc, 0xbb, 0x06, 0x71, 0x75, 0xe6, 0x6a, 0xd0, 0xa6, 0x6e, 0x5b, 0x83, 0x33, 0x73, 0xf3,
 0xac, 0x59, 0xdd, 0x57, 0x23, 0x6e, 0x97, 0x9e, 0x54, 0xd3, 0xca, 0x19, 0x4b, 0x62, 0x4e, 0xd3,
 0x45, 0x76, 0xa9, 0xd4, 0x69, 0x70, 0x66, 0x95, 0x3a, 0x4b, 0xb0, 0x67, 0x17, 0xac, 0xb8, 0xb3,
 0x7d, 0x72, 0xb7, 0x56, 0x46, 0x97, 0x8e, 0x9e, 0x52, 0x22, 0x29, 0x08, 0xd2, 0x4d, 0x7a, 0x6a,
 0xdd, 0x1d, 0xe8, 0x35, 0xb8, 0x13, 0xba, 0x71, 0xde, 0x19, 0x4a, 0xe2, 0x0a, 0x9c, 0x9d, 0xa1,
 0xba, 0xb9, 0x66, 0x17, 0x31, 0x4c, 0x9f, 0xe2, 0x87, 0xb3, 0x18, 0x7f, 0x3f, 0x24, 0x59, 0x31,
 0x21, 0xa6, 0xba, 0x21, 0xb2, 0x41, 0x9e, 0x87, 0x11, 0x11, 0x22, 0x22, 0x2d, 0xd0, 0x9b, 0xe0,
 0x41, 0x8c, 0x9a, 0xb1, 0x53, 0x5e, 0xa5, 0x39, 0x34, 0xe4, 0x69, 0xc0, 0xcf, 0xe1, 0xb4, 0xbf,
 0x9c, 0x3f, 0x35, 0xfc, 0x2c, 0xd9, 0x4f, 0x6f, 0x99, 0x8d, 0x9d, 0x5e, 0xa6, 0xfe, 0xcd, 0x08,
 0xe5, 0x27, 0x60, 0xf0, 0xc9, 0x87, 0x4b, 0xc2, 0x3b, 0x34, 0xc3, 0xd3, 0x97, 0xa9, 0x7f, 0xb2,
 0xc2, 0x39, 0x02, 0x9d, 0x8d, 0x67, 0x71, 0xb7, 0x63, 0x8a, 0xbd, 0x14, 0x8a, 0xf6, 0x87, 0x80,
 0x35, 0xca, 0xf9, 0x73, 0x1c, 0xcd, 0x18, 0x9f, 0x8b, 0x72, 0xfe, 0x15, 0x37, 0x8a, 0x4e, 0x24,
 0x37, 0x45, 0xa1, 0x2d, 0x0d, 0x5e, 0xfd, 0xc6, 0xe9, 0xab, 0xb4, 0x4e, 0x84, 0xd5, 0x0d, 0xa1,
 0x76, 0x3b, 0xb5, 0x04, 0xe7, 0x90, 0xb3, 0x02, 0x7f, 0xb1, 0xb8, 0xcb, 0x36, 0xc9, 0x4a, 0xff,
 0x00, 0x8a, 0x74, 0xd0, 0x80, 0xde, 0x97, 0x63, 0xfb, 0x4f, 0x4f, 0xe0, 0x2e, 0x3f, 0xfb, 0x1b,
 0x8f, 0x17, 0x64, 0x7b, 0x4c, 0x4e, 0x79, 0x1b, 0x1e, 0xfd, 0x91, 0xc1, 0x1f, 0x11, 0x8b, 0xee,
 0x8f, 0x58, 0x68, 0xc0, 0x6e, 0xeb, 0xb2, 0x5d, 0xa4, 0xa7, 0x3c, 0x91, 0x8e, 0xa7, 0xfb, 0x2b,
 0x88, 0xae, 0xca, 0x36, 0x8e, 0x9c, 0xf2, 0x56, 0x39, 0xfb, 0x2a, 0x99, 0xd3, 0x1f, 0x15, 0x83,
 0xef, 0x8f, 0x58, 0x74, 0xdf, 0x04, 0x56, 0x6f, 0xcb, 0xe6, 0x5f, 0xd2, 0x96, 0xfa, 0x22, 0x1d,
 0xd5, 0xf0, 0xac, 0x72, 0xcf, 0x05, 0xdc, 0xa5, 0x98, 0xb2, 0xec, 0x1c, 0xc2, 0xdc, 0x7f, 0x05,
 0x9e, 0xc3, 0x16, 0x3b, 0xa5, 0xd6, 0x0f, 0xaa, 0x61, 0x2b, 0x37, 0xf4, 0xa9, 0xae, 0x9d, 0x7a,
 0x6a, 0x9f, 0x29, 0xd9, 0x22, 0x4b, 0xd8, 0xec, 0x30, 0x5f, 0x54, 0x88, 0x7c, 0xab, 0xda, 0x49,
 0xeb, 0xf1, 0x1c, 0x96, 0xac, 0xee, 0x3c, 0xbf, 0x94, 0x14, 0x3e, 0x09, 0x85, 0xf0, 0x6c, 0x35,
 0x89, 0x05, 0x7a, 0x8c, 0x2f, 0x85, 0x63, 0x95, 0x5b, 0xba, 0x38, 0xb9, 0x4c, 0x48, 0x46, 0x07,
 0xc2, 0xb0, 0xd9, 0xf0, 0x8c, 0x2f, 0x83, 0xc0, 0xdb, 0x5b, 0xb6, 0xd6, 0xe5, 0x2f, 0x85, 0x63,
 0x0b, 0xe0, 0xd8, 0x6c, 0xf8, 0x4b, 0xd4, 0x60, 0x7c, 0x1b, 0x1b, 0x6b, 0x76, 0xd8, 0xb9, 0x53,
 0xe1, 0x27, 0x51, 0x85, 0xf0, 0x86, 0xaf, 0x83, 0x63, 0x0c, 0x48, 0x26, 0xd8, 0xbb, 0x75, 0x72,
 0x14, 0xbe, 0x15, 0x8c, 0x2f, 0x85, 0x61, 0xab, 0xe1, 0x2f, 0x51, 0x89, 0xf0, 0xac, 0x6d, 0x8b,
 0xb6, 0xc5, 0xca, 0x5f, 0x0a, 0xc6, 0x17, 0xc2, 0xb0, 0xd9, 0xf0, 0x97, 0xa8, 0xc0, 0xf8, 0x56,
 0x36, 0xc5, 0xdb, 0x6b, 0x72, 0xa7, 0xc2, 0xb1, 0x89, 0xd0, 0xec, 0x34, 0x7c, 0x1b, 0x18, 0x5f,
 0x0a, 0xc6, 0xda, 0xdd, 0xb6, 0x32, 0x16, 0xb9, 0x84, 0x1c, 0xd2, 0xf3, 0xe0, 0xd8, 0xc4, 0xf8,
 0x4a, 0x6c, 0x8b, 0x36, 0x45, 0xd4, 0xd5, 0xa4, 0x55, 0xa5, 0x97, 0x31, 0x4c, 0x6e, 0x6a, 0x97,
 0x16, 0x6c, 0x8b, 0x30, 0x2b, 0x48, 0x2b, 0x4b, 0x0a, 0xd2, 0x2a, 0xd2, 0xa2, 0x55, 0xb5, 0x67,
 0x34, 0x8a, 0xb4, 0xb2, 0xad, 0x31, 0xb9, 0xa5, 0x6d, 0x51, 0x2c, 0x0e, 0x69, 0x8d, 0xcd, 0x2c,
 0xb9, 0xa4, 0x55, 0xa5, 0x45, 0x95, 0x12, 0xac, 0xad, 0x20, 0xad, 0x2d, 0x2b, 0x4c, 0x6e, 0x69,
 0x51, 0x2a, 0x89, 0x60, 0x56, 0x98, 0xdc, 0xd2, 0xca, 0xb4, 0x8a, 0xb4, 0xad, 0xaa, 0x2c, 0xac,
 0xac, 0x20, 0xe6, 0x96, 0x9c, 0xd3, 0x1a, 0xb4, 0xa8, 0x95, 0x6d, 0x5d, 0x5a, 0x41, 0x5b, 0xc4,
 0xb2, 0xad, 0x20, 0xad, 0x2b, 0x6b, 0x8b, 0x2b, 0xab, 0x48, 0x2b, 0x4b, 0x2a, 0xd2, 0x0a, 0xd2,
 0xa2, 0x59, 0x8b, 0x2b, 0xab, 0x48, 0xab, 0x0b, 0x0e, 0x69, 0x07, 0x34, 0xad, 0xae, 0x25, 0x5d,
 0x5a, 0x45, 0x5a, 0x58, 0x54, 0x20, 0xe6, 0x95, 0x12, 0xae, 0xa5, 0x75, 0x69, 0x17, 0x34, 0xb0,
 0xad, 0x20, 0xad, 0x2a, 0x2c, 0xad, 0xab, 0xab, 0x48, 0x2b, 0x4b, 0x2a, 0xde, 0x24, 0x5c, 0xd2,
 0xa2, 0x55, 0x16, 0x56, 0x56, 0xf1, 0x20, 0xe6, 0x96, 0x55, 0x84, 0x15, 0xa5, 0x44, 0xae, 0x25,
 0x5d, 0x5a, 0x45, 0x5a, 0x58, 0x56, 0x91, 0x73, 0x4a, 0xea, 0x66, 0x2c, 0xac, 0xad, 0x22, 0xe6,
 0x96, 0x15, 0x84, 0x15, 0xa5, 0x45, 0x97, 0xb5, 0x77, 0x34, 0x57, 0x98, 0x27, 0x5b, 0x25, 0x28,
 0xac, 0x6b, 0x92, 0xb4, 0x44, 0xd1, 0xa9, 0xd4, 0x9d, 0x2a, 0x5b, 0xc6, 0x31, 0x19, 0x7c, 0x3e,
 0x12, 0xef, 0xaa, 0x3e, 0x32, 0xa7, 0x93, 0x0d, 0x17, 0x8f, 0xc7, 0xd4, 0x86, 0x93, 0x3b, 0x33,
 0x16, 0x6e, 0x61, 0xf1, 0xe3, 0x3b, 0x79, 0xce, 0xf9, 0xac, 0x79, 0xff, 0x00, 0x1b, 0xf1, 0x8a,
 0xf1, 0xe9, 0x38, 0x71, 0xcf, 0xe9, 0xcf, 0xf0, 0xff, 0x00, 0x77, 0x67, 0xc1, 0xe2, 0x5b, 0x25,
 0xba, 0xed, 0x1e, 0x4a, 0xe7, 0xad, 0xe6, 0x87, 0x84, 0x99, 0xed, 0x93, 0xd2, 0x78, 0x2a, 0xfc,
 0xdd, 0xf3, 0x7b, 0xdd, 0x22, 0xad, 0x52, 0xc2, 0xa1, 0x05, 0x69, 0xf6, 0x2a, 0xcf, 0x93, 0xca,
 0x75, 0x30, 0x81, 0x35, 0x69, 0x15, 0x69, 0x7b, 0x65, 0xe0, 0x02, 0xa2, 0xa0, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x01, 0xf6, 0x9c, 0x29, 0x8b, 0x96, 0xa1, 0xcc, 0xdc, 0xd7, 0xe1, 0xcc, 0x5c, 0xb3,
 0x0e, 0x62, 0xe7, 0xe7, 0x08, 0x97, 0x32, 0xb7, 0x6c, 0x30, 0xa6, 0x6e, 0x5b, 0x85, 0x33, 0xc7,
 0x99, 0xae, 0x42, 0x98, 0xb9, 0x6a, 0x14, 0xce, 0x9d, 0x25, 0x44, 0xb6, 0xd7, 0x23, 0x64, 0x83,
 0x35, 0x72, 0xec, 0x19, 0xbb, 0x9a, 0xc4, 0x29, 0x9b, 0x96, 0xe1, 0x4c, 0xdc, 0xa8, 0xb3, 0x75,
 0x72, 0x36, 0x98, 0x13, 0x8a, 0x9d, 0x23, 0x09, 0x79, 0xf5, 0x4e, 0x3b, 0xc6, 0xa3, 0x06, 0x69,
 0x7a, 0xcb, 0x90, 0xa6, 0xd5, 0x3a, 0x4b, 0xea, 0x6f, 0xae, 0x57, 0xc3, 0xbe, 0x18, 0x71, 0x16,
 0x37, 0x84, 0x4e, 0x67, 0x88, 0xab, 0xae, 0xbe, 0xa5, 0xfe, 0xcb, 0x08, 0xe4, 0x6a, 0x75, 0x3f,
 0x0a, 0xe7, 0xef, 0xed, 0xef, 0x31, 0xbb, 0xaf, 0xd4, 0xdf, 0xd9, 0xa1, 0x1c, 0xac, 0xef, 0xf1,
 0x7f, 0x82, 0xbf, 0x87, 0x2e, 0x27, 0x71, 0xb7, 0x7f, 0xf0, 0x0e, 0x84, 0x91, 0xb6, 0xe0, 0xf6,
 0x2a, 0x6b, 0xf9, 0x1e, 0x6b, 0xe9, 0x61, 0xf7, 0x34, 0xce, 0x1c, 0xdf, 0x78, 0x9f, 0x21, 0xf0,
 0xcf, 0x80, 0x64, 0x6a, 0x1b, 0x72, 0x73, 0xff, 0x00, 0xd0, 0xf3, 0x5f, 0xf2, 0x1f, 0x7e, 0xc3,
 0x9b, 0x81, 0x19, 0x3c, 0xb6, 0xa7, 0x1e, 0x94, 0x38, 0x99, 0xf2, 0xf4, 0x64, 0xd3, 0x8d, 0x9f,
 0x8b, 0x4c, 0xdf, 0x3f, 0x9b, 0x57, 0x98, 0xc3, 0xd1, 0x39, 0x37, 0xe6, 0x28, 0x46, 0x94, 0xd3,
 0xf3, 0x13, 0xe4, 0x37, 0x88, 0x92, 0xb0, 0xe2, 0xa6, 0xac, 0x54, 0x70, 0xbe, 0x67, 0x0f, 0xfe,
 0x29, 0x78, 0xf9, 0x0e, 0x97, 0x93, 0xe1, 0x33, 0xf4, 0x69, 0x91, 0x65, 0x93, 0xde, 0xa7, 0xc8,
 0x56, 0x89, 0x2c, 0x9e, 0xf5, 0x0d, 0xaa, 0x67, 0x0f, 0xd3, 0xf3, 0x45, 0xf1, 0xe4, 0xd5, 0x3a,
 0x0e, 0x55, 0x33, 0x44, 0xba, 0x4c, 0xfe, 0x1f, 0x31, 0xf4, 0x6b, 0x91, 0x25, 0x93, 0xa1, 0x10,
 0xab, 0x12, 0x5d, 0x7a, 0x8d, 0x86, 0x2c, 0xb6, 0x8b, 0xc5, 0x14, 0xab, 0x16, 0x59, 0x3a, 0x8e,
 0x45, 0x72, 0x3a, 0xac, 0xbc, 0x36, 0xbd, 0x1a, 0x06, 0x9c, 0xd0, 0xad, 0x12, 0x02, 0x1c, 0xf3,
 0xc2, 0xcf, 0x1e, 0xc7, 0x72, 0xbe, 0x4e, 0xc2, 0x26, 0xf0, 0x1c, 0x56, 0x6f, 0x0d, 0x8f, 0x1b,
 0x11, 0x74, 0x38, 0x91, 0x25, 0xe2, 0x2b, 0x15, 0xcd, 0x48, 0x4a, 0xba, 0x2e, 0x9d, 0x1a, 0xf1,
 0x3e, 0x6a, 0xf6, 0x54, 0xda, 0x2a, 0xf3, 0xce, 0x78, 0xd7, 0xed, 0x4a, 0x5f, 0xbf, 0xd3, 0x95,
 0xc6, 0xf6, 0x5f, 0x27, 0x33, 0x14, 0x65, 0xad, 0xe2, 0x22, 0x5f, 0x68, 0x44, 0x82, 0x60, 0x7c,
 0x1d, 0x3a, 0x0f, 0x9c, 0x36, 0x0b, 0x9e, 0xb3, 0x96, 0x3b, 0xb5, 0x6c, 0x23, 0x0a, 0xc5, 0x73,
 0x26, 0x27, 0x3d, 0x27, 0x19, 0x23, 0x54, 0x81, 0x1a, 0x3a, 0xb9, 0x8f, 0xd2, 0x0b, 0xd5, 0x35,
 0x4f, 0x4a, 0x22, 0x8f, 0xf6, 0xe9, 0xb6, 0x29, 0x89, 0x3c, 0x4e, 0x3e, 0x5a, 0xc9, 0xf3, 0x4d,
 0x84, 0xe8, 0x0e, 0x58, 0x73, 0x78, 0x83, 0x34, 0x55, 0xdf, 0x4e, 0x0a, 0xc8, 0x6b, 0xd1, 0xa7,
 0x25, 0x77, 0x3d, 0x79, 0x72, 0xd5, 0x76, 0x57, 0x93, 0x1a, 0xdc, 0xb8, 0xb9, 0x3d, 0x96, 0xe5,
 0x57, 0x95, 0x1c, 0x7a, 0x4c, 0x4e, 0xe3, 0x7b, 0xfa, 0x47, 0xd3, 0xcd, 0xda, 0x62, 0x42, 0xd1,
 0x74, 0x54, 0xd3, 0xd2, 0x62, 0x7c, 0x1e, 0x1a, 0xe8, 0xba, 0x2f, 0x25, 0x3e, 0x1c, 0x9e, 0xc4,
 0xf1, 0x09, 0xf8, 0xee, 0x8f, 0x3b, 0x3d, 0x35, 0x33, 0x15, 0x57, 0x55, 0x7c, 0x58, 0xce, 0x72,
 0xfc, 0xaa, 0xa3, 0x3c, 0xbf, 0x9c, 0x73, 0x46, 0x05, 0x15, 0xb1, 0x30, 0xac, 0x72, 0x76, 0x5f,
 0x4f, 0xcc, 0xaa, 0xae, 0x62, 0xfa, 0x5a, 0xba, 0xa2, 0xfc, 0x86, 0x63, 0x9b, 0xe7, 0xf2, 0x76,
 0xb6, 0xf6, 0x2f, 0x24, 0x57, 0xf4, 0x73, 0x46, 0xff, 0x00, 0x1e, 0x5f, 0xcf, 0xfa, 0x3e, 0xc9,
 0x89, 0x0a, 0xc6, 0x07, 0xc2, 0x31, 0xe4, 0x88, 0xd8, 0xae, 0x21, 0x93, 0xf0, 0xa9, 0xfc, 0x69,
 0xb0, 0x9b, 0x88, 0x4c, 0xcb, 0x36, 0x2c, 0x66, 0xc3, 0x66, 0xea, 0x26, 0xf7, 0x14, 0xe1, 0xd0,
 0xba, 0x69, 0xad, 0xcb, 0x58, 0xc4, 0xd4, 0x9e, 0x15, 0x87, 0x47, 0xc4, 0x71, 0x19, 0x86, 0x4b,
 0x4a, 0xc0, 0x62, 0xbe, 0x2c, 0x47, 0xaf, 0x06, 0xa7, 0xfe, 0x70, 0xd3, 0xac, 0xe7, 0x57, 0x2c,
 0x6b, 0x6f, 0x1f, 0x34, 0xb5, 0x72, 0xce, 0x28, 0xf3, 0x98, 0x9d, 0x79, 0x7d, 0x67, 0xe5, 0xe4,
 0xa6, 0xf8, 0x45, 0x79, 0x86, 0xb2, 0x13, 0x15, 0xf1, 0x5c, 0xd8, 0x6d, 0x4e, 0x6a, 0xe5, 0xd1,
 0x3e, 0x55, 0x38, 0x4e, 0x7f, 0xdb, 0x4e, 0x2f, 0x88, 0xcc, 0x44, 0x95, 0xcb, 0x28, 0xb8, 0x5c,
 0x92, 0x2e, 0x89, 0x1d, 0x5a, 0x8b, 0x1e, 0x22, 0x75, 0xea, 0xbc, 0x19, 0xe8, 0x4e, 0x37, 0x39,
 0x6e, 0x23, 0x89, 0xe2, 0x38, 0x8c, 0x55, 0x8d, 0x3f, 0x3d, 0x35, 0x35, 0x11, 0x79, 0xba, 0x34,
 0x57, 0x3d, 0x7e, 0x75, 0x34, 0x5b, 0xc4, 0x22, 0xb3, 0xaa, 0xc6, 0xde, 0xbb, 0x87, 0xec, 0x9f,
 0x23, 0x25, 0x62, 0xd9, 0xad, 0x15, 0xfd, 0x9f, 0x39, 0x7d, 0x6f, 0x17, 0x13, 0xc2, 0x18, 0xba,
 0x3b, 0x16, 0xc3, 0xda, 0xbd, 0x4b, 0x37, 0x0d, 0x3e, 0xf2, 0x0c, 0x9c, 0xc3, 0xa3, 0x2e, 0x90,
 0x67, 0xe4, 0xe2, 0x2f, 0x53, 0x26, 0x18, 0xef, 0xa1, 0x4f, 0x90, 0x35, 0xb2, 0x1e, 0xb5, 0x74,
 0xe2, 0x9c, 0x14, 0x98, 0xf1, 0x3b, 0x47, 0xf9, 0x5d, 0x97, 0xfd, 0xa5, 0x8f, 0x5e, 0x59, 0x67,
 0xd3, 0xfd, 0xdf, 0x61, 0x3e, 0x0a, 0xe9, 0xaa, 0xa7, 0x0e, 0xb3, 0x03, 0xe0, 0xa1, 0xf2, 0xde,
 0x09, 0x99, 0xb1, 0xfc, 0x22, 0x2b, 0x5f, 0x87, 0x62, 0xd3, 0x70, 0x37, 0x7f, 0x31, 0x22, 0x2a,
 0xb1, 0x7d, 0x2d, 0x5e, 0x0a, 0x76, 0x3d, 0x9c, 0x6d, 0x3e, 0x0e, 0x35, 0x33, 0x0b, 0x09, 0xc7,
 0xd9, 0x0a, 0x56, 0x75, 0xeb, 0xbb, 0x0a, 0x61, 0x9c, 0x21, 0xc5, 0x77, 0x42, 0x2a, 0x7e, 0x6b,
 0x97, 0xe4, 0x5b, 0x1c, 0xbc, 0x1e, 0x25, 0x4b, 0xce, 0xa7, 0xc9, 0xd6, 0x73, 0x7d, 0x9d, 0xe4,
 0xf1, 0x6b, 0x39, 0x29, 0x3d, 0x71, 0x1d, 0xbe, 0x7e, 0x8d, 0xf1, 0xf0, 0xac, 0x60, 0x7c, 0x24,
 0xea, 0x1a, 0xbe, 0x15, 0x8c, 0x2f, 0x85, 0x63, 0xb3, 0x8b, 0xba, 0x18, 0xb9, 0x4b, 0xe1, 0x75,
 0xf2, 0x30, 0xbe, 0x11, 0x47, 0x6a, 0x13, 0x13, 0x78, 0x76, 0x47, 0xc4, 0x67, 0x64, 0xa6, 0x22,
 0x4b, 0x4c, 0x42, 0x48, 0x6a, 0xc8, 0x90, 0xd7, 0x47, 0x37, 0x58, 0x8d, 0x45, 0xd1, 0x7d, 0x0a,
 0xa7, 0x0a, 0x5c, 0xe7, 0x9a, 0xbf, 0xcf, 0xf8, 0x87, 0x6c, 0xa7, 0x1b, 0x3f, 0x88, 0xd7, 0x8f,
 0x6e, 0x99, 0x8d, 0xbb, 0xef, 0x0d, 0xf0, 0x8c, 0xbc, 0xec, 0x5e, 0xf2, 0xb6, 0x88, 0x8d, 0xe9,
 0xdf, 0x9c, 0xcd, 0x17, 0x43, 0x1b, 0x9a, 0x71, 0x0c, 0x0f, 0x36, 0x66, 0x58, 0xf8, 0xd4, 0x8c,
 0x18, 0xb8, 0xe4, 0xf3, 0xe1, 0xc4, 0x99, 0x86, 0xd7, 0x35, 0x62, 0xae, 0x8a, 0x8a, 0xe4, 0x45,
 0x43, 0xad, 0x67, 0x8c, 0xd1, 0x86, 0xe5, 0x98, 0x5a, 0x46, 0xfe, 0xef, 0x38, 0xfe, 0x30, 0xa5,
 0x98, 0xba, 0x2a, 0xa7, 0x5a, 0xf5, 0x34, 0xd9, 0xc7, 0xf1, 0x2c, 0x79, 0x69, 0x36, 0x9f, 0x28,
 0x85, 0xf2, 0x7c, 0x27, 0x3e, 0x0c, 0x94, 0xc7, 0x1f, 0xa5, 0x36, 0xec, 0x66, 0xad, 0xd5, 0x74,
 0x4e, 0x3e, 0x82, 0x2a, 0x9a, 0x2e, 0x8a, 0x70, 0xec, 0x77, 0x3a, 0xe3, 0xf8, 0xac, 0x47, 0x6f,
 0x4e, 0xba, 0x5a, 0x0a, 0xf2, 0x83, 0x2e, 0xaa, 0xc6, 0xa7, 0xc6, 0x9c, 0x57, 0xe3, 0x53, 0x5e,
 0x7c, 0x78, 0xcf, 0x76, 0xf3, 0xa2, 0xc4, 0x73, 0x97, 0xa5, 0x5c, 0xba, 0x9c, 0x6b, 0xf8, 0xe5,
 0x22, 0x7f, 0x46, 0xbb, 0x76, 0x58, 0xbd, 0x9c, 0xc9, 0x35, 0xde, 0x4b, 0xc4, 0x4f, 0xab, 0xe9,
 0x07, 0x36, 0xcb, 0xc4, 0x82, 0xb0, 0xe0, 0xb8, 0x4e, 0x63, 0xc6, 0xb0, 0xc8, 0x88, 0xe9, 0x4c,
 0x46, 0x3b, 0x51, 0x3f, 0x31, 0xce, 0xde, 0x62, 0xfa, 0x5a, 0xbc, 0x0e, 0xa7, 0x91, 0xf3, 0x84,
 0xbe, 0x60, 0x4f, 0x52, 0x4c, 0xb1, 0xb2, 0xf8, 0x83, 0x53, 0x5d, 0xc6, 0xaf, 0x93, 0x11, 0x13,
 0x9a, 0xb7, 0xa9, 0x6c, 0x72, 0xb8, 0xbe, 0x2b, 0x8b, 0x3c, 0xf4, 0xcf, 0x94, 0xb8, 0xbc, 0xcf,
 0x06, 0xcd, 0xc6, 0xaf, 0x5c, 0x4f, 0x54, 0x36, 0x45, 0x69, 0x15, 0x69, 0x4f, 0x32, 0xe3, 0x72,
 0x18, 0x0c, 0x97, 0xaa, 0x67, 0x5e, 0xba, 0xbb, 0x54, 0x87, 0x09, 0x9e, 0xde, 0x22, 0xf5, 0x27,
 0x79, 0xca, 0x31, 0xfc, 0xef, 0x8d, 0xe2, 0x51, 0x1c, 0xd8, 0x31, 0x96, 0x46, 0x5d, 0x79, 0x43,
 0x82, 0xba, 0x2e, 0x97, 0x77, 0x35, 0x37, 0x72, 0xbc, 0x4b, 0x17, 0x1b, 0xca, 0xde, 0x73, 0xda,
 0x1a, 0xb8, 0x3e, 0x19, 0x9f, 0x97, 0x1d, 0x55, 0xf2, 0xaf, 0x79, 0x76, 0x07, 0x37, 0x45, 0xd1,
 0x78, 0x11, 0x56, 0x70, 0xe0, 0x9c, 0x0f, 0x9f, 0x62, 0xc7, 0x8f, 0x15, 0xfb, 0xf1, 0x23, 0x44,
 0x7b, 0xba, 0xdc, 0xe5, 0x55, 0x2c, 0xc8, 0xe2, 0xd8, 0x9c, 0x8b, 0xd1, 0xf2, 0xb3, 0xf3, 0x10,
 0x95, 0x17, 0x93, 0x62, 0x2e, 0x9f, 0x27, 0x23, 0x83, 0x5f, 0x1f, 0xae, 0xfc, 0xe9, 0xfc, 0x5d,
 0xac, 0xfb, 0x3d, 0x6d, 0x79, 0x64, 0xf3, 0xfc, 0x7f, 0xbb, 0xbb, 0xb9, 0xa4, 0x15, 0xa6, 0x91,
 0x94, 0x73, 0xdf, 0xaa, 0x63, 0xb2, 0x47, 0x1a, 0xdc, 0x63, 0xdc, 0xba, 0x32, 0x61, 0xa9, 0xa2,
 0x2a, 0xff, 0x00, 0x19, 0x3a, 0x3d, 0x26, 0xfa, 0xe6, 0x9d, 0xcf, 0x1b, 0x97, 0x8f, 0x91, 0x5e,
 0xaa, 0x4b, 0xa6, 0xe4, 0xf1, 0x72, 0xf1, 0x6d, 0xd3, 0x92, 0x3f, 0xf8, 0xae, 0xad, 0x20, 0xad,
 0x2c, 0x39, 0xa4, 0x1c, 0xd3, 0x95, 0xb7, 0x1e, 0x25, 0x81, 0xcd, 0x31, 0xab, 0x4c, 0xf1, 0x9c,
 0xc8, 0x50, 0xdf, 0x16, 0x23, 0x9a, 0xc6, 0x31, 0x35, 0x73, 0x9c, 0xba, 0x22, 0x27, 0x5a, 0x9c,
 0xfb, 0x32, 0x67, 0xa7, 0xac, 0x47, 0x4b, 0xe0, 0xcd, 0x46, 0xb1, 0x38, 0x2c, 0xc3, 0x93, 0x8b,
 0xbf, 0x45, 0x17, 0x97, 0xa5, 0x4e, 0x3f, 0x27, 0x9d, 0x8b, 0x8b, 0x5d, 0xde, 0x7f, 0x77, 0xd5,
 0xcc, 0xe2, 0x71, 0x32, 0xf2, 0xad, 0xaa, 0x47, 0xef, 0x6e, 0xf1, 0x37, 0x5a, 0x9a, 0xb9, 0x51,
 0xa9, 0xd6, 0xab, 0xa2, 0x15, 0x96, 0x6a, 0x4d, 0x57, 0x4f, 0x56, 0x4b, 0x6b, 0xd5, 0x55, 0xbd,
 0xe7, 0x1c, 0x9c, 0x9d, 0x9c, 0x9c, 0x88, 0xaf, 0x9a, 0x9a, 0x8b, 0x1d, 0xcb, 0xd2, 0xf7, 0xaa,
 0x98, 0x0e, 0x96, 0xde, 0xd1, 0x4e, 0xff, 0x00, 0x46, 0x9f, 0xc5, 0xde, 0x53, 0xc0, 0xa3, 0x5f,
 0xa5, 0x7f, 0xe0, 0xed, 0xcd, 0xdd, 0x7b, 0x77, 0x98, 0xe4, 0x7a, 0x75, 0xb5, 0x75, 0x42, 0x2a,
 0xd3, 0x8c, 0x4b, 0xcc, 0xcc, 0x4b, 0x3d, 0x22, 0x40, 0x8f, 0x16, 0x13, 0x93, 0xa5, 0x8e, 0x54,
 0x36, 0x8c, 0x0f, 0x3a, 0xce, 0x40, 0x73, 0x61, 0x62, 0x49, 0xea, 0xa8, 0x3e, 0xfd, 0x13, 0x47,
 0xb7, 0xbc, 0xe4, 0xf1, 0xbd, 0xa0, 0xc5, 0x79, 0xe9, 0xc9, 0x5e, 0x9f, 0xe2, 0xd3, 0x9f, 0xc1,
 0x72, 0xd2, 0x37, 0x8e, 0x77, 0xfc, 0x1b, 0xea, 0xb4, 0x8b, 0x9a, 0x4a, 0x4e, 0x62, 0x5e, 0x76,
 0x59, 0x93, 0x32, 0xb1, 0x5b, 0x16, 0x13, 0xd3, 0x83, 0x93, 0xff, 0x00, 0x38, 0x29, 0x35, 0x69,
 0xdf, 0xd2, 0xf1, 0x68, 0xdc, 0x7c, 0x9d, 0x3c, 0xee, 0xb3, 0xa9, 0x57, 0x56, 0x10, 0x73, 0x4b,
 0x2a, 0xd2, 0x0a, 0xd3, 0x64, 0x59, 0x98, 0x95, 0x75, 0x69, 0x15, 0x69, 0x61, 0x5a, 0x41, 0xcc,
 0x2b, 0x6a, 0x8b, 0x2b, 0xab, 0x08, 0x39, 0xa5, 0x95, 0x69, 0x15, 0x69, 0x5d, 0x4a, 0x89, 0x50,
 0x9c, 0x8f, 0x02, 0x56, 0x0a, 0xc6, 0x99, 0x88, 0x90, 0xe1, 0xa7, 0x35, 0x5e, 0xb3, 0x57, 0xc5,
 0xf3, 0x46, 0xa8, 0xe8, 0x58, 0x7b, 0x15, 0xbf, 0xca, 0xbd, 0x38, 0xfc, 0x48, 0x38, 0xcf, 0x29,
 0xa6, 0x02, 0xe5, 0xfe, 0x55, 0x9f, 0x79, 0xcf, 0x97, 0x99, 0xe5, 0xbc, 0x73, 0xc5, 0x33, 0xe1,
 0xcb, 0xee, 0x71, 0xce, 0xa3, 0x5f, 0x3f, 0xab, 0xbd, 0xf0, 0xde, 0x2e, 0x3c, 0x98, 0xfd, 0xe5,
 0xa3, 0x72, 0x9c, 0x58, 0xaf, 0x8b, 0x11, 0xd1, 0x22, 0x3d, 0xcf, 0x73, 0xb8, 0xab, 0x9c, 0xba,
 0xaa, 0x91, 0xd1, 0x55, 0x09, 0x4b, 0x41, 0x8b, 0x31, 0x19, 0xb0, 0xa0, 0xc3, 0x73, 0xde, 0xee,
 0x08, 0xd6, 0xa6, 0xaa, 0xa3, 0xdc, 0x47, 0x02, 0x4c, 0x3b, 0x03, 0xf5, 0x44, 0x77, 0x6b, 0x30,
 0xe8, 0x8d, 0x4d, 0x11, 0x78, 0x35, 0x17, 0x5e, 0x17, 0x53, 0xcd, 0xe2, 0xe3, 0x65, 0xcd, 0x5b,
 0x64, 0x88, 0xf2, 0x8f, 0x39, 0x97, 0x6f, 0x6c, 0xb4, 0xa4, 0xc5, 0x66, 0x7c, 0xe7, 0xe4, 0xd7,
 0x8f, 0x5b, 0xcd, 0x3d, 0x27, 0x87, 0xad, 0xe6, 0x9e, 0x93, 0x8d, 0x5f, 0x9b, 0x6b, 0xa4, 0x2b,
 0x48, 0x2b, 0x4b, 0x3b, 0xa4, 0x5c, 0xd3, 0xeb, 0xb5, 0xb7, 0x93, 0xc7, 0xed, 0x59, 0x5a, 0x41,
 0x5a, 0x59, 0x56, 0xf1, 0x20, 0xe6, 0x97, 0xb5, 0x45, 0x95, 0xd5, 0xa4, 0x5c, 0xd2, 0xc2, 0xb5,
 0x48, 0x2b, 0x4a, 0x8b, 0x2a, 0x2c, 0xc1, 0xa2, 0x9e, 0x68, 0x66, 0x56, 0x91, 0x73, 0x4a, 0xda,
 0xb6, 0xc6, 0x07, 0xbb, 0xa7, 0x86, 0x47, 0xd5, 0x30, 0xe3, 0xdc, 0xb1, 0x0e, 0x3d, 0xc4, 0x8c,
 0x8f, 0xd4, 0xa6, 0x76, 0x47, 0xb9, 0xf9, 0xae, 0x24, 0x8b, 0x9e, 0xc3, 0x8f, 0x72, 0xc4, 0x38,
 0xf7, 0x11, 0x43, 0x8f, 0x72, 0xcc, 0x38, 0xf7, 0x2b, 0x6d, 0xb1, 0x73, 0xd8, 0x73, 0x17, 0x2d,
 0x43, 0x98, 0xb8, 0x82, 0x1c, 0xc5, 0xcb, 0x30, 0xe6, 0x2e, 0x54, 0x59, 0xb6, 0x2e, 0xd8, 0x21,
 0x4c, 0xdc, 0xb5, 0x0a, 0x66, 0xe6, 0xbb, 0x0a, 0x62, 0xe5, 0xa8, 0x73, 0x17, 0x2a, 0x25, 0xb6,
 0xb9, 0x1f, 0x20, 0x78, 0x4f, 0xbb, 0x7f, 0x6d, 0xf8, 0xfb, 0xba, 0xfd, 0x4f, 0xfd, 0x9e, 0x19,
 0xcc, 0xce, 0x8f, 0xe1, 0x24, 0xed, 0xfd, 0xb3, 0x63, 0x8e, 0xff, 0x00, 0x57, 0xfb, 0x08, 0x67,
 0x38, 0x3d, 0x26, 0x1f, 0xd5, 0xd7, 0xf0, 0xee, 0x31, 0xce, 0xe9, 0x0e, 0xaf, 0xe0, 0xb5, 0x9b,
 0xf0, 0x0c, 0x93, 0xb4, 0xd7, 0x63, 0x39, 0x8e, 0x7f, 0xd4, 0x32, 0x4b, 0x87, 0x47, 0x83, 0x56,
 0x93, 0xe2, 0x79, 0x6e, 0xdd, 0xd1, 0x34, 0x62, 0x2a, 0xf4, 0x2f, 0x41, 0xf5, 0x6c, 0x1f, 0x08,
 0xed, 0x91, 0xb7, 0x9e, 0x6d, 0x5f, 0xff, 0x00, 0x9f, 0x33, 0xff, 0x00, 0x6c, 0xfc, 0xfb, 0x3d,
 0xd5, 0x4d, 0x79, 0x38, 0xd4, 0xc9, 0x6e, 0xa9, 0x66, 0x6b, 0xb9, 0xdb, 0xf4, 0x3e, 0x5f, 0xc2,
 0x5b, 0x64, 0x0c, 0xe7, 0x9b, 0xd5, 0x3f, 0xfd, 0x7c, 0xcf, 0xfd, 0xb2, 0xfc, 0x2f, 0x09, 0xed,
 0x8c, 0x2a, 0x69, 0x17, 0x37, 0xeb, 0xe9, 0xc3, 0x66, 0xbf, 0xed, 0x9f, 0x9c, 0x07, 0xba, 0x93,
 0x1c, 0x4a, 0x47, 0x75, 0x3f, 0x48, 0x22, 0x78, 0x4a, 0x6c, 0x32, 0x22, 0x6b, 0xeb, 0xd3, 0x75,
 0x7a, 0x97, 0x0c, 0x9a, 0xff, 0x00, 0xb6, 0x31, 0xc9, 0x7b, 0x5b, 0xd9, 0x96, 0x7a, 0xc7, 0x9b,
 0x80, 0xe5, 0x5c, 0xc7, 0xe3, 0x0c, 0x45, 0xf0, 0xdf, 0x15, 0xb0, 0x7d, 0x45, 0x1e, 0x1e, 0xad,
 0x6a, 0x6a, 0xe5, 0xd5, 0xec, 0x44, 0xe0, 0x97, 0x3f, 0x33, 0xb5, 0x3b, 0xaf, 0x80, 0xcc, 0x6a,
 0x3b, 0x7c, 0x93, 0x7a, 0xf4, 0x61, 0xf3, 0x5f, 0x50, 0xcd, 0xb0, 0xd6, 0x95, 0x99, 0x89, 0x69,
 0xc9, 0x82, 0x97, 0xf9, 0xc3, 0xee, 0xc9, 0x9c, 0x3f, 0x9f, 0x92, 0x2e, 0x8f, 0x22, 0xa9, 0xc9,
 0xa6, 0xda, 0xc8, 0xf2, 0xf1, 0x93, 0xca, 0xd1, 0xab, 0xd6, 0x42, 0x34, 0x93, 0x5e, 0xd5, 0x56,
 0x68, 0xa9, 0x63, 0x46, 0x3e, 0x43, 0xac, 0xcf, 0xe1, 0x75, 0xb7, 0x9c, 0x3e, 0x46, 0xf0, 0xea,
 0x82, 0xb0, 0xb6, 0x7f, 0x80, 0xaa, 0xa6, 0x9a, 0xe2, 0xce, 0xfb, 0x17, 0x1f, 0x1e, 0x9f, 0x6c,
 0xff, 0x00, 0xea, 0x0d, 0x2d, 0x43, 0x67, 0x39, 0x75, 0x74, 0xd3, 0x5c, 0x61, 0xff, 0x00, 0x60,
 0xe3, 0xe2, 0x63, 0x9d, 0x4b, 0x75, 0x46, 0xdc, 0xde, 0x0e, 0x1f, 0x73, 0x86, 0x28, 0x69, 0x96,
 0x71, 0xbc, 0x43, 0x2f, 0x62, 0xcd, 0xc5, 0x30, 0xc8, 0xb4, 0x66, 0xdb, 0x06, 0x2c, 0x26, 0x44,
 0xe9, 0x65, 0x48, 0x6e, 0x62, 0xb9, 0x2e, 0x88, 0xe5, 0xd1, 0x7a, 0x14, 0x5c, 0xed, 0x5c, 0xaa,
 0xee, 0x64, 0x53, 0x8a, 0x9f, 0x46, 0x78, 0x30, 0x6c, 0x5f, 0x0c, 0xcc, 0xb8, 0x47, 0xaf, 0x1c,
 0xd7, 0x2c, 0xe9, 0x99, 0x17, 0x45, 0x58, 0x72, 0x12, 0x6a, 0xaa, 0x8c, 0x8d, 0xba, 0xba, 0x3a,
 0x23, 0xf4, 0xe2, 0xad, 0xd7, 0x82, 0x27, 0x4e, 0x8b, 0xa9, 0x4d, 0x9c, 0x9c, 0xf8, 0xf8, 0xf4,
 0x9c, 0xb7, 0x7c, 0xe8, 0x88, 0xba, 0xf0, 0x5f, 0x9c, 0xd9, 0x36, 0x69, 0x97, 0x9f, 0x9a, 0x33,
 0xde, 0x11, 0x81, 0xa3, 0x55, 0x59, 0x31, 0x30, 0x95, 0xb4, 0xe8, 0x86, 0xdf, 0x29, 0xeb, 0xfa,
 0xa8, 0xa7, 0xdd, 0xd3, 0x39, 0x03, 0x26, 0xc4, 0x92, 0xf5, 0x13, 0xf2, 0x9e, 0x06, 0xb2, 0xfa,
 0x69, 0xb9, 0xea, 0x18, 0x69, 0xc3, 0xd3, 0xa6, 0xbf, 0x39, 0xad, 0x65, 0x3d, 0x91, 0x65, 0x4c,
 0xa5, 0x9c, 0x66, 0x33, 0x26, 0x05, 0x02, 0x3c, 0xbb, 0xe2, 0xcb, 0x3a, 0x02, 0x4b, 0x39, 0xfb,
 0xf0, 0xa1, 0x2b, 0x95, 0x15, 0x5c, 0xcd, 0x78, 0xa6, 0xa8, 0x9a, 0x69, 0xaa, 0x97, 0x15, 0xf3,
 0x74, 0x79, 0x7d, 0xa0, 0xa4, 0xe2, 0xbc, 0x45, 0x66, 0x2d, 0xaf, 0x2f, 0xc9, 0xcb, 0xa5, 0x9a,
 0xc6, 0xa3, 0x58, 0xdd, 0xd6, 0xa2, 0x68, 0xd4, 0x4e, 0x84, 0xe8, 0x43, 0xe6, 0x1f, 0x09, 0xec,
 0xe3, 0x12, 0x7b, 0x31, 0xfa, 0xd3, 0x93, 0x8a, 0xa9, 0x27, 0x87, 0xaa, 0x2c, 0xce, 0xea, 0xfe,
 0xf9, 0x1d, 0x53, 0x92, 0xd9, 0xa8, 0xba, 0x7a, 0x75, 0x3e, 0xb6, 0x89, 0x2f, 0xa7, 0x14, 0x43,
 0xe6, 0x5c, 0xdf, 0xe0, 0xe7, 0x99, 0xa7, 0x31, 0x29, 0xcc, 0x4a, 0x4f, 0x32, 0x61, 0xd3, 0xd1,
 0xa6, 0x63, 0x3e, 0x33, 0x92, 0x62, 0x1b, 0xe0, 0xb9, 0xce, 0x72, 0xaa, 0xaf, 0x1f, 0x29, 0x3a,
 0x7a, 0xcd, 0xf9, 0x2f, 0x36, 0xae, 0xa1, 0xe5, 0xfd, 0x9e, 0xc7, 0xc5, 0xe3, 0xf2, 0xa7, 0x37,
 0x26, 0xd1, 0x13, 0x11, 0xe5, 0xbe, 0xf3, 0xf5, 0x7c, 0xf6, 0x59, 0xc3, 0xa4, 0x27, 0x71, 0x29,
 0xc8, 0x72, 0x72, 0x12, 0xb1, 0xa6, 0xa6, 0x22, 0x2e, 0x8c, 0x85, 0x05, 0x8a, 0xe7, 0x3b, 0xe2,
 0x43, 0x7e, 0xc5, 0xf6, 0x25, 0xb4, 0x7c, 0x35, 0xce, 0x5f, 0x10, 0x2c, 0xec, 0x36, 0xfe, 0x74,
 0x9c, 0x76, 0x45, 0xd7, 0xd0, 0x9a, 0xef, 0x7c, 0xc7, 0x76, 0xd8, 0x4e, 0x42, 0x6e, 0x53, 0xca,
 0x10, 0xa6, 0xa7, 0x25, 0x29, 0x63, 0x33, 0xed, 0xa9, 0x34, 0xaf, 0x6f, 0x97, 0x09, 0xba, 0xf9,
 0x30, 0xad, 0xa2, 0x71, 0x54, 0xeb, 0x5b, 0x1a, 0x71, 0xe3, 0x9b, 0x5b, 0x4f, 0x61, 0xe2, 0x5e,
 0x3d, 0xc7, 0xe2, 0x71, 0xfd, 0xee, 0x39, 0x8b, 0xcf, 0xca, 0x22, 0x27, 0xeb, 0xfd, 0x1f, 0x3d,
 0xc1, 0xd9, 0x1e, 0xd0, 0xa2, 0xc2, 0xa8, 0x99, 0x72, 0x2b, 0x13, 0x4d, 0x74, 0x89, 0x1e, 0x1b,
 0x1d, 0xf2, 0x2b, 0xb5, 0x12, 0x66, 0x1c, 0x9b, 0x99, 0xf2, 0xf4, 0x2a, 0xb8, 0xc6, 0x09, 0x39,
 0x29, 0x0b, 0x5d, 0x2a, 0xb9, 0x9a, 0xc3, 0xd7, 0xf4, 0x93, 0x54, 0x3e, 0xdd, 0x7c, 0x1d, 0x3a,
 0x0a, 0x93, 0xb2, 0x52, 0xf3, 0x52, 0xb1, 0x65, 0x66, 0xa0, 0xb2, 0x34, 0xbc, 0x66, 0xab, 0x22,
 0xc3, 0x7a, 0x6a, 0xd7, 0x35, 0x79, 0xa2, 0xa1, 0xca, 0xf8, 0x4a, 0xcc, 0x79, 0x4b, 0xcb, 0x62,
 0xf6, 0xd7, 0x3f, 0x5c, 0x7b, 0xcc, 0x71, 0xaf, 0xd9, 0xbd, 0xbe, 0x0f, 0x72, 0x68, 0x78, 0xd5,
 0x54, 0x5d, 0x51, 0x55, 0x14, 0x73, 0x9d, 0xb0, 0xb6, 0xe0, 0x99, 0xb3, 0x15, 0xc2, 0x19, 0xaa,
 0xb2, 0x52, 0x6e, 0x24, 0x16, 0x6b, 0xef, 0x51, 0xcb, 0xa7, 0xcd, 0xa0, 0x94, 0xe0, 0xfc, 0xbc,
 0x9f, 0x43, 0xa5, 0xe3, 0x25, 0x62, 0xd1, 0xf2, 0x97, 0xd5, 0xbb, 0x2e, 0xc5, 0xa2, 0x66, 0x0c,
 0x8b, 0x87, 0x62, 0x11, 0xdc, 0xaf, 0x98, 0x46, 0x2c, 0x18, 0xce, 0x5e, 0x6e, 0x7b, 0x17, 0x4d,
 0x7e, 0x34, 0xd1, 0x7e, 0x33, 0x62, 0x7c, 0x13, 0x9f, 0xf8, 0x33, 0x3d, 0xd1, 0xb2, 0x2c, 0xec,
 0x35, 0x5d, 0x52, 0x16, 0x20, 0xe4, 0x4b, 0x6a, 0xc6, 0xa9, 0xd3, 0x9f, 0x0a, 0xc7, 0xa1, 0xe3,
 0xe5, 0x9b, 0x63, 0xac, 0xcb, 0xe4, 0xde, 0x2b, 0x48, 0xc1, 0xcd, 0xc9, 0x4a, 0xfc, 0xa2, 0x7f,
 0x9f, 0x9b, 0x9d, 0xed, 0xa2, 0x1e, 0xee, 0xcd, 0xb1, 0x65, 0xd3, 0xa2, 0x17, 0xda, 0xb0, 0xf9,
 0xa1, 0x4f, 0xa8, 0xb6, 0xe1, 0x0f, 0x77, 0x66, 0x18, 0xc2, 0xe9, 0xc9, 0x21, 0x7d, 0xab, 0x0f,
 0x97, 0x7a, 0x0e, 0xb7, 0xc4, 0x67, 0x79, 0x23, 0xf0, 0xf6, 0xbe, 0xca, 0x4e, 0xf8, 0x73, 0xfe,
 0xa9, 0xfe, 0x50, 0xcf, 0x87, 0xcd, 0x3a, 0x4e, 0x76, 0x04, 0xdc, 0x34, 0x45, 0x7c, 0x18, 0x8d,
 0x88, 0xd4, 0x5e, 0x4a, 0xad, 0x5d, 0x78, 0xfc, 0x86, 0x4c, 0x56, 0x7a, 0x6b, 0x14, 0xc4, 0x63,
 0x4f, 0xce, 0x46, 0x74, 0x68, 0xf1, 0xde, 0xae, 0x7b, 0x97, 0xaf, 0xb8, 0xa8, 0x9c, 0xf8, 0x9d,
 0x63, 0x62, 0x19, 0x26, 0x5b, 0x12, 0x84, 0xfc, 0xc3, 0x8a, 0x40, 0x6c, 0x68, 0x30, 0xe2, 0x2b,
 0x25, 0x61, 0x3d, 0x35, 0x6b, 0x9c, 0x9c, 0xde, 0xa9, 0xd2, 0x89, 0xc9, 0x13, 0xac, 0xe3, 0x61,
 0xc7, 0x6c, 0xb6, 0xe8, 0xab, 0xba, 0xe6, 0xf2, 0xb1, 0x70, 0xf1, 0x4e, 0x7c, 0x9f, 0x4f, 0xf9,
 0xa7, 0x3c, 0xc3, 0xb2, 0xe6, 0x3d, 0x88, 0x41, 0xad, 0x25, 0x83, 0xce, 0xcc, 0x43, 0x5e, 0x4f,
 0x64, 0x15, 0x54, 0x5f, 0x8c, 0xa9, 0x88, 0x61, 0xf3, 0xb8, 0x7c, 0x7a, 0x33, 0xf2, 0x91, 0xa5,
 0xa2, 0x7b, 0xc8, 0xac, 0x56, 0xaf, 0xce, 0x7d, 0x64, 0xe8, 0x3a, 0x22, 0x22, 0x27, 0x04, 0xe4,
 0x9d, 0x46, 0xb3, 0xb4, 0x4c, 0x02, 0x06, 0x37, 0x95, 0xa7, 0x60, 0xc4, 0x86, 0x8b, 0x1e, 0x0c,
 0x27, 0x45, 0x97, 0x7a, 0xf3, 0x63, 0x9a, 0x9a, 0xf0, 0xb2, 0xe9, 0xa1, 0xd9, 0x5f, 0xc2, 0xe2,
 0x29, 0x33, 0x5b, 0x6e, 0x5e, 0x77, 0x8f, 0xed, 0x3f, 0xbc, 0xcd, 0x15, 0xbd, 0x35, 0x59, 0xfd,
 0xbe, 0x6f, 0x99, 0xcb, 0x12, 0x13, 0x51, 0xe4, 0xa6, 0xa1, 0x4d, 0x4b, 0xc4, 0x74, 0x38, 0xb0,
 0x9e, 0x8f, 0x63, 0x93, 0xa1, 0x50, 0xae, 0x7a, 0x87, 0x51, 0x13, 0xa9, 0xdc, 0x3d, 0x6c, 0xc4,
 0x4c, 0x6a, 0x4c, 0xb3, 0x06, 0x31, 0x39, 0x8e, 0x62, 0x2f, 0x9d, 0x9d, 0x7a, 0x2c, 0x45, 0xe0,
 0xd6, 0xa7, 0x06, 0xb1, 0xbd, 0x08, 0x89, 0xd0, 0x86, 0x1c, 0x3b, 0x0b, 0xc4, 0x71, 0x17, 0xab,
 0x64, 0x64, 0xa6, 0x26, 0x55, 0x39, 0xd3, 0x62, 0xae, 0x83, 0xad, 0x9d, 0xe5, 0xbf, 0x5c, 0x78,
 0xea, 0x40, 0x8b, 0xbc, 0x92, 0x90, 0x5b, 0x52, 0x3b, 0x93, 0x9e, 0x9a, 0xf0, 0x6a, 0x5d, 0x57,
 0xef, 0x3b, 0xa4, 0xac, 0x94, 0xbc, 0x94, 0xb3, 0x25, 0xa5, 0x20, 0x32, 0x04, 0x16, 0x26, 0x8d,
 0x63, 0x13, 0x44, 0x43, 0xb3, 0xe1, 0xf0, 0x6d, 0xcb, 0x99, 0xbd, 0xe7, 0x51, 0xfc, 0xdd, 0x2f,
 0x88, 0x78, 0xb6, 0x3e, 0x04, 0xc6, 0x1c, 0x71, 0xb9, 0xed, 0xf4, 0x87, 0xce, 0x78, 0x96, 0x13,
 0x89, 0x61, 0xca, 0x89, 0x3d, 0x23, 0x31, 0x2d, 0xaf, 0x25, 0x89, 0x0d, 0x51, 0x17, 0xe3, 0x28,
 0xbb, 0x82, 0x9f, 0x4a, 0xcf, 0xc9, 0xcb, 0xce, 0xca, 0x44, 0x94, 0x9b, 0x84, 0xd8, 0xb0, 0x22,
 0x26, 0x8f, 0x6b, 0x93, 0x5f, 0xfc, 0x5b, 0x9f, 0x3c, 0x66, 0x19, 0x15, 0xc3, 0x71, 0xb9, 0xc9,
 0x05, 0x5d, 0x68, 0x46, 0x73, 0x11, 0x7a, 0xd1, 0x17, 0x87, 0xcc, 0x47, 0x3f, 0x81, 0xf0, 0xba,
 0x98, 0x9d, 0xc4, 0xb6, 0xf8, 0x5f, 0x8a, 0x47, 0x36, 0x26, 0x26, 0x35, 0x30, 0xa2, 0xde, 0x67,
 0x66, 0xd9, 0xb6, 0x2a, 0xfc, 0x53, 0x2e, 0xb5, 0x91, 0x9d, 0xbd, 0x1e, 0x51, 0xd4, 0x5c, 0xaa,
 0xbc, 0x5c, 0xdd, 0x3c, 0x95, 0xf9, 0x38, 0x7c, 0x47, 0x19, 0x43, 0xa2, 0xec, 0x4e, 0x22, 0xac,
 0xde, 0x27, 0x03, 0xa1, 0x61, 0xb1, 0xfa, 0x7a, 0x15, 0x53, 0xef, 0x2f, 0xc2, 0x32, 0xcd, 0x39,
 0x31, 0x11, 0xf5, 0xf2, 0x3c, 0x6b, 0x14, 0x5f, 0x89, 0x6b, 0x4f, 0xce, 0x3c, 0xdd, 0x19, 0x5a,
 0x41, 0x5a, 0x5a, 0x56, 0x8a, 0x33, 0x6c, 0xff, 0x00, 0x8a, 0x72, 0xf4, 0xe4, 0xf3, 0x57, 0x48,
 0x8c, 0x87, 0xbb, 0x0f, 0xf4, 0xd7, 0x82, 0x7d, 0x3a, 0xfc, 0x47, 0xad, 0xbe, 0x58, 0xa5, 0x66,
 0xd3, 0xf4, 0x78, 0xcc, 0x55, 0x9c, 0x97, 0x8a, 0x57, 0xe7, 0x2e, 0x77, 0xb4, 0xbc, 0xc4, 0xe9,
 0xa9, 0xc7, 0xe1, 0x12, 0x91, 0x15, 0x25, 0xa0, 0xbb, 0x48, 0xaa, 0x8b, 0xfb, 0xe3, 0xd3, 0xa3,
 0xd0, 0x86, 0x90, 0xbc, 0xc9, 0x3d, 0xca, 0xe5, 0x57, 0x39, 0x55, 0x55, 0x57, 0x55, 0x55, 0xe9,
 0x22, 0x78, 0x6e, 0x4f, 0x22, 0xdc, 0x8c, 0x93, 0x7b, 0x7d, 0x5f, 0x42, 0xe3, 0x71, 0xe9, 0xc7,
 0xc7, 0x18, 0xe9, 0xf4, 0x64, 0x85, 0x0a, 0x24, 0x58, 0xad, 0x85, 0x06, 0x1b, 0xa2, 0x3d, 0xcb,
 0xa2, 0x35, 0xa9, 0xaa, 0xa8, 0xea, 0x1e, 0x50, 0xcc, 0x71, 0x21, 0xef, 0xa6, 0x19, 0x11, 0xa9,
 0xd4, 0xe7, 0x35, 0xab, 0xf2, 0x2a, 0xea, 0x74, 0x5c, 0x89, 0x97, 0x61, 0x61, 0x18, 0x64, 0x29,
 0x88, 0xb0, 0xda, 0xb3, 0xd1, 0xda, 0x8f, 0x7b, 0x95, 0x38, 0xb1, 0x17, 0x8a, 0x35, 0x3a, 0xae,
 0x6c, 0x4a, 0xdd, 0x0e, 0xef, 0x8b, 0xe0, 0x95, 0xbd, 0x22, 0xd9, 0x67, 0x53, 0x3f, 0x48, 0x74,
 0x9c, 0xaf, 0x1d, 0x9a, 0x64, 0x9a, 0xe2, 0xae, 0xe2, 0x3e, 0xb2, 0xe0, 0x73, 0xf2, 0x13, 0x92,
 0x31, 0x69, 0x4e, 0x4b, 0x45, 0x80, 0xfe, 0xa7, 0xb7, 0x4d, 0x7b, 0xca, 0xca, 0x77, 0x6c, 0x6b,
 0x0a, 0x94, 0xc5, 0x64, 0x5f, 0x29, 0x37, 0x0d, 0x1c, 0xd5, 0xf6, 0xae, 0xe9, 0x62, 0xf5, 0xa1,
 0xc4, 0xf1, 0x59, 0x28, 0xb8, 0x7e, 0x23, 0x31, 0x25, 0x1b, 0xdb, 0xc1, 0x7a, 0xb5, 0x6f, 0xa7,
 0x49, 0xd7, 0x78, 0x87, 0x87, 0xcf, 0x12, 0x62, 0x62, 0x77, 0x12, 0xec, 0x7c, 0x3f, 0xc4, 0x6b,
 0xcc, 0x89, 0x8d, 0x6a, 0x60, 0xd7, 0x27, 0x63, 0x8f, 0xc2, 0x27, 0xd1, 0xb1, 0x1c, 0xab, 0x29,
 0x15, 0xc8, 0x91, 0x5b, 0xd5, 0xfc, 0x64, 0xba, 0x7d, 0x07, 0x55, 0xd1, 0x1c, 0x88, 0xad, 0x54,
 0x54, 0x5e, 0x28, 0xa9, 0xd2, 0x87, 0x0c, 0x45, 0xd1, 0x79, 0x1d, 0x63, 0x67, 0xf3, 0xcb, 0x3f,
 0x97, 0x21, 0xb5, 0xeb, 0xac, 0x49, 0x67, 0x2c, 0x17, 0x7a, 0x13, 0xda, 0xfc, 0xcb, 0xf3, 0x1d,
 0x9f, 0x80, 0xf3, 0x27, 0x73, 0x82, 0xdf, 0x98, 0xfe, 0xae, 0x07, 0x8d, 0x71, 0xa2, 0x22, 0x33,
 0x57, 0xf7, 0x9c, 0xab, 0x48, 0x2b, 0x4b, 0x2a, 0xd2, 0x0e, 0x69, 0xea, 0x76, 0xf3, 0xb1, 0x65,
 0x75, 0x69, 0x15, 0x69, 0x65, 0xcd, 0x31, 0xb9, 0xa5, 0x44, 0xaa, 0x25, 0x5d, 0x5a, 0x84, 0x5c,
 0xd2, 0xc2, 0xb4, 0x82, 0xb4, 0xad, 0xaa, 0x25, 0xad, 0xe7, 0x88, 0x2f, 0x89, 0x81, 0xab, 0x21,
 0xb1, 0xcf, 0x72, 0xc6, 0x62, 0x22, 0x22, 0x6a, 0xab, 0xcc, 0xd7, 0x30, 0xac, 0xa7, 0x3f, 0x30,
 0xa8, 0xf9, 0xbd, 0x25, 0x61, 0x74, 0xef, 0x71, 0x72, 0xfc, 0x5d, 0xe7, 0x46, 0x56, 0x98, 0xd5,
 0xbd, 0x48, 0x75, 0xbc, 0x8f, 0x0a, 0xc5, 0xca, 0xcf, 0xef, 0x72, 0xce, 0xfc, 0xbe, 0x4e, 0xc7,
 0x07, 0x88, 0xdf, 0x06, 0x2f, 0x77, 0x48, 0xfd, 0xe5, 0x78, 0x66, 0x15, 0x27, 0x87, 0x43, 0x56,
 0xcb, 0x43, 0xd1, 0xca, 0x9e, 0x53, 0xdd, 0xc5, 0xce, 0xf8, 0xc5, 0x79, 0xed, 0xba, 0x60, 0x4a,
 0xbf, 0xcb, 0x33, 0xef, 0x36, 0x65, 0x6f, 0x13, 0x5d, 0xcf, 0xc9, 0xa6, 0x5f, 0x55, 0xfe, 0x59,
 0x9f, 0x79, 0xb3, 0x9f, 0x4a, 0x63, 0xe0, 0xde, 0x94, 0x8d, 0x46, 0x8e, 0x26, 0x4b, 0x5f, 0x93,
 0x59, 0xb4, 0xee, 0x76, 0xe7, 0x87, 0xad, 0xf6, 0xc9, 0xe9, 0x3c, 0x24, 0xde, 0x69, 0xe9, 0x3e,
 0x79, 0x1f, 0x37, 0xad, 0x75, 0x35, 0x69, 0x17, 0x34, 0xb1, 0xbb, 0xf4, 0x10, 0x56, 0x9f, 0x58,
 0xac, 0xf9, 0x3c, 0x56, 0xd5, 0xd5, 0xa4, 0x55, 0xa5, 0x85, 0x69, 0x17, 0x34, 0xd9, 0x16, 0x54,
 0x4a, 0xb2, 0xb4, 0x83, 0x9a, 0x59, 0x56, 0x90, 0x56, 0x99, 0xda, 0xa2, 0x55, 0xd5, 0xa4, 0x15,
 0xa5, 0x95, 0x69, 0x05, 0x69, 0x7b, 0x54, 0x4a, 0xba, 0xb4, 0x8a, 0xb4, 0xb1, 0xba, 0x41, 0x5a,
 0x67, 0x6a, 0x89, 0x77, 0x98, 0x71, 0xae, 0x58, 0x87, 0x18, 0x4d, 0x0e, 0x35, 0xcc, 0xec, 0x8f,
 0x73, 0xf3, 0x5e, 0xda, 0x22, 0xe7, 0x2c, 0x8f, 0x72, 0xc4, 0x38, 0xf7, 0x12, 0xb2, 0x3d, 0xcb,
 0x0c, 0x8d, 0x73, 0x3b, 0x6c, 0x8b, 0x9d, 0x43, 0x8f, 0x72, 0xc4, 0x38, 0xfc, 0x79, 0x89, 0x19,
 0x1a, 0xe5, 0x88, 0x71, 0xee, 0x56, 0xdb, 0x62, 0xe7, 0x8c, 0x8f, 0x72, 0xc4, 0x38, 0xf7, 0x11,
 0xc3, 0x8f, 0x72, 0xc3, 0x23, 0xf1, 0xe6, 0x54, 0x4b, 0x64, 0x5d, 0xf2, 0xff, 0x00, 0x84, 0x33,
 0xb7, 0xb6, 0xbb, 0x8d, 0x3b, 0xae, 0x87, 0xd8, 0xb0, 0xe7, 0xc6, 0xf9, 0xb7, 0xb7, 0x6f, 0x6d,
 0x5b, 0x18, 0x5b, 0x41, 0xfb, 0x16, 0x1a, 0x22, 0x9e, 0xa7, 0x0f, 0xea, 0xeb, 0xf8, 0x87, 0xa3,
 0xc5, 0xfa, 0xba, 0xfe, 0x0c, 0x30, 0x0c, 0x13, 0x17, 0xc7, 0xe7, 0xfd, 0x41, 0x82, 0xe1, 0xd3,
 0x33, 0xf3, 0x5b, 0x8b, 0x12, 0x94, 0x06, 0x6f, 0x3b, 0x75, 0x39, 0xae, 0x9d, 0x49, 0xa9, 0xb0,
 0x26, 0xcb, 0xb6, 0x86, 0xbc, 0xb2, 0x76, 0x34, 0xbf, 0xec, 0xae, 0x36, 0x6f, 0x05, 0x97, 0x6e,
 0x6d, 0x35, 0xcb, 0xfe, 0x8e, 0x8f, 0xff, 0x00, 0x29, 0xf5, 0x64, 0x38, 0xe9, 0x63, 0x87, 0xca,
 0xe6, 0x5b, 0x0d, 0xfa, 0x62, 0x1c, 0x7c, 0xfc, 0x99, 0xc7, 0x7e, 0x98, 0x87, 0xc5, 0xe9, 0xb2,
 0xbd, 0xa2, 0xaf, 0x2c, 0x99, 0x8d, 0xaf, 0xfb, 0x2b, 0x89, 0x26, 0xca, 0x36, 0x90, 0xbc, 0xb2,
 0x56, 0x39, 0xfb, 0x23, 0x8f, 0xb5, 0xe1, 0x47, 0x4b, 0x16, 0xa1, 0xcc, 0x27, 0x52, 0x1a, 0x3f,
 0xea, 0x37, 0xec, 0x88, 0xe6, 0x4c, 0xfd, 0x1f, 0x10, 0x26, 0xc9, 0x76, 0x94, 0xbc, 0xb2, 0x46,
 0x3a, 0xbf, 0xec, 0x8e, 0x3a, 0xc7, 0x82, 0xae, 0x43, 0xce, 0xb9, 0x63, 0x6b, 0x92, 0xd8, 0xae,
 0x39, 0x96, 0x31, 0x5c, 0x3a, 0x4d, 0xb2, 0x73, 0x10, 0xd6, 0x3c, 0xc4, 0xba, 0xb1, 0x88, 0xe7,
 0x33, 0x44, 0x4d, 0x57, 0xac, 0xfa, 0x46, 0x14, 0xc2, 0x58, 0xb7, 0x06, 0x67, 0x45, 0xe1, 0xa1,
 0x8b, 0x73, 0xed, 0x6a, 0xcd, 0x74, 0xaf, 0x89, 0xdf, 0x96, 0x9b, 0x64, 0xbc, 0xea, 0xa7, 0x48,
 0xc6, 0x5f, 0x10, 0x72, 0x2f, 0x07, 0x1a, 0x74, 0x19, 0xa5, 0xe1, 0xc4, 0xb9, 0x06, 0x6f, 0x8f,
 0xb6, 0x38, 0xb5, 0xb2, 0xa9, 0x97, 0x4e, 0x37, 0xff, 0x00, 0xa8, 0x54, 0xca, 0x4c, 0x6c, 0xcf,
 0x2d, 0xf2, 0xd7, 0xc7, 0x2f, 0xfb, 0x07, 0x1f, 0x10, 0x1f, 0x63, 0x78, 0x76, 0x47, 0xab, 0xb3,
 0xac, 0xbe, 0x9a, 0xeb, 0xa6, 0x2e, 0xf5, 0xff, 0x00, 0x82, 0xa7, 0xc7, 0x27, 0x75, 0xc5, 0x9d,
 0xe2, 0x87, 0x26, 0xb3, 0xd5, 0x1b, 0x49, 0x9c, 0x5d, 0xa2, 0x73, 0x5f, 0xa4, 0xfd, 0x40, 0xc9,
 0x19, 0x5e, 0x1e, 0x5e, 0xc8, 0xb8, 0x1e, 0x09, 0x0a, 0x1e, 0xeb, 0x64, 0xb0, 0xf8, 0x30, 0x95,
 0x34, 0xfc, 0xe4, 0x62, 0x2b, 0x97, 0xe3, 0x72, 0xaa, 0x9f, 0x99, 0xd9, 0x6a, 0x02, 0x4d, 0xe6,
 0x2c, 0x36, 0x55, 0xc9, 0xaa, 0x46, 0x9b, 0x85, 0x0d, 0x53, 0xd2, 0xf4, 0x4f, 0xbc, 0xfd, 0x6e,
 0xd6, 0x5a, 0x2e, 0xad, 0xf6, 0xab, 0xc8, 0xc7, 0x23, 0x2f, 0x46, 0x9a, 0x39, 0x3c, 0x7f, 0x7f,
 0x5d, 0x34, 0xe8, 0xf2, 0x4e, 0x6f, 0x41, 0x4a, 0x2c, 0xb2, 0xa7, 0x41, 0xbb, 0xcc, 0x48, 0x23,
 0x93, 0x54, 0x44, 0x54, 0xb0, 0xb6, 0x67, 0x0f, 0xfe, 0x28, 0xa7, 0x21, 0xe7, 0xf9, 0x1e, 0x15,
 0x31, 0xf2, 0x86, 0xa1, 0x12, 0x5e, 0xc5, 0x68, 0xb2, 0xd6, 0x36, 0x69, 0x89, 0x05, 0x45, 0xe0,
 0x87, 0x29, 0xdb, 0x86, 0xd5, 0x30, 0x1d, 0x99, 0xca, 0x32, 0x04, 0x76, 0x78, 0xc3, 0x1b, 0x98,
 0x66, 0xfc, 0xbe, 0x1f, 0x0d, 0xfb, 0xab, 0xbb, 0xcb, 0x7e, 0x23, 0xbf, 0x31, 0xbd, 0x5d, 0x2b,
 0xa7, 0x0e, 0xb3, 0x95, 0x4c, 0xbb, 0x75, 0x16, 0xf0, 0xcb, 0xde, 0xdd, 0x35, 0x8f, 0x36, 0xcd,
 0x16, 0x59, 0x57, 0x86, 0xee, 0xbf, 0x11, 0xae, 0xe6, 0x1c, 0xc3, 0x96, 0xf0, 0x24, 0x5f, 0x1c,
 0xe3, 0xd8, 0x64, 0x82, 0xa7, 0xe6, 0xc7, 0x99, 0x6b, 0x5d, 0xfa, 0xba, 0xeb, 0xf3, 0x1f, 0x21,
 0x67, 0x9d, 0xb2, 0x67, 0xec, 0xd9, 0x16, 0x23, 0x66, 0x71, 0xb8, 0xb2, 0x12, 0x6e, 0x5e, 0x12,
 0xb2, 0x0a, 0xb0, 0x61, 0xa2, 0x75, 0x2a, 0xa7, 0x94, 0xef, 0x8d, 0x54, 0xe7, 0xcf, 0x88, 0xf7,
 0x3d, 0x5e, 0xe7, 0x2a, 0xb9, 0x57, 0x55, 0x55, 0xe2, 0xaa, 0x6d, 0xf7, 0xb3, 0x0e, 0x76, 0x2f,
 0x64, 0xe2, 0xde, 0x79, 0x6f, 0xaf, 0xc7, 0xff, 0x00, 0x5f, 0x5e, 0x66, 0x0d, 0xb8, 0x6c, 0xeb,
 0x0e, 0x47, 0x24, 0xbc, 0xfc, 0xd6, 0x27, 0x11, 0x39, 0x36, 0x52, 0x59, 0x74, 0x55, 0xfd, 0x27,
 0xee, 0xa1, 0xce, 0x33, 0x2f, 0x84, 0x4c, 0xdc, 0x64, 0x7c, 0x2c, 0xbf, 0x97, 0xa0, 0xcb, 0x22,
 0xfb, 0x58, 0xd3, 0x91, 0x2a, 0x3b, 0xd3, 0xb8, 0xdd, 0x13, 0xe7, 0x53, 0x84, 0x2a, 0xaa, 0xf3,
 0x18, 0xe0, 0x98, 0x16, 0x33, 0x8d, 0xcc, 0x24, 0x1c, 0x1f, 0x0a, 0x9d, 0x9f, 0x89, 0xae, 0x9b,
 0xb2, 0xf0, 0x1d, 0x13, 0x4f, 0x4e, 0x89, 0xc0, 0xc4, 0xe6, 0xbc, 0xfd, 0x5d, 0x86, 0x2f, 0x66,
 0x7c, 0x37, 0x07, 0xe9, 0x5e, 0xbb, 0xfc, 0xcf, 0xfc, 0x86, 0x3c, 0x7b, 0x14, 0x9b, 0xc6, 0xb1,
 0x69, 0xbc, 0x56, 0x7e, 0x22, 0x44, 0x9b, 0x9b, 0x8a, 0xe8, 0xb1, 0x9c, 0x8d, 0x46, 0xa2, 0xb9,
 0x79, 0xf0, 0x4e, 0x08, 0x50, 0x2e, 0xe3, 0x58, 0x6c, 0xee, 0x11, 0x89, 0xcc, 0xe1, 0x98, 0x94,
 0xb3, 0xe5, 0x67, 0x25, 0xa2, 0x2c, 0x38, 0xd0, 0x5f, 0xed, 0x98, 0xe4, 0xe6, 0x8a, 0x52, 0x35,
 0x3d, 0x05, 0x62, 0xb1, 0x58, 0x8a, 0xfc, 0xbe, 0x8f, 0xa4, 0x7c, 0x15, 0x59, 0xbd, 0x93, 0x31,
 0x7f, 0xfe, 0xe2, 0x9f, 0x64, 0x87, 0x5c, 0x7c, 0x23, 0x96, 0x78, 0x24, 0xc3, 0xde, 0xc9, 0x38,
 0xc2, 0xff, 0x00, 0xa4, 0x5b, 0xf6, 0x4d, 0x3b, 0x13, 0xe0, 0xa9, 0xda, 0x71, 0xaf, 0xac, 0x70,
 0xf9, 0x27, 0xb4, 0x56, 0xd7, 0x89, 0x65, 0xfc, 0xc7, 0xf2, 0x87, 0x33, 0xdb, 0xc4, 0x3d, 0xdd,
 0x95, 0xe3, 0x4b, 0x68, 0x3f, 0x6c, 0xc3, 0xe5, 0x13, 0xeb, 0x9f, 0x08, 0x08, 0x7b, 0xbb, 0x25,
 0xc6, 0xd6, 0xd0, 0x7e, 0xd9, 0x87, 0xc8, 0xca, 0x71, 0xb9, 0x93, 0xbc, 0x9f, 0xb9, 0xec, 0xfd,
 0x8f, 0x9d, 0xf0, 0x66, 0x7f, 0xf6, 0x9f, 0xe5, 0x0f, 0x53, 0x43, 0xea, 0xdd, 0x99, 0xc8, 0x36,
 0x53, 0x67, 0xb8, 0x1c, 0x26, 0xb7, 0x4d, 0x65, 0x1b, 0x11, 0xc9, 0xfc, 0x67, 0x6a, 0xe5, 0xfa,
 0x4f, 0x94, 0x53, 0x91, 0xf6, 0x5e, 0x51, 0x80, 0x8d, 0xca, 0x38, 0x3a, 0x22, 0x70, 0x49, 0x08,
 0x1f, 0x66, 0xd3, 0x6f, 0x87, 0xce, 0xaf, 0x32, 0xd7, 0xed, 0x7e, 0x49, 0xae, 0x0c, 0x71, 0xde,
 0x7f, 0xa0, 0x7c, 0x2b, 0x15, 0xa6, 0xe5, 0xf7, 0xe5, 0xe2, 0xb1, 0x53, 0x83, 0x98, 0xe4, 0x5f,
 0x8d, 0x34, 0x1c, 0x3e, 0x15, 0x8c, 0x11, 0x60, 0xf9, 0x2b, 0xc3, 0xa0, 0xee, 0x62, 0xfe, 0x5a,
 0x78, 0x5a, 0x64, 0xd4, 0xc3, 0xe2, 0xb7, 0xa6, 0x8f, 0x54, 0xb8, 0x21, 0xec, 0x5f, 0xdf, 0x1d,
 0xe9, 0x53, 0xc4, 0x3c, 0xbb, 0xed, 0x0e, 0xd3, 0xb0, 0x29, 0x26, 0xa6, 0x5f, 0xc4, 0x27, 0x15,
 0x3c, 0xa8, 0xb3, 0x29, 0x0f, 0x5b, 0x35, 0xba, 0xfd, 0x2e, 0x53, 0xa2, 0xbe, 0x15, 0x8d, 0x4f,
 0x60, 0xb0, 0x75, 0xc8, 0x3b, 0xe8, 0x9e, 0xda, 0x76, 0x2f, 0xcc, 0x8d, 0x37, 0xa7, 0xc2, 0xb1,
 0xea, 0x38, 0x33, 0xd3, 0x82, 0xb0, 0xf9, 0x9f, 0x8c, 0x65, 0x9b, 0x73, 0xb2, 0x6f, 0xb9, 0x53,
 0xe0, 0xd8, 0xf9, 0xff, 0x00, 0x6a, 0xb0, 0xd2, 0x16, 0x7c, 0xc4, 0x9a, 0x9d, 0x2e, 0x63, 0xbe,
 0x56, 0x35, 0x4f, 0xa3, 0xe2, 0x42, 0x5d, 0x39, 0x1f, 0x3b, 0xed, 0x89, 0x37, 0x76, 0x87, 0x89,
 0x27, 0x52, 0x42, 0xfb, 0x36, 0x9a, 0x3c, 0x5e, 0xdb, 0xc3, 0x1f, 0x9f, 0xe8, 0xed, 0x7d, 0x98,
 0xbe, 0xf9, 0x16, 0x8f, 0xd9, 0xfd, 0x61, 0xa8, 0xa1, 0xd0, 0xb6, 0x20, 0x9a, 0xe3, 0x18, 0x8a,
 0x7f, 0x36, 0x4f, 0xae, 0x87, 0x3c, 0x3a, 0x3e, 0xc2, 0x9b, 0xbd, 0x8c, 0xe2, 0x5f, 0xea, 0xa9,
 0xf5, 0xd0, 0xea, 0xbc, 0x3e, 0x75, 0xc9, 0xa7, 0xe5, 0xe9, 0xfc, 0x56, 0x75, 0xc3, 0xc9, 0xf8,
 0x75, 0x17, 0x34, 0xd0, 0xb6, 0xd1, 0x1d, 0x61, 0x60, 0x32, 0x92, 0xc8, 0xba, 0x56, 0x98, 0xd5,
 0x7d, 0x0d, 0x6f, 0x7a, 0x9d, 0x15, 0xcc, 0xd0, 0xe6, 0x3b, 0x74, 0x45, 0x48, 0x78, 0x4a, 0x74,
 0x2a, 0xc5, 0x5f, 0xa8, 0x7a, 0x4f, 0x12, 0xbe, 0xb8, 0xb7, 0xff, 0x00, 0x9f, 0x57, 0x90, 0xf0,
 0x68, 0xea, 0xe6, 0x53, 0xf7, 0xff, 0x00, 0x29, 0x72, 0xe5, 0x2d, 0x61, 0x29, 0x05, 0xd8, 0x94,
 0xaa, 0x4c, 0x39, 0xad, 0x83, 0x59, 0x95, 0x15, 0xdc, 0x91, 0xbb, 0xc9, 0xaf, 0xcc, 0x55, 0xe8,
 0x04, 0x55, 0xe8, 0x3c, 0x85, 0x67, 0x53, 0x12, 0xf7, 0xd3, 0x1b, 0x8d, 0x3b, 0xbb, 0xb3, 0x26,
 0x5d, 0xd5, 0x74, 0xc6, 0xa4, 0x79, 0xff, 0x00, 0x95, 0x20, 0xb9, 0x8f, 0x2f, 0xff, 0x00, 0x9e,
 0xa4, 0x7b, 0x53, 0x86, 0x71, 0x03, 0xba, 0x8f, 0x1e, 0xcd, 0xf6, 0xc3, 0xa1, 0xff, 0x00, 0xb7,
 0xf0, 0xfd, 0xd3, 0xfc, 0x1d, 0xc9, 0x73, 0x1e, 0x5e, 0xff, 0x00, 0x3d, 0x49, 0x76, 0x87, 0x30,
 0xda, 0x2c, 0x79, 0x29, 0xac, 0xcb, 0x12, 0x66, 0x46, 0x62, 0x14, 0xc4, 0x38, 0x90, 0xd8, 0xaa,
 0xf8, 0x6b, 0xaa, 0x6f, 0x69, 0xa2, 0xa7, 0xcc, 0x86, 0xb8, 0x8a, 0x0a, 0x71, 0xb9, 0x7e, 0x27,
 0x93, 0x95, 0x8f, 0xa2, 0xd5, 0x88, 0x72, 0xf8, 0x5e, 0x17, 0x8f, 0x89, 0x93, 0xae, 0xb6, 0x99,
 0xf2, 0xd2, 0x26, 0xf7, 0xb2, 0x19, 0x85, 0x49, 0xc9, 0xe9, 0x45, 0x5e, 0x0e, 0x86, 0xd8, 0x88,
 0x97, 0x45, 0xd3, 0xef, 0x34, 0x43, 0x6e, 0xd9, 0x43, 0xb4, 0xcd, 0x3b, 0xbe, 0xfa, 0x5e, 0x22,
 0x7d, 0x0a, 0x6a, 0xf0, 0xdb, 0xcd, 0x79, 0x54, 0x9f, 0xda, 0xdd, 0xe2, 0x55, 0xea, 0xe2, 0xde,
 0x3f, 0x63, 0xa9, 0x39, 0xa4, 0x15, 0xa5, 0x87, 0x34, 0x8a, 0xb7, 0x43, 0xdd, 0xc4, 0xbc, 0x36,
 0xd5, 0x95, 0xa4, 0x1c, 0xd2, 0xd3, 0x9a, 0x41, 0x5a, 0x54, 0x4a, 0xb6, 0xac, 0xad, 0x22, 0xad,
 0x2c, 0xb9, 0xa6, 0x37, 0x34, 0xa8, 0xb2, 0xa2, 0xca, 0xea, 0xd2, 0x0a, 0xd2, 0xd2, 0xb4, 0x82,
 0xb4, 0xa8, 0x95, 0x44, 0xab, 0x2b, 0x4d, 0x73, 0x68, 0x49, 0xa6, 0x5e, 0x5f, 0xe9, 0xd9, 0xf7,
 0x9b, 0x4a, 0xb4, 0xd6, 0xb6, 0x8c, 0x9a, 0x65, 0xc5, 0x5f, 0xe5, 0xd9, 0xf7, 0x9c, 0x4f, 0x12,
 0x9f, 0xee, 0x99, 0x3f, 0x12, 0xe6, 0xf0, 0x27, 0xfb, 0xcd, 0x3f, 0x2e, 0x66, 0x7a, 0xcf, 0x6c,
 0x9e, 0x93, 0xc3, 0xd6, 0x7b, 0x64, 0xf4, 0x9f, 0x3c, 0x8f, 0x9b, 0xda, 0x3b, 0x06, 0xe9, 0x15,
 0x69, 0x61, 0x59, 0xc1, 0x08, 0x39, 0xa7, 0xd4, 0xeb, 0x3e, 0x4f, 0x0b, 0x33, 0xe6, 0xae, 0xac,
 0x20, 0xe6, 0x96, 0x55, 0xa4, 0x15, 0xa5, 0xc4, 0xaa, 0x2c, 0xae, 0xad, 0x22, 0xad, 0x2c, 0x2b,
 0x08, 0x2b, 0x4a, 0x89, 0x57, 0x52, 0xba, 0xb1, 0x08, 0x39, 0xa5, 0x95, 0x69, 0x15, 0x69, 0x71,
 0x65, 0x6d, 0x59, 0x5a, 0x45, 0x5a, 0x58, 0x73, 0x48, 0x2b, 0x4a, 0xda, 0xa2, 0xce, 0x97, 0x0e,
 0x35, 0xcc, 0xec, 0x8d, 0x71, 0x43, 0x22, 0xdc, 0xce, 0xc8, 0xd7, 0x3f, 0x36, 0x6d, 0xc4, 0x8b,
 0x1c, 0x32, 0x35, 0xcc, 0xec, 0x8d, 0x71, 0x3b, 0x23, 0x19, 0xa1, 0xc6, 0xb9, 0x9d, 0xb6, 0x45,
 0x8e, 0x19, 0x1a, 0xe5, 0x86, 0x46, 0xb8, 0x9d, 0x91, 0xae, 0x67, 0x64, 0x6b, 0x95, 0xb5, 0xc5,
 0xce, 0x19, 0x1b, 0x87, 0x32, 0xc3, 0x23, 0x5c, 0x4a, 0xc8, 0xd7, 0x2c, 0x32, 0x35, 0xcc, 0xed,
 0xb6, 0x2e, 0xf9, 0xeb, 0x6e, 0x2e, 0xde, 0xda, 0x7e, 0x2a, 0xee, 0xb4, 0x83, 0xf6, 0x4c, 0x34,
 0x83, 0x72, 0xdb, 0x3b, 0xb7, 0xb6, 0x91, 0x89, 0xad, 0xa1, 0x7d, 0x93, 0x0d, 0x39, 0x4f, 0x59,
 0xc7, 0xfd, 0x55, 0x7f, 0x10, 0xf5, 0x98, 0x3f, 0x55, 0x5f, 0xc4, 0x3a, 0x7f, 0x83, 0x33, 0xf7,
 0x36, 0x8e, 0xe5, 0xfe, 0x61, 0x1b, 0xfe, 0x53, 0xe9, 0xe8, 0x71, 0xee, 0x7c, 0xb5, 0xe0, 0xe6,
 0xed, 0xcd, 0xa0, 0xb9, 0x7f, 0x98, 0xc6, 0xff, 0x00, 0x94, 0xfa, 0x46, 0x1c, 0x7b, 0x9d, 0x37,
 0x89, 0x4f, 0xf6, 0xdf, 0xb9, 0xd5, 0x73, 0xed, 0xac, 0xdf, 0xb8, 0xf6, 0x1c, 0x7b, 0x96, 0x61,
 0xc7, 0xb8, 0x86, 0x1c, 0x7b, 0x96, 0x61, 0xcc, 0x5c, 0xe1, 0x75, 0x38, 0xb1, 0x73, 0xe8, 0x53,
 0x17, 0x2d, 0x43, 0x99, 0xb8, 0x82, 0x1c, 0x7b, 0x96, 0x21, 0xcc, 0x5c, 0xce, 0xdb, 0x22, 0xed,
 0x86, 0x14, 0xcd, 0xcb, 0x50, 0xa6, 0x78, 0xf3, 0x35, 0xd8, 0x73, 0x17, 0x2d, 0x42, 0x98, 0xb9,
 0x51, 0x66, 0xea, 0xe4, 0x72, 0x5f, 0x0d, 0x78, 0xd5, 0x32, 0x06, 0x04, 0xde, 0xac, 0x55, 0xcb,
 0xff, 0x00, 0x05, 0x4f, 0x92, 0x8f, 0xa9, 0xbc, 0x31, 0x62, 0xd4, 0xc8, 0xb8, 0x22, 0x75, 0x62,
 0x6e, 0xfb, 0x25, 0x3e, 0x59, 0x3b, 0xee, 0x17, 0xea, 0x61, 0xda, 0x71, 0xe7, 0x78, 0xe2, 0x4f,
 0x32, 0x02, 0x23, 0xb3, 0xce, 0x02, 0xd5, 0xe4, 0xb8, 0x9c, 0xb2, 0x7f, 0xc5, 0x69, 0xfa, 0x82,
 0xd9, 0xd5, 0x48, 0xcf, 0x4d, 0xef, 0xce, 0x5f, 0xa4, 0xfc, 0xbe, 0xc8, 0x2b, 0xa6, 0x79, 0xc0,
 0x57, 0xab, 0x12, 0x96, 0xfb, 0x56, 0x9f, 0xa3, 0xfe, 0xab, 0xfe, 0xea, 0xff, 0x00, 0x2b, 0xf3,
 0x97, 0xe9, 0x34, 0x73, 0xe7, 0x53, 0x53, 0x2d, 0xfa, 0x66, 0x1b, 0x8c, 0xae, 0x22, 0xad, 0xd3,
 0xca, 0x51, 0x8c, 0x39, 0xb8, 0x31, 0x93, 0x47, 0xa2, 0x6b, 0xd6, 0x86, 0x91, 0x06, 0x6d, 0x53,
 0xa4, 0xbd, 0x02, 0x75, 0x53, 0xa4, 0xe0, 0xc5, 0xe5, 0x88, 0xcb, 0xbf, 0x99, 0xa6, 0x73, 0xc4,
 0xf0, 0xec, 0xbb, 0x95, 0x31, 0x5c, 0xc7, 0x38, 0xe4, 0x74, 0xae, 0x1b, 0x29, 0x12, 0x6a, 0x2a,
 0x22, 0xe8, 0xae, 0x46, 0x35, 0x57, 0x77, 0xd2, 0xab, 0xa2, 0x7c, 0x67, 0xe5, 0x8e, 0x76, 0xcc,
 0x78, 0x9e, 0x6d, 0xcd, 0x58, 0x86, 0x62, 0xc6, 0x23, 0x2c, 0x59, 0xd9, 0xe8, 0xcb, 0x16, 0x22,
 0xf4, 0x37, 0x5e, 0x4d, 0x4e, 0xa6, 0xb5, 0x34, 0x44, 0x4e, 0xa4, 0x3e, 0xf7, 0xf0, 0xaa, 0xc4,
 0x63, 0xb3, 0xc1, 0xef, 0x35, 0x24, 0x07, 0x2a, 0x39, 0xf0, 0xa0, 0x31, 0xda, 0x2f, 0xe6, 0xba,
 0x62, 0x1a, 0x3b, 0xe6, 0xd4, 0xfc, 0xef, 0x77, 0x33, 0xb4, 0xe2, 0x4f, 0x55, 0x76, 0xd9, 0x5a,
 0xd7, 0x7b, 0x88, 0x09, 0xaa, 0xaf, 0x03, 0xe8, 0x0d, 0x83, 0x78, 0x3b, 0xcd, 0x67, 0x4c, 0x0e,
 0x0e, 0x67, 0xcc, 0xd3, 0xb1, 0xf0, 0xec, 0x22, 0x61, 0x55, 0x65, 0x20, 0x40, 0x6a, 0x57, 0x99,
 0x6a, 0x2e, 0x8a, 0xfd, 0x57, 0x83, 0x19, 0xaa, 0x68, 0x8b, 0xa2, 0xaa, 0xf3, 0xe0, 0x9c, 0xf8,
 0x03, 0x39, 0xfc, 0x47, 0xea, 0x26, 0xc7, 0x97, 0x0f, 0xc5, 0xb6, 0x45, 0x94, 0xe7, 0xb0, 0xb5,
 0x62, 0xca, 0x3f, 0x08, 0x97, 0x6b, 0x77, 0x39, 0x35, 0xcc, 0x86, 0x8d, 0x7b, 0x7d, 0x28, 0xe6,
 0xb9, 0x15, 0x3a, 0xcd, 0xf9, 0x2f, 0xd1, 0x0d, 0x5c, 0xaf, 0x79, 0xd1, 0xac, 0x7f, 0x37, 0x3c,
 0xcb, 0xdb, 0x16, 0xd9, 0xc6, 0x5f, 0x6b, 0x16, 0x4f, 0x2a, 0xca, 0x4c, 0x45, 0x6f, 0x1a, 0xd3,
 0xba, 0xcc, 0x3d, 0x57, 0xaf, 0xcb, 0xe1, 0xf2, 0x22, 0x1b, 0x74, 0x39, 0x08, 0x32, 0xd0, 0x12,
 0x04, 0xac, 0x08, 0x50, 0x21, 0x22, 0x68, 0x90, 0xe1, 0x31, 0x18, 0xd4, 0xf8, 0x93, 0x81, 0xb9,
 0x4c, 0xe1, 0xfc, 0xfc, 0x93, 0x5d, 0xcd, 0x73, 0xb8, 0x76, 0x5a, 0xc0, 0xa7, 0x71, 0xdc, 0x5e,
 0x3b, 0x25, 0xe4, 0x64, 0x61, 0x2c, 0x68, 0xcf, 0x77, 0x52, 0x72, 0x44, 0xeb, 0x55, 0x5d, 0x11,
 0x13, 0xa5, 0x55, 0x0c, 0xd3, 0x2c, 0x4b, 0xc9, 0xf2, 0xb8, 0x79, 0xb2, 0x4e, 0xaf, 0x33, 0x2f,
 0xcf, 0x2d, 0xb9, 0xb9, 0x1d, 0xb5, 0xfc, 0xd6, 0xad, 0x5e, 0x1e, 0x35, 0x8e, 0x9f, 0xef, 0x1a,
 0x58, 0xcf, 0x34, 0x62, 0x91, 0x31, 0xbc, 0xc7, 0x89, 0x63, 0x11, 0x5b, 0xb8, 0xf9, 0xe9, 0xa8,
 0x93, 0x0a, 0xdd, 0x75, 0xdd, 0xdf, 0x72, 0xbb, 0x4f, 0x8b, 0x5d, 0x05, 0x85, 0xbd, 0x86, 0x1a,
 0x4d, 0x31, 0xd6, 0xb3, 0xf4, 0x88, 0x7d, 0x4d, 0xe0, 0x75, 0x0a, 0xa6, 0x45, 0xc6, 0x97, 0xfd,
 0x26, 0xdf, 0xb2, 0x43, 0xb4, 0xc4, 0x96, 0x5e, 0xa3, 0x91, 0x78, 0x14, 0xb1, 0x22, 0x64, 0x5c,
 0x79, 0xbd, 0x2d, 0xc4, 0xd8, 0xbf, 0xf0, 0x93, 0xb8, 0xee, 0x91, 0x65, 0xec, 0x72, 0xb1, 0x5f,
 0x55, 0xd3, 0xe6, 0xbe, 0x3f, 0xc6, 0xeb, 0xe7, 0x64, 0xb7, 0xfc, 0xf9, 0x43, 0x90, 0xf8, 0x44,
 0xc1, 0xdc, 0xd8, 0xf6, 0x3a, 0xba, 0x72, 0x48, 0x3f, 0x6c, 0xc3, 0xe3, 0x85, 0xe4, 0x7d, 0xaf,
 0xe1, 0x2d, 0x07, 0x73, 0x62, 0xd8, 0xfb, 0xb4, 0xe4, 0x90, 0x3e, 0xde, 0x19, 0xf1, 0x4b, 0x8d,
 0x59, 0xa7, 0x76, 0xdb, 0xd3, 0x7b, 0x27, 0x8f, 0xdd, 0xf0, 0xad, 0x1f, 0xfb, 0x4f, 0xf2, 0x81,
 0xdc, 0x7d, 0xb5, 0x94, 0x61, 0x6b, 0x94, 0x70, 0x65, 0xff, 0x00, 0x47, 0xc0, 0xfb, 0x36, 0x9f,
 0x12, 0xa7, 0x23, 0xee, 0x9c, 0x9d, 0x05, 0x7d, 0x66, 0xe0, 0x8b, 0xfe, 0x8e, 0x97, 0xfb, 0x36,
 0x9b, 0xb8, 0x93, 0xab, 0x4b, 0x85, 0xed, 0xac, 0xeb, 0x06, 0x2f, 0xcc, 0xff, 0x00, 0x27, 0xaf,
 0x84, 0x9d, 0x46, 0x08, 0xb0, 0x7c, 0x95, 0xf4, 0x28, 0xd9, 0xf0, 0x94, 0xc1, 0x16, 0x17, 0x92,
 0xee, 0x1d, 0x0a, 0x76, 0x51, 0x77, 0xcf, 0xe9, 0x7f, 0x38, 0x7c, 0x1b, 0x17, 0xf7, 0xc7, 0x7a,
 0x54, 0xf1, 0x39, 0x12, 0x8b, 0xfb, 0xeb, 0xbd, 0x2a, 0x45, 0x0e, 0x89, 0xf7, 0x58, 0x7d, 0x1b,
 0xe0, 0xf9, 0x0f, 0x7b, 0x67, 0x4d, 0x5d, 0x3f, 0xc7, 0xa3, 0x7d, 0x0c, 0x37, 0xe7, 0xc2, 0xb1,
 0xa6, 0x78, 0x39, 0xc3, 0xde, 0xd9, 0xab, 0x57, 0xf9, 0xfc, 0x7f, 0xa1, 0x87, 0x42, 0x74, 0x2b,
 0x1e, 0x87, 0x8b, 0x7f, 0xec, 0xaa, 0xf9, 0x37, 0x8b, 0xdf, 0x5c, 0xfc, 0xbf, 0x99, 0x2a, 0x7c,
 0x24, 0xea, 0x3e, 0x6c, 0xdb, 0x52, 0x6e, 0xed, 0x27, 0x13, 0x4b, 0x42, 0xfb, 0x26, 0x9f, 0x51,
 0x3e, 0x15, 0x8f, 0x98, 0x76, 0xe4, 0x9b, 0xbb, 0x4e, 0xc5, 0x12, 0xd0, 0x7e, 0xc9, 0x86, 0x8f,
 0x11, 0xb6, 0xf1, 0x47, 0xe5, 0xdd, 0x7b, 0x27, 0x6d, 0xf2, 0xaf, 0xfe, 0x9f, 0xeb, 0x0d, 0x25,
 0x0e, 0x99, 0xe0, 0xfe, 0xdd, 0xec, 0x73, 0x13, 0x4f, 0xe6, 0x8d, 0xfb, 0x44, 0x39, 0x92, 0x1d,
 0x53, 0xc1, 0xd1, 0xbb, 0xd8, 0xf6, 0x2a, 0x9d, 0x52, 0x6d, 0xfb, 0x46, 0x9c, 0x0e, 0x0c, 0xeb,
 0x3d, 0x7f, 0x2f, 0x5b, 0xe3, 0x13, 0xae, 0x16, 0x4f, 0xc3, 0xac, 0xbe, 0x15, 0x8e, 0x65, 0xb7,
 0x99, 0x45, 0xf1, 0x56, 0x1b, 0x34, 0x89, 0xc1, 0x91, 0xde, 0xc5, 0xb6, 0xf3, 0x51, 0x7f, 0xe5,
 0x3a, 0xeb, 0xe1, 0x71, 0xe4, 0x6a, 0x5b, 0x53, 0xc1, 0xdf, 0x8a, 0x64, 0xa9, 0xe8, 0x50, 0x9a,
 0xae, 0x8d, 0x05, 0x12, 0x62, 0x1a, 0x27, 0x4a, 0xb3, 0x8a, 0xa7, 0xc9, 0xa9, 0xe8, 0x79, 0x71,
 0x39, 0x30, 0x5a, 0xb0, 0xf0, 0x9e, 0x13, 0xc9, 0x8c, 0x5c, 0xbc, 0x76, 0xb7, 0xcb, 0x7f, 0xcf,
 0xc9, 0xf3, 0x8a, 0x17, 0xb0, 0x18, 0x70, 0x23, 0x63, 0x52, 0x50, 0x66, 0x9a, 0x8f, 0x82, 0xf8,
 0xec, 0x64, 0x44, 0xd5, 0x53, 0x56, 0xaa, 0xa2, 0x29, 0x45, 0x79, 0x1e, 0xb1, 0xee, 0x63, 0x91,
 0xcd, 0x5d, 0x15, 0x17, 0x54, 0x5e, 0xa5, 0x3c, 0xac, 0x4c, 0x44, 0xc4, 0xbe, 0x99, 0x68, 0x99,
 0x89, 0x87, 0x74, 0x76, 0x42, 0xca, 0xa8, 0xab, 0xf9, 0x29, 0xbc, 0xff, 0x00, 0xcb, 0xc4, 0xef,
 0x20, 0xec, 0x89, 0x95, 0x7f, 0xcd, 0x49, 0xdb, 0x44, 0xef, 0x1a, 0xe4, 0xec, 0x62, 0x5f, 0x30,
 0xe0, 0x30, 0x27, 0x61, 0x3d, 0x2b, 0x35, 0x11, 0x93, 0x0c, 0xe9, 0x63, 0xd1, 0x38, 0xeb, 0xe9,
 0xe6, 0x83, 0x65, 0x86, 0xa7, 0xb1, 0xc5, 0x87, 0x8d, 0x92, 0xb1, 0x6a, 0xd6, 0x3c, 0xff, 0x00,
 0x64, 0x3e, 0x79, 0x97, 0x99, 0xcc, 0xc5, 0x79, 0xa5, 0xef, 0x3b, 0x8f, 0xda, 0xd4, 0xbd, 0x62,
 0x65, 0x7f, 0xf3, 0x52, 0x76, 0xd1, 0x3b, 0xc8, 0xae, 0x45, 0xca, 0xfd, 0x18, 0x5a, 0x76, 0xcf,
 0xef, 0x36, 0x98, 0xee, 0x64, 0x18, 0x4f, 0x8b, 0x15, 0xe8, 0xc8, 0x6c, 0x6a, 0xb9, 0xce, 0x55,
 0xd1, 0x1a, 0x89, 0xcd, 0x4e, 0x35, 0x3b, 0xb4, 0x2c, 0x75, 0x31, 0x59, 0x88, 0xb2, 0x73, 0x0c,
 0xf5, 0x2b, 0xa2, 0x2a, 0xc2, 0x85, 0x12, 0x13, 0x55, 0x11, 0xbd, 0x17, 0x34, 0xf2, 0xad, 0xc4,
 0xe3, 0x6b, 0xae, 0x91, 0xe7, 0xfb, 0x21, 0xcd, 0xe0, 0xc7, 0x3f, 0x9b, 0xbe, 0x8c, 0x93, 0xe5,
 0xfb, 0x65, 0xbd, 0xae, 0x46, 0xca, 0xe9, 0xff, 0x00, 0xc5, 0xa7, 0x6c, 0xfe, 0xf2, 0xc6, 0x17,
 0x96, 0x70, 0x4c, 0x2e, 0x6d, 0x26, 0xa4, 0x64, 0x52, 0x14, 0x64, 0x45, 0x6a, 0x3a, 0xa3, 0x97,
 0x82, 0xf3, 0xe0, 0xaa, 0x69, 0x52, 0x7b, 0x4e, 0x9f, 0x66, 0x9e, 0xab, 0xc3, 0x65, 0xa3, 0x27,
 0x4a, 0xc3, 0x73, 0x98, 0xbf, 0x7a, 0x1b, 0xa6, 0x4f, 0xcc, 0x70, 0xf3, 0x24, 0xbc, 0x78, 0xb0,
 0xa4, 0x62, 0xcb, 0x36, 0x0a, 0xa3, 0x5c, 0xaf, 0x72, 0x39, 0x15, 0x57, 0xa1, 0x3f, 0xf3, 0xa8,
 0xcf, 0x1b, 0x3f, 0x07, 0x2d, 0xe2, 0x29, 0x11, 0xbf, 0xc2, 0xb9, 0x58, 0x3c, 0x47, 0x0e, 0x39,
 0x9c, 0xb6, 0x9e, 0x9f, 0xaf, 0x9e, 0xcd, 0x55, 0xa4, 0x55, 0xa5, 0x97, 0x34, 0xc6, 0xad, 0x3b,
 0x7e, 0xa7, 0x51, 0x12, 0xc0, 0xe6, 0x90, 0x56, 0x96, 0x15, 0xa4, 0x55, 0xa5, 0x6d, 0x51, 0x65,
 0x75, 0x69, 0x05, 0x69, 0x61, 0x5a, 0x41, 0x5a, 0x54, 0x4a, 0xa2, 0x55, 0xd5, 0xba, 0x10, 0x56,
 0x96, 0x55, 0xa4, 0x5c, 0xd2, 0xb6, 0xa8, 0x95, 0x65, 0x69, 0xab, 0xed, 0x29, 0x34, 0xcb, 0x4b,
 0xfd, 0x3b, 0x3e, 0xf3, 0x6e, 0x56, 0x9a, 0xb6, 0xd3, 0x53, 0x4c, 0xb0, 0xbf, 0xeb, 0x10, 0xfe,
 0x87, 0x1c, 0x3f, 0x11, 0x9f, 0xee, 0xb9, 0x3f, 0x12, 0xe6, 0xf8, 0x7c, 0xff, 0x00, 0x79, 0xa7,
 0xe5, 0xca, 0xc9, 0x33, 0xdb, 0x27, 0xa4, 0x89, 0xeb, 0x7d, 0xb2, 0x7a, 0x4f, 0x03, 0x1f, 0x37,
 0xb9, 0x76, 0xcd, 0xdf, 0xa0, 0x8a, 0xb4, 0xb1, 0xbb, 0xc1, 0x08, 0x39, 0x87, 0xd3, 0xeb, 0x3e,
 0x4f, 0x01, 0xb5, 0x75, 0x61, 0x07, 0x34, 0xb2, 0xad, 0x20, 0xad, 0x2f, 0x6c, 0xc5, 0x95, 0xd5,
 0xbc, 0x48, 0xab, 0x4b, 0x0a, 0xd2, 0x0a, 0xc2, 0xa2, 0xcb, 0x8b, 0x2b, 0xab, 0x50, 0x82, 0xb0,
 0xb2, 0xad, 0xe2, 0x41, 0xcd, 0x2a, 0x25, 0x5b, 0x57, 0x56, 0x91, 0x56, 0x96, 0x15, 0xa4, 0x15,
 0xa6, 0x62, 0x55, 0xb6, 0xc0, 0xc8, 0xc6, 0x76, 0x45, 0x15, 0x31, 0xea, 0x9c, 0xd1, 0x4c, 0xcc,
 0x88, 0xb7, 0x3f, 0x37, 0xed, 0xc1, 0x8b, 0x1a, 0xb2, 0x35, 0xcc, 0xec, 0x8d, 0x71, 0x4b, 0x22,
 0xad, 0xcc, 0xf0, 0xe2, 0x2f, 0x46, 0xa6, 0x62, 0x57, 0x17, 0x35, 0x64, 0x6b, 0x99, 0xd9, 0x1a,
 0xe2, 0x96, 0x44, 0x5b, 0x99, 0x99, 0x15, 0x6e, 0x67, 0x6b, 0x8b, 0x9b, 0xb2, 0x35, 0xcc, 0xec,
 0x8d, 0x71, 0x43, 0x22, 0xad, 0xcc, 0xcc, 0x8a, 0xb7, 0x33, 0xb6, 0xc8, 0xbb, 0x89, 0xed, 0x79,
 0xdb, 0xdb, 0x42, 0xc4, 0x97, 0xad, 0x21, 0x7d, 0x9b, 0x4d, 0x49, 0x4d, 0xab, 0x6a, 0xa8, 0xe7,
 0xe7, 0xa9, 0xf7, 0x6e, 0xaa, 0xea, 0x90, 0xfa, 0x3f, 0x93, 0x69, 0xab, 0x2b, 0x1f, 0xef, 0x5d,
 0xf2, 0x1e, 0xbf, 0x8f, 0xfa, 0xaa, 0xfe, 0x21, 0xed, 0x38, 0xd3, 0xfd, 0x8d, 0x7f, 0x10, 0xe8,
 0x3e, 0x0f, 0xee, 0xdc, 0xcf, 0x8e, 0x5f, 0xe6, 0x51, 0x7f, 0xe5, 0x3e, 0x84, 0x87, 0x1e, 0xe7,
 0xce, 0xfb, 0x0b, 0xde, 0x66, 0x76, 0x72, 0xaa, 0x2a, 0x7f, 0x79, 0xc5, 0xe8, 0xfd, 0x13, 0xbb,
 0xb2, 0x32, 0x9d, 0x27, 0x89, 0xcf, 0xf6, 0xdf, 0xb9, 0xd2, 0xf8, 0x9d, 0xb5, 0x9f, 0xf7, 0x1c,
 0xb2, 0x3d, 0xcb, 0x10, 0xe3, 0xe9, 0xd2, 0x26, 0x87, 0x19, 0x6e, 0x67, 0x87, 0x19, 0x6e, 0x70,
 0x36, 0xe0, 0xc5, 0xce, 0xa1, 0xc7, 0xb9, 0x66, 0x1c, 0x7e, 0x3c, 0xc4, 0x90, 0xe3, 0x2d, 0xcc,
 0xf0, 0xe3, 0x2e, 0xbd, 0x26, 0x76, 0xd9, 0x17, 0x3c, 0x87, 0x1e, 0xe5, 0x98, 0x73, 0x17, 0x11,
 0x43, 0x8e, 0xa5, 0x96, 0x47, 0xf4, 0x95, 0xb6, 0xd8, 0xbb, 0x99, 0x78, 0x5a, 0xc5, 0xa9, 0x92,
 0xb0, 0x64, 0xea, 0xc4, 0x5d, 0xf6, 0x4a, 0x7c, 0xce, 0x7d, 0x1b, 0xe1, 0x4c, 0xf5, 0x7e, 0x4e,
 0xc2, 0x53, 0x9e, 0x98, 0x82, 0xfd, 0x92, 0x9f, 0x39, 0xe8, 0xbd, 0x4a, 0x7a, 0x1e, 0x04, 0xef,
 0x04, 0x3b, 0xce, 0x1c, 0xef, 0x14, 0x1c, 0xe4, 0x65, 0xd3, 0x3a, 0x60, 0x8b, 0xd5, 0x88, 0xcb,
 0xfd, 0xab, 0x4f, 0xd0, 0x64, 0x99, 0xfe, 0xea, 0xfe, 0x3f, 0x9c, 0xbf, 0x49, 0xf9, 0xef, 0x92,
 0xd1, 0x53, 0x38, 0x60, 0xab, 0xa2, 0xf0, 0xc4, 0x20, 0x7d, 0xa3, 0x4f, 0xbc, 0x6b, 0xad, 0x47,
 0x7e, 0x92, 0xfd, 0x27, 0x1b, 0xc4, 0xa7, 0x53, 0x56, 0xbe, 0x65, 0xb5, 0x30, 0xd8, 0x21, 0x4c,
 0xdc, 0xb7, 0x0a, 0x69, 0x7a, 0xcd, 0x72, 0x14, 0xc2, 0xf5, 0x96, 0xa1, 0x4c, 0x2a, 0x74, 0x9d,
 0x6c, 0x59, 0xc6, 0xae, 0x46, 0x4d, 0xa3, 0x61, 0x3e, 0xba, 0xf6, 0x7f, 0x8e, 0x65, 0xd4, 0x54,
 0xa9, 0x3f, 0x24, 0xf8, 0x50, 0x95, 0x79, 0x24, 0x4d, 0x35, 0x67, 0xfb, 0xc8, 0xd3, 0xf3, 0x9a,
 0x6e, 0x04, 0x69, 0x69, 0xa8, 0xb2, 0xf3, 0x10, 0x9d, 0x0a, 0x34, 0x27, 0xab, 0x22, 0x31, 0xc9,
 0xa2, 0xb5, 0xc8, 0xba, 0x2a, 0x2a, 0x59, 0x51, 0x4f, 0xd2, 0x08, 0x53, 0x37, 0x38, 0x1f, 0x84,
 0x4e, 0xc5, 0xe3, 0xe6, 0x19, 0xe8, 0xd9, 0xbb, 0x28, 0x40, 0x6b, 0xf1, 0x18, 0x9e, 0x54, 0xf4,
 0x83, 0x74, 0x4a, 0xeb, 0xfe, 0x52, 0x1f, 0x46, 0xff, 0x00, 0x5b, 0x7a, 0x79, 0xa7, 0x1e, 0x0b,
 0xd8, 0xf0, 0xb9, 0x11, 0x59, 0x9a, 0xdb, 0xea, 0xe6, 0x60, 0xcb, 0x1f, 0x29, 0x7c, 0xac, 0x9c,
 0x14, 0xec, 0x9b, 0x00, 0xf0, 0x80, 0xcc, 0xbb, 0x29, 0x6c, 0x4c, 0x31, 0x25, 0x99, 0x8c, 0xe5,
 0xf8, 0xd1, 0x2a, 0x3a, 0x42, 0x34, 0x45, 0x62, 0xc2, 0x7a, 0xf3, 0x74, 0x27, 0xe8, 0xbb, 0xaa,
 0xbd, 0x28, 0xa8, 0xa8, 0xbc, 0xf8, 0x2f, 0x13, 0x91, 0x4f, 0x49, 0xcd, 0x49, 0x4c, 0xc4, 0x96,
 0x9c, 0x96, 0x8d, 0x2f, 0x1e, 0x1a, 0xee, 0xbe, 0x1c, 0x56, 0x2b, 0x5c, 0xd5, 0xea, 0x54, 0x5e,
 0x28, 0x60, 0xd1, 0x7a, 0x94, 0xed, 0x6d, 0x58, 0xb4, 0x6a, 0x5c, 0xb7, 0xda, 0xf8, 0x97, 0x86,
 0x8e, 0x59, 0xf5, 0x02, 0xba, 0x47, 0x23, 0x62, 0xb1, 0x66, 0xf7, 0x78, 0x32, 0x34, 0xe4, 0x36,
 0x43, 0xd7, 0xf4, 0x9a, 0x8a, 0xba, 0x7c, 0x47, 0xce, 0x3b, 0x65, 0xdb, 0x36, 0x6f, 0xda, 0x84,
 0xcb, 0x59, 0x8c, 0x47, 0x87, 0x27, 0x85, 0xc2, 0x7e, 0xfc, 0x0c, 0x36, 0x53, 0x56, 0xc1, 0x62,
 0xf4, 0x39, 0xda, 0xf1, 0x7b, 0xae, 0xee, 0x5d, 0x08, 0x87, 0x36, 0x46, 0xb9, 0x57, 0x92, 0xfc,
 0x87, 0x5e, 0xd8, 0xce, 0xc1, 0x73, 0x6e, 0x7e, 0x9a, 0x81, 0x37, 0x39, 0x02, 0x2e, 0x07, 0x80,
 0xab, 0x91, 0x62, 0x4f, 0x4c, 0xc3, 0x54, 0x74, 0x46, 0xf5, 0x41, 0x62, 0xe8, 0xaf, 0x5b, 0xf0,
 0x6d, 0xfa, 0x0d, 0x7d, 0x38, 0xf1, 0x46, 0xd3, 0x31, 0x1b, 0xdc, 0xb9, 0x12, 0xa2, 0xe8, 0x44,
 0xfa, 0x47, 0xc3, 0x23, 0x65, 0xd8, 0x0e, 0x46, 0xc2, 0xb2, 0x8c, 0xe6, 0x55, 0xc3, 0xbd, 0x4d,
 0x20, 0x90, 0x22, 0x48, 0x4c, 0xbd, 0x78, 0xbe, 0x2c, 0x66, 0xad, 0x46, 0xc4, 0x88, 0xef, 0xce,
 0x7b, 0x91, 0xce, 0xe3, 0xfc, 0x54, 0x44, 0xe1, 0xa2, 0x1f, 0x37, 0xe8, 0xbd, 0x4a, 0x55, 0x2f,
 0x17, 0xaf, 0x54, 0x29, 0xf5, 0x5f, 0x80, 0x8c, 0xcb, 0x63, 0x61, 0xb9, 0xaf, 0x0e, 0xd5, 0x37,
 0xe1, 0xc5, 0x96, 0x8e, 0x8d, 0xb2, 0xa3, 0xda, 0xab, 0xf3, 0x27, 0xca, 0x7d, 0x23, 0x16, 0x5e,
 0xc7, 0xc5, 0xfe, 0x06, 0x99, 0x9e, 0x1e, 0x5e, 0xdb, 0x2c, 0xae, 0x1f, 0x36, 0xfd, 0xc9, 0x4c,
 0x72, 0x0b, 0xb0, 0xf7, 0x2a, 0xae, 0x88, 0x91, 0x15, 0x51, 0xd0, 0x95, 0x7f, 0xae, 0xd4, 0x6f,
 0xf5, 0x8f, 0xbc, 0xa6, 0x70, 0xf5, 0xe3, 0xe4, 0x89, 0xc9, 0xd3, 0x3a, 0x79, 0xaf, 0x14, 0xf0,
 0xf9, 0xc9, 0x96, 0x6f, 0x1f, 0x57, 0x0a, 0xf0, 0xa3, 0x80, 0xac, 0xd8, 0x6e, 0x62, 0x72, 0xa7,
 0x24, 0x97, 0xfe, 0xd1, 0x0c, 0xf8, 0x59, 0x4f, 0xbf, 0x7c, 0x2c, 0xe5, 0x1d, 0x0b, 0x60, 0x99,
 0x91, 0xda, 0x72, 0xf5, 0x37, 0xf6, 0x98, 0x47, 0xc0, 0x6a, 0x8b, 0xaf, 0x25, 0x2b, 0xab, 0xab,
 0xcd, 0xce, 0xf0, 0x5c, 0x33, 0x8b, 0x04, 0xd6, 0x7b, 0xff, 0x00, 0xf0, 0x27, 0xdc, 0x7d, 0xf9,
 0x92, 0xa5, 0xf5, 0xc9, 0x38, 0x12, 0xe9, 0xcf, 0x0d, 0x97, 0xfb, 0x26, 0x9f, 0x01, 0xa2, 0x2f,
 0x52, 0x9f, 0xa2, 0x39, 0x16, 0x06, 0xb9, 0x13, 0x2f, 0xae, 0x9c, 0xf0, 0xb9, 0x6f, 0xb2, 0x69,
 0xbb, 0x15, 0xb5, 0x2e, 0xb3, 0xda, 0xac, 0x5e, 0xf7, 0x0e, 0x38, 0xfd, 0xb2, 0xc3, 0x12, 0x5e,
 0xc5, 0x68, 0xb0, 0x17, 0x75, 0xdc, 0x3a, 0x14, 0xd8, 0x62, 0xcb, 0x58, 0xa9, 0x1e, 0x5f, 0xc9,
 0x77, 0x0e, 0x85, 0x39, 0x51, 0x91, 0xf3, 0xeb, 0x71, 0x26, 0x25, 0xf9, 0xd1, 0x1b, 0xf7, 0xd7,
 0xfe, 0x92, 0xfd, 0x24, 0x7a, 0x09, 0x46, 0x45, 0xaa, 0xfe, 0x0b, 0xed, 0x94, 0xf1, 0x11, 0x7a,
 0x94, 0xe0, 0x3e, 0xd5, 0x1f, 0x27, 0xd4, 0x3e, 0x0d, 0x30, 0xf7, 0xb6, 0x62, 0xd5, 0xfe, 0x7f,
 0x1f, 0xe8, 0x61, 0xd2, 0x1f, 0x04, 0xd0, 0xbc, 0x18, 0x61, 0x2b, 0xb6, 0x58, 0xd5, 0xd3, 0xff,
 0x00, 0x90, 0x8f, 0xf4, 0x30, 0xe9, 0x8f, 0x82, 0xbd, 0x47, 0x6d, 0xc7, 0xbe, 0xb1, 0xc3, 0xe3,
 0xbe, 0x35, 0x6d, 0x78, 0x86, 0x6f, 0xf5, 0x49, 0x4b, 0xe1, 0x58, 0xf9, 0x57, 0x6f, 0x49, 0xbb,
 0xb5, 0x4c, 0x59, 0x2d, 0x07, 0xec, 0x98, 0x7d, 0x75, 0x12, 0x0a, 0xf5, 0x1f, 0x25, 0x78, 0x41,
 0x35, 0x53, 0x6b, 0x38, 0xba, 0x68, 0xbc, 0xa0, 0xfd, 0x8b, 0x08, 0xe6, 0xdb, 0x74, 0x8f, 0xcb,
 0xbc, 0xf6, 0x3a, 0xdb, 0xe5, 0xdf, 0xfd, 0x3f, 0xd6, 0x1a, 0x01, 0xd6, 0xbc, 0x1a, 0x9b, 0xbd,
 0x98, 0x71, 0x7b, 0x49, 0x37, 0xed, 0x1a, 0x72, 0x6d, 0xd5, 0xea, 0x53, 0xb0, 0x78, 0x2f, 0xb1,
 0x5d, 0x98, 0xf1, 0x84, 0xd1, 0x7f, 0xc0, 0x5b, 0xf6, 0x8d, 0x38, 0x9c, 0x59, 0xd6, 0x6a, 0xbd,
 0x97, 0x8d, 0xce, 0xb8, 0x19, 0x7f, 0x0e, 0xd4, 0xf8, 0x56, 0x30, 0xbe, 0x0a, 0x2a, 0x2a, 0x2b,
 0x51, 0x51, 0x79, 0xa2, 0xf4, 0x8d, 0x9f, 0x05, 0x7a, 0x8c, 0x2f, 0x85, 0x63, 0xd1, 0x45, 0xdf,
 0x2c, 0xae, 0x4d, 0x3e, 0x5b, 0xda, 0xa6, 0x54, 0x8b, 0x96, 0xb3, 0x0c, 0x4a, 0x30, 0xd7, 0xc5,
 0xf3, 0x4a, 0xb1, 0x25, 0x9f, 0xd0, 0x9d, 0x6c, 0xf4, 0xa7, 0xd1, 0xa1, 0xa7, 0xe8, 0xa8, 0x7d,
 0x79, 0x99, 0x70, 0x09, 0x0c, 0x7b, 0x0b, 0x8b, 0x86, 0xe2, 0x50, 0x2a, 0xc1, 0x7f, 0x14, 0x54,
 0xe0, 0xe6, 0x3b, 0xa1, 0xcd, 0x5e, 0x85, 0x43, 0xe7, 0xfc, 0xef, 0xb3, 0x1c, 0x7f, 0x00, 0x8b,
 0x12, 0x34, 0xac, 0x17, 0xe2, 0x38, 0x7a, 0x2e, 0xa9, 0x1a, 0x0b, 0x75, 0x73, 0x13, 0xf8, 0xed,
 0x4e, 0x29, 0xe9, 0x4d, 0x50, 0xe9, 0x39, 0x7c, 0x4b, 0x52, 0xd3, 0x6a, 0x7c, 0x9f, 0x44, 0xf0,
 0x6f, 0x1c, 0xc5, 0xc9, 0xa4, 0x62, 0xcd, 0x3a, 0xbc, 0x77, 0xfa, 0xff, 0x00, 0xbb, 0x55, 0xcb,
 0xf8, 0xe6, 0x23, 0x81, 0x4e, 0xfa, 0xaf, 0x0d, 0x99, 0x74, 0x27, 0xaa, 0x68, 0xe4, 0xd3, 0x56,
 0xbd, 0x3a, 0x9c, 0x9d, 0x28, 0x6f, 0x92, 0xdb, 0x5c, 0x98, 0x48, 0x28, 0x93, 0x58, 0x24, 0x18,
 0x91, 0x34, 0xf6, 0xd0, 0xe3, 0xab, 0x51, 0x7e, 0x25, 0x45, 0x39, 0x93, 0x9a, 0xe4, 0x5d, 0x15,
 0xab, 0xaf, 0xa0, 0xf3, 0x45, 0xea, 0x53, 0x46, 0x2e, 0x56, 0x6c, 0x31, 0xaa, 0x5b, 0x4e, 0xe3,
 0x91, 0xc0, 0xe3, 0x72, 0x67, 0x79, 0x69, 0xb9, 0xff, 0x00, 0x9d, 0x9b, 0x66, 0x6c, 0xcf, 0x78,
 0xae, 0x3f, 0x01, 0xd2, 0x9b, 0x90, 0xe4, 0xe5, 0x1d, 0xed, 0xa1, 0x42, 0xd5, 0x55, 0xff, 0x00,
 0xa4, 0xe5, 0xe7, 0xe8, 0xe4, 0x6a, 0x8b, 0xcf, 0x53, 0xc4, 0x45, 0xea, 0x5f, 0x90, 0x6b, 0x80,
 0x65, 0xfc, 0x5f, 0x1d, 0x8f, 0x47, 0x0d, 0x91, 0x8b, 0x1d, 0x75, 0xd1, 0xcf, 0xd3, 0x46, 0x37,
 0xd2, 0xe5, 0xe0, 0x84, 0x5e, 0xf9, 0x33, 0xdb, 0x76, 0x9d, 0xcb, 0x6e, 0x3c, 0x78, 0x78, 0xb8,
 0xf5, 0x58, 0x8a, 0xd5, 0x46, 0x4a, 0x5a, 0x3c, 0xdc, 0xdc, 0x29, 0x69, 0x68, 0x6e, 0x89, 0x1a,
 0x2b, 0x91, 0xac, 0x63, 0x79, 0xaa, 0xa9, 0xdf, 0x32, 0xa6, 0x09, 0x0f, 0x02, 0xc0, 0xe0, 0x48,
 0x35, 0x51, 0x62, 0x22, 0x6f, 0x46, 0x72, 0x7e, 0x73, 0xd7, 0x9f, 0x77, 0xc4, 0x57, 0xc8, 0xb9,
 0x16, 0x5f, 0x2e, 0xc2, 0xf5, 0x4c, 0xc2, 0xb6, 0x67, 0x11, 0x7b, 0x74, 0x74, 0x44, 0x4f, 0x26,
 0x1a, 0x74, 0xa3, 0x7b, 0xcd, 0x9d, 0xd0, 0x55, 0x3a, 0x0f, 0x45, 0xe1, 0x9c, 0x39, 0xc1, 0xfd,
 0xa5, 0xff, 0x00, 0xc5, 0x3f, 0xc1, 0xe4, 0x3c, 0x67, 0xc5, 0xab, 0xc9, 0x9f, 0x75, 0x8a, 0x7f,
 0x46, 0x3f, 0x8a, 0x9a, 0xb4, 0x8a, 0xb4, 0xb2, 0xe8, 0x6b, 0xd4, 0x41, 0x58, 0xbd, 0x47, 0x73,
 0xb7, 0x47, 0x12, 0xae, 0xad, 0x31, 0xb9, 0xa5, 0xa7, 0x31, 0x7a, 0x88, 0x2b, 0x2c, 0x56, 0xd7,
 0xb5, 0x67, 0x34, 0x82, 0xb4, 0xb4, 0xe6, 0xd8, 0x83, 0x99, 0x62, 0xa2, 0xca, 0xea, 0x57, 0x73,
 0x48, 0x2b, 0x4b, 0x2e, 0x62, 0xf5, 0x29, 0x07, 0x31, 0x7a, 0x94, 0xad, 0xab, 0x6a, 0xee, 0x69,
 0xa9, 0xed, 0x45, 0x34, 0xca, 0xca, 0xbf, 0xce, 0x21, 0xfd, 0x0e, 0x37, 0x25, 0x62, 0xf5, 0x29,
 0xa9, 0x6d, 0x55, 0x8b, 0xeb, 0x4d, 0x78, 0x2f, 0xf8, 0x4c, 0x3f, 0xa1, 0xc7, 0x13, 0xc4, 0x27,
 0xfb, 0xad, 0xff, 0x00, 0x12, 0xe7, 0x78, 0x74, 0xef, 0x95, 0x4f, 0xcb, 0x91, 0x1e, 0xb3, 0xdb,
 0x27, 0xa4, 0x34, 0x5e, 0xa5, 0x3d, 0x63, 0x57, 0x7d, 0xbc, 0x17, 0x99, 0xe1, 0x63, 0xe6, 0xf7,
 0xae, 0xef, 0xbb, 0xc1, 0x08, 0xab, 0x4b, 0x2a, 0xc5, 0xd3, 0x97, 0x41, 0x05, 0x62, 0xf5, 0x29,
 0xf4, 0xaa, 0xdb, 0xc9, 0xf3, 0xb9, 0xb7, 0x9a, 0xbb, 0x9a, 0x63, 0x56, 0x96, 0x95, 0x8b, 0xd4,
 0xa4, 0x1c, 0xc5, 0xea, 0x52, 0xe2, 0xcc, 0xc4, 0xab, 0x2b, 0x48, 0xab, 0x4b, 0x2a, 0xc5, 0xea,
 0x20, 0xac, 0x5e, 0xa5, 0x2b, 0x6a, 0x89, 0x57, 0x56, 0x90, 0x56, 0x16, 0x55, 0x8b, 0xd4, 0xa4,
 0x15, 0x8b, 0xd4, 0xa5, 0x6d, 0x71, 0x2a, 0xca, 0xd2, 0x0a, 0xd2, 0xd2, 0xb1, 0x7a, 0x94, 0x82,
 0xb1, 0x7a, 0x8c, 0xed, 0x51, 0x67, 0xde, 0x9e, 0xc3, 0xfb, 0x32, 0xe8, 0xc9, 0x78, 0x57, 0x66,
 0xbd, 0xe1, 0xec, 0x41, 0xb3, 0x3f, 0x81, 0x98, 0x57, 0x66, 0xbd, 0xe6, 0xe5, 0x58, 0x2b, 0x1f,
 0x27, 0xf7, 0x18, 0xfe, 0xd8, 0xf4, 0x7b, 0x6f, 0x87, 0xc3, 0xf6, 0x47, 0xa3, 0x4e, 0xf6, 0x21,
 0xd9, 0xa7, 0xc0, 0xcc, 0x2b, 0xb3, 0x5e, 0xf3, 0xd4, 0xd9, 0x1e, 0xcd, 0x53, 0xf8, 0x1b, 0x85,
 0x76, 0x6b, 0xde, 0x6e, 0x15, 0x82, 0xb0, 0xf7, 0x18, 0xbe, 0xd8, 0xf4, 0x3e, 0x1b, 0x0f, 0xd9,
 0x1e, 0x8d, 0x41, 0x36, 0x4b, 0xb3, 0x74, 0xe5, 0x93, 0xb0, 0xae, 0xcd, 0x7b, 0xcf, 0x53, 0x64,
 0xfb, 0x38, 0x4e, 0x59, 0x3f, 0x0b, 0xec, 0xd7, 0xbc, 0xdb, 0xab, 0x5c, 0x2b, 0x5c, 0x7b, 0x8c,
 0x5f, 0x6c, 0x7a, 0x1f, 0x0d, 0x87, 0xed, 0x8f, 0x46, 0xa4, 0x9b, 0x29, 0xd9, 0xd2, 0x72, 0xca,
 0x18, 0x5f, 0x66, 0xbd, 0xe4, 0xbd, 0x8a, 0xf6, 0x77, 0xf0, 0x47, 0x0c, 0xec, 0xd7, 0xbc, 0xda,
 0xeb, 0x05, 0x61, 0xee, 0x31, 0x7d, 0xb1, 0xe8, 0x7c, 0x3e, 0x2f, 0xb6, 0x3d, 0x21, 0xc4, 0xf3,
 0x76, 0x42, 0xc9, 0x72, 0xd9, 0x86, 0x66, 0x0c, 0x1c, 0xaf, 0x85, 0xb5, 0x8d, 0xdc, 0xd1, 0x28,
 0xeb, 0xf9, 0xa8, 0x2a, 0xf5, 0x95, 0x94, 0x7e, 0x0d, 0x61, 0x7d, 0x82, 0x1b, 0x96, 0x78, 0x8b,
 0xae, 0x68, 0x9c, 0xe3, 0xef, 0x3e, 0xa2, 0x09, 0x6a, 0xdc, 0xcc, 0x62, 0xa4, 0x7d, 0x21, 0x71,
 0x8a, 0x91, 0xfe, 0x58, 0xf4, 0x66, 0xc8, 0xb9, 0x0f, 0x26, 0xcc, 0xe3, 0xb4, 0xa3, 0x65, 0x9c,
 0x31, 0xcc, 0xa2, 0xf5, 0xd1, 0x20, 0xe9, 0xc7, 0x81, 0xbe, 0xa6, 0xcd, 0x32, 0x1a, 0x72, 0xca,
 0xd8, 0x77, 0xea, 0x2f, 0x79, 0xaf, 0xec, 0xee, 0x2f, 0xee, 0x8f, 0x9f, 0xf8, 0xbb, 0xfe, 0xe3,
 0xa3, 0x56, 0x13, 0x87, 0x1c, 0xff, 0x00, 0x96, 0x3d, 0x18, 0x9c, 0x38, 0xe7, 0xfc, 0xb1, 0xe8,
 0xd6, 0xd3, 0x66, 0xd9, 0x15, 0x39, 0x65, 0x7c, 0x3f, 0xf5, 0x17, 0xbc, 0xf5, 0x36, 0x71, 0x91,
 0xd3, 0x96, 0x58, 0xc3, 0xff, 0x00, 0x51, 0x7b, 0xcd, 0x8e, 0xa8, 0x55, 0x31, 0xee, 0x31, 0xfd,
 0xb1, 0xe8, 0xc7, 0xb8, 0xc7, 0xf6, 0xc7, 0xa3, 0x5d, 0x4d, 0x9d, 0x64, 0x94, 0xfe, 0x0d, 0x61,
 0xff, 0x00, 0xa8, 0xbd, 0xe4, 0x93, 0x67, 0xb9, 0x29, 0x3f, 0x83, 0x72, 0x1f, 0xa8, 0xbd, 0xe6,
 0xc1, 0x58, 0x2b, 0x5c, 0x7b, 0x9c, 0x7f, 0x6c, 0x7a, 0x1e, 0xe7, 0x1f, 0xdb, 0x1e, 0x84, 0x09,
 0x90, 0x32, 0x62, 0x72, 0xcb, 0x92, 0x1f, 0xa8, 0xbd, 0xe7, 0xa9, 0x90, 0xb2, 0x72, 0x7f, 0x07,
 0xa4, 0x7f, 0x55, 0x7b, 0xc7, 0xd5, 0xc2, 0xb0, 0xf7, 0x38, 0xfe, 0xd8, 0x67, 0xdc, 0xe3, 0xfb,
 0x63, 0xd1, 0xcc, 0x76, 0xa9, 0xb3, 0xcc, 0x8f, 0x33, 0x84, 0xc9, 0xc3, 0x9a, 0xca, 0xb8, 0x5c,
 0xc3, 0x12, 0x61, 0x55, 0x1b, 0x16, 0x16, 0xf2, 0x22, 0xee, 0x2f, 0x1e, 0x67, 0x3b, 0xf6, 0x2f,
 0xd9, 0xc7, 0xc0, 0x7c, 0x0b, 0xf6, 0x6f, 0xc4, 0xec, 0xdb, 0x4c, 0x8b, 0xf9, 0x32, 0x53, 0xfd,
 0x61, 0x7e, 0xaa, 0x9a, 0x15, 0x5b, 0x9b, 0x22, 0x22, 0x23, 0x50, 0xb8, 0x88, 0x88, 0xd4, 0x10,
 0x61, 0x1b, 0x31, 0xd9, 0xdb, 0x31, 0x69, 0x37, 0xb3, 0x25, 0x60, 0x6c, 0x7b, 0x66, 0x21, 0xab,
 0x5c, 0x92, 0xfc, 0x51, 0x77, 0x93, 0x8f, 0x33, 0xb8, 0xfa, 0xcd, 0xca, 0xfa, 0xaa, 0xf8, 0x92,
 0x51, 0x55, 0x57, 0x5f, 0x6b, 0xf8, 0x9c, 0xd7, 0x0c, 0x8b, 0xf9, 0x4e, 0x53, 0x8f, 0xbb, 0xc3,
 0xfa, 0xc8, 0x76, 0x25, 0x8d, 0xc5, 0x7d, 0x26, 0x2d, 0x4a, 0xdb, 0xe7, 0x0c, 0x4d, 0x62, 0xdf,
 0x38, 0x29, 0x4c, 0xa1, 0x96, 0x53, 0x96, 0x0b, 0x28, 0x9f, 0xd5, 0xfc, 0x49, 0x26, 0x53, 0xcb,
 0x69, 0xcb, 0x07, 0x95, 0xfd, 0x55, 0xef, 0x19, 0xd6, 0xd0, 0x2b, 0x13, 0xee, 0xa9, 0xda, 0x18,
 0xf7, 0x74, 0xec, 0x5d, 0xeb, 0x5b, 0x2f, 0x22, 0x7f, 0xf4, 0x99, 0x6f, 0xd5, 0x10, 0x66, 0x96,
 0xe5, 0xcc, 0x21, 0x3d, 0x4f, 0x2f, 0x84, 0xca, 0xc5, 0x9c, 0x72, 0x6b, 0xba, 0xa9, 0xe4, 0xc3,
 0x4e, 0xb5, 0xe3, 0xf3, 0x1b, 0x4e, 0x23, 0x3e, 0xc9, 0x39, 0x08, 0xf3, 0x4f, 0xe2, 0xd8, 0x50,
 0xd5, 0xfa, 0x75, 0xe8, 0x9c, 0x8e, 0x45, 0x35, 0x39, 0x16, 0x66, 0x62, 0x24, 0xc4, 0x77, 0xab,
 0xa2, 0x44, 0x72, 0xb9, 0xcb, 0x75, 0x1e, 0xea, 0x9d, 0xa1, 0x9e, 0x8a, 0xf6, 0x25, 0xcc, 0x99,
 0x3f, 0x2a, 0x66, 0x49, 0xe4, 0x9d, 0xc7, 0xb2, 0xe6, 0x17, 0x88, 0xcc, 0x35, 0xbb, 0x8d, 0x89,
 0x1e, 0x06, 0xaa, 0xd6, 0xf5, 0x25, 0x85, 0x7e, 0xc5, 0xfb, 0x38, 0xf8, 0x0f, 0x81, 0x7e, 0xcd,
 0xf8, 0x9b, 0x4d, 0x5b, 0x97, 0xf0, 0x8c, 0x3a, 0x7b, 0x15, 0x8a, 0xac, 0x94, 0x87, 0xaa, 0x37,
 0xdb, 0x3d, 0xcb, 0xa3, 0x5b, 0xe9, 0x53, 0x64, 0x46, 0xbc, 0xa1, 0x51, 0x1a, 0x69, 0xb2, 0x5b,
 0x38, 0xc8, 0x32, 0x53, 0x70, 0xa6, 0xe5, 0x32, 0x76, 0x0b, 0x06, 0x3c, 0x17, 0x23, 0xe1, 0xc4,
 0x64, 0xbe, 0x8e, 0x63, 0x93, 0x92, 0xa5, 0xce, 0x95, 0x81, 0x63, 0x92, 0xb0, 0x9e, 0xd8, 0x38,
 0xa4, 0x9c, 0x28, 0xd0, 0xf9, 0x56, 0x6b, 0x7c, 0xb6, 0xfa, 0x53, 0xa5, 0x0f, 0x62, 0x64, 0xec,
 0x49, 0xb0, 0xf7, 0x99, 0x35, 0x2a, 0xf7, 0x7b, 0xdd, 0x5c, 0x9f, 0x3a, 0xa0, 0x83, 0x11, 0x95,
 0x9b, 0xc3, 0xe3, 0x51, 0x9c, 0x80, 0xf8, 0x4f, 0xe6, 0x9a, 0xf2, 0x5b, 0xa2, 0xf2, 0x52, 0x6d,
 0x58, 0xb7, 0xce, 0x18, 0xd4, 0x1c, 0x6d, 0x73, 0x06, 0xca, 0xf8, 0xfe, 0x17, 0x21, 0x86, 0x4f,
 0xe1, 0x32, 0x18, 0x94, 0xa3, 0x9f, 0xea, 0xa4, 0x64, 0x66, 0x6f, 0xb3, 0x54, 0x4d, 0xd6, 0xaa,
 0x5f, 0x8b, 0x8e, 0x6b, 0xec, 0x5f, 0xb3, 0x8f, 0x80, 0xf8, 0x17, 0xec, 0xdf, 0x89, 0xb5, 0x2c,
 0x55, 0xd1, 0x13, 0x79, 0x74, 0x4e, 0x56, 0x3c, 0xab, 0x73, 0x31, 0x11, 0x11, 0xa8, 0x65, 0x4f,
 0x22, 0xec, 0x9b, 0x67, 0xd1, 0xb3, 0x34, 0xa4, 0x68, 0x59, 0x2f, 0x05, 0x86, 0xe9, 0x57, 0x24,
 0xc2, 0x3d, 0xb2, 0xfa, 0x2b, 0x55, 0xab, 0xab, 0x55, 0x38, 0xf3, 0xde, 0xd0, 0xee, 0xee, 0x96,
 0x80, 0xee, 0x2e, 0x84, 0xd7, 0x2a, 0xf3, 0xd4, 0xd2, 0x36, 0x63, 0xa7, 0xf7, 0xf4, 0x75, 0xe7,
 0xe4, 0x31, 0x3e, 0x75, 0xee, 0x37, 0x5a, 0xd7, 0x13, 0x11, 0x3f, 0x36, 0x26, 0x36, 0xd6, 0x76,
 0x9d, 0x97, 0xf0, 0x5c, 0x5b, 0x24, 0xe2, 0x12, 0x38, 0xa6, 0x17, 0x2b, 0x3b, 0x2b, 0x16, 0x9d,
 0x48, 0x31, 0x99, 0xbc, 0xc7, 0x69, 0x11, 0xaa, 0x9a, 0xa5, 0x95, 0x11, 0x7e, 0x23, 0x8a, 0x2e,
 0xcb, 0xf6, 0x73, 0xf0, 0x1f, 0x02, 0xfd, 0x9b, 0xf1, 0x3b, 0xbe, 0x78, 0x8d, 0xae, 0x57, 0x9c,
 0x4d, 0x7d, 0xe7, 0xd7, 0x43, 0x98, 0x55, 0xb9, 0x9d, 0x68, 0x88, 0x88, 0xf9, 0x35, 0x65, 0xd9,
 0x7e, 0xce, 0x74, 0x5f, 0xdc, 0x46, 0x05, 0xcb, 0xcd, 0xbf, 0x13, 0xbd, 0xe0, 0x59, 0x77, 0x03,
 0x83, 0x81, 0xc8, 0x40, 0x85, 0x85, 0xcb, 0x43, 0x85, 0x0e, 0x5a, 0x1b, 0x18, 0xc6, 0xb7, 0x44,
 0x6b, 0x51, 0xa8, 0x88, 0x89, 0x64, 0x43, 0x96, 0xac, 0x5e, 0x0b, 0xc7, 0xa0, 0xeb, 0xf8, 0x44,
 0x6d, 0x30, 0xa9, 0x4e, 0x3e, 0xe0, 0xcf, 0xaa, 0x81, 0x37, 0xc7, 0x5c, 0x9e, 0x56, 0x88, 0x94,
 0x57, 0x2f, 0xe0, 0xab, 0xcf, 0x0e, 0x97, 0xfd, 0x52, 0x2e, 0xcb, 0x98, 0x12, 0xa2, 0xeb, 0x85,
 0xcb, 0x2f, 0xf5, 0x4b, 0xd5, 0xc1, 0x63, 0x70, 0x53, 0x3b, 0x96, 0xaf, 0x84, 0xc1, 0xf6, 0x47,
 0xa4, 0x3e, 0x6e, 0x5d, 0x97, 0xec, 0xe3, 0x55, 0xfd, 0xc3, 0xe0, 0x5f, 0xb3, 0x7e, 0x27, 0x9e,
 0xc5, 0xdb, 0x39, 0xf8, 0x0f, 0x81, 0x7e, 0xcd, 0xf8, 0x9b, 0x52, 0xc5, 0xe2, 0xbc, 0x7a, 0x4f,
 0x2a, 0xdc, 0xc3, 0x90, 0xda, 0xb6, 0x5d, 0x91, 0xf2, 0x8c, 0x96, 0x57, 0xf5, 0x3c, 0x96, 0x5c,
 0xc3, 0xa5, 0xa0, 0xfa, 0xa2, 0x23, 0xb7, 0x21, 0x42, 0xdd, 0x6e, 0xab, 0xbb, 0xc7, 0xe6, 0x43,
 0x69, 0x5c, 0xa1, 0x96, 0x57, 0x9e, 0x0b, 0x29, 0xfa, 0xa5, 0x2d, 0x9d, 0x45, 0xd3, 0x2e, 0xf3,
 0xe3, 0xea, 0x88, 0x9f, 0x71, 0xb1, 0xd6, 0xb9, 0x5d, 0x56, 0x8f, 0xab, 0x8d, 0x7e, 0x17, 0x1e,
 0xf6, 0x9b, 0x5b, 0x1c, 0x4c, 0xcf, 0xec, 0x82, 0x85, 0xc9, 0xb9, 0x63, 0xfc, 0xc9, 0x29, 0xfa,
 0xa7, 0x23, 0xda, 0x0e, 0xcd, 0xf2, 0x04, 0xd6, 0x6e, 0x9d, 0x8f, 0x35, 0x93, 0xb0, 0x68, 0xf1,
 0x5d, 0xb9, 0xbd, 0x12, 0x24, 0x0d, 0x5c, 0xbe, 0x43, 0x53, 0x8a, 0xea, 0x77, 0x3a, 0xc7, 0x30,
 0xcf, 0x11, 0x7f, 0x75, 0x13, 0x9c, 0x7d, 0xe7, 0xd4, 0x43, 0x13, 0x69, 0x9f, 0x9c, 0xab, 0x17,
 0x1b, 0x0e, 0x29, 0xde, 0x3a, 0x44, 0x4f, 0xec, 0x88, 0x87, 0x3c, 0xf6, 0x2f, 0xd9, 0xcf, 0xc0,
 0x7c, 0x0b, 0xf6, 0x6f, 0xc4, 0xdc, 0x76, 0x55, 0xb3, 0x9c, 0x89, 0x29, 0x8b, 0x4e, 0xba, 0x4f,
 0x29, 0x61, 0x32, 0xce, 0x74, 0xba, 0x22, 0xac, 0x28, 0x3b, 0xaa, 0xa9, 0xbe, 0x9c, 0x39, 0xd8,
 0xaf, 0x56, 0xe6, 0xd7, 0xb3, 0x38, 0xbf, 0x95, 0x26, 0xf8, 0xff, 0x00, 0x8b, 0xa7, 0xd6, 0x43,
 0x11, 0x3a, 0x9d, 0xc3, 0x6d, 0xe9, 0x5b, 0xc7, 0x4d, 0xa3, 0x71, 0x2d, 0x89, 0x72, 0x2e, 0x51,
 0x5e, 0x78, 0x04, 0x97, 0xea, 0x2f, 0x78, 0x7a, 0xc4, 0xc9, 0xeb, 0xcf, 0x2f, 0xc8, 0xfe, 0xa2,
 0xf7, 0x8f, 0x12, 0x30, 0x56, 0x2f, 0xde, 0x5f, 0xbc, 0xfa, 0xb8, 0xff, 0x00, 0x03, 0xc5, 0xff,
 0x00, 0xc7, 0x5f, 0x48, 0x6b, 0xd3, 0x39, 0x23, 0x24, 0x40, 0x82, 0xf8, 0xd1, 0xf0, 0x1c, 0x3e,
 0x1c, 0x36, 0x26, 0xae, 0x73, 0x9b, 0xa2, 0x22, 0x7c, 0xa6, 0x8f, 0x8d, 0x4a, 0x65, 0x37, 0xc4,
 0x74, 0x2c, 0x2b, 0x2d, 0x48, 0x42, 0x62, 0x7b, 0xb3, 0xe1, 0xaa, 0xb9, 0x6e, 0x89, 0xaf, 0x01,
 0xa6, 0x78, 0xc7, 0xdd, 0x3d, 0x3c, 0xe9, 0x28, 0x0f, 0x5f, 0x52, 0xc0, 0x76, 0x8b, 0xa7, 0x27,
 0xbd, 0x39, 0xaf, 0xa1, 0x39, 0x21, 0xad, 0xd5, 0xb9, 0x9f, 0x7b, 0x7f, 0xba, 0x4f, 0x82, 0xe3,
 0x7f, 0xe3, 0x8f, 0x48, 0x6b, 0xb3, 0xdb, 0x39, 0xc8, 0x53, 0xd3, 0x4f, 0x9a, 0x9c, 0xc9, 0xf8,
 0x34, 0xc4, 0x78, 0x8b, 0xab, 0xe2, 0x3e, 0x5f, 0x55, 0x72, 0xdf, 0x89, 0x83, 0xd8, 0xbf, 0x67,
 0x3f, 0x01, 0xf0, 0x2f, 0xd9, 0xbf, 0x13, 0x6c, 0x80, 0x91, 0x63, 0xc5, 0x6c, 0x28, 0x2c, 0x7c,
 0x48, 0x8e, 0x5d, 0x1a, 0xd6, 0xa6, 0xaa, 0xa3, 0xc8, 0x39, 0x57, 0x1b, 0x88, 0xcd, 0xe5, 0x85,
 0x0a, 0x1e, 0xbf, 0x9a, 0xf8, 0xa8, 0x8b, 0xf3, 0x1a, 0xdc, 0x98, 0x88, 0x88, 0xd4, 0x39, 0xbf,
 0xb1, 0x76, 0xce, 0x7e, 0x04, 0x60, 0x5f, 0xb3, 0x7e, 0x23, 0xfc, 0x1b, 0x2e, 0x65, 0x6c, 0x32,
 0x1c, 0x39, 0x78, 0x59, 0x5f, 0x09, 0x74, 0xab, 0x38, 0x24, 0x05, 0x83, 0xa3, 0x51, 0x2d, 0xa2,
 0xf0, 0x1c, 0x62, 0x98, 0x76, 0x21, 0x86, 0x2a, 0x24, 0xe4, 0x07, 0x31, 0xae, 0x5d, 0x11, 0xe8,
 0xba, 0xb5, 0x57, 0xd2, 0x85, 0x1a, 0xb7, 0x2a, 0xb6, 0xb5, 0x7c, 0xeb, 0x3a, 0x4e, 0x4c, 0x74,
 0xc9, 0x1a, 0xbc, 0x44, 0xfe, 0x5b, 0x96, 0x07, 0x93, 0xf6, 0x71, 0x8b, 0xc0, 0x58, 0x90, 0x32,
 0xce, 0x1e, 0xd8, 0x8d, 0xf6, 0xf0, 0x9c, 0xcf, 0x29, 0xbf, 0x3f, 0x14, 0xb8, 0xc5, 0x76, 0x67,
 0x90, 0x97, 0xf8, 0x2d, 0x86, 0xfe, 0xa2, 0xf7, 0x9a, 0x2e, 0x1b, 0x88, 0xc7, 0xc3, 0xe7, 0x21,
 0xcd, 0x4b, 0x3f, 0x76, 0x23, 0x17, 0xe2, 0x54, 0xe9, 0x45, 0xb2, 0x9d, 0x5f, 0x0b, 0xc4, 0xa0,
 0xe2, 0x12, 0x10, 0x67, 0x20, 0xfb, 0x48, 0x8d, 0xd7, 0x4e, 0x96, 0xaf, 0x4a, 0x2f, 0xa0, 0xbf,
 0x7f, 0x97, 0xee, 0x9f, 0x56, 0xaf, 0x84, 0xe3, 0xfd, 0x91, 0xe9, 0x04, 0x2b, 0xb3, 0x1c, 0x82,
 0xbc, 0xf2, 0xae, 0x1b, 0xfa, 0x8b, 0xde, 0x79, 0xec, 0x5f, 0x90, 0x3e, 0x0a, 0x61, 0xbf, 0xa8,
 0xbd, 0xe6, 0xd1, 0x59, 0x02, 0xa8, 0xf7, 0xf9, 0x7e, 0xe9, 0xf5, 0x93, 0xe1, 0x70, 0x7d, 0x91,
 0xe9, 0x0d, 0x57, 0xd8, 0xbf, 0x67, 0xff, 0x00, 0x05, 0x30, 0xde, 0xcd, 0x7b, 0xc3, 0xd8, 0xbb,
 0x67, 0xdf, 0x04, 0xf0, 0xde, 0xcd, 0x7b, 0xcd, 0xaa, 0xb5, 0xc2, 0xb0, 0xf8, 0x8c, 0xbf, 0x74,
 0xfa, 0x9f, 0x0b, 0x83, 0xec, 0x8f, 0x48, 0x6a, 0xab, 0xb2, 0xed, 0x9e, 0xfc, 0x12, 0xc3, 0x3b,
 0x35, 0xef, 0x3c, 0xf6, 0x2d, 0xd9, 0xef, 0xc1, 0x2c, 0x33, 0xb3, 0x5e, 0xf3, 0x6b, 0xad, 0x70,
 0xad, 0x71, 0xf1, 0x19, 0xbe, 0xe9, 0xf5, 0x96, 0x7e, 0x17, 0x07, 0xd9, 0x1e, 0x90, 0xd5, 0x3d,
 0x8b, 0x36, 0x79, 0xf0, 0x47, 0x0c, 0xec, 0xd7, 0xbc, 0x3d, 0x8a, 0xf6, 0x77, 0xf0, 0x47, 0x0b,
 0xec, 0xd7, 0xbc, 0xda, 0xeb, 0x5c, 0x2b, 0x5c, 0xcf, 0xc4, 0x66, 0xfb, 0xa7, 0xd6, 0x4f, 0x85,
 0xc3, 0xf6, 0x47, 0xa4, 0x35, 0x3f, 0x62, 0xad, 0x9d, 0xfc, 0x11, 0xc2, 0xfb, 0x35, 0xef, 0x35,
 0xcd, 0xa1, 0x6c, 0xaf, 0x67, 0x4d, 0xc0, 0x11, 0x57, 0x26, 0xe1, 0x0f, 0xfe, 0xee, 0xce, 0x0f,
 0x83, 0xaa, 0x74, 0xdc, 0xe9, 0xf5, 0xee, 0x6b, 0x9b, 0x45, 0x8b, 0xae, 0x5d, 0xe7, 0xfe, 0x30,
 0xcf, 0xbc, 0xc4, 0xe7, 0xcb, 0x68, 0xd4, 0xda, 0x7d, 0x59, 0xaf, 0x1f, 0x15, 0x67, 0x71, 0x58,
 0xdf, 0xe2, 0x1c, 0x43, 0xd8, 0xbf, 0x67, 0x1f, 0x01, 0xf0, 0x2f, 0xd9, 0xbf, 0x13, 0xd4, 0xd9,
 0x76, 0xce, 0x75, 0x4f, 0xdc, 0x3e, 0x05, 0xfb, 0x37, 0xe2, 0x6d, 0x15, 0x6e, 0x7a, 0x91, 0x78,
 0xa7, 0x1e, 0x93, 0x53, 0x73, 0x79, 0x4d, 0x93, 0xec, 0xe3, 0x4f, 0xfd, 0x9d, 0x85, 0x76, 0x6b,
 0xde, 0x1e, 0xc4, 0xdb, 0x37, 0xf8, 0x1d, 0x85, 0x76, 0x6b, 0xde, 0x6d, 0xe9, 0x1b, 0x82, 0x7a,
 0x02, 0xb5, 0xcd, 0xdf, 0x13, 0x9b, 0xef, 0x9f, 0x59, 0x68, 0xf8, 0x6c, 0x3f, 0x64, 0x7a, 0x43,
 0x50, 0xf6, 0x25, 0xd9, 0xb7, 0xc0, 0xdc, 0x2b, 0xb3, 0x5e, 0xf3, 0xcf, 0x62, 0x4d, 0x9b, 0x7c,
 0x0d, 0xc2, 0xbb, 0x35, 0xef, 0x37, 0x0a, 0xf7, 0x0a, 0xd7, 0x1f, 0x13, 0x9b, 0xef, 0x9f, 0x59,
 0x67, 0xe1, 0xb0, 0xfd, 0x91, 0xe9, 0x0d, 0x3f, 0xd8, 0x8f, 0x66, 0xdf, 0x03, 0x70, 0xae, 0xcd,
 0x7b, 0xcf, 0x3d, 0x88, 0xf6, 0x6b, 0xf0, 0x37, 0x0a, 0xec, 0xd7, 0xbc, 0xdc, 0x6b, 0x5c, 0x2b,
 0x5c, 0x7c, 0x4e, 0x7f, 0xbe, 0x7d, 0x64, 0xf8, 0x7c, 0x3f, 0x6c, 0x7a, 0x34, 0xef, 0x62, 0x2d,
 0x9a, 0xfc, 0x0c, 0xc2, 0xbb, 0x35, 0xef, 0x3c, 0xf6, 0x21, 0xd9, 0xa7, 0xc0, 0xcc, 0x27, 0xb2,
 0x5e, 0xf3, 0x72, 0xad, 0x70, 0xad, 0x73, 0x3f, 0x13, 0x9f, 0xef, 0x9f, 0x59, 0x3e, 0x1f, 0x17,
 0xdb, 0x1e, 0x90, 0xd3, 0x7d, 0x88, 0x36, 0x67, 0xf0, 0x2f, 0x09, 0xec, 0xd7, 0xbc, 0xf1, 0x76,
 0x41, 0xb3, 0x2f, 0x81, 0x78, 0x4f, 0x66, 0xbd, 0xe6, 0xe7, 0x5a, 0xe1, 0x5a, 0xe3, 0xe2, 0xb3,
 0xfd, 0xf3, 0xeb, 0x27, 0xc3, 0xe2, 0xfb, 0x63, 0xd2, 0x0b, 0xab, 0x5c, 0x2b, 0xdc, 0x5b, 0x5a,
 0xe1, 0x5a, 0xe6, 0x86, 0xe3, 0x2a, 0xd7, 0x0a, 0xd7, 0x16, 0xd6, 0xb8, 0x57, 0xb8, 0x0c, 0xab,
 0xdc, 0x2b, 0x5c, 0x5b, 0x5e, 0xe0, 0x91, 0x80, 0x65, 0x5a, 0xe1, 0x5e, 0xe2, 0xda, 0xd7, 0x0a,
 0xd7, 0x03, 0x45, 0xce, 0xd1, 0x55, 0x73, 0x34, 0xdf, 0xf5, 0x3e, 0xa2, 0x09, 0xaa, 0x5c, 0xb9,
 0x9d, 0x22, 0xeb, 0x99, 0x66, 0xff, 0x00, 0xa9, 0xf5, 0x10, 0x4d, 0x54, 0x0d, 0xbf, 0x67, 0xd1,
 0x74, 0xcc, 0x3c, 0xfd, 0xc1, 0xff, 0x00, 0x71, 0xd0, 0xd2, 0x31, 0xcb, 0x72, 0x0c, 0x5d, 0x33,
 0x07, 0xff, 0x00, 0x81, 0xff, 0x00, 0x71, 0xd0, 0x2b, 0x80, 0xc9, 0x63, 0x5c, 0x2b, 0x5c, 0x5b,
 0x5c, 0x2b, 0x5c, 0x06, 0x55, 0xae, 0x15, 0x85, 0xb5, 0x82, 0xb0, 0x0c, 0x96, 0x35, 0xc1, 0x23,
 0x5c, 0x5b, 0x58, 0x2b, 0x00, 0x9f, 0x69, 0x31, 0x75, 0xc3, 0x25, 0x38, 0xfb, 0xba, 0xfd, 0x55,
 0x34, 0x4a, 0x97, 0x36, 0xcd, 0xa3, 0x46, 0xd7, 0x0d, 0x94, 0xe3, 0xee, 0xeb, 0xf5, 0x54, 0xd1,
 0xaa, 0x80, 0xd7, 0x0c, 0x89, 0xf9, 0x4a, 0x57, 0x8f, 0xbb, 0xb3, 0xeb, 0x21, 0xd7, 0x5d, 0x1b,
 0xca, 0x5e, 0x3d, 0x27, 0x14, 0xc3, 0xa2, 0xe9, 0x88, 0x4b, 0x2e, 0xbe, 0xec, 0xcf, 0xac, 0x87,
 0x5a, 0x74, 0x7f, 0x29, 0x7d, 0x20, 0x31, 0xad, 0x70, 0xae, 0x2d, 0xae, 0x15, 0xae, 0x06, 0x1c,
 0xe7, 0x19, 0x7d, 0x6d, 0x4e, 0x6e, 0xf4, 0xa3, 0x51, 0x7d, 0x1b, 0xc8, 0x73, 0x2a, 0x87, 0x4b,
 0xc4, 0xd8, 0x93, 0xb8, 0x7c, 0x79, 0x45, 0x5d, 0x2a, 0xc3, 0x56, 0xa2, 0xf5, 0x2f, 0x47, 0xce,
 0x72, 0xa8, 0xaa, 0xf8, 0x51, 0x5d, 0x0a, 0x23, 0x77, 0x5e, 0xc5, 0x56, 0xb9, 0x17, 0xa1, 0x50,
 0x0b, 0x4b, 0x17, 0x81, 0xd5, 0x32, 0xec, 0x38, 0x52, 0x78, 0x2c, 0xac, 0x18, 0x68, 0x89, 0xac,
 0x36, 0xbd, 0xca, 0x9c, 0xdc, 0xe7, 0x26, 0xaa, 0xbf, 0x39, 0xc7, 0xaa, 0x9b, 0x96, 0x57, 0xcd,
 0x72, 0xf0, 0xa4, 0xe1, 0xc9, 0x62, 0x11, 0x16, 0x1a, 0xc2, 0x4d, 0xd6, 0x45, 0xd3, 0x54, 0x54,
 0xe8, 0xd7, 0xa9, 0x40, 0xe8, 0x15, 0xca, 0x78, 0xbc, 0xac, 0xbe, 0x27, 0x24, 0xf9, 0x58, 0xed,
 0x45, 0xde, 0x4f, 0x21, 0xdd, 0x2c, 0x77, 0x42, 0xa1, 0x56, 0x5e, 0x7a, 0x04, 0xc3, 0x11, 0xd2,
 0xf1, 0xe1, 0xc5, 0x4e, 0xb6, 0x39, 0x14, 0xc8, 0xb1, 0xae, 0x07, 0x2f, 0x8f, 0xbd, 0x06, 0x3c,
 0x48, 0x2f, 0xe0, 0xf6, 0x39, 0x5a, 0xef, 0x4a, 0x2e, 0x84, 0x2a, 0x5c, 0x96, 0x61, 0x7a, 0x37,
 0x1e, 0x9e, 0x44, 0xe4, 0x91, 0xdc, 0x50, 0xab, 0x70, 0x3a, 0x3e, 0xcd, 0xa2, 0x69, 0x87, 0x4e,
 0x2f, 0xf2, 0xe8, 0x9f, 0xee, 0x9b, 0x5d, 0x73, 0x45, 0xd9, 0xd4, 0x6d, 0x30, 0xd9, 0xbf, 0xe9,
 0xd3, 0xea, 0xa1, 0xb4, 0x56, 0xb8, 0x15, 0xf3, 0xac, 0x5f, 0xdc, 0xcc, 0xdf, 0x1f, 0x79, 0xf5,
 0xd0, 0xe6, 0x95, 0x0d, 0xef, 0x39, 0xc6, 0xd7, 0x2d, 0x4d, 0xff, 0x00, 0x53, 0xeb, 0xa1, 0xcd,
 0xea, 0xdc, 0x0b, 0xab, 0x13, 0x82, 0xf1, 0xe8, 0x3a, 0xe6, 0x13, 0x1b, 0xf2, 0x5c, 0xa7, 0xf4,
 0x0c, 0xfa, 0xa8, 0x71, 0x65, 0x8b, 0xc1, 0x7d, 0x07, 0x57, 0xc2, 0xe3, 0x7e, 0x4c, 0x94, 0xfe,
 0x81, 0x9f, 0x55, 0x00, 0x75, 0x5a, 0xe7, 0xab, 0x1b, 0x82, 0xf1, 0x16, 0xd6, 0xb8, 0x2c, 0x6e,
 0x0b, 0xc4, 0x0e, 0x5a, 0xb1, 0x38, 0xaf, 0x13, 0xca, 0x97, 0x29, 0xac, 0x5e, 0x2a, 0x79, 0x54,
 0x0e, 0xa1, 0xb3, 0xd8, 0xda, 0x65, 0xee, 0x7e, 0xee, 0xff, 0x00, 0xb8, 0xd8, 0xab, 0xdc, 0xd3,
 0xb2, 0x0c, 0x6d, 0x32, 0xfe, 0x9a, 0xfb, 0xbb, 0xfe, 0xe1, 0xfd, 0x6b, 0x80, 0xc9, 0x63, 0xdc,
 0xe6, 0x99, 0xda, 0x2e, 0xb9, 0x9e, 0x6f, 0x8f, 0xbc, 0xfa, 0x88, 0x6f, 0x35, 0xae, 0x73, 0x8c,
 0xe9, 0x17, 0x5c, 0xcb, 0x37, 0xc7, 0xde, 0x7d, 0x44, 0x02, 0x9d, 0x4b, 0x9b, 0x56, 0xcd, 0xa2,
 0xe9, 0x89, 0xcd, 0xf1, 0xf7, 0x04, 0xfa, 0xc8, 0x69, 0x15, 0x4d, 0xa3, 0x67, 0x31, 0x74, 0xc4,
 0xa6, 0xd7, 0x5f, 0x70, 0x4f, 0xac, 0x80, 0x74, 0x9a, 0xd7, 0x17, 0x66, 0x4c, 0x4d, 0x64, 0x30,
 0x59, 0x99, 0x86, 0x3b, 0x47, 0xee, 0xee, 0xc3, 0xfd, 0x25, 0xe0, 0x9d, 0xe1, 0x5c, 0xd5, 0xf6,
 0x8b, 0x36, 0xa9, 0x87, 0x4b, 0x41, 0xd7, 0xdb, 0xc5, 0x57, 0x2f, 0xc4, 0x9f, 0x88, 0x1a, 0xa5,
 0x4b, 0xf1, 0x0a, 0x85, 0x2a, 0xa5, 0x8c, 0x31, 0xcc, 0x7e, 0x23, 0x2c, 0xc8, 0x8e, 0x44, 0x62,
 0xc5, 0x6a, 0x39, 0x57, 0x96, 0x9a, 0x81, 0xd3, 0xf2, 0x96, 0x1b, 0x0f, 0x0c, 0x90, 0x64, 0x47,
 0xb1, 0x3d, 0x57, 0x19, 0xa8, 0xe8, 0x8e, 0xe9, 0x6a, 0x2f, 0xe6, 0xa5, 0xbe, 0xf1, 0xdd, 0x64,
 0xeb, 0x13, 0xae, 0x25, 0x27, 0xaf, 0xf8, 0x64, 0xb7, 0x6c, 0xde, 0xf0, 0xf1, 0x94, 0x9f, 0x9e,
 0x4b, 0x76, 0xcd, 0xef, 0x01, 0x94, 0xe3, 0x20, 0xce, 0x4a, 0xc4, 0x96, 0x8e, 0xd4, 0x7c, 0x28,
 0x8d, 0xd1, 0xc9, 0xf7, 0xfa, 0x50, 0xe6, 0x13, 0x18, 0x64, 0xfc, 0x39, 0xe8, 0xd2, 0xb0, 0xe5,
 0x63, 0xc6, 0x58, 0x6f, 0x56, 0xea, 0xc8, 0x6a, 0xa8, 0xb7, 0xd4, 0xdf, 0x7c, 0x67, 0x27, 0xe7,
 0x92, 0xdd, 0xb3, 0x7b, 0xc3, 0xc6, 0x72, 0x9e, 0x79, 0x2f, 0xdb, 0x37, 0xbc, 0x0d, 0x32, 0x5f,
 0x2d, 0xe3, 0x51, 0xb9, 0xca, 0xa4, 0x24, 0xeb, 0x89, 0x11, 0x1b, 0xf8, 0x9b, 0x7e, 0x51, 0x90,
 0x9d, 0xc2, 0x65, 0xa3, 0x41, 0x9a, 0x8d, 0x09, 0xec, 0x7b, 0x91, 0xed, 0x6b, 0x15, 0x57, 0x75,
 0x7a, 0x7e, 0xe3, 0x27, 0x8c, 0xa4, 0xfc, 0xf2, 0x5b, 0xb6, 0x6f, 0x79, 0xec, 0x39, 0xf9, 0x78,
 0xaf, 0xdc, 0x87, 0x33, 0x05, 0xee, 0x5e, 0x3a, 0x36, 0x22, 0x2a, 0xfc, 0xca, 0x03, 0x6a, 0xd7,
 0x05, 0x8d, 0x71, 0x75, 0x70, 0xad, 0x70, 0x19, 0x56, 0x0a, 0xd7, 0x16, 0xd6, 0x0a, 0xd7, 0x01,
 0x95, 0x6b, 0x85, 0x6b, 0x8b, 0x6b, 0x85, 0x70, 0x18, 0xd6, 0xb9, 0xed, 0x61, 0x6d, 0x6b, 0x85,
 0x6b, 0x80, 0xca, 0xb5, 0xcd, 0x7b, 0x68, 0x51, 0xb5, 0xcb, 0xdf, 0xed, 0x0c, 0xfb, 0xcb, 0xf5,
 0xae, 0x6b, 0xf9, 0xfa, 0x36, 0xb9, 0x7f, 0x9f, 0xbb, 0xb3, 0xef, 0x03, 0x4c, 0xa9, 0x73, 0xd4,
 0x89, 0xc5, 0x38, 0x94, 0x6a, 0x9e, 0xa4, 0x5e, 0x28, 0x07, 0x70, 0x48, 0xdc, 0x13, 0x8f, 0x41,
 0xed, 0x6b, 0x8b, 0x52, 0x37, 0x04, 0xe2, 0x15, 0xc0, 0x65, 0x5a, 0xe7, 0x95, 0xae, 0x2e, 0xad,
 0x70, 0xad, 0x70, 0x19, 0x57, 0xb8, 0x56, 0xb8, 0xb6, 0xbd, 0xc2, 0xb5, 0xc0, 0x65, 0x5a, 0xe1,
 0x5a, 0xe2, 0xda, 0xe1, 0x5e, 0xe0, 0x32, 0xad, 0x70, 0xad, 0x71, 0x6d, 0x70, 0xae, 0x02, 0xea,
 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1,
 0x5a, 0xe0, 0x31, 0xaf, 0x70, 0xaf, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5,
 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x06, 0x97, 0x9c, 0x22, 0xfe, 0xe8, 0xa6, 0x97, 0x5f, 0x79, 0xf5,
 0x50, 0x53, 0x54, 0xb3, 0x9b, 0xa2, 0xeb, 0x98, 0x66, 0x78, 0xfb, 0xdf, 0xaa, 0x82, 0x9a, 0x97,
 0x03, 0x6b, 0xc8, 0x91, 0x7f, 0x2f, 0x73, 0xf7, 0x07, 0xfd, 0xc6, 0xfb, 0x5a, 0xe7, 0x21, 0xc3,
 0x31, 0x38, 0xf8, 0x74, 0xd7, 0xaa, 0x65, 0x95, 0x95, 0x37, 0x55, 0xbe, 0x5a, 0x6a, 0x9a, 0x28,
 0xcf, 0xd7, 0x86, 0x2d, 0xd7, 0x2d, 0xd9, 0x7e, 0x20, 0x74, 0xba, 0xd7, 0x0a, 0xd7, 0x39, 0xa7,
 0xaf, 0x0c, 0x5b, 0xae, 0x5b, 0xb2, 0xfc, 0x43, 0xd7, 0x86, 0x2d, 0xd7, 0x2d, 0xd9, 0x7e, 0x20,
 0x74, 0xba, 0xd7, 0x0a, 0xc7, 0x34, 0xf5, 0xe1, 0x8b, 0x75, 0xcb, 0x76, 0x5f, 0x88, 0xcb, 0x2e,
 0x66, 0x39, 0xf9, 0xfc, 0x51, 0xb2, 0xd3, 0x0b, 0x06, 0x9a, 0xb1, 0xcb, 0xe4, 0xb3, 0x45, 0xd5,
 0x13, 0xd2, 0x06, 0xf3, 0x5a, 0xe1, 0x58, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x2a, 0xda, 0x14, 0x6d,
 0x70, 0xe9, 0x5f, 0xe9, 0xd7, 0xea, 0xa9, 0xa5, 0x55, 0x36, 0x5c, 0xff, 0x00, 0x17, 0x5c, 0x3e,
 0x5b, 0x8f, 0xbb, 0xaf, 0xd5, 0x53, 0x4d, 0xa9, 0x70, 0x18, 0xca, 0xc6, 0xdd, 0x9a, 0x82, 0xee,
 0xa8, 0x8d, 0x5f, 0x9d, 0x0e, 0xae, 0xb1, 0xd3, 0x5e, 0x67, 0x17, 0xab, 0xa7, 0x1d, 0x7e, 0x43,
 0xa9, 0xca, 0xcd, 0xa4, 0x69, 0x68, 0x51, 0x91, 0xda, 0xa3, 0xd8, 0x8e, 0x4f, 0x8d, 0x00, 0x6b,
 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x9a, 0xf6, 0x66, 0xc0, 0xd3,
 0x11, 0x72, 0xcd, 0xca, 0xb9, 0xac, 0x99, 0xd3, 0xca, 0x45, 0xe0, 0x91, 0x3b, 0x94, 0x61, 0x5a,
 0xe1, 0x58, 0x0e, 0x77, 0x39, 0x06, 0x62, 0x4e, 0x22, 0xc3, 0x99, 0x82, 0xf8, 0x4e, 0xea, 0x72,
 0x73, 0xf4, 0x29, 0x86, 0xad, 0xce, 0x91, 0x11, 0xd0, 0xe2, 0xb1, 0x59, 0x11, 0xad, 0x7b, 0x57,
 0x9a, 0x39, 0x11, 0x50, 0x55, 0x35, 0x81, 0x61, 0x11, 0xd5, 0x57, 0xd4, 0xd4, 0x97, 0xae, 0x13,
 0x95, 0xbf, 0x37, 0x20, 0x34, 0xd6, 0x47, 0x73, 0x1d, 0xbc, 0xc7, 0xb9, 0x8e, 0xeb, 0x6a, 0xe8,
 0xa3, 0x29, 0x3c, 0xc9, 0x8b, 0xca, 0xe8, 0x8c, 0x9d, 0x7b, 0xda, 0x9f, 0x9b, 0x17, 0xcb, 0x4f,
 0x9c, 0xbd, 0x33, 0x95, 0x61, 0x2e, 0xab, 0x2d, 0x3a, 0xf6, 0xaf, 0x54, 0x46, 0xa2, 0xfc, 0xe8,
 0x2a, 0x9b, 0xcb, 0xf8, 0xa4, 0x0d, 0x55, 0x90, 0xd9, 0x30, 0xd4, 0xff, 0x00, 0x24, 0xed, 0x57,
 0xe4, 0x50, 0x30, 0xce, 0xce, 0xbe, 0x6e, 0x6e, 0x34, 0xcc, 0x44, 0x6a, 0x3e, 0x2b, 0x95, 0xce,
 0xdd, 0xe5, 0xaa, 0x98, 0x6a, 0x94, 0xde, 0xe7, 0xb1, 0xea, 0xc7, 0xb5, 0x5a, 0xe4, 0x5d, 0x15,
 0x15, 0x34, 0x54, 0x3c, 0xa9, 0x70, 0x3a, 0x16, 0xcf, 0x62, 0xe9, 0x86, 0xcd, 0x71, 0xf7, 0x74,
 0xfa, 0xa8, 0x6c, 0xd5, 0xae, 0x69, 0x59, 0x02, 0x2e, 0x98, 0x7c, 0xcf, 0x1f, 0x76, 0x4f, 0xaa,
 0x86, 0xc9, 0x5a, 0xe0, 0x61, 0xce, 0x31, 0xb5, 0xcb, 0x93, 0x5f, 0xd4, 0xfa, 0xc8, 0x73, 0xa4,
 0x8b, 0x73, 0x74, 0xcd, 0xd1, 0xb5, 0xcb, 0xd3, 0x5c, 0x7d, 0xe7, 0xd6, 0x43, 0x9f, 0xd4, 0xb8,
 0x17, 0x16, 0x2f, 0x05, 0xf4, 0x1d, 0x4f, 0x0b, 0x8c, 0x9e, 0x2c, 0x95, 0xe3, 0xee, 0x2c, 0xfa,
 0xa8, 0x72, 0x0a, 0x97, 0x3a, 0x56, 0x03, 0x34, 0x91, 0x30, 0x59, 0x37, 0xa2, 0xfb, 0x8b, 0x51,
 0x7e, 0x2e, 0x00, 0x3e, 0xad, 0x70, 0x58, 0xdc, 0x17, 0x88, 0xba, 0xb5, 0xc8, 0xbe, 0x32, 0x23,
 0x55, 0x75, 0xe4, 0x9a, 0x81, 0xcd, 0xd6, 0x2f, 0x15, 0x0a, 0xb7, 0x29, 0x2c, 0x4e, 0x3c, 0xc2,
 0xa5, 0xc0, 0xe9, 0x39, 0x0e, 0x37, 0xe4, 0x1d, 0x35, 0xe5, 0x1d, 0xff, 0x00, 0x70, 0xfe, 0xb5,
 0xcd, 0x2f, 0x21, 0xcc, 0xa2, 0xe1, 0x91, 0xe1, 0xeb, 0xc5, 0x91, 0xb5, 0xf9, 0x51, 0x3b, 0x8d,
 0x8d, 0x23, 0x5c, 0x06, 0x35, 0x8e, 0x75, 0x9c, 0x62, 0xeb, 0x98, 0xe6, 0xbf, 0xa9, 0xf5, 0x50,
 0xdd, 0x2b, 0x5c, 0xe7, 0xb9, 0xb6, 0x36, 0xf6, 0x61, 0x9a, 0x5d, 0x7a, 0x5a, 0x9f, 0xee, 0xa0,
 0x15, 0xea, 0x9b, 0x36, 0xcf, 0x62, 0xe9, 0x88, 0xcd, 0x2e, 0xbe, 0xe0, 0x9f, 0x59, 0x0d, 0x32,
 0xa5, 0xcd, 0x93, 0x20, 0x45, 0xd3, 0x10, 0x9a, 0xe3, 0xee, 0x29, 0xf5, 0x90, 0x0e, 0x89, 0x5a,
 0xe6, 0xa5, 0xb4, 0x48, 0xba, 0xb6, 0x47, 0xab, 0x57, 0xff, 0x00, 0xca, 0x3c, 0xad, 0x73, 0x59,
 0xcf, 0xeb, 0xbd, 0x25, 0x2b, 0x17, 0x5f, 0x6b, 0x15, 0x51, 0x7e, 0x34, 0xfc, 0x00, 0xd6, 0xea,
 0x85, 0x52, 0x95, 0x43, 0x2c, 0xa3, 0x99, 0x12, 0x6a, 0x0c, 0x38, 0x8a, 0xbb, 0x8e, 0x7b, 0x51,
 0xda, 0x2f, 0x42, 0xa8, 0x19, 0xf7, 0xd3, 0xa9, 0x02, 0xa2, 0x75, 0x27, 0xc8, 0x6d, 0xde, 0xb6,
 0xb0, 0x9d, 0x79, 0xcc, 0xf6, 0xbf, 0x81, 0xe7, 0xad, 0xac, 0x27, 0xae, 0x67, 0xb5, 0xfc, 0x00,
 0xd4, 0xaa, 0x27, 0x52, 0x7c, 0x81, 0x51, 0x3a, 0x90, 0xdb, 0x7d, 0x6d, 0x61, 0x3d, 0x73, 0x3d,
 0xaf, 0xe0, 0x6b, 0x19, 0x92, 0x5e, 0x5e, 0x43, 0x14, 0x59, 0x69, 0x55, 0x7e, 0xe2, 0x31, 0xaa,
 0xbb, 0xce, 0xd5, 0x75, 0x50, 0x30, 0xd4, 0x4e, 0xa4, 0x1f, 0x64, 0x57, 0xa2, 0xe3, 0xed, 0x54,
 0x44, 0xf2, 0x60, 0xbd, 0x7e, 0x83, 0x55, 0xa9, 0x73, 0x64, 0xc8, 0x3a, 0xac, 0xfc, 0xc4, 0x6e,
 0x86, 0x42, 0x46, 0xfc, 0x6a, 0xbf, 0x80, 0x1d, 0x12, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15,
 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c,
 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6,
 0xb5, 0xc4, 0x39, 0xee, 0x36, 0xb8, 0x0e, 0x9a, 0xfb, 0xbb, 0x3e, 0xf2, 0xed, 0x6b, 0x88, 0xb3,
 0xcc, 0x6f, 0xc8, 0x5c, 0xfd, 0xd9, 0x9f, 0x78, 0x1a, 0x95, 0x5b, 0x82, 0x45, 0xe2, 0x85, 0x2a,
 0x97, 0x04, 0x89, 0xc5, 0x38, 0x81, 0xd9, 0xd2, 0x37, 0x04, 0xe2, 0x7b, 0x5a, 0xe2, 0xd4, 0x8d,
 0xc3, 0x99, 0xed, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x78, 0xb1, 0xae, 0x03,
 0x2a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a,
 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xb6, 0xb5, 0xc2,
 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0x0a, 0xd7, 0x01,
 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x05, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae,
 0x15, 0xae, 0x06, 0xa5, 0x9b, 0x22, 0xfe, 0xe8, 0x26, 0x78, 0xfb, 0xdf, 0xaa, 0x82, 0xba, 0x97,
 0x33, 0xe6, 0x98, 0xba, 0xe3, 0xb3, 0x3f, 0xd5, 0xfa, 0xa8, 0x2b, 0xaa, 0x05, 0xda, 0x97, 0x0a,
 0x97, 0x25, 0x81, 0x4b, 0x43, 0xc4, 0x27, 0xfd, 0x4f, 0x12, 0x23, 0xd8, 0xdd, 0xc7, 0x3b, 0x56,
 0xe9, 0xaf, 0x0d, 0x3a, 0xc7, 0xde, 0xb6, 0xa4, 0xfc, 0xee, 0x63, 0xe4, 0x68, 0x1a, 0xfd, 0x4b,
 0x85, 0x4b, 0x9b, 0x07, 0xad, 0xa9, 0x3f, 0x3b, 0x98, 0xf9, 0x1a, 0x1e, 0xb6, 0xa4, 0xfc, 0xee,
 0x63, 0xe4, 0x68, 0x1a, 0xfd, 0x5b, 0x8e, 0x72, 0x6c, 0x5d, 0x31, 0xc6, 0x71, 0xf7, 0x37, 0xfd,
 0x06, 0x7f, 0x5b, 0x52, 0x7e, 0x77, 0x31, 0xf2, 0x34, 0xb5, 0x85, 0xe0, 0xf2, 0xf8, 0x7c, 0xe2,
 0x4d, 0x43, 0x98, 0x8c, 0xf7, 0x23, 0x55, 0xba, 0x39, 0x13, 0x4e, 0x3e, 0x80, 0x36, 0x8a, 0xd7,
 0x0a, 0xc2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x76, 0x7c, 0x8b, 0xae, 0x1f, 0x2d, 0xc7, 0xdd, 0x97,
 0xea, 0xa9, 0xa7, 0xd5, 0xb9, 0xb0, 0xe7, 0x88, 0xda, 0xc8, 0x4b, 0x71, 0xf7, 0x65, 0xfa, 0xaa,
 0x6a, 0x35, 0x40, 0xbb, 0x56, 0xe6, 0xdf, 0x94, 0x31, 0xa8, 0x4e, 0x95, 0x6e, 0x1f, 0x1e, 0x22,
 0x32, 0x24, 0x3e, 0x10, 0xf7, 0x97, 0x4d, 0xe6, 0xf5, 0x7a, 0x50, 0xd1, 0x61, 0xb9, 0xcf, 0x72,
 0xa3, 0x11, 0x5c, 0xa8, 0x8a, 0xba, 0x27, 0x52, 0x26, 0xaa, 0x46, 0xa8, 0x1d, 0x7e, 0xb2, 0x98,
 0x21, 0x62, 0x72, 0xb1, 0xa6, 0x9d, 0x2d, 0x0a, 0x3b, 0x1f, 0x15, 0x8d, 0xde, 0x73, 0x51, 0x75,
 0xd1, 0x35, 0xeb, 0x39, 0x5a, 0xce, 0x47, 0x56, 0x6e, 0x2c, 0x78, 0xaa, 0xde, 0xad, 0xf5, 0xd0,
 0xb5, 0x81, 0x4f, 0xfa, 0x8f, 0x15, 0x81, 0x19, 0x57, 0x46, 0xab, 0xb7, 0x5f, 0xe8, 0x5e, 0x00,
 0x75, 0x1a, 0xd7, 0x10, 0x4c, 0xe6, 0xf9, 0x58, 0x6e, 0x73, 0x61, 0xcb, 0xc7, 0x88, 0xe6, 0xaa,
 0xa7, 0x95, 0xa3, 0x53, 0x52, 0xf5, 0x7b, 0x9a, 0x4e, 0x6a, 0x96, 0x59, 0x6c, 0x49, 0xd1, 0x9a,
 0x9a, 0x42, 0x8f, 0xe5, 0x25, 0x9d, 0xd2, 0x9f, 0x78, 0x0e, 0x26, 0x33, 0x8c, 0xdb, 0xb5, 0x48,
 0x32, 0xf0, 0x61, 0xa7, 0x5b, 0x95, 0x5d, 0xdc, 0x6c, 0x18, 0x16, 0x2b, 0xe3, 0x1c, 0x3d, 0x91,
 0x95, 0xc9, 0x55, 0x3c, 0x98, 0xa8, 0x9d, 0x0e, 0x39, 0x7d, 0x52, 0xc4, 0x86, 0x25, 0x33, 0x23,
 0x1a, 0xac, 0xb4, 0x55, 0x62, 0xaf, 0x05, 0x4e, 0x68, 0xa9, 0x74, 0x03, 0xab, 0xd6, 0xb8, 0x56,
 0xeb, 0x53, 0x40, 0x6e, 0x6f, 0x9d, 0x44, 0xd1, 0xd0, 0x25, 0xdc, 0xbd, 0x7c, 0x53, 0xef, 0x2a,
 0x4f, 0xe6, 0x4c, 0x46, 0x6e, 0x13, 0xa1, 0x2b, 0xd9, 0x0a, 0x1b, 0x93, 0x45, 0x48, 0x69, 0xa2,
 0xaa, 0x7a, 0x40, 0x96, 0x2d, 0x34, 0x91, 0xf1, 0x49, 0xa8, 0xed, 0x5d, 0x5a, 0xf8, 0xae, 0x54,
 0x5d, 0x79, 0xf1, 0x2a, 0xd5, 0xb9, 0x4a, 0xa8, 0x55, 0x03, 0x7f, 0xc8, 0xb1, 0x37, 0x70, 0xc8,
 0xee, 0xf7, 0xd1, 0xbe, 0x84, 0x43, 0x60, 0xaf, 0x73, 0x5b, 0xcb, 0x0d, 0x59, 0x7c, 0x16, 0x0b,
 0x5d, 0xaa, 0x39, 0xfa, 0xc4, 0x54, 0xf4, 0xf2, 0xf9, 0x86, 0x75, 0xae, 0x06, 0x3c, 0xd9, 0x1b,
 0x5c, 0xbf, 0x33, 0xc7, 0xde, 0xfd, 0x64, 0x34, 0x2a, 0x86, 0xdd, 0x9a, 0xa3, 0x6b, 0x80, 0xcc,
 0xa6, 0xbe, 0xf7, 0xeb, 0x21, 0xa2, 0x2c, 0x4b, 0x81, 0x76, 0xa5, 0xcd, 0xbb, 0x25, 0xe2, 0xcc,
 0x59, 0x75, 0xc3, 0xe2, 0x3d, 0x11, 0xec, 0x55, 0x74, 0x3d, 0x57, 0xdb, 0x22, 0xf3, 0x43, 0x45,
 0x63, 0xd5, 0xef, 0x6b, 0x1a, 0x9a, 0xb9, 0xca, 0x88, 0x89, 0xd6, 0xa7, 0xab, 0x11, 0xf0, 0xdf,
 0xa2, 0xef, 0x31, 0xed, 0x5f, 0x42, 0xa2, 0xa0, 0x1d, 0x76, 0xb5, 0xca, 0xb8, 0xb4, 0xf3, 0x25,
 0x70, 0xd9, 0x88, 0xcf, 0x72, 0x26, 0x8c, 0x54, 0x4b, 0xaa, 0xa6, 0x88, 0x68, 0x12, 0xf9, 0x9b,
 0x14, 0x82, 0xc4, 0x6d, 0x76, 0xc4, 0x44, 0xe4, 0xb1, 0x19, 0xaa, 0xfc, 0xa5, 0x4c, 0x43, 0x16,
 0x9c, 0x9f, 0x54, 0xf5, 0x4c, 0x6d, 0xe6, 0xb7, 0x93, 0x51, 0x34, 0x6a, 0x7c, 0x40, 0x4a, 0xa5,
 0xc2, 0xa5, 0xca, 0x55, 0x4f, 0x5b, 0x11, 0x5c, 0xe4, 0x6a, 0x71, 0x55, 0x5d, 0x11, 0x00, 0xd9,
 0x72, 0x9e, 0x2a, 0xc9, 0x0c, 0x41, 0x5b, 0x19, 0xfb, 0xb0, 0x63, 0x26, 0xeb, 0x95, 0x79, 0x35,
 0x7a, 0x17, 0xe9, 0xf9, 0x4d, 0xe6, 0xbe, 0xbc, 0x75, 0xe6, 0x72, 0x38, 0xf5, 0x60, 0x46, 0x74,
 0x28, 0xcc, 0x56, 0x3d, 0xab, 0xa2, 0xa2, 0xf4, 0x17, 0x64, 0x71, 0xdc, 0x42, 0x4d, 0x89, 0x0e,
 0x14, 0x7d, 0x61, 0xa7, 0x26, 0x3d, 0x37, 0x91, 0x3d, 0x1d, 0x40, 0x74, 0xe7, 0x47, 0x46, 0xa2,
 0xab, 0x97, 0x44, 0x4e, 0x2a, 0xaa, 0xbc, 0x8e, 0x71, 0x8b, 0x4e, 0x24, 0xd6, 0x27, 0x33, 0x30,
 0xd5, 0xd5, 0xaf, 0x88, 0xaa, 0xdf, 0x47, 0x24, 0x30, 0xcf, 0xe3, 0xd8, 0x8c, 0xec, 0x25, 0x85,
 0x16, 0x3a, 0x24, 0x35, 0xe6, 0xd6, 0x37, 0x75, 0x14, 0x5d, 0x54, 0x0b, 0xb5, 0x6e, 0x6c, 0xb9,
 0x0d, 0xeb, 0xea, 0xa9, 0xa8, 0x9d, 0x50, 0xda, 0x9f, 0x3f, 0xe0, 0x69, 0xb5, 0x4d, 0xcb, 0x26,
 0xc3, 0x74, 0x0c, 0x39, 0xd1, 0xdc, 0x9a, 0x3a, 0x3b, 0xb5, 0x4f, 0xd1, 0x4e, 0x09, 0xf7, 0x81,
 0xb6, 0xd6, 0xb8, 0xbb, 0x31, 0xc3, 0x59, 0xcc, 0x1e, 0x3c, 0x26, 0xa6, 0xaf, 0x6a, 0x6f, 0xb5,
 0x2e, 0x9c, 0x7e, 0x8d, 0x42, 0xb5, 0xc2, 0xb0, 0x1c, 0xfa, 0xad, 0xcf, 0x52, 0x2a, 0xa7, 0x14,
 0x5d, 0x14, 0xb1, 0x99, 0x64, 0x96, 0x46, 0x75, 0x62, 0x43, 0x6f, 0xf7, 0xbc, 0x55, 0x55, 0x62,
 0xfb, 0xd5, 0xe9, 0x68, 0xa6, 0xa8, 0x1d, 0x47, 0x03, 0xc5, 0x59, 0x88, 0x48, 0x32, 0x2a, 0x39,
 0x2a, 0x35, 0x11, 0xb1, 0x1b, 0xd2, 0x8e, 0xfc, 0x4b, 0xd5, 0xee, 0x72, 0x69, 0x39, 0xf9, 0x89,
 0x48, 0xc9, 0x16, 0x5e, 0x2b, 0xa1, 0xbf, 0x97, 0x0e, 0x94, 0xea, 0x54, 0xe9, 0x1c, 0xb7, 0x37,
 0x4f, 0x23, 0x34, 0x74, 0x18, 0x0e, 0x77, 0xbe, 0xd1, 0x53, 0xef, 0x03, 0x7d, 0x8f, 0x37, 0x0e,
 0x04, 0x17, 0xc6, 0x8d, 0x11, 0x19, 0x0d, 0x89, 0xab, 0x95, 0x4e, 0x73, 0x8a, 0x4f, 0x2c, 0xee,
 0x21, 0x1a, 0x69, 0x78, 0x54, 0x76, 0xa8, 0x9d, 0x49, 0xc9, 0x3e, 0x62, 0xb6, 0x25, 0x8c, 0x4e,
 0x62, 0x0a, 0x9e, 0xa8, 0x8b, 0xe4, 0x22, 0xea, 0x90, 0xda, 0x9a, 0x35, 0x3e, 0x2e, 0x92, 0x95,
 0x50, 0x2e, 0xd4, 0xb9, 0xbb, 0x64, 0xb8, 0x6b, 0x03, 0x0a, 0x58, 0xce, 0xe0, 0xe8, 0xee, 0xde,
 0x4f, 0xd1, 0x4e, 0x09, 0xf7, 0x9a, 0x46, 0x11, 0x2b, 0x13, 0x10, 0x9c, 0x6c, 0x06, 0xea, 0x8d,
 0xe6, 0xf7, 0x7b, 0xd6, 0x9d, 0x02, 0x13, 0xdb, 0x0a, 0x1b, 0x61, 0xb1, 0x11, 0xad, 0x6a, 0x22,
 0x35, 0x13, 0xa1, 0x00, 0x67, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b,
 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad,
 0x70, 0x18, 0xd6, 0xff, 0x00, 0xcd, 0x42, 0xb5, 0xcd, 0x6f, 0x32, 0x4f, 0xc7, 0x94, 0xc3, 0x2b,
 0xcb, 0xc4, 0xdc, 0x88, 0x91, 0x1a, 0x9a, 0xf3, 0xe0, 0x2c, 0xc3, 0xb3, 0x6f, 0x14, 0x64, 0xf4,
 0x24, 0x44, 0xff, 0x00, 0x29, 0x0d, 0x3e, 0x94, 0xee, 0x03, 0x77, 0xad, 0x71, 0x26, 0x75, 0x8d,
 0xae, 0x09, 0xcf, 0xdd, 0x99, 0xf7, 0x99, 0xa5, 0xe7, 0x60, 0xcc, 0x42, 0x48, 0xb0, 0x22, 0xb6,
 0x23, 0x17, 0x92, 0xb5, 0x45, 0x39, 0xce, 0x37, 0xe4, 0x6e, 0x7e, 0xec, 0xcf, 0xbc, 0x0d, 0x62,
 0xa5, 0xc1, 0x22, 0x71, 0x4e, 0x25, 0x2a, 0xa0, 0x91, 0x78, 0x81, 0xd7, 0xd2, 0x37, 0x0e, 0x61,
 0x5a, 0xe2, 0xea, 0xdc, 0x13, 0x88, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0xdc, 0x5d, 0x5a, 0xe1,
 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x72, 0x46, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x05, 0x61,
 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xee, 0x02, 0xea,
 0xd7, 0x3c, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc5, 0x23, 0x5c, 0xf6, 0xb5, 0xc5, 0xb5,
 0xae, 0x15, 0xae, 0x03, 0x14, 0x8d, 0x70, 0x58, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0xab,
 0x5c, 0xf2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x06, 0xb3, 0x99, 0xe2, 0xeb, 0x8d, 0xcc, 0x2e,
 0xbe, 0xf7, 0xea, 0xa0, 0xb6, 0xa9, 0x97, 0x32, 0xc5, 0xfc, 0xb5, 0x31, 0xfd, 0x5f, 0xaa, 0x82,
 0xda, 0xa0, 0x6c, 0xb9, 0x3e, 0x2f, 0xe5, 0x8e, 0x7e, 0xe4, 0xff, 0x00, 0xb8, 0xdc, 0x6b, 0x5c,
 0xd0, 0x32, 0x94, 0x5d, 0x31, 0x7e, 0x7e, 0xe4, 0xef, 0xb8, 0xdb, 0xab, 0x5c, 0x06, 0x4b, 0x18,
 0xf2, 0xb5, 0xc5, 0xd5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7,
 0x01, 0x92, 0xc6, 0xb9, 0xe5, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x0a, 0x59, 0xd6, 0x2e, 0xb2,
 0x32, 0xff, 0x00, 0xd2, 0xaf, 0xd5, 0x53, 0x54, 0xa8, 0xbf, 0xf8, 0x86, 0xf1, 0x58, 0x2b, 0x25,
 0x80, 0xd6, 0xb2, 0xcc, 0x4f, 0xcb, 0x72, 0xfa, 0xf2, 0xf2, 0xb9, 0xfe, 0x8a, 0x99, 0xb1, 0xfc,
 0x31, 0xf2, 0x91, 0x5d, 0x31, 0x2e, 0xd5, 0x74, 0xbb, 0x97, 0x5e, 0x1c, 0x77, 0x2d, 0xe8, 0x1f,
 0xd6, 0x0a, 0xd7, 0x03, 0x48, 0xa8, 0x7a, 0xc7, 0xab, 0xdc, 0x8c, 0x62, 0x2b, 0x9c, 0xbc, 0x91,
 0x13, 0x55, 0x36, 0xd8, 0x92, 0xd2, 0x31, 0x1d, 0xbc, 0xf9, 0x48, 0x0e, 0x5e, 0xb5, 0x62, 0x19,
 0x60, 0xa4, 0x08, 0x29, 0xa4, 0x18, 0x50, 0xe1, 0xfe, 0x8b, 0x51, 0x00, 0xbb, 0x86, 0xcc, 0x46,
 0x7c, 0x84, 0x07, 0x4c, 0x31, 0xd0, 0xe2, 0xee, 0x26, 0xfb, 0x5d, 0xcf, 0x53, 0xd9, 0xf8, 0x70,
 0x67, 0x65, 0x5d, 0x2f, 0x19, 0x35, 0x6b, 0xb9, 0x2a, 0x73, 0x45, 0xeb, 0x42, 0xad, 0x6b, 0x85,
 0x6b, 0x81, 0xab, 0xe2, 0x58, 0x74, 0xdc, 0x93, 0xd5, 0x5c, 0xc5, 0x89, 0x0b, 0x5e, 0x11, 0x1a,
 0x9a, 0xa7, 0xc7, 0xd4, 0x50, 0xaa, 0x86, 0xef, 0x5a, 0xe5, 0x68, 0xf2, 0xd2, 0x51, 0xd7, 0x58,
 0xb2, 0xb0, 0x9c, 0xbd, 0x7b, 0xbc, 0x40, 0xd4, 0x2a, 0x1e, 0xd4, 0x36, 0x65, 0xc2, 0xb0, 0xb5,
 0x5f, 0xf0, 0x54, 0x4f, 0x43, 0x9d, 0xde, 0x7a, 0xdc, 0x33, 0x0c, 0x6a, 0xea, 0x92, 0x8c, 0x5f,
 0x4a, 0xaa, 0xfd, 0xe0, 0x6b, 0x0d, 0x7a, 0xb9, 0xc8, 0xd6, 0xa2, 0xb9, 0xcb, 0xc9, 0x11, 0x35,
 0x51, 0xfe, 0x09, 0x83, 0x44, 0x89, 0x11, 0xb1, 0xe7, 0x9b, 0xb9, 0x0d, 0x38, 0xa4, 0x35, 0xe6,
 0xef, 0x4f, 0x52, 0x0c, 0xe0, 0x36, 0x04, 0x04, 0xd2, 0x0c, 0x18, 0x70, 0xff, 0x00, 0x45, 0xa8,
 0x86, 0x5a, 0xf7, 0x01, 0x8a, 0x46, 0xd3, 0x97, 0x00, 0x58, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8,
 0x1e, 0x66, 0x78, 0xba, 0xe0, 0x73, 0x1f, 0xd5, 0xfa, 0xc8, 0x69, 0x35, 0x0d, 0xde, 0xb5, 0xc2,
 0xb0, 0x1a, 0x74, 0x9c, 0x4d, 0x27, 0x20, 0x73, 0xfd, 0xf5, 0xbf, 0x4a, 0x1b, 0x56, 0x3f, 0x85,
 0x32, 0x79, 0xee, 0x98, 0x97, 0x56, 0xb2, 0x63, 0xa5, 0x3a, 0x1f, 0xdc, 0xb7, 0x33, 0x55, 0x44,
 0xea, 0x3d, 0x48, 0xd7, 0x03, 0x4d, 0x9a, 0x87, 0x1e, 0x56, 0x22, 0xc3, 0x98, 0x84, 0xe8, 0x6e,
 0xfe, 0x32, 0x70, 0xf9, 0x4c, 0x35, 0x0d, 0xdd, 0xf1, 0x1b, 0x11, 0xbb, 0xaf, 0x6a, 0x39, 0xbd,
 0x4a, 0x9a, 0xa1, 0x59, 0x64, 0xf0, 0xf5, 0x5d, 0x56, 0x4e, 0x02, 0xaf, 0xe8, 0x20, 0x1a, 0x9c,
 0x37, 0x3a, 0x23, 0xd1, 0x90, 0xda, 0xe7, 0xb9, 0x79, 0x35, 0xa9, 0xaa, 0x9b, 0x3e, 0x5e, 0xc2,
 0x5d, 0x2f, 0x11, 0xb3, 0x73, 0x88, 0x95, 0x13, 0x8b, 0x21, 0xf3, 0xdd, 0xba, 0xdc, 0xb7, 0x06,
 0x94, 0x16, 0xe9, 0x06, 0x1b, 0x21, 0xa7, 0xf1, 0x5a, 0x88, 0x64, 0xad, 0x70, 0x3c, 0xc6, 0xf0,
 0xf8, 0x38, 0x8b, 0x11, 0xe8, 0xe4, 0x87, 0x30, 0xd4, 0xd1, 0xaf, 0xd3, 0x9d, 0x96, 0xc6, 0xa3,
 0x3b, 0x2d, 0x35, 0x26, 0xfd, 0xc9, 0x88, 0x4e, 0x6f, 0x53, 0xb4, 0xf2, 0x57, 0xd0, 0xa6, 0xdf,
 0x5e, 0xe7, 0x8e, 0x8a, 0x8e, 0x45, 0x6b, 0x91, 0x15, 0x17, 0x9a, 0x2f, 0x20, 0x34, 0x9a, 0xa9,
 0xd6, 0x09, 0x13, 0x55, 0xd1, 0x38, 0xaf, 0x52, 0x1b, 0x6b, 0xe5, 0x24, 0x1e, 0xed, 0x5d, 0x27,
 0x01, 0x57, 0xf4, 0x10, 0xcb, 0x05, 0x92, 0xf0, 0x78, 0xc1, 0x81, 0x0a, 0x1a, 0xf5, 0xb5, 0x88,
 0x80, 0x27, 0xc1, 0xb0, 0x78, 0xd3, 0x11, 0x1b, 0x16, 0x71, 0xae, 0x87, 0x01, 0x38, 0xee, 0xaf,
 0x07, 0x3f, 0xb9, 0x0d, 0xb5, 0xb1, 0x5a, 0xd6, 0xa3, 0x5a, 0x88, 0xd4, 0x44, 0xd1, 0x11, 0x39,
 0x20, 0xbe, 0xb5, 0xc2, 0xb5, 0xc0, 0x65, 0x5a, 0xe0, 0xb1, 0xae, 0x2d, 0xad, 0x70, 0xad, 0x70,
 0x2e, 0xcd, 0x36, 0x14, 0xd4, 0x07, 0x40, 0x8e, 0xdd, 0xf8, 0x6e, 0x4e, 0x28, 0x6a, 0x18, 0xae,
 0x11, 0x33, 0x28, 0xe7, 0x3e, 0x0a, 0x3a, 0x3c, 0x1e, 0x68, 0xad, 0x4f, 0x29, 0xbe, 0x94, 0xfb,
 0xcd, 0x8a, 0xb5, 0xc2, 0xbd, 0xc0, 0xd2, 0x2a, 0x05, 0x43, 0x6f, 0x98, 0x97, 0x93, 0x98, 0x5d,
 0x63, 0x4b, 0x42, 0x7a, 0xf5, 0xab, 0x78, 0xfc, 0xa5, 0x6f, 0x15, 0x61, 0x7a, 0xeb, 0xea, 0x54,
 0xfd, 0x77, 0x77, 0x81, 0xac, 0x55, 0x4e, 0xbd, 0x06, 0x18, 0x6e, 0x1b, 0x39, 0x3a, 0xa8, 0xa8,
 0xd5, 0x87, 0x0b, 0xa6, 0x23, 0xd3, 0x44, 0xf8, 0x93, 0xa4, 0x7d, 0x02, 0x56, 0x46, 0x03, 0xb7,
 0xa1, 0x4a, 0xc2, 0x6a, 0xf5, 0xee, 0xea, 0xbf, 0x39, 0x6a, 0xb0, 0x16, 0x30, 0xd9, 0x78, 0x12,
 0x12, 0xf4, 0x60, 0x27, 0x3e, 0x2e, 0x72, 0xf3, 0x72, 0xdc, 0xb3, 0x5a, 0xe2, 0xea, 0xd7, 0x0a,
 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x7a, 0x91,
 0xee, 0x2d, 0xad, 0x70, 0xad, 0x70, 0x19, 0x2c, 0x6b, 0x9e, 0x56, 0xb8, 0xba, 0xb0, 0x56, 0xb8,
 0x18, 0xb3, 0x6c, 0x5f, 0xc8, 0xee, 0xe3, 0xee, 0x8d, 0xfb, 0xcd, 0x32, 0xa5, 0xcd, 0xc3, 0x11,
 0x85, 0x0e, 0x76, 0x55, 0x60, 0x45, 0x73, 0x9a, 0xd5, 0x54, 0x5d, 0x5b, 0xcd, 0x15, 0x0d, 0x63,
 0x12, 0xc2, 0x26, 0x65, 0x51, 0x62, 0x42, 0x5a, 0xf0, 0x93, 0x9a, 0xb5, 0x3c, 0xa4, 0xf4, 0xa7,
 0x70, 0x04, 0x8e, 0x23, 0x31, 0x25, 0x1a, 0xa4, 0xbc, 0x55, 0x6a, 0xaf, 0xb6, 0x45, 0xe2, 0x8e,
 0xf4, 0xa0, 0xe3, 0x18, 0xc6, 0x60, 0xe2, 0x38, 0x16, 0x89, 0xa3, 0x23, 0xb6, 0x2b, 0x37, 0xa1,
 0xaa, 0xfa, 0x78, 0xa7, 0x5a, 0x1a, 0x8d, 0x50, 0xab, 0x70, 0x2f, 0x55, 0x04, 0x8b, 0xc4, 0xa3,
 0x54, 0xf6, 0xaf, 0x10, 0x3a, 0xaa, 0x46, 0xb9, 0xed, 0x6b, 0x8b, 0x52, 0x3f, 0x0e, 0x61, 0x5a,
 0xe0, 0x32, 0xad, 0x73, 0xc5, 0x8d, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5,
 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x25, 0x8d, 0x70, 0x48, 0xd7, 0x16, 0xd6, 0xb8, 0x56, 0xb8,
 0x0c, 0xab, 0xdc, 0xf2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x02, 0xea, 0xd7, 0x0a, 0xd7, 0x17,
 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0xf2, 0xb5, 0xc5, 0xd5, 0xee, 0x15, 0xee, 0x03, 0x2a,
 0xf7, 0x0a, 0xd7, 0x16, 0xd7, 0xb9, 0xea, 0x46, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0xdc, 0x5b, 0x5e,
 0xe7, 0xb5, 0xae, 0x02, 0x0c, 0xc5, 0x17, 0xf2, 0xc4, 0x75, 0xd7, 0xde, 0xfd, 0x54, 0x17, 0x55,
 0xb9, 0x3c, 0xc1, 0x17, 0x5c, 0x5e, 0x3f, 0x1f, 0x7b, 0xf4, 0x21, 0x42, 0xa5, 0xc0, 0x69, 0x23,
 0x88, 0x45, 0x92, 0x8f, 0x5a, 0x0a, 0xb7, 0x7f, 0x75, 0x5b, 0xe5, 0x26, 0xa9, 0xa2, 0x97, 0xbd,
 0x72, 0xe2, 0x1d, 0x70, 0x3b, 0x3f, 0xc4, 0xd7, 0x6a, 0x5c, 0x2a, 0x5c, 0x0d, 0x8f, 0xd7, 0x2e,
 0x21, 0xfc, 0x87, 0x67, 0xf8, 0x9e, 0x7a, 0xe5, 0xc4, 0x3f, 0x90, 0xec, 0xff, 0x00, 0x13, 0x5d,
 0xa9, 0x70, 0xa9, 0x70, 0x36, 0x2f, 0x5c, 0xb8, 0x87, 0x5c, 0x0e, 0xcf, 0xf1, 0x0f, 0x5c, 0xb8,
 0x87, 0x5c, 0x0e, 0xcf, 0xf1, 0x35, 0xda, 0x97, 0x0a, 0x97, 0x03, 0x78, 0xc0, 0x31, 0x59, 0x89,
 0xe4, 0x8d, 0x5d, 0x59, 0xe4, 0x6e, 0xe9, 0xba, 0xdd, 0x39, 0xeb, 0xdc, 0x35, 0x48, 0xf7, 0x35,
 0x0c, 0xa7, 0x1b, 0x44, 0x99, 0xe3, 0xef, 0x7e, 0xf1, 0xf2, 0x46, 0xb8, 0x0c, 0x6b, 0xdc, 0x2b,
 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x73, 0xca, 0xd7, 0x17, 0x56, 0xb8, 0x2c, 0x7b,
 0x80, 0xc9, 0x63, 0x05, 0x6b, 0x8b, 0x6b, 0x5c, 0x2b, 0xdc, 0x06, 0x55, 0xae, 0x15, 0xee, 0x2d,
 0xad, 0x70, 0x58, 0xd7, 0x01, 0x95, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0xf1, 0x63, 0x5c, 0x06,
 0x55, 0xae, 0x15, 0xae, 0x2d, 0x48, 0xf7, 0x05, 0x8d, 0x70, 0x19, 0x56, 0xb8, 0x56, 0xb8, 0xb9,
 0x63, 0x5c, 0xf2, 0xbd, 0xc0, 0x65, 0x5a, 0xe1, 0x5a, 0xe2, 0xe5, 0x8d, 0x70, 0x48, 0xd7, 0x01,
 0x8d, 0x7b, 0x85, 0x6b, 0x8b, 0x6b, 0x5c, 0x2b, 0x5c, 0x06, 0x55, 0xae, 0x15, 0xae, 0x2e, 0xad,
 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xb6, 0xbd, 0xcf, 0x52, 0x35, 0xc0, 0x63, 0x5a,
 0xe1, 0x5c, 0x5b, 0x5b, 0x8f, 0x30, 0x58, 0xd7, 0x01, 0x95, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c,
 0xf1, 0x63, 0x5c, 0x06, 0x55, 0xc2, 0xb5, 0xc5, 0xa9, 0x1a, 0xe0, 0xb1, 0xee, 0x03, 0x2a, 0xd7,
 0x0a, 0xd7, 0x16, 0xd6, 0xb9, 0xea, 0x46, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5a, 0x91, 0xae,
 0x7b, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x6d, 0x7b, 0x85, 0x6b, 0x80, 0xca, 0xb5, 0xc2,
 0xb5, 0xc5, 0xb5, 0xee, 0x7a, 0x91, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x16, 0xa4, 0x6b, 0x82,
 0xc7, 0xb8, 0x0c, 0xab, 0x5c, 0x2b, 0x5c, 0x5b, 0x5a, 0xe1, 0x5e, 0xe0, 0x31, 0xad, 0x73, 0xda,
 0xd7, 0x16, 0xd6, 0xb8, 0x2c, 0x6b, 0x80, 0xca, 0xb0, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0,
 0x61, 0x5a, 0xe7, 0xb5, 0xae, 0x2d, 0xaf, 0x73, 0xda, 0xd7, 0x01, 0x8d, 0x60, 0xad, 0x71, 0x6a,
 0x47, 0xb8, 0x2c, 0x7b, 0x81, 0x8b, 0x18, 0xc3, 0x21, 0xcd, 0x6f, 0x46, 0x97, 0xd2, 0x1c, 0x7e,
 0x7a, 0x72, 0x6b, 0xbb, 0x96, 0xe6, 0xaf, 0x11, 0xce, 0x86, 0xf5, 0x63, 0xd1, 0x5a, 0xe6, 0xae,
 0x8a, 0x8b, 0xd0, 0x6d, 0xb5, 0xee, 0x28, 0xcc, 0x52, 0xc9, 0x1e, 0x0a, 0xcd, 0x43, 0x4f, 0xee,
 0xac, 0x4f, 0x2b, 0x4f, 0xce, 0x6f, 0xe0, 0x02, 0x7a, 0xb7, 0x3d, 0x48, 0x9c, 0x79, 0x94, 0xaa,
 0x5c, 0x12, 0x2d, 0xc0, 0xe9, 0x89, 0x1a, 0xe7, 0xb5, 0xae, 0x2d, 0x48, 0xd7, 0x05, 0x8f, 0x70,
 0x19, 0x56, 0xb8, 0x57, 0xb8, 0xb9, 0x63, 0x5c, 0x12, 0x35, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2,
 0xda, 0xf7, 0x0a, 0xf7, 0x01, 0x95, 0x7b, 0x85, 0x6b, 0x8b, 0x6b, 0xdc, 0x2b, 0xdc, 0x06, 0x55,
 0xae, 0x15, 0xae, 0x2e, 0x58, 0xd7, 0x3c, 0xaf, 0x70, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0xba, 0xb5,
 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5e, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85,
 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70,
 0x3c, 0x9c, 0xc3, 0xa0, 0xcd, 0x4c, 0xbe, 0x3b, 0xe3, 0x44, 0x6b, 0x9d, 0xa6, 0xa8, 0x9a, 0x69,
 0xcb, 0x43, 0x17, 0x89, 0xe5, 0xfc, 0xe2, 0x37, 0xc8, 0x86, 0x6a, 0xd7, 0x0a, 0xd7, 0x03, 0x0f,
 0x89, 0xe5, 0xfc, 0xe2, 0x37, 0xc8, 0x81, 0xe2, 0x79, 0x7f, 0x38, 0x8d, 0xf2, 0x21, 0x9a, 0xb5,
 0xc2, 0xb5, 0xc0, 0xc3, 0xe2, 0x79, 0x7f, 0x38, 0x8d, 0xf2, 0x20, 0x78, 0x9e, 0x5f, 0xce, 0x23,
 0x7c, 0x88, 0x66, 0xad, 0x70, 0xad, 0x70, 0x30, 0xf8, 0x9e, 0x5f, 0xce, 0x23, 0x7c, 0x88, 0x79,
 0xe2, 0x79, 0x7f, 0x38, 0x8d, 0xf3, 0x19, 0xeb, 0x5c, 0x2b, 0x5c, 0x0c, 0xb8, 0x74, 0xb4, 0x39,
 0x1a, 0x94, 0xe2, 0x3d, 0xfb, 0xfa, 0x6b, 0xbd, 0xa7, 0x0d, 0x3d, 0x1e, 0x92, 0xe5, 0x6b, 0x8b,
 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6,
 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5e, 0xe1, 0x5e, 0xe2, 0xea, 0xd7, 0x0a,
 0xd7, 0x01, 0x8d, 0x7b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae,
 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63,
 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0x52, 0x35,
 0xcf, 0x6b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0x85, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a,
 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0xdc, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0,
 0x31, 0xac, 0x15, 0x85, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8,
 0x56, 0xb8, 0x0c, 0x6b, 0xdc, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xac, 0x15, 0x85,
 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b,
 0xdc, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xac, 0x15, 0x85, 0xd5, 0xae, 0x15, 0xae,
 0x03, 0x1a, 0xd7, 0x0a, 0xf7, 0x17, 0x56, 0xba, 0x85, 0x6b, 0x80, 0xc6, 0xbd, 0xc2, 0xb0, 0xba,
 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b,
 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad,
 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe0, 0xb1, 0xb5,
 0x4d, 0x17, 0x8a, 0x28, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0xc2, 0xec, 0x22, 0x59, 0x5c, 0xaa, 0x91,
 0xe2, 0xa2, 0x6b, 0xcb, 0x87, 0x00, 0xf1, 0x3c, 0xbf, 0x9c, 0x45, 0xf9, 0x10, 0xcd, 0x5a, 0xe1,
 0x5a, 0xe0, 0x31, 0xaf, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xbd, 0xc2, 0xb5,
 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c,
 0x6b, 0x05, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70,
 0xad, 0x70, 0x16, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a,
 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06,
 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xaf, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5,
 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85,
 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70,
 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea,
 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae,
 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5,
 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b,
 0xab, 0x05, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7,
 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5c, 0x2b, 0x80,
 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56,
 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70,
 0xad, 0x71, 0x75, 0x6b, 0x85, 0x7b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae,
 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d,
 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5,
 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56,
 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5e, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71,
 0x75, 0x7b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a,
 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x57, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5e, 0xe1,
 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5,
 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c,
 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b,
 0x85, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a,
 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x75, 0x6b, 0x85, 0x6b, 0x8b, 0x6b, 0x5c, 0x2b, 0x5c, 0x06,
 0x55, 0xae, 0x79, 0x5a, 0xe2, 0xea, 0xf7, 0x0a, 0xf7, 0x01, 0x8d, 0x6b, 0x9e, 0xd6, 0x16, 0xd7,
 0xb8, 0x57, 0xb8, 0x0c, 0xab, 0x5c, 0xf2, 0xb5, 0xc5, 0xd5, 0xee, 0x15, 0xee, 0x03, 0x14, 0x8d,
 0x70, 0x58, 0xd7, 0x17, 0x57, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0xf6, 0xb5, 0xc5, 0xb5, 0xee,
 0x15, 0xae, 0x03, 0x2a, 0xd7, 0x0a, 0xd7, 0x16, 0xd7, 0xb8, 0x57, 0xb8, 0x0c, 0xab, 0x5c, 0x2b,
 0x5c, 0x5b, 0x5e, 0xe1, 0x5e, 0xe0, 0x31, 0x48, 0xd7, 0x3d, 0xad, 0x71, 0x6d, 0x6b, 0x85, 0x6b,
 0x80, 0xc6, 0xb5, 0xcf, 0x6b, 0x5c, 0x5b, 0x5e, 0xe1, 0x5e, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71,
 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xcf, 0x6b, 0x5c, 0x5b, 0x5e, 0xe1, 0x5e, 0xe0, 0x32,
 0x58, 0xc7, 0x95, 0xae, 0x2e, 0xaf, 0x70, 0xaf, 0x70, 0x18, 0xd6, 0xb9, 0xed, 0x6b, 0x8b, 0x6b,
 0xdc, 0x2b, 0xdc, 0x06, 0x55, 0xae, 0x79, 0x5a, 0xe2, 0xea, 0xf7, 0x0a, 0xf7, 0x01, 0x8d, 0x6b,
 0x85, 0x6b, 0x8b, 0xab, 0xdc, 0x2b, 0xdc, 0x06, 0x55, 0xee, 0x78, 0xb1, 0xae, 0x2e, 0xaf, 0x70,
 0xaf, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xbd, 0xc2, 0xbd, 0xc0, 0x63, 0x5a, 0xe7, 0xb5,
 0x85, 0xb5, 0xae, 0x15, 0xee, 0x03, 0x1a, 0xd7, 0x3d, 0xad, 0x71, 0x6d, 0x6b, 0x85, 0x6b, 0x80,
 0xca, 0xb5, 0xc2, 0xb5, 0xc5, 0xb5, 0xae, 0x15, 0xee, 0x03, 0x2a, 0xd7, 0x0a, 0xd7, 0x16, 0xd7,
 0xb8, 0x57, 0xb8, 0x0c, 0x96, 0x3d, 0xcf, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5e, 0xe0, 0x32, 0xad,
 0x73, 0xca, 0xd7, 0x17, 0x57, 0xb8, 0x57, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5e, 0xe1,
 0x5e, 0xe0, 0x31, 0xad, 0x73, 0xd4, 0x8c, 0x2d, 0xaf, 0x70, 0xaf, 0x70, 0x18, 0xd6, 0xb8, 0x56,
 0xb8, 0xba, 0xbd, 0xc2, 0xbd, 0xc0, 0x63, 0x5a, 0xe7, 0xb5, 0xae, 0x2d, 0xaf, 0x70, 0xaf, 0x70,
 0x19, 0x56, 0xb9, 0xe5, 0x6b, 0x8b, 0xab, 0xdc, 0x2b, 0xdc, 0x06, 0x55, 0xae, 0x79, 0x5a, 0xe2,
 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x95, 0x6b, 0x85, 0x7b, 0x8b, 0x6b, 0xdc, 0x2b, 0xdc, 0x06, 0x55,
 0xae, 0x79, 0x5a, 0xe2, 0xea, 0xd7, 0x05, 0x8f, 0x70, 0x18, 0xa4, 0x6b, 0x9e, 0xd7, 0x16, 0xd7,
 0xb8, 0x57, 0xb8, 0x0c, 0xab, 0x5c, 0xf1, 0x63, 0x5c, 0x5d, 0x5e, 0xe1, 0x5e, 0xe0, 0x31, 0xad,
 0x70, 0xad, 0x71, 0x75, 0x7b, 0x85, 0x7b, 0x80, 0xc6, 0xb5, 0xcf, 0x6b, 0x5c, 0x5b, 0x5e, 0xe1,
 0x5e, 0xe0, 0x31, 0xad, 0x73, 0xda, 0xd7, 0x16, 0xd6, 0xb8, 0x57, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b,
 0x5c, 0x5d, 0x5e, 0xe1, 0x5e, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x7b, 0x85, 0x7b, 0x80,
 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xee, 0x15, 0xee, 0x02, 0xea, 0xd7, 0x0a, 0xd7, 0x17, 0x56,
 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0xdc, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70,
 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae,
 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0xdc, 0x5d,
 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xaf, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5,
 0xc2, 0xbd, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x2c, 0x6b, 0x9e,
 0x56, 0xb8, 0x0c, 0xab, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad,
 0x71, 0x75, 0x6b, 0x9e, 0x2c, 0x6b, 0x80, 0xca, 0xb5, 0xc2, 0xbd, 0xc5, 0xb5, 0xae, 0x7a, 0x91,
 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0xdc, 0x2b, 0x5c,
 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6,
 0xbd, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8,
 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x0b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xee, 0x15, 0xae,
 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd7, 0xb8, 0x56, 0xb8, 0xba, 0xb7, 0x1e, 0x61, 0x5a, 0xe0,
 0x31, 0xaf, 0x70, 0xaf, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xbd, 0xc2, 0xb5, 0xc5, 0xd5,
 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xf7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c,
 0x2b, 0xdc, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xaf, 0x71, 0x75, 0x6b, 0x85, 0x6b,
 0x80, 0xc6, 0xb5, 0xc2, 0xbd, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xcb, 0xd6, 0x15, 0xae,
 0x2e, 0xad, 0x73, 0xca, 0xd7, 0x01, 0x95, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0xf1, 0x63, 0x5c,
 0x06, 0x55, 0xee, 0x15, 0xae, 0x2d, 0xaf, 0x70, 0xad, 0x70, 0x19, 0x56, 0xb8, 0x56, 0xb8, 0xba,
 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x58, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70,
 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xbd, 0xc5, 0xb5, 0xae, 0x7b, 0x5a,
 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x9e, 0x56, 0xb8, 0x0c, 0xab, 0x5c, 0x2b, 0x5c,
 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6,
 0xb5, 0xc2, 0xbd, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8,
 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5b, 0x5a, 0xe1, 0x5a, 0xe0, 0x32, 0xad, 0x70, 0xaf,
 0x71, 0x6d, 0x6b, 0x85, 0x6b, 0x80, 0xba, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03,
 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a,
 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2,
 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8,
 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75,
 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7,
 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a,
 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5,
 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b,
 0x5c, 0x2b, 0x71, 0xe6, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb0,
 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad,
 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03,
 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a,
 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2,
 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8,
 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75,
 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7,
 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a,
 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5,
 0xd5, 0xee, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b,
 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85,
 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7,
 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31,
 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae,
 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0b, 0x6b, 0x5c, 0x2b,
 0x5c, 0x5d, 0x5e, 0xe1, 0x5e, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x7b, 0x85, 0x7b, 0x80,
 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xee, 0x15, 0xee, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x57,
 0xb8, 0x57, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5e, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70,
 0xad, 0x71, 0x75, 0x7b, 0x85, 0x7b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xee, 0x15, 0xee,
 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x57, 0xb8, 0x57, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d,
 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5,
 0xc2, 0xb5, 0xc5, 0xd5, 0xee, 0x15, 0xee, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x57, 0xb8, 0x56,
 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d, 0x5e, 0xe1, 0x5e, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71,
 0x75, 0x7b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xee, 0x15, 0xee, 0x03, 0x1a,
 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x96, 0x3a, 0x75, 0x9e, 0x56, 0xb8, 0xba,
 0xbd, 0xc2, 0xbd, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b,
 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xaf, 0x70, 0xaf,
 0x70, 0x19, 0x56, 0xb9, 0xe5, 0x6b, 0x8b, 0xab, 0xdc, 0x2b, 0xdc, 0x06, 0x35, 0xae, 0x15, 0xae,
 0x2e, 0xaf, 0x70, 0xaf, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xbd, 0xc2, 0xbd, 0xc0, 0x63,
 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xf7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0xdc,
 0x2b, 0xdc, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xaf, 0x70, 0x18, 0xd6, 0xb8, 0x56,
 0xb8, 0xba, 0xbd, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xf7, 0x01,
 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0xdc, 0x2b, 0xdc, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad,
 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1,
 0x5a, 0xe2, 0xea, 0xf7, 0x0a, 0xf7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0xdc, 0x2b, 0xdc,
 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xaf, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba,
 0xbd, 0xc2, 0xbd, 0xc0, 0x65, 0x5a, 0xe7, 0x95, 0xae, 0x2e, 0xaf, 0x70, 0xaf, 0x70, 0x18, 0xd6,
 0xb8, 0x56, 0x5e, 0xb1, 0x75, 0x6b, 0x85, 0x7b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xee,
 0x15, 0xee, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x57, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b,
 0x5c, 0x5d, 0x5e, 0xe1, 0x5e, 0xe0, 0x50, 0xdf, 0x50, 0xdf, 0x52, 0x20, 0x04, 0xb7, 0xd4, 0x37,
 0xd4, 0x88, 0x01, 0x2d, 0xf5, 0x0d, 0xf5, 0x22, 0x00, 0x4b, 0x7d, 0x43, 0x7d, 0x48, 0x80, 0x12,
 0xdf, 0x50, 0xdf, 0x52, 0x20, 0x04, 0xb7, 0xd4, 0x37, 0xdc, 0x44, 0x00, 0x96, 0xfa, 0x86, 0xfb,
 0x88, 0x80, 0x12, 0xdf, 0x50, 0xdf, 0x52, 0x20, 0x04, 0xb7, 0xd4, 0x37, 0xd4, 0x88, 0x01, 0x2d,
 0xf5, 0x0d, 0xf5, 0x22, 0x00, 0x4b, 0x7d, 0xdd, 0x61, 0xbe, 0xe2, 0x20, 0x04, 0xb7, 0xd4, 0x37,
 0xd4, 0x88, 0x01, 0x2d, 0xf5, 0x0d, 0xf5, 0x22, 0x00, 0x4b, 0x7d, 0x43, 0x7d, 0x48, 0x80, 0x12,
 0xdf, 0x50, 0xdf, 0x52, 0x20, 0x04, 0xb7, 0xd4, 0x37, 0xd4, 0x88, 0x01, 0x2d, 0xf5, 0x0d, 0xf5,
 0x22, 0x00, 0x4b, 0x7d, 0x43, 0x7d, 0xc4, 0x40, 0x09, 0x6f, 0xa8, 0x6f, 0xa9, 0x10, 0x02, 0x5b,
 0xea, 0x1b, 0xea, 0x44, 0x00, 0x96, 0xfb, 0x83, 0x7d, 0x48, 0x80, 0x12, 0xdf, 0x70, 0x6f, 0xb8,
 0x88, 0x01, 0x2d, 0xf5, 0x0d, 0xf5, 0x22, 0x00, 0x4b, 0x7d, 0xc1, 0xbe, 0xa4, 0x40, 0x09, 0x6f,
 0xb8, 0x37, 0xd4, 0x88, 0x01, 0x2d, 0xf5, 0x0d, 0xf7, 0x11, 0x00, 0x25, 0xbe, 0xa1, 0xbe, 0xe2,
 0x20, 0x04, 0xb7, 0xdc, 0x1b, 0xee, 0x22, 0x00, 0x4b, 0x7d, 0xc1, 0xbe, 0xee, 0xb2, 0x20, 0x04,
 0xb7, 0xd4, 0x37, 0xd4, 0x88, 0x01, 0x2d, 0xf5, 0x0d, 0xf5, 0x22, 0x00, 0x4b, 0x7d, 0xc1, 0xbe,
 0xe2, 0x20, 0x04, 0xb7, 0xd4, 0x37, 0xd4, 0x88, 0x01, 0x2d, 0xf5, 0x0d, 0xf5, 0x22, 0x00, 0x4b,
 0x7d, 0x43, 0x7d, 0x48, 0x80, 0x12, 0xdf, 0x70, 0x6f, 0xb8, 0x88, 0x01, 0x2d, 0xf5, 0x0d, 0xf5,
 0x22, 0x00, 0x4b, 0x7d, 0x43, 0x7d, 0x48, 0x80, 0x12, 0xdf, 0x50, 0xdf, 0x52, 0x20, 0x04, 0xb7,
 0xdc, 0x1b, 0xee, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0xf1,
 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x64, 0xee,
 0xe3, 0x1d, 0x51, 0xdd, 0x3d, 0x75, 0xee, 0xa6, 0x05, 0xcf, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x64,
 0xee, 0xe0, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee, 0x1d, 0x51, 0xdc, 0xeb, 0xaf,
 0x75, 0x30, 0x2e, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0x27, 0x77, 0x07, 0x8b, 0xa7, 0xfc, 0xc6,
 0x67, 0xb2, 0x77, 0x70, 0xea, 0x8e, 0xe7, 0x5d, 0x7b, 0xa9, 0x81, 0x73, 0xc5, 0xd3, 0xfe, 0x63,
 0x33, 0xd9, 0x3b, 0xb8, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0x93, 0xbb, 0x87, 0x54, 0x77, 0x3a,
 0xeb, 0xdd, 0x4c, 0x0b, 0x9e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xc9, 0xdd, 0xc1, 0xe2, 0xe9, 0xff,
 0x00, 0x31, 0x99, 0xec, 0x9d, 0xdc, 0x3a, 0xa3, 0xb9, 0xd7, 0x5e, 0xea, 0x60, 0x5c, 0xf1, 0x74,
 0xff, 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x64, 0xee, 0xe1,
 0xd5, 0x1d, 0xce, 0xba, 0xf7, 0x53, 0x02, 0xe7, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xb2, 0x77, 0x70,
 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0x27, 0x77, 0x0e, 0xa8, 0xee, 0x75, 0xd7, 0xba, 0x98, 0x17,
 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0x93, 0xbb, 0x83, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xd9, 0x3b,
 0xb8, 0x75, 0x47, 0x73, 0xae, 0xbd, 0xd4, 0xc0, 0xb9, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xec,
 0x9d, 0xdc, 0x1e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xc9, 0xdd, 0xc3, 0xaa, 0x3b, 0x9d, 0x75, 0xee,
 0xa6, 0x05, 0xcf, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x64, 0xee, 0xe0, 0xf1, 0x74, 0xff, 0x00, 0x98,
 0xcc, 0xf6, 0x4e, 0xee, 0x1d, 0x51, 0xdc, 0xeb, 0xaf, 0x75, 0x30, 0x2e, 0x78, 0xba, 0x7f, 0xcc,
 0x66, 0x7b, 0x27, 0x77, 0x07, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xb2, 0x77, 0x70, 0xea, 0x8e, 0xe7,
 0x5d, 0x7b, 0xa9, 0x81, 0x73, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xd9, 0x3b, 0xb8, 0x3c, 0x5d, 0x3f,
 0xe6, 0x33, 0x3d, 0x93, 0xbb, 0x87, 0x54, 0x77, 0x3a, 0xeb, 0xdd, 0x4c, 0x0b, 0x9e, 0x2e, 0x9f,
 0xf3, 0x19, 0x9e, 0xc9, 0xdd, 0xc1, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xec, 0x9d, 0xdc, 0x3a,
 0xa3, 0xb9, 0xd7, 0x5e, 0xea, 0x60, 0x5c, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee,
 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x64, 0xee, 0xe1, 0xd5, 0x1d, 0xce, 0xba, 0xf7, 0x53, 0x02,
 0xe7, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xb2, 0x77, 0x70, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0x27,
 0x77, 0x0e, 0xa8, 0xee, 0x75, 0xd7, 0xba, 0x98, 0x17, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0x93,
 0xbb, 0x83, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xd9, 0x3b, 0xb8, 0x75, 0x47, 0x73, 0xae, 0xbd, 0xd4,
 0xc0, 0xb9, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xec, 0x9d, 0xdc, 0x1e, 0x2e, 0x9f, 0xf3, 0x19,
 0x9e, 0xc9, 0xdd, 0xc3, 0xaa, 0x3b, 0x9d, 0x75, 0xee, 0xa6, 0x05, 0xcf, 0x17, 0x4f, 0xf9, 0x8c,
 0xcf, 0x64, 0xee, 0xe0, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee, 0x1d, 0x51, 0xdc,
 0xeb, 0xaf, 0x75, 0x30, 0x2e, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0x27, 0x77, 0x07, 0x8b, 0xa7,
 0xfc, 0xc6, 0x67, 0xb2, 0x77, 0x70, 0xea, 0x8e, 0xe7, 0x5d, 0x7b, 0xa9, 0x81, 0x73, 0xc5, 0xd3,
 0xfe, 0x63, 0x33, 0xd9, 0x3b, 0xb8, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0x93, 0xbb, 0x87, 0x54,
 0x77, 0x3a, 0xeb, 0xdd, 0x4c, 0x0b, 0x9e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xc9, 0xdd, 0xc1, 0xe2,
 0xe9, 0xff, 0x00, 0x31, 0x99, 0xec, 0x9d, 0xdc, 0x3a, 0xa3, 0xb9, 0xd7, 0x5e, 0xea, 0x60, 0x5c,
 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x64,
 0xee, 0xe1, 0xd5, 0x1d, 0xce, 0xba, 0xf7, 0x53, 0x02, 0xe7, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xb2,
 0x77, 0x70, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0x27, 0x77, 0x0e, 0xa8, 0xee, 0x75, 0xd7, 0xba,
 0x98, 0x17, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0x93, 0xbb, 0x83, 0xc5, 0xd3, 0xfe, 0x63, 0x33,
 0xd9, 0x3b, 0xb8, 0x75, 0x47, 0x73, 0xae, 0xbd, 0xd4, 0xc0, 0xb9, 0xe2, 0xe9, 0xff, 0x00, 0x31,
 0x99, 0xec, 0x9d, 0xdc, 0x1e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xc9, 0xdd, 0xc3, 0xaa, 0x3b, 0x9d,
 0x75, 0xee, 0xa6, 0x05, 0xcf, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x64, 0xee, 0xe0, 0xf1, 0x74, 0xff,
 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee, 0x1d, 0x51, 0xdc, 0xeb, 0xaf, 0x75, 0x30, 0x2e, 0x78, 0xba,
 0x7f, 0xcc, 0x66, 0x7b, 0x27, 0x77, 0x07, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xb2, 0x77, 0x70, 0xea,
 0x8e, 0xe7, 0x5d, 0x7b, 0xa9, 0x81, 0x73, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xd9, 0x3b, 0xb8, 0x3c,
 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0x93, 0xbb, 0x87, 0x54, 0x77, 0x3a, 0xeb, 0xdd, 0x4c, 0x0b, 0x9e,
 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xc9, 0xdd, 0xc1, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xec, 0x9d,
 0xdc, 0x3a, 0xa3, 0xb9, 0xd7, 0x5e, 0xea, 0x60, 0x5c, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf6,
 0x4e, 0xee, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x64, 0xee, 0xe1, 0xd5, 0x1d, 0xce, 0xba, 0xf7,
 0x53, 0x02, 0xe7, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xb2, 0x77, 0x70, 0x78, 0xba, 0x7f, 0xcc, 0x66,
 0x7b, 0x27, 0x77, 0x0e, 0xa8, 0xee, 0x75, 0xd7, 0xba, 0x98, 0x17, 0x3c, 0x5d, 0x3f, 0xe6, 0x33,
 0x3d, 0x93, 0xbb, 0x83, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xd9, 0x3b, 0xb8, 0x75, 0x47, 0x73, 0xae,
 0xbd, 0xd4, 0xc0, 0xb9, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xec, 0x9d, 0xdc, 0x1e, 0x2e, 0x9f,
 0xf3, 0x19, 0x9e, 0xc9, 0xdd, 0xc3, 0xaa, 0x3b, 0x9d, 0x75, 0xee, 0xa6, 0x05, 0xcf, 0x17, 0x4f,
 0xf9, 0x8c, 0xcf, 0x64, 0xee, 0xe0, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee, 0x1d,
 0x51, 0xdc, 0xeb, 0xaf, 0x75, 0x30, 0x2e, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0x27, 0x77, 0x07,
 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xb2, 0x77, 0x70, 0xea, 0x8e, 0xe7, 0x5d, 0x7b, 0xa9, 0x81, 0x73,
 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xd9, 0x3b, 0xb8, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0x93, 0xbb,
 0x87, 0x54, 0x77, 0x3a, 0xeb, 0xdd, 0x4c, 0x0b, 0x9e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xc9, 0xdd,
 0xc1, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xec, 0x9d, 0xdc, 0x3a, 0xa3, 0xb9, 0xd7, 0x5e, 0xea,
 0x60, 0x5c, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf6, 0x4e, 0xee, 0x0f, 0x17, 0x4f, 0xf9, 0x8c,
 0xcf, 0x64, 0xee, 0xe1, 0xd5, 0x1d, 0xce, 0xba, 0xf7, 0x53, 0x02, 0xe7, 0x8b, 0xa7, 0xfc, 0xc6,
 0x67, 0xb2, 0x77, 0x70, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0x27, 0x77, 0x0e, 0xa8, 0xee, 0x75,
 0xd7, 0xba, 0x98, 0x17, 0x3c, 0x5b, 0x3f, 0xd1, 0x21, 0x33, 0xd9, 0x3b, 0xb8, 0xf7, 0xc5, 0xb8,
 0x87, 0x98, 0xcd, 0x76, 0x2e, 0xee, 0x1d, 0x51, 0xdc, 0xeb, 0xaf, 0x77, 0xff, 0xd9};
static const unsigned char PIC_960x720_1[] = { 
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xe1, 0x00, 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d,
 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x17,
 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65,
 0x20, 0x47, 0x49, 0x4d, 0x50, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x05, 0x03, 0x04, 0x04, 0x04, 0x03,
 0x05, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0c, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0f,
 0x0b, 0x0b, 0x09, 0x0c, 0x11, 0x0f, 0x12, 0x12, 0x11, 0x0f, 0x11, 0x11, 0x13, 0x16, 0x1c, 0x17,
 0x13, 0x14, 0x1a, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1a, 0x1d, 0x1d, 0x1f, 0x1f, 0x1f, 0x13,
 0x17, 0x22, 0x24, 0x22, 0x1e, 0x24, 0x1c, 0x1e, 0x1f, 0x1e, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x05,
 0x05, 0x05, 0x07, 0x06, 0x07, 0x0e, 0x08, 0x08, 0x0e, 0x1e, 0x14, 0x11, 0x14, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0xff,
 0xc0, 0x00, 0x11, 0x08, 0x02, 0xd0, 0x03, 0xc0, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03,
 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1d, 0x00, 0x01, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x01, 0x02, 0x05, 0x06, 0x07, 0x08,
 0x09, 0xff, 0xc4, 0x00, 0x61, 0x10, 0x00, 0x02, 0x01, 0x02, 0x03, 0x04, 0x03, 0x05, 0x0f, 0x0e,
 0x0a, 0x07, 0x08, 0x03, 0x01, 0x00, 0x00, 0x01, 0x02, 0x03, 0x13, 0x04, 0x05, 0x61, 0x06, 0x07,
 0x11, 0x12, 0x21, 0x31, 0xd1, 0x15, 0x41, 0x51, 0x55, 0x93, 0x08, 0x14, 0x17, 0x22, 0x25, 0x65,
 0x71, 0x81, 0x91, 0x94, 0xa1, 0xb2, 0xb3, 0xd2, 0xd3, 0x23, 0x32, 0x42, 0x44, 0x45, 0x56, 0x74,
 0x83, 0x92, 0xa4, 0xa5, 0xb1, 0xc1, 0xc2, 0x16, 0x52, 0x53, 0x54, 0x62, 0x64, 0x72, 0x73, 0xa3,
 0xe1, 0x18, 0x33, 0x34, 0x43, 0x46, 0x82, 0xc3, 0x09, 0x24, 0x26, 0x35, 0x84, 0x85, 0x95, 0xa2,
 0x63, 0x75, 0xf0, 0xe2, 0xff, 0xc4, 0x00, 0x1c, 0x01, 0x01, 0x00, 0x02, 0x03, 0x01, 0x01, 0x01,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x05, 0x06, 0x04,
 0x07, 0x08, 0xff, 0xc4, 0x00, 0x3f, 0x11, 0x01, 0x00, 0x02, 0x01, 0x02, 0x04, 0x01, 0x08, 0x08,
 0x05, 0x04, 0x01, 0x04, 0x03, 0x00, 0x00, 0x00, 0x01, 0x11, 0x02, 0x03, 0x04, 0x05, 0x13, 0x52,
 0x91, 0x14, 0x06, 0x12, 0x21, 0x31, 0x51, 0x71, 0x81, 0xb1, 0x22, 0x32, 0x33, 0x41, 0x53, 0x61,
 0xc1, 0xd1, 0x15, 0x24, 0x42, 0x43, 0xa1, 0x23, 0x82, 0xe1, 0xf0, 0xb2, 0x34, 0x35, 0x62, 0x72,
 0x16, 0x92, 0xf1, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f,
 0x00, 0xf3, 0xe6, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x71, 0x3e, 0x8b, 0x6f, 0x99, 0xda, 0x17, 0x13,
 0x57, 0x12, 0x66, 0x8c, 0x34, 0x4d, 0xa6, 0xd0, 0xb8, 0x9a, 0xb4, 0x4c, 0xd1, 0xab, 0x89, 0x36,
 0xb5, 0xa2, 0x68, 0xd5, 0xa2, 0x56, 0x8c, 0x38, 0x96, 0xb4, 0xda, 0x17, 0x13, 0x57, 0x12, 0x66,
 0x8c, 0x34, 0x4d, 0xa6, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x46, 0xae, 0x24, 0xda, 0xd1, 0x28, 0x9a,
 0x35, 0x68, 0x95, 0xa3, 0x0d, 0x16, 0xb4, 0xda, 0x16, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0x9b,
 0x5a, 0xd1, 0x34, 0x6a, 0xd1, 0x33, 0x46, 0xae, 0x24, 0xda, 0x62, 0x50, 0xb8, 0x98, 0x68, 0x95,
 0xc4, 0xc3, 0x45, 0xad, 0x6b, 0x42, 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x13, 0x69, 0xb4, 0x4e,
 0x26, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x36, 0x9b, 0x42, 0xe2, 0x61, 0xa2, 0x57, 0x13, 0x0d, 0x16,
 0xb5, 0xad, 0x0b, 0x46, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x36, 0x9b, 0x44, 0xe2, 0x6a, 0xd1, 0x33,
 0x89, 0xab, 0x44, 0xda, 0xd6, 0x85, 0xa3, 0x0d, 0x12, 0xb8, 0x98, 0x71, 0x2d, 0x69, 0xb4, 0x2d,
 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x44, 0xda, 0x62, 0x51, 0x34, 0x6a, 0xe2, 0x4a, 0xd1, 0x87, 0x12,
 0x6d, 0x68, 0x94, 0x2d, 0x18, 0x68, 0x95, 0xa3, 0x57, 0x12, 0xd6, 0x9b, 0x44, 0xd1, 0xab, 0x44,
 0xcd, 0x1a, 0xb4, 0x4d, 0xad, 0x68, 0x9a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xc4, 0x9b, 0x4c, 0x4a,
 0x17, 0x13, 0x56, 0x89, 0x9c, 0x4c, 0x38, 0x96, 0xb4, 0xda, 0x16, 0x8d, 0x5a, 0x26, 0x71, 0x35,
 0x68, 0x9b, 0x5a, 0xd1, 0x38, 0x9a, 0xb4, 0x4a, 0xd1, 0x86, 0x89, 0xb4, 0xda, 0x16, 0x8c, 0x12,
 0xb8, 0x98, 0x68, 0xb5, 0xa6, 0xd1, 0x83, 0x67, 0x13, 0x0d, 0x12, 0x96, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x7a, 0xd3, 0x46, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0xcd, 0xdb, 0x99, 0xb4, 0x2d, 0x18, 0x71, 0x25,
 0x68, 0xc3, 0x89, 0x36, 0xb5, 0xa1, 0x68, 0xd5, 0xc4, 0x99, 0xa3, 0x57, 0x12, 0x6d, 0x36, 0x89,
 0xa3, 0x57, 0x12, 0x56, 0x8c, 0x34, 0x4d, 0xad, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x0e, 0x25,
 0xad, 0x36, 0x85, 0xa3, 0x56, 0x89, 0x9c, 0x4d, 0x5a, 0x26, 0xd3, 0x68, 0x9a, 0x35, 0x71, 0x25,
 0x68, 0xc3, 0x44, 0xda, 0xd1, 0x28, 0x5c, 0x4d, 0x5c, 0x49, 0x9a, 0x30, 0xe2, 0x5a, 0xd3, 0x68,
 0x5c, 0x4d, 0x5a, 0x26, 0x71, 0x35, 0x68, 0x9b, 0x5a, 0xd1, 0x34, 0x6a, 0xd1, 0x2b, 0x46, 0x1a,
 0x26, 0xd3, 0x68, 0x5c, 0x4d, 0x5a, 0x26, 0xe0, 0x61, 0xa2, 0xd6, 0x98, 0x94, 0x2d, 0x1a, 0xb4,
 0x4c, 0xe2, 0x6a, 0xd1, 0x36, 0xb5, 0xa1, 0x68, 0xc3, 0x44, 0xad, 0x18, 0x68, 0x9b, 0x4d, 0xa1,
 0x71, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa2, 0xd6, 0xb5, 0xa2, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5c,
 0x49, 0xb4, 0xda, 0x16, 0x8c, 0x34, 0x4a, 0xe2, 0x61, 0xa2, 0x6d, 0x6b, 0x42, 0xd1, 0xab, 0x89,
 0x33, 0x46, 0xad, 0x16, 0xb4, 0xda, 0x16, 0x8c, 0x34, 0x4c, 0xd6, 0x86, 0xae, 0x24, 0xda, 0x6d,
 0x0b, 0x46, 0x1a, 0x25, 0x71, 0x30, 0xd1, 0x36, 0xb5, 0xa1, 0x68, 0xd5, 0xc4, 0x99, 0xa3, 0x56,
 0x8b, 0x5a, 0x6d, 0x13, 0x89, 0xab, 0x89, 0x33, 0x46, 0xad, 0x13, 0x6b, 0x5a, 0x16, 0x8c, 0x34,
 0x4a, 0xe2, 0x6a, 0xd1, 0x6b, 0x4d, 0xa2, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x26, 0xd6, 0xb4,
 0x4e, 0x26, 0xae, 0x24, 0xad, 0x18, 0x68, 0x9b, 0x4d, 0xa1, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x57,
 0x12, 0x6d, 0x36, 0x89, 0xa3, 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x2d, 0x6b, 0x5a, 0x16, 0x8c, 0x34,
 0x4c, 0xd1, 0xab, 0x89, 0x36, 0x9b, 0x44, 0x0d, 0xda, 0x31, 0xc0, 0x94, 0xb5, 0x06, 0x78, 0x18,
 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b,
 0x13, 0x89, 0xab, 0x89, 0x62, 0x50, 0x34, 0x71, 0x39, 0x78, 0x97, 0x2d, 0x12, 0x81, 0xa3, 0x1c,
 0x09, 0x5a, 0x30, 0xe2, 0x5a, 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x89, 0xb5, 0xad,
 0x13, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x4d, 0xa6, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x89, 0x86,
 0x8b, 0x5a, 0xd1, 0x28, 0x5a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x6d, 0x36, 0x89, 0xa3, 0x56,
 0x89, 0x9a, 0x35, 0x68, 0x9b, 0x4d, 0xa1, 0x71, 0x30, 0xd1, 0x2b, 0x89, 0xab, 0x45, 0xad, 0x6b,
 0x44, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xad, 0x13, 0x69, 0xb4, 0x4e, 0x26, 0xad, 0x12, 0xb4, 0x61,
 0xa2, 0x6d, 0x6b, 0x42, 0xd1, 0x86, 0x89, 0x5c, 0x4d, 0x5c, 0x49, 0xb4, 0xda, 0x26, 0x8d, 0x5a,
 0x26, 0x68, 0xd5, 0xc4, 0xb5, 0xad, 0x68, 0x9a, 0x35, 0x71, 0x25, 0x68, 0xc3, 0x44, 0xc4, 0xa6,
 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x46, 0xae, 0x25, 0xad, 0x36, 0x89, 0xa3, 0x56, 0x89, 0x9a, 0x35,
 0x68, 0x9b, 0x5a, 0xd1, 0x34, 0x6a, 0xe2, 0x4a, 0xd1, 0x87, 0x12, 0x6d, 0x36, 0x85, 0xa3, 0x56,
 0x89, 0x9a, 0x35, 0x68, 0xb5, 0xad, 0x68, 0x9a, 0x35, 0x71, 0x26, 0x71, 0x35, 0x68, 0x9b, 0x4d,
 0xa2, 0x68, 0xd5, 0xc4, 0x95, 0xa3, 0x0d, 0x13, 0x69, 0xb4, 0x2e, 0x26, 0xad, 0x13, 0x38, 0x9a,
 0xb4, 0x5a, 0xd6, 0x89, 0x44, 0xe2, 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x44, 0xda, 0x6d, 0x0b, 0x46,
 0x1a, 0x25, 0x68, 0xc3, 0x44, 0xda, 0xd1, 0x28, 0x5c, 0x4d, 0x5a, 0x26, 0x68, 0xd5, 0xa2, 0xd6,
 0x9b, 0x44, 0xd1, 0xab, 0x89, 0x33, 0x89, 0xab, 0x89, 0x36, 0xb5, 0xa1, 0x68, 0xc3, 0x44, 0xad,
 0x1a, 0xb8, 0x93, 0x69, 0xb4, 0x4d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xd1, 0x6b, 0x4d, 0xa1, 0x68,
 0xc3, 0x44, 0xcd, 0x1a, 0xb4, 0x4d, 0xad, 0x68, 0x5a, 0x30, 0xe2, 0x4a, 0xe2, 0x6a, 0xd1, 0x36,
 0x9b, 0x44, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb8, 0x96, 0xb4, 0xda, 0x2e, 0x0c, 0xc1, 0x23, 0x89,
 0x87, 0x12, 0x6d, 0x6b, 0x68, 0x0c, 0xf0, 0x30, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xf7, 0x29, 0x53, 0xd0, 0x8e, 0x54, 0xcb, 0xd2, 0x81, 0x1c, 0xa9, 0x9c, 0x84,
 0x64, 0xe3, 0xa3, 0x25, 0x19, 0x53, 0x23, 0x70, 0x2e, 0xca, 0x9e, 0x84, 0x72, 0xa7, 0xa1, 0x78,
 0xc9, 0x92, 0x32, 0x53, 0x71, 0x35, 0x71, 0x2d, 0x4a, 0x04, 0x72, 0x81, 0x78, 0xc9, 0x78, 0xc9,
 0x03, 0x89, 0xab, 0x44, 0xce, 0x26, 0xad, 0x16, 0xb5, 0xa2, 0x50, 0xb4, 0x61, 0xc4, 0x95, 0xc4,
 0xc3, 0x89, 0x36, 0x9b, 0x42, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x5a, 0xd6, 0xb4, 0x4d, 0x1a,
 0xb4, 0x4c, 0xd1, 0xab, 0x44, 0xda, 0x6d, 0x0b, 0x46, 0x1a, 0x25, 0x68, 0xc3, 0x89, 0x36, 0xb5,
 0xa1, 0x68, 0xd5, 0xc4, 0x99, 0xc4, 0xd5, 0xc4, 0xb5, 0xa6, 0xd0, 0xb4, 0x61, 0xc4, 0x99, 0xa3,
 0x57, 0x12, 0x6d, 0x31, 0x28, 0x5a, 0x30, 0xd1, 0x2b, 0x46, 0x1c, 0x49, 0xb5, 0xad, 0x0b, 0x46,
 0xae, 0x24, 0xcd, 0x1a, 0xb8, 0x96, 0xb4, 0xc4, 0xa2, 0x68, 0xd5, 0xc4, 0x99, 0xa3, 0x57, 0x12,
 0x6d, 0x36, 0x85, 0xa3, 0x56, 0x89, 0x9a, 0x35, 0x68, 0x9b, 0x5a, 0xd1, 0x34, 0x6a, 0xe2, 0x4c,
 0xd1, 0xab, 0x45, 0xad, 0x36, 0x85, 0xc4, 0xc3, 0x44, 0xce, 0x26, 0xad, 0x13, 0x6b, 0x44, 0xa1,
 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x56, 0x89, 0xb4, 0xda, 0x26, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x68,
 0xb5, 0xad, 0x68, 0x5c, 0x4c, 0x34, 0x4a, 0xd1, 0x86, 0x89, 0xb4, 0xda, 0x16, 0x8d, 0x5a, 0x26,
 0x71, 0x35, 0x71, 0x26, 0xd3, 0x68, 0x9a, 0x35, 0x68, 0x95, 0xa3, 0x0d, 0x16, 0xb5, 0xad, 0x0b,
 0x89, 0x87, 0x12, 0x56, 0x8c, 0x34, 0x4c, 0x4a, 0x62, 0x50, 0xb4, 0x6a, 0xd1, 0x33, 0x46, 0xae,
 0x24, 0xc4, 0xad, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0xd6, 0x9b, 0x42, 0xd1, 0x87,
 0x12, 0x56, 0x8c, 0x38, 0x93, 0x69, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x89, 0x36, 0xb5,
 0xa2, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x56, 0x8b, 0x5a, 0x6d, 0x0b, 0x89, 0x86, 0x89, 0x5a, 0x30,
 0xd1, 0x36, 0xb5, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x6d, 0x36, 0x89, 0xc4, 0xd5,
 0xa2, 0x57, 0x13, 0x0d, 0x16, 0xb4, 0xda, 0x16, 0x8c, 0x34, 0x4a, 0xe2, 0x61, 0xa2, 0x6d, 0x6b,
 0x42, 0xd1, 0x8e, 0x0c, 0x95, 0xc4, 0xd5, 0xa2, 0x6d, 0x36, 0x8c, 0x1b, 0x34, 0x61, 0xa2, 0x6d,
 0x2c, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x43, 0x4a, 0x04, 0x72, 0xa6, 0x5e, 0x95, 0x32,
 0x39, 0x53, 0x38, 0x88, 0xc9, 0xc3, 0x46, 0x4a, 0x12, 0xa7, 0xa1, 0x1c, 0xa9, 0x97, 0xa5, 0x4c,
 0x8e, 0x54, 0xf4, 0x32, 0x46, 0x4c, 0x91, 0x92, 0x8c, 0xa9, 0x91, 0xca, 0x05, 0xe9, 0x53, 0x23,
 0x94, 0x0b, 0xc6, 0x4b, 0xc6, 0x4a, 0x32, 0xa6, 0x47, 0x28, 0x17, 0xa5, 0x4c, 0x8e, 0x54, 0xcb,
 0xc6, 0x4b, 0xc6, 0x4a, 0x2e, 0x06, 0xad, 0x17, 0x25, 0x4c, 0x8a, 0x54, 0xcb, 0xc6, 0x4c, 0x91,
 0x92, 0xb3, 0x89, 0xab, 0x45, 0x87, 0x03, 0x47, 0x12, 0xd1, 0x2b, 0x44, 0xa1, 0x68, 0xd5, 0xa2,
 0x66, 0x8d, 0x5c, 0x4b, 0x5a, 0xd6, 0x85, 0xa3, 0x0d, 0x12, 0xb4, 0x61, 0xa2, 0x6d, 0x36, 0x85,
 0xa3, 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x2d, 0x69, 0xb4, 0x4d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a, 0xe2,
 0x4d, 0xad, 0x12, 0x85, 0xa3, 0x0d, 0x12, 0xb4, 0x61, 0xa2, 0x6d, 0x36, 0x85, 0xc4, 0xd5, 0xc4,
 0x99, 0xa3, 0x56, 0x8b, 0x5a, 0xd6, 0x89, 0xc4, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x26, 0xd3, 0x68,
 0x5a, 0x30, 0xd1, 0x2b, 0x89, 0xab, 0x44, 0xda, 0x6d, 0x13, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4,
 0x4d, 0xad, 0x68, 0x5c, 0x4c, 0x34, 0x4c, 0xe2, 0x6a, 0xd1, 0x6b, 0x4d, 0xa1, 0x68, 0xc3, 0x44,
 0xad, 0x1a, 0xb4, 0x4c, 0x4a, 0xd1, 0x28, 0x9c, 0x4d, 0x5a, 0x26, 0x68, 0xd5, 0xa2, 0x6d, 0x36,
 0x85, 0xa3, 0x0d, 0x13, 0x38, 0x9a, 0xb8, 0x96, 0xb5, 0xad, 0x0b, 0x46, 0x1a, 0x25, 0x68, 0xd5,
 0xa2, 0x6d, 0x36, 0x89, 0xc4, 0xd5, 0xc4, 0x99, 0xa3, 0x5e, 0x04, 0xda, 0x6d, 0x0b, 0x46, 0x38,
 0x13, 0x34, 0x6a, 0xe2, 0x5a, 0xd6, 0x89, 0x42, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4d, 0xa6,
 0x25, 0x13, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x4d, 0xad, 0x68, 0x5c, 0x4d, 0x5a, 0x26, 0x68,
 0xc3, 0x89, 0x6b, 0x4d, 0xa1, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x56, 0x89, 0xb5, 0xad, 0x13, 0x89,
 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x5a, 0xd3, 0x68, 0x5c, 0x4d, 0x5c, 0x49, 0x9a, 0x30, 0xd1, 0x36,
 0x9b, 0x42, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xae, 0x24, 0xda, 0xd6, 0x89, 0xc4, 0xd5, 0xa2, 0x56,
 0x8c, 0x70, 0x2d, 0x69, 0xb4, 0x2e, 0x26, 0x1c, 0x49, 0x5a, 0x30, 0xe2, 0x4d, 0xad, 0x68, 0x5a,
 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0x6d, 0x36, 0x85, 0xa3, 0x0e, 0x24, 0xbc, 0x0c, 0x34, 0x5a,
 0xd3, 0x68, 0x5a, 0x31, 0xcb, 0xe0, 0x25, 0x68, 0xc3, 0x89, 0x31, 0x2b, 0x5a, 0x1e, 0x00, 0x91,
 0xc4, 0xd5, 0xc4, 0x9b, 0x4d, 0xb5, 0x06, 0x5a, 0x66, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x4d, 0x4a, 0x99, 0x14, 0xa9,
 0x97, 0xe5, 0x4c, 0x8a, 0x54, 0xce, 0x02, 0x32, 0x7c, 0xfa, 0x33, 0x51, 0x94, 0x08, 0xe5, 0x4c,
 0xbd, 0x28, 0x11, 0xca, 0x05, 0xe3, 0x25, 0xe3, 0x25, 0x19, 0x43, 0x42, 0x39, 0x40, 0xbd, 0x2a,
 0x64, 0x72, 0xa7, 0xa1, 0x92, 0x32, 0x64, 0x8c, 0x94, 0x65, 0x4c, 0x8a, 0x50, 0xd0, 0xbf, 0x28,
 0x11, 0xca, 0x99, 0x78, 0xc9, 0x78, 0xc9, 0x46, 0x54, 0xc8, 0xa5, 0x4c, 0xbd, 0x2a, 0x64, 0x72,
 0xa6, 0x5e, 0x32, 0x5e, 0x32, 0x51, 0x94, 0x08, 0xe5, 0x4c, 0xbd, 0x2a, 0x64, 0x72, 0xa6, 0x64,
 0x8c, 0x99, 0x23, 0x25, 0x19, 0x40, 0xd1, 0xc5, 0xa2, 0xec, 0xa0, 0x47, 0x2a, 0x65, 0xe3, 0x26,
 0x48, 0xc9, 0x4d, 0xa3, 0x0e, 0x25, 0x89, 0x53, 0x34, 0x70, 0x2f, 0x19, 0x2d, 0x19, 0x20, 0x71,
 0x35, 0x68, 0x99, 0xc7, 0x43, 0x0e, 0x24, 0xc4, 0xad, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x71, 0x35,
 0x68, 0xb5, 0xad, 0x68, 0x5a, 0x30, 0xd1, 0x2b, 0x46, 0x1a, 0x26, 0xd3, 0x68, 0x5c, 0x4d, 0x5c,
 0x49, 0x9c, 0x4d, 0x5a, 0x26, 0xd3, 0x68, 0x9c, 0x4d, 0x5a, 0x26, 0x71, 0x35, 0x68, 0xb5, 0xad,
 0x68, 0x5c, 0x4c, 0x34, 0x4a, 0xd1, 0x86, 0x89, 0xb4, 0xda, 0x17, 0x13, 0x56, 0x89, 0x9c, 0x4d,
 0x5c, 0x49, 0xb5, 0xad, 0x13, 0x46, 0xad, 0x12, 0xb4, 0x61, 0xa2, 0xd6, 0x9b, 0x42, 0xe2, 0x61,
 0xc4, 0x95, 0xa3, 0x0d, 0x13, 0x69, 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x38, 0x9a, 0xb8, 0x93, 0x6b,
 0x5a, 0x16, 0x8c, 0x34, 0x4a, 0xd1, 0x86, 0x89, 0xb4, 0xda, 0x16, 0x8c, 0x38, 0x92, 0xb4, 0x6a,
 0xd1, 0x68, 0x94, 0xda, 0x26, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x71, 0x26, 0xd6, 0x89, 0x42, 0xe2,
 0x61, 0xa2, 0x56, 0x8c, 0x34, 0x5a, 0xd3, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa2, 0x6d,
 0x6b, 0x44, 0xe2, 0x6a, 0xd1, 0x33, 0x46, 0xae, 0x24, 0xda, 0x62, 0x50, 0xb4, 0x61, 0xa2, 0x57,
 0x13, 0x56, 0x8b, 0x5a, 0xd6, 0x89, 0xa3, 0x0d, 0x12, 0xb4, 0x6a, 0xd1, 0x36, 0x9b, 0x44, 0xe2,
 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x13, 0x12, 0xb5, 0xa1, 0x68, 0xc3, 0x44, 0xae, 0x26, 0x1c, 0x4b,
 0x5a, 0x6d, 0x0b, 0x46, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x36, 0xb5, 0xa2, 0x71, 0x35, 0x71, 0x26,
 0x68, 0xd5, 0xc4, 0x9b, 0x4d, 0xa1, 0x68, 0xc3, 0x44, 0xcd, 0x1a, 0xb8, 0x96, 0x89, 0x4d, 0xa1,
 0x6b, 0x43, 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x26, 0xd6, 0xb4, 0x4d, 0x1a, 0xb8, 0x93, 0x34, 0x6a,
 0xe2, 0x4d, 0xa6, 0xd0, 0xb8, 0x9a, 0xb8, 0x93, 0x38, 0x98, 0x68, 0xb5, 0xa6, 0xd0, 0xb4, 0x6a,
 0xe2, 0x4c, 0xe2, 0x6a, 0xd1, 0x36, 0xb4, 0x4a, 0x17, 0x13, 0x0e, 0x24, 0xad, 0x18, 0x68, 0x9b,
 0x4d, 0xa1, 0xe0, 0x60, 0x95, 0xa3, 0x0d, 0x16, 0xb4, 0xda, 0x30, 0x6c, 0xd1, 0x8e, 0x01, 0x2c,
 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xea, 0xd9, 0x40,
 0x8e, 0x54, 0xcb, 0xd2, 0xa6, 0x47, 0x28, 0x1f, 0x38, 0x8c, 0x9f, 0x35, 0x8c, 0x94, 0x65, 0x4c,
 0x8e, 0x54, 0xcb, 0xd2, 0x81, 0x1c, 0xa9, 0x97, 0x8c, 0x99, 0x23, 0x25, 0x19, 0x40, 0x8e, 0x54,
 0xcb, 0xd2, 0xa6, 0x47, 0x2a, 0x66, 0x48, 0xc9, 0x78, 0xcd, 0x46, 0x50, 0x22, 0x94, 0x34, 0x2f,
 0xca, 0x04, 0x52, 0xa6, 0x5e, 0x32, 0x64, 0x8c, 0x94, 0x65, 0x4c, 0x8e, 0x54, 0xcb, 0xd2, 0xa6,
 0x47, 0x28, 0x19, 0x23, 0x25, 0xe3, 0x25, 0x19, 0x53, 0x23, 0x95, 0x32, 0xf4, 0xa9, 0x91, 0xca,
 0x05, 0xe3, 0x26, 0x48, 0xcd, 0x46, 0x50, 0x23, 0x95, 0x32, 0xf4, 0xa9, 0xe8, 0x47, 0x2a, 0x7a,
 0x17, 0x8c, 0x97, 0x8c, 0x94, 0x25, 0x4c, 0x8e, 0x50, 0x2f, 0x4a, 0x9e, 0x84, 0x72, 0xa6, 0x5e,
 0x32, 0x64, 0x8c, 0x94, 0x65, 0x4c, 0x8e, 0x50, 0x2f, 0x4a, 0x99, 0x1c, 0xa0, 0x64, 0x8c, 0x97,
 0x8c, 0x94, 0x9c, 0x59, 0xab, 0x45, 0xb9, 0x53, 0xd0, 0x8e, 0x54, 0xcb, 0xc6, 0x4b, 0xc6, 0x4a,
 0xce, 0x26, 0xad, 0x13, 0xb8, 0x1a, 0xb8, 0x96, 0xb5, 0xa2, 0x50, 0xb4, 0x6a, 0xd1, 0x33, 0x89,
 0xab, 0x89, 0x36, 0xb5, 0xa2, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8b, 0x5a, 0x6d, 0x0b, 0x46,
 0x1a, 0x25, 0x68, 0xc3, 0x44, 0xda, 0xd1, 0x28, 0x5a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x6d,
 0x36, 0x89, 0xa3, 0x57, 0x12, 0x66, 0x8d, 0x5c, 0x49, 0xb5, 0xad, 0x0b, 0x46, 0xae, 0x24, 0xcd,
 0x18, 0x71, 0x2d, 0x69, 0xb4, 0x2e, 0x26, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x36, 0x9b, 0x44, 0xd1,
 0xab, 0x89, 0x33, 0x89, 0xab, 0x44, 0xda, 0xd6, 0x85, 0xa3, 0x56, 0x89, 0x9a, 0x30, 0xd1, 0x6b,
 0x4d, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x62, 0x56, 0xb4, 0x4d, 0x1a, 0xb4, 0x4a,
 0xe2, 0x61, 0xa2, 0x6d, 0x36, 0x85, 0xc4, 0xd5, 0xc4, 0x99, 0xa3, 0x0d, 0x16, 0xb4, 0xda, 0x17,
 0x13, 0x56, 0x89, 0x9c, 0x4d, 0x5c, 0x49, 0x89, 0x5a, 0xd0, 0xb4, 0x61, 0xa2, 0x66, 0x8d, 0x5a,
 0x26, 0xd3, 0x12, 0x85, 0xc4, 0xd5, 0xc4, 0x99, 0xa3, 0x0d, 0x16, 0xb5, 0xad, 0x0b, 0x46, 0xad,
 0x13, 0x38, 0x9a, 0xb8, 0x93, 0x69, 0x89, 0x42, 0xd1, 0x86, 0x89, 0x5a, 0x30, 0xd1, 0x36, 0xb4,
 0x4a, 0x16, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0xb5, 0xa6, 0xd1, 0x34, 0x6a, 0xd1, 0x33, 0x46,
 0xae, 0x24, 0xc4, 0xa6, 0xd0, 0xb4, 0x61, 0xa2, 0x56, 0x8d, 0x5a, 0x2d, 0x6b, 0x5a, 0x26, 0x8d,
 0x5c, 0x49, 0x9a, 0x35, 0x68, 0x9b, 0x4d, 0xa2, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x6d,
 0x6b, 0x42, 0xd1, 0x86, 0x89, 0x5c, 0x4c, 0x34, 0x4d, 0xa6, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x46,
 0xad, 0x16, 0xb4, 0xc4, 0xa1, 0x71, 0x30, 0xd1, 0x33, 0x89, 0xab, 0x44, 0xda, 0xd6, 0x85, 0xc4,
 0xd5, 0xa2, 0x67, 0x13, 0x57, 0x12, 0x62, 0x53, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8b,
 0x5a, 0xd6, 0x89, 0xa3, 0x56, 0x89, 0x5c, 0x4c, 0x38, 0x93, 0x69, 0xb4, 0x40, 0xdd, 0xa3, 0x0d,
 0x13, 0x69, 0x6a, 0x07, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x83, 0x2a,
 0x64, 0x72, 0xa6, 0x72, 0x13, 0xa4, 0x43, 0x2a, 0x7a, 0x1f, 0x30, 0x8c, 0x9f, 0x2f, 0xf4, 0xc2,
 0x8c, 0xa9, 0x91, 0xca, 0x99, 0x7a, 0x54, 0xf4, 0x23, 0x95, 0x33, 0x24, 0x64, 0xb4, 0x64, 0xa3,
 0x2a, 0x64, 0x72, 0x81, 0x7a, 0x50, 0x22, 0x95, 0x32, 0xf1, 0x92, 0xf1, 0x92, 0x8c, 0xa9, 0x91,
 0xca, 0x99, 0x7a, 0x54, 0xc8, 0xe5, 0x02, 0xf1, 0x92, 0xf1, 0x92, 0x8c, 0xa9, 0x91, 0xca, 0x05,
 0xe9, 0x53, 0x23, 0x95, 0x33, 0x24, 0x64, 0xc9, 0x19, 0x28, 0xca, 0x99, 0x1c, 0xa9, 0x97, 0xa5,
 0x4c, 0x8e, 0x50, 0x2f, 0x19, 0x2f, 0x19, 0x28, 0xca, 0x1a, 0x11, 0xca, 0x99, 0x7a, 0x54, 0xc8,
 0xe5, 0x4f, 0x42, 0xf1, 0x93, 0x24, 0x64, 0xa1, 0x28, 0x11, 0xca, 0x99, 0x7a, 0x50, 0xd0, 0x8e,
 0x54, 0xcb, 0xc6, 0x4b, 0xc6, 0x4a, 0x32, 0xa6, 0x47, 0x28, 0x17, 0xa5, 0x0d, 0x08, 0xe5, 0x03,
 0x24, 0x64, 0xc9, 0x19, 0x28, 0xca, 0x99, 0x1c, 0xa9, 0x97, 0xa5, 0x4c, 0x8e, 0x50, 0x2f, 0x19,
 0x2f, 0x19, 0x28, 0xca, 0x04, 0x52, 0xa6, 0x5f, 0x95, 0x32, 0x29, 0x53, 0x2f, 0x19, 0x32, 0x46,
 0x4a, 0x52, 0x81, 0xa3, 0x89, 0x72, 0x54, 0xc8, 0xe5, 0x03, 0x24, 0x64, 0xbc, 0x64, 0xaa, 0xe2,
 0x6a, 0xe2, 0x58, 0x94, 0x0d, 0x1c, 0x4b, 0x44, 0xaf, 0x12, 0x81, 0xa3, 0x0d, 0x12, 0xb4, 0x61,
 0xc4, 0xb5, 0xa6, 0x25, 0x0f, 0x03, 0x56, 0x89, 0x9a, 0x35, 0x68, 0x9b, 0x5a, 0xd1, 0x34, 0x6a,
 0xe2, 0x4c, 0xd1, 0xab, 0x89, 0x36, 0x9b, 0x42, 0xe2, 0x6a, 0xd1, 0x33, 0x46, 0x1a, 0x2d, 0x6b,
 0x5a, 0x17, 0x13, 0x56, 0x89, 0x9c, 0x4d, 0x5a, 0x26, 0x25, 0x31, 0x28, 0x9c, 0x4d, 0x5a, 0x26,
 0x68, 0xd5, 0xa2, 0x6d, 0x36, 0x85, 0xc4, 0xd5, 0xa2, 0x66, 0x8d, 0x5c, 0x49, 0xb5, 0xa2, 0x51,
 0x34, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x16, 0xb4, 0xda, 0x27, 0x13, 0x57, 0x12, 0x66, 0x8d, 0x5a,
 0x26, 0xd3, 0x12, 0x85, 0xa3, 0x0d, 0x12, 0xb8, 0x9a, 0xb8, 0x93, 0x6b, 0x44, 0xa2, 0x68, 0xd7,
 0x81, 0x33, 0x46, 0xae, 0x25, 0xad, 0x36, 0x89, 0xa3, 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x26, 0xd6,
 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xe2, 0x5a, 0xd3, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xa3,
 0x56, 0x89, 0xb5, 0xad, 0x13, 0x46, 0xae, 0x24, 0xad, 0x18, 0x68, 0x9b, 0x4d, 0xa1, 0x71, 0x35,
 0x68, 0x99, 0xa3, 0x0e, 0x25, 0xad, 0x6b, 0x42, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xbc, 0x09, 0xb4,
 0xda, 0x16, 0x8c, 0x34, 0x4a, 0xd1, 0x86, 0x89, 0xb4, 0xc4, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xa3,
 0x56, 0x8b, 0x5a, 0xd1, 0x28, 0x9a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xc4, 0x9b, 0x4d, 0xa1, 0x71,
 0x30, 0xd1, 0x2b, 0x46, 0x1a, 0x26, 0xd6, 0xb4, 0x2e, 0x26, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x5a,
 0xd3, 0x12, 0x89, 0xa3, 0x56, 0x89, 0x9c, 0x4d, 0x5c, 0x49, 0xb4, 0xda, 0x16, 0x8c, 0x34, 0x4a,
 0xd1, 0x86, 0x89, 0xb5, 0xad, 0x0b, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb8, 0x96, 0xb4, 0xda, 0x16,
 0x8c, 0x34, 0x4c, 0xd1, 0xab, 0x44, 0xda, 0xd6, 0x85, 0xa3, 0x0e, 0x24, 0xae, 0x26, 0xad, 0x13,
 0x12, 0x9b, 0x44, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x5a, 0xd3, 0x68, 0xb8, 0x18, 0x24, 0x71,
 0x30, 0xe2, 0x4d, 0xad, 0x6d, 0x01, 0x96, 0x8c, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xdc, 0x9d, 0x2d, 0x08,
 0x67, 0x47, 0x43, 0x96, 0x9d, 0x2d, 0x08, 0x27, 0x4b, 0x43, 0xe4, 0xd1, 0x9b, 0x82, 0xcf, 0x6e,
 0xe2, 0x67, 0x48, 0x8a, 0x74, 0x8e, 0x56, 0x74, 0xb4, 0x20, 0x9d, 0x2d, 0x0c, 0xb1, 0x9b, 0xc9,
 0x9e, 0xde, 0x9c, 0x64, 0xa9, 0x91, 0xca, 0x99, 0xc8, 0xce, 0x96, 0x84, 0x33, 0xa5, 0xa1, 0x92,
 0x33, 0x60, 0x9c, 0x72, 0xc5, 0xc7, 0xca, 0x1a, 0x11, 0xca, 0x05, 0xf9, 0x53, 0xd0, 0x8a, 0x54,
 0xf4, 0x2f, 0x19, 0x22, 0x32, 0x51, 0x95, 0x32, 0x39, 0x40, 0xbd, 0x2a, 0x64, 0x72, 0x81, 0x92,
 0x32, 0x64, 0x8c, 0x94, 0x65, 0x4c, 0x8e, 0x50, 0x2f, 0x4a, 0x99, 0x1c, 0xa0, 0x5e, 0x32, 0x5e,
 0x32, 0x51, 0x95, 0x32, 0x29, 0x53, 0x2f, 0xca, 0x04, 0x52, 0xa6, 0x5e, 0x32, 0x5e, 0x32, 0x51,
 0x95, 0x3d, 0x08, 0xe5, 0x4c, 0xbd, 0x2a, 0x64, 0x72, 0xa6, 0x64, 0x8c, 0x99, 0x23, 0x25, 0x19,
 0x53, 0x23, 0x95, 0x32, 0xf4, 0xa0, 0x47, 0x2a, 0x65, 0xe3, 0x25, 0xe3, 0x35, 0x19, 0x53, 0x22,
 0x94, 0x0b, 0xd2, 0x81, 0x1c, 0xa9, 0x97, 0x8c, 0x99, 0x23, 0x25, 0x19, 0x53, 0x23, 0x95, 0x32,
 0xf4, 0xa9, 0x91, 0xca, 0x05, 0xe3, 0x25, 0xe3, 0x25, 0x19, 0x53, 0x23, 0x95, 0x32, 0xf4, 0xa0,
 0x47, 0x2a, 0x66, 0x48, 0xc9, 0x92, 0x32, 0x51, 0x94, 0x34, 0x23, 0x95, 0x3d, 0x0b, 0xd2, 0xa6,
 0x47, 0x2a, 0x65, 0xe3, 0x25, 0xe3, 0x25, 0x19, 0x53, 0x23, 0x70, 0x2e, 0xca, 0x9e, 0x86, 0x92,
 0x81, 0x78, 0xc9, 0x92, 0x32, 0x52, 0x6b, 0x43, 0x0d, 0x16, 0x65, 0x4c, 0x8e, 0x50, 0x2f, 0x19,
 0x2f, 0x19, 0x20, 0x71, 0x35, 0x68, 0x99, 0xc7, 0x81, 0xab, 0x45, 0xad, 0x68, 0x94, 0x2d, 0x18,
 0x68, 0x95, 0xc4, 0xc3, 0x44, 0xda, 0x6d, 0x0b, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x5a, 0xd6,
 0xb4, 0x4e, 0x26, 0xad, 0x13, 0x38, 0x9a, 0xb8, 0x93, 0x69, 0xb4, 0x2d, 0x18, 0x71, 0x25, 0x71,
 0x30, 0xd1, 0x36, 0xb5, 0xa1, 0x71, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa2, 0xd6, 0x9b, 0x44, 0xd1,
 0xab, 0x44, 0xce, 0x26, 0xae, 0x24, 0xda, 0x6d, 0x0b, 0x46, 0x1a, 0x25, 0x68, 0xc3, 0x89, 0x31,
 0x2b, 0x5a, 0x16, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0xb5, 0xa6, 0x25, 0x0b, 0x46, 0x1a, 0x26,
 0x68, 0xd5, 0xc4, 0x9b, 0x4d, 0xa1, 0x68, 0xc3, 0x44, 0xad, 0x1a, 0xb8, 0x93, 0x12, 0xb5, 0xa2,
 0x68, 0xd5, 0xc4, 0x99, 0xc4, 0xd5, 0xa2, 0x6d, 0x36, 0x85, 0xc4, 0xc3, 0x5a, 0x13, 0x34, 0x6a,
 0xd1, 0x6b, 0x5a, 0xd0, 0xb8, 0x9a, 0xb4, 0x4c, 0xe2, 0x6a, 0xe2, 0x4d, 0xa6, 0xd1, 0x34, 0x6a,
 0xd1, 0x33, 0x46, 0xad, 0x16, 0xb5, 0xad, 0x0b, 0x89, 0x86, 0x89, 0x5a, 0x30, 0xd1, 0x36, 0x9b,
 0x42, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xae, 0x24, 0xda, 0x6d, 0x13, 0x89, 0xab, 0x44, 0xcd, 0x1a,
 0xb4, 0x5a, 0xd6, 0xb4, 0x4e, 0x26, 0x8e, 0x24, 0xcd, 0x18, 0x68, 0x9b, 0x4d, 0xa1, 0x68, 0xd5,
 0xa2, 0x66, 0x8c, 0x38, 0x93, 0x6b, 0x5a, 0x16, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0xb5, 0xa6,
 0xd0, 0xb5, 0xa1, 0x8e, 0x52, 0x56, 0x8c, 0x34, 0x4d, 0xad, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x68,
 0xd5, 0xc4, 0x9b, 0x4d, 0xa2, 0x68, 0xd5, 0xc4, 0x95, 0xc4, 0xc3, 0x45, 0xad, 0x36, 0x89, 0xa3,
 0x57, 0x12, 0x56, 0x8c, 0x34, 0x4d, 0xad, 0x68, 0x5c, 0x4d, 0x5a, 0x26, 0x71, 0x35, 0x68, 0x9b,
 0x4d, 0xa1, 0x68, 0xc3, 0x44, 0xce, 0x26, 0xad, 0x16, 0x89, 0x4d, 0xa1, 0x68, 0xc3, 0x44, 0xae,
 0x26, 0xad, 0x13, 0x6b, 0x5a, 0x26, 0x8c, 0x34, 0x4a, 0xe2, 0x6a, 0xd1, 0x36, 0x9b, 0x46, 0x0d,
 0x9a, 0x30, 0xd3, 0x25, 0x2c, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x1f, 0x7d, 0xce, 0x96, 0x84, 0x13, 0xa3, 0xa1, 0xcb, 0xd4, 0xa3, 0xc3, 0xad,
 0x10, 0x4e, 0x96, 0x87, 0xc7, 0x23, 0x37, 0x3f, 0xa9, 0xb7, 0x71, 0x33, 0xa3, 0xa1, 0x0c, 0xe9,
 0x68, 0x72, 0xb3, 0xa4, 0x43, 0x3a, 0x5a, 0x19, 0x23, 0x37, 0x8f, 0x3d, 0xbb, 0x89, 0x9d, 0x22,
 0x19, 0xd2, 0x39, 0x69, 0xd2, 0x20, 0x9d, 0x2d, 0x0c, 0xb1, 0x9b, 0xc7, 0x9e, 0xdd, 0xc5, 0x4e,
 0x91, 0x04, 0xe9, 0x68, 0x72, 0xd3, 0xa5, 0xa1, 0x04, 0xe9, 0x19, 0x23, 0x37, 0x8f, 0x3d, 0xbb,
 0x8a, 0x95, 0x2d, 0x08, 0xe5, 0x4f, 0x43, 0x93, 0x9d, 0x2d, 0x08, 0x67, 0x4b, 0x43, 0x24, 0x66,
 0xf3, 0x65, 0xa5, 0x30, 0xe3, 0xa5, 0x4c, 0x8a, 0x54, 0xce, 0x42, 0x74, 0x88, 0xa5, 0x4c, 0xc9,
 0x19, 0x29, 0x73, 0x1e, 0xb5, 0x09, 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa7, 0xa1, 0x1c, 0xa9, 0x97,
 0x8c, 0x96, 0x8c, 0x94, 0x65, 0x02, 0x39, 0x53, 0x2f, 0x4a, 0x04, 0x72, 0xa6, 0x64, 0x8c, 0x99,
 0x23, 0x25, 0x19, 0x43, 0x42, 0x39, 0x40, 0xbd, 0x28, 0x11, 0xca, 0x99, 0x78, 0xc9, 0x78, 0xc9,
 0x42, 0x54, 0xc8, 0xe5, 0x4f, 0x42, 0xf4, 0xa0, 0x47, 0x28, 0x17, 0x8c, 0x99, 0x23, 0x35, 0x19,
 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47, 0x2a, 0x66, 0x48, 0xc9, 0x78, 0xc9, 0x46, 0x54, 0xc8,
 0xe5, 0x4c, 0xbd, 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x32, 0x5e, 0x32, 0x51, 0x94, 0x08, 0xe5, 0x4c,
 0xbd, 0x28, 0x68, 0x45, 0x2a, 0x65, 0xe3, 0x26, 0x48, 0xc9, 0x4a, 0x54, 0xf4, 0x22, 0x95, 0x32,
 0xf4, 0xa0, 0x47, 0x28, 0x17, 0x8c, 0x97, 0x8c, 0x94, 0x65, 0x4c, 0x8e, 0x50, 0x2f, 0x4a, 0x9e,
 0x84, 0x72, 0x81, 0x92, 0x32, 0x64, 0x8c, 0x94, 0x65, 0x02, 0x39, 0x40, 0xbd, 0x2a, 0x64, 0x72,
 0x86, 0x85, 0xe3, 0x25, 0xe3, 0x25, 0x17, 0x03, 0x57, 0x12, 0xe4, 0xa0, 0x47, 0x2a, 0x65, 0xe3,
 0x26, 0x48, 0xc9, 0x55, 0xa3, 0x57, 0x12, 0xc4, 0xa0, 0x68, 0xe2, 0x5a, 0x25, 0x68, 0x94, 0x2d,
 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x89, 0x6b, 0x5a, 0xd0, 0xb4, 0x61, 0xc4, 0x95, 0xa3, 0x0d, 0x13,
 0x69, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x45, 0xad, 0x31, 0x28, 0x9a, 0x35, 0x68, 0x99,
 0xa3, 0x57, 0x12, 0x6d, 0x6b, 0x42, 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x13, 0x69, 0xb4, 0x4d,
 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x44, 0xda, 0xd6, 0x8b, 0x81, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x5a,
 0xd3, 0x68, 0x5a, 0x30, 0xd1, 0x2b, 0x89, 0x86, 0x89, 0xb4, 0xda, 0x17, 0x13, 0x56, 0x89, 0x9a,
 0x35, 0x68, 0x9b, 0x5a, 0xd0, 0xb8, 0x98, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0xd6, 0x9b, 0x42, 0xd1,
 0xab, 0x44, 0xcd, 0x1a, 0xb8, 0x93, 0x6b, 0x44, 0xa2, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x89,
 0xb4, 0xc4, 0xa1, 0x68, 0xc3, 0x44, 0xce, 0x26, 0xae, 0x25, 0xad, 0x6b, 0x42, 0xd1, 0x87, 0x12,
 0x56, 0x8d, 0x5c, 0x49, 0xb4, 0xda, 0x26, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0xb5, 0xa6, 0xd0,
 0xb4, 0x61, 0xa2, 0x66, 0x8d, 0x5c, 0x49, 0xb5, 0xad, 0x0b, 0x46, 0x1a, 0x25, 0x68, 0xd5, 0xa2,
 0x6d, 0x36, 0x89, 0xa3, 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x26, 0xd6, 0xb4, 0x2e, 0x26, 0xad, 0x13,
 0x34, 0x61, 0xa2, 0xd6, 0x9b, 0x42, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xad, 0x13, 0x69, 0xb4, 0x4d,
 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x45, 0xa2, 0x56, 0xb4, 0x2e, 0x26, 0xae, 0x24, 0xcd, 0x18, 0x68,
 0x9b, 0x4d, 0xa1, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x57, 0x12, 0x6d, 0x6b, 0x44, 0xe2, 0x6a, 0xd1,
 0x33, 0x46, 0xad, 0x16, 0xb4, 0xda, 0x17, 0x13, 0x57, 0x12, 0x66, 0x8c, 0x38, 0x93, 0x6b, 0x5a,
 0x16, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x71, 0x26, 0xd3, 0x68, 0x9a, 0x35, 0x68, 0x95, 0xa3, 0x0d,
 0x16, 0xb4, 0xda, 0x16, 0x8c, 0x34, 0x4a, 0xd1, 0x87, 0x12, 0x6d, 0x6b, 0x45, 0xd2, 0x60, 0x91,
 0xa3, 0x57, 0x12, 0x6d, 0x36, 0xd4, 0x19, 0xe0, 0x60, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x01, 0xfa, 0x49, 0x5b, 0x09, 0xa1, 0x4e, 0xae, 0x17, 0x87, 0x78, 0xed, 0x55, 0xb0, 0x9a,
 0x14, 0xab, 0x61, 0x34, 0x3e, 0x19, 0x8e, 0xb3, 0xd7, 0xaf, 0xc3, 0xff, 0x00, 0x27, 0x58, 0xa9,
 0x41, 0xae, 0xf1, 0x5e, 0x74, 0xb4, 0x3b, 0x1d, 0x6c, 0x26, 0x85, 0x2a, 0xd8, 0x4d, 0x0f, 0x46,
 0x3a, 0xad, 0x56, 0xae, 0xca, 0x61, 0xc1, 0xce, 0x96, 0x84, 0x13, 0xa5, 0xa1, 0xcc, 0xd5, 0xc3,
 0xb5, 0xde, 0x2b, 0x4e, 0x8f, 0x0e, 0xf1, 0x9b, 0x1c, 0xda, 0xed, 0x4d, 0xb5, 0x38, 0x99, 0xd2,
 0xd0, 0x86, 0x74, 0xb4, 0x39, 0x59, 0xd2, 0xd0, 0x86, 0x74, 0xb4, 0x32, 0x46, 0x6f, 0x1e, 0x7b,
 0x77, 0x15, 0x3a, 0x5a, 0x10, 0x4e, 0x8e, 0x87, 0x2d, 0x3a, 0x3a, 0x10, 0x4e, 0x8e, 0x86, 0x58,
 0xcd, 0xe3, 0xcf, 0x6e, 0xe2, 0xa7, 0x4b, 0x42, 0x09, 0xd2, 0xd0, 0xe5, 0xa7, 0x47, 0x42, 0x19,
 0xd2, 0x32, 0x46, 0x6f, 0x1e, 0x7b, 0x77, 0x13, 0x3a, 0x44, 0x52, 0xa6, 0xce, 0x52, 0x74, 0xb4,
 0x21, 0x9d, 0x2d, 0x0c, 0x91, 0x9b, 0xc9, 0x96, 0x84, 0xc7, 0xa9, 0xc6, 0x4a, 0x99, 0x1c, 0xa0,
 0x72, 0x33, 0xa5, 0xa1, 0x0c, 0xa9, 0x70, 0xef, 0x19, 0x23, 0x36, 0x19, 0x89, 0x85, 0x09, 0x53,
 0xd0, 0x8a, 0x54, 0xcb, 0xf2, 0xa7, 0xa1, 0x1c, 0xa9, 0x99, 0x23, 0x24, 0xc6, 0x4a, 0x12, 0xa7,
 0xa1, 0x1c, 0xa0, 0x5e, 0x95, 0x3d, 0x08, 0xe5, 0x4c, 0xbc, 0x64, 0xbc, 0x64, 0xa3, 0x2a, 0x64,
 0x72, 0x81, 0x7a, 0x54, 0xc8, 0xe5, 0x03, 0x24, 0x64, 0xc9, 0x19, 0x28, 0xca, 0x9e, 0x84, 0x72,
 0xa6, 0x5e, 0x94, 0x08, 0xe5, 0x4c, 0xbc, 0x64, 0xbc, 0x64, 0xa3, 0x2a, 0x64, 0x72, 0xa6, 0x5e,
 0x95, 0x32, 0x29, 0x53, 0x2f, 0x19, 0x32, 0x46, 0x4a, 0x32, 0x81, 0x1c, 0xa9, 0x97, 0xa5, 0x4c,
 0x8e, 0x54, 0xcb, 0xc6, 0x4b, 0xc6, 0x4a, 0x32, 0x81, 0x1c, 0xa1, 0xa1, 0x7a, 0x50, 0x23, 0x94,
 0x34, 0x32, 0x46, 0x4c, 0x91, 0x92, 0x8c, 0xa9, 0x91, 0xca, 0x99, 0x7a, 0x50, 0x23, 0x94, 0x0b,
 0xc6, 0x4b, 0xc6, 0x4a, 0x32, 0xa6, 0x45, 0x2a, 0x65, 0xe9, 0x53, 0x23, 0x95, 0x32, 0xf1, 0x93,
 0x24, 0x66, 0xa3, 0x28, 0x11, 0xca, 0x99, 0x7a, 0x54, 0xc8, 0xe5, 0x4c, 0xc9, 0x19, 0x2f, 0x19,
 0x28, 0xca, 0x06, 0x8e, 0x0c, 0xbb, 0x28, 0x11, 0xca, 0x99, 0x78, 0xc9, 0x78, 0xc9, 0x4d, 0xa3,
 0x0e, 0x25, 0x99, 0x53, 0x23, 0x70, 0x2f, 0x12, 0xbc, 0x64, 0x81, 0xc4, 0xd5, 0xa2, 0x67, 0x13,
 0x57, 0x12, 0x6d, 0x6b, 0x44, 0xd1, 0xab, 0x89, 0x33, 0x89, 0xab, 0x45, 0xad, 0x6b, 0x42, 0xe2,
 0x61, 0xa2, 0x56, 0x8c, 0x38, 0x93, 0x69, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a, 0xd1, 0x36,
 0x9b, 0x44, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xad, 0x16, 0xb5, 0xa2, 0x50, 0xb8, 0x98, 0x68, 0x95,
 0xa3, 0x0d, 0x13, 0x69, 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xd1, 0x36, 0xb5, 0xa2, 0x68,
 0xd5, 0xa2, 0x57, 0x13, 0x0e, 0x24, 0xda, 0x6d, 0x0b, 0x89, 0x87, 0x12, 0x56, 0x8c, 0x34, 0x5a,
 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0x6d, 0x68, 0x94, 0x2d, 0x18, 0x68, 0x95,
 0xa3, 0x0d, 0x13, 0x69, 0xb4, 0x2d, 0x18, 0x71, 0x25, 0x68, 0xd5, 0xc4, 0xb5, 0xad, 0x68, 0x9a,
 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0x6d, 0x36, 0x85, 0xa3, 0x0d, 0x12, 0xb4, 0x61, 0xa2, 0xd6,
 0x9b, 0x42, 0xd1, 0x86, 0x89, 0x5a, 0x35, 0x68, 0x9b, 0x5a, 0x25, 0x13, 0x89, 0xab, 0x44, 0xcd,
 0x1a, 0xb4, 0x4c, 0x4a, 0x6d, 0x0b, 0x46, 0x1a, 0x25, 0x71, 0x30, 0xd1, 0x6b, 0x5a, 0x25, 0x0b,
 0x46, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x36, 0x9b, 0x44, 0xe2, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x13,
 0x6b, 0x5a, 0x16, 0x8c, 0x34, 0x4c, 0xe2, 0x6a, 0xe2, 0x5a, 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99,
 0xa3, 0x56, 0x89, 0xb4, 0xda, 0x26, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x71, 0x26, 0xd6, 0xb4, 0x2d,
 0x1a, 0xf0, 0x26, 0x68, 0xc3, 0x89, 0x6b, 0x4d, 0xa1, 0x68, 0xd5, 0xc4, 0x99, 0xc4, 0xd5, 0xa2,
 0x6d, 0x6b, 0x44, 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x13, 0x69, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c,
 0xd1, 0x86, 0x8b, 0x5a, 0x6d, 0x0b, 0x46, 0xad, 0x13, 0x38, 0x9a, 0xf0, 0x26, 0xd6, 0x89, 0x42,
 0xe2, 0x61, 0xa2, 0x56, 0x8c, 0x34, 0x4d, 0xa6, 0xd0, 0xb8, 0x98, 0x25, 0x71, 0x30, 0xd1, 0x6b,
 0x4d, 0xa3, 0x06, 0xcd, 0x18, 0xe0, 0x4a, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfa, 0x81, 0x43, 0x1c,
 0xf8, 0x70, 0x97, 0x4a, 0xd4, 0xb3, 0x19, 0xd1, 0xaa, 0xbc, 0x0c, 0xea, 0xf4, 0xb1, 0x3a, 0x96,
 0xe8, 0xe2, 0xb8, 0x77, 0xcf, 0xcf, 0x71, 0x9d, 0x3a, 0x78, 0xd4, 0x89, 0xf5, 0xb9, 0xaa, 0xb8,
 0x54, 0xd7, 0x15, 0xd2, 0x53, 0xad, 0x84, 0xd0, 0x61, 0xf1, 0xad, 0x7d, 0x91, 0x76, 0x9e, 0x2a,
 0x9d, 0x45, 0xc2, 0x6b, 0xdc, 0x33, 0x63, 0xab, 0x4a, 0x67, 0xa1, 0x86, 0x6e, 0x1a, 0xb6, 0x13,
 0x42, 0x9d, 0x6c, 0x26, 0x87, 0x67, 0x95, 0x18, 0x54, 0x5c, 0x60, 0xd3, 0x2a, 0xd6, 0xc2, 0x68,
 0x7a, 0x30, 0xd6, 0x6b, 0xf5, 0xb8, 0x7d, 0xba, 0xb5, 0x5c, 0x2b, 0x5d, 0xe2, 0xad, 0x4a, 0x0d,
 0x77, 0x8e, 0xcf, 0x5b, 0x09, 0xa1, 0x4a, 0xb6, 0x13, 0x43, 0xd1, 0x8e, 0xb3, 0x53, 0xad, 0xb0,
 0x98, 0x75, 0xe9, 0xd2, 0x21, 0x9d, 0x2d, 0x0e, 0x6e, 0xb6, 0x17, 0x42, 0xad, 0x4c, 0x3b, 0x5d,
 0xe3, 0x3e, 0x3a, 0x8d, 0x66, 0xa6, 0xd6, 0x63, 0xee, 0x70, 0xf3, 0xa5, 0xa1, 0x0c, 0xe9, 0x1c,
 0xb4, 0xe8, 0xe8, 0x41, 0x3a, 0x5a, 0x19, 0x63, 0x37, 0x8b, 0x3d, 0xbb, 0x8a, 0x9d, 0x2d, 0x08,
 0x27, 0x4b, 0x43, 0xa6, 0x6f, 0x57, 0x7c, 0x3b, 0x2f, 0xbb, 0xbd, 0xa0, 0xa1, 0x92, 0x67, 0x78,
 0x0c, 0xe3, 0x11, 0x89, 0xaf, 0x85, 0x8e, 0x2a, 0x32, 0xc1, 0xd1, 0xa7, 0x28, 0x28, 0x4a, 0x73,
 0x8a, 0x4d, 0xca, 0xa4, 0x5f, 0x1e, 0x30, 0x7d, 0xef, 0x01, 0xd3, 0xa5, 0xe6, 0x9b, 0xd8, 0x07,
 0xf7, 0x23, 0x69, 0xbd, 0xed, 0x43, 0xe9, 0x8b, 0xc6, 0xa1, 0x1c, 0x1f, 0x73, 0xa9, 0x8c, 0x65,
 0x86, 0x13, 0x31, 0x2f, 0x5e, 0x9d, 0x2d, 0x08, 0x27, 0x4b, 0x43, 0xc9, 0x25, 0xe6, 0x98, 0xd8,
 0x17, 0xf7, 0x23, 0x69, 0x7d, 0xed, 0x43, 0xe9, 0x88, 0xe5, 0xe6, 0x95, 0xd8, 0x27, 0xf7, 0x27,
 0x69, 0x3d, 0xed, 0x43, 0xe9, 0x8c, 0x91, 0xab, 0x0f, 0x3e, 0x7c, 0x07, 0x79, 0x3f, 0xdb, 0x97,
 0xac, 0xce, 0x96, 0x84, 0x33, 0xa5, 0xa1, 0xe5, 0x12, 0xf3, 0x48, 0xec, 0x23, 0xfb, 0x93, 0xb4,
 0x7e, 0xf7, 0xa3, 0xf4, 0xa4, 0x72, 0xf3, 0x47, 0x6c, 0x2b, 0xfb, 0x95, 0xb4, 0x7e, 0xf7, 0xa3,
 0xf4, 0xa5, 0xe3, 0x5b, 0x1f, 0x6b, 0xcd, 0x9f, 0x93, 0xdb, 0xef, 0xbb, 0x4a, 0x5e, 0xad, 0x2a,
 0x7a, 0x11, 0x4a, 0x99, 0xe5, 0x52, 0xf3, 0x45, 0xec, 0x33, 0xfb, 0x95, 0xb4, 0x5e, 0xf7, 0xa3,
 0xf4, 0xa6, 0x92, 0xf3, 0x44, 0x6c, 0x43, 0xfb, 0x97, 0xb4, 0x3e, 0xf7, 0xa3, 0xf4, 0xa6, 0x48,
 0xd7, 0xc3, 0xda, 0xc3, 0x3e, 0x4f, 0xf1, 0x18, 0xf5, 0x69, 0x4b, 0xd5, 0x25, 0x4c, 0x8e, 0x50,
 0x3c, 0xad, 0xf9, 0xa1, 0x76, 0x25, 0xfd, 0xcb, 0xda, 0x0f, 0x7b, 0xd1, 0xfa, 0x53, 0x47, 0xe6,
 0x83, 0xd8, 0xa7, 0xf7, 0x33, 0x68, 0x3d, 0xef, 0x47, 0xe9, 0x4b, 0xc6, 0xe3, 0x0f, 0x69, 0x1c,
 0x0b, 0x89, 0x7e, 0x0c, 0xbd, 0x4e, 0x54, 0xc8, 0xe5, 0x4c, 0xf2, 0xe7, 0xe6, 0x81, 0xd8, 0xb7,
 0xf7, 0x33, 0x3f, 0xf2, 0x14, 0x7e, 0x94, 0xd1, 0xef, 0xff, 0x00, 0x63, 0x1f, 0xdc, 0xcc, 0xff,
 0x00, 0xc8, 0x51, 0xfa, 0x52, 0xd1, 0xb8, 0xc3, 0xda, 0xbc, 0x70, 0x3e, 0x23, 0xf8, 0x32, 0xf5,
 0x09, 0x40, 0x8a, 0x54, 0xce, 0x95, 0xb1, 0xdb, 0xdb, 0xd9, 0xad, 0xab, 0xda, 0x2c, 0x36, 0x45,
 0x97, 0x60, 0x73, 0x6a, 0x58, 0x9c, 0x42, 0x9b, 0x84, 0xab, 0xd2, 0xa7, 0x18, 0x2e, 0x58, 0xb9,
 0x3e, 0x2d, 0x4d, 0xbe, 0xa4, 0xfb, 0xc7, 0x7f, 0x94, 0x34, 0x33, 0x61, 0xab, 0x19, 0x45, 0xc4,
 0xbc, 0x9b, 0x8d, 0xb6, 0xb6, 0xd7, 0x3f, 0x33, 0x5b, 0x1f, 0x36, 0x7d, 0x7e, 0x95, 0x19, 0x43,
 0x42, 0x39, 0x53, 0x2f, 0x4a, 0x99, 0x1c, 0xa9, 0x99, 0xa3, 0x26, 0x28, 0xc9, 0x46, 0x50, 0x23,
 0x95, 0x32, 0xf4, 0xa0, 0x47, 0x2a, 0x65, 0xe3, 0x25, 0xe3, 0x25, 0x19, 0x53, 0x22, 0x94, 0x0b,
 0xf2, 0x81, 0x14, 0xa9, 0x97, 0x8c, 0x99, 0x23, 0x25, 0x19, 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa6,
 0x47, 0x28, 0x68, 0x5e, 0x32, 0x5e, 0x32, 0x51, 0x95, 0x32, 0x39, 0x53, 0x2f, 0x4a, 0x99, 0x1c,
 0xa9, 0x99, 0x23, 0x26, 0x48, 0xc9, 0x46, 0x54, 0xc8, 0xe5, 0x4f, 0x42, 0xf4, 0xa0, 0x47, 0x2a,
 0x65, 0xe3, 0x25, 0xe3, 0x25, 0x19, 0x53, 0x22, 0x94, 0x0b, 0xf2, 0x81, 0x1c, 0xa9, 0x97, 0x8c,
 0x99, 0x23, 0x25, 0x09, 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47, 0x2a, 0x7a, 0x19, 0x23, 0x25,
 0xe3, 0x25, 0x27, 0x13, 0x56, 0x8b, 0x72, 0xa6, 0x47, 0x2a, 0x65, 0xe3, 0x25, 0xe3, 0x25, 0x67,
 0x13, 0x0d, 0x13, 0x38, 0x33, 0x57, 0x12, 0xd1, 0x2b, 0x44, 0xa1, 0x68, 0xc3, 0x44, 0xae, 0x26,
 0x1c, 0x49, 0xb5, 0xad, 0x0b, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x5a, 0xd3, 0x68, 0x5c, 0x4c,
 0x38, 0x92, 0xb4, 0x61, 0xc4, 0x9b, 0x5a, 0xd0, 0xb4, 0x6a, 0xe2, 0x4c, 0xd1, 0xab, 0x89, 0x36,
 0x9b, 0x44, 0xe2, 0x6a, 0xe2, 0x4c, 0xd1, 0xab, 0x45, 0xad, 0x6b, 0x42, 0xd1, 0x86, 0x89, 0x5c,
 0x4c, 0x38, 0x93, 0x69, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a, 0xe2, 0x4d, 0xa6, 0xd1, 0x34,
 0x6a, 0xe2, 0x4c, 0xe2, 0x6a, 0xd1, 0x36, 0xb5, 0xa1, 0x68, 0xd5, 0xa2, 0x66, 0x8c, 0x34, 0x5a,
 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xc4, 0x9b, 0x5a, 0xd1, 0x34, 0x6a, 0xd1, 0x2b,
 0x46, 0x1a, 0x26, 0xd3, 0x12, 0x85, 0xc4, 0xd5, 0xc4, 0x9b, 0x81, 0x86, 0x8b, 0x5a, 0x62, 0x50,
 0xf0, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xc4, 0x9b, 0x5a, 0xd1, 0x38, 0x9a, 0xb4, 0x4a, 0xd1, 0x86,
 0x89, 0xb4, 0xda, 0x17, 0x13, 0x57, 0x12, 0x66, 0x8c, 0x34, 0x5a, 0xd6, 0xb4, 0x2d, 0x1a, 0xb4,
 0x4c, 0xd1, 0xab, 0x89, 0x36, 0x9b, 0x42, 0xd1, 0x86, 0x89, 0x5a, 0x30, 0xd1, 0x36, 0x9b, 0x42,
 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x16, 0xb5, 0xad, 0x0b, 0x46, 0x1c, 0x49, 0x9a, 0x35, 0x71,
 0x26, 0xd3, 0x68, 0x5a, 0x30, 0xd1, 0x2b, 0x89, 0x86, 0x89, 0xb5, 0xad, 0x0b, 0x46, 0x1c, 0x49,
 0x5a, 0x35, 0x68, 0xb5, 0xa6, 0xd1, 0x38, 0x9a, 0xb4, 0x4c, 0xd1, 0xab, 0x44, 0xda, 0xd6, 0x85,
 0xa3, 0x0d, 0x12, 0xb8, 0x9a, 0xb4, 0x4d, 0xa6, 0xd1, 0x38, 0x9a, 0xb4, 0x4c, 0xd1, 0xab, 0x45,
 0xad, 0x36, 0x85, 0xc4, 0xc3, 0x44, 0xce, 0x26, 0xad, 0x13, 0x6b, 0x5a, 0x16, 0x8c, 0x34, 0x4a,
 0xe2, 0x61, 0xc4, 0x9b, 0x4d, 0xa1, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x2d, 0x12, 0xb5, 0xa2,
 0x68, 0xd7, 0x81, 0x33, 0x46, 0xae, 0x24, 0xda, 0x6d, 0x10, 0x38, 0xda, 0xb9, 0xee, 0x0a, 0x15,
 0x25, 0x0e, 0x4a, 0xd2, 0xe5, 0x6d, 0x71, 0x49, 0x70, 0x7f, 0x09, 0xa7, 0x77, 0xb0, 0x5f, 0xc9,
 0x62, 0x3f, 0x25, 0x76, 0x9a, 0xe9, 0xe3, 0x1b, 0x18, 0x9a, 0x9d, 0x58, 0x7a, 0x63, 0x6b, 0xad,
 0x3f, 0xd2, 0xe5, 0x41, 0xc4, 0xf7, 0x7b, 0x07, 0xfc, 0x9d, 0x7f, 0xc9, 0x5d, 0xa7, 0x2c, 0x7a,
 0x76, 0xdb, 0xdd, 0x0d, 0xcd, 0xf2, 0x72, 0x8c, 0xab, 0xd6, 0xc7, 0xa9, 0xa5, 0x9e, 0x9f, 0xd6,
 0x8a, 0x00, 0x07, 0xa9, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x01, 0xfa, 0x15, 0x4e, 0xbe, 0xa5, 0x9a, 0x78, 0x8d, 0x4e, 0x0e, 0x9d, 0x6d, 0x49, 0xe9, 0xd7,
 0xd4, 0xfc, 0xed, 0x12, 0xdd, 0xc6, 0x6e, 0x7a, 0x96, 0x27, 0x52, 0xdd, 0x2c, 0x53, 0xf0, 0x9d,
 0x7a, 0x9d, 0x7d, 0x4b, 0x34, 0xf1, 0x1a, 0x93, 0x12, 0xcb, 0x8e, 0xa3, 0xb2, 0xd1, 0xc6, 0x35,
 0xc3, 0xa4, 0xbd, 0x47, 0x1b, 0xcc, 0xb8, 0x4f, 0x83, 0x3a, 0xb5, 0x2c, 0x46, 0xa5, 0xaa, 0x58,
 0x9d, 0x4b, 0xc6, 0x4c, 0xb8, 0xea, 0x3b, 0x3a, 0xb3, 0x55, 0x74, 0x34, 0x9e, 0xa4, 0x35, 0x70,
 0xbe, 0x04, 0x71, 0x34, 0x71, 0x6d, 0x77, 0xcb, 0xf8, 0x7c, 0x73, 0x5c, 0x3a, 0x4c, 0x98, 0xea,
 0x4c, 0x2d, 0x38, 0xe1, 0x9f, 0xad, 0x15, 0x6c, 0x26, 0x85, 0x2a, 0xd8, 0x4d, 0x0e, 0x76, 0x15,
 0xe8, 0xd4, 0x5e, 0x99, 0x70, 0x62, 0x78, 0x78, 0xcd, 0x71, 0x8b, 0x4d, 0x68, 0x67, 0xc7, 0x59,
 0xe4, 0xd5, 0xd8, 0xc6, 0x5e, 0xa7, 0x56, 0xad, 0x84, 0xd0, 0xa9, 0x57, 0x0c, 0xd7, 0x78, 0xed,
 0x35, 0xb0, 0x9a, 0x14, 0xab, 0x61, 0x34, 0x3d, 0x38, 0xeb, 0x35, 0x3a, 0xdc, 0x3f, 0xf2, 0x7c,
 0x21, 0xe6, 0xe4, 0x87, 0x26, 0xf6, 0x72, 0xb5, 0xeb, 0x15, 0x1f, 0x97, 0xc4, 0x1e, 0x08, 0x7d,
 0x0b, 0xe6, 0xf7, 0xa7, 0x6b, 0x7c, 0x39, 0x54, 0x7d, 0x60, 0xa2, 0xff, 0x00, 0x38, 0xc4, 0x1f,
 0x3d, 0x1e, 0xac, 0x66, 0xe2, 0xdb, 0xbd, 0x9e, 0x1e, 0x66, 0x86, 0x38, 0x80, 0x02, 0x5e, 0x90,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xa1, 0x79, 0x9d, 0x57, 0x1d, 0xee, 0xe5, 0x0b,
 0xfa, 0x35, 0xfe, 0x42, 0x67, 0xd6, 0xb2, 0xa6, 0x7c, 0x9b, 0xe6, 0x6f, 0x5c, 0xdb, 0xe1, 0xc9,
 0xd7, 0xf4, 0x31, 0x1f, 0x21, 0x33, 0xeb, 0xd9, 0x53, 0xd0, 0xf7, 0xed, 0x66, 0xb0, 0x7c, 0xcb,
 0xcb, 0x39, 0x98, 0xdf, 0xe3, 0xff, 0x00, 0xd6, 0x3e, 0x79, 0x28, 0x4a, 0x1a, 0x11, 0xca, 0x99,
 0x7a, 0x54, 0xf4, 0x23, 0x95, 0x33, 0xd9, 0x19, 0x39, 0x38, 0xc9, 0x46, 0x54, 0xf4, 0x23, 0x95,
 0x32, 0xf4, 0xa0, 0x47, 0x2a, 0x7a, 0x17, 0x8c, 0x99, 0x23, 0x25, 0x19, 0x53, 0x22, 0x94, 0x0b,
 0xd2, 0x81, 0x1c, 0xa0, 0x5e, 0x32, 0x5e, 0x32, 0x51, 0x95, 0x32, 0x39, 0x40, 0xbd, 0x2a, 0x64,
 0x72, 0xa6, 0x5e, 0x32, 0x64, 0x8c, 0x94, 0x65, 0x4c, 0x8e, 0x54, 0xcb, 0xd2, 0xa6, 0x47, 0x28,
 0x19, 0x23, 0x25, 0xe3, 0x25, 0x19, 0x53, 0x23, 0x95, 0x32, 0xf4, 0xa0, 0x45, 0x2a, 0x65, 0xe3,
 0x26, 0x48, 0xc9, 0x4a, 0x50, 0x22, 0x95, 0x32, 0xf4, 0xa0, 0x47, 0x2a, 0x65, 0xe3, 0x25, 0xe3,
 0x25, 0x19, 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47, 0x2a, 0x66, 0x48, 0xc9, 0x92, 0x32, 0x51,
 0x95, 0x32, 0x39, 0x40, 0xbd, 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x32, 0x5e, 0x32, 0x51, 0x95, 0x32,
 0x29, 0x53, 0x2f, 0xca, 0x99, 0x14, 0xa9, 0x97, 0x8c, 0x99, 0x23, 0x25, 0x29, 0x40, 0xd1, 0xc4,
 0xb9, 0x2a, 0x64, 0x72, 0xa6, 0x64, 0x8c, 0x97, 0x8c, 0x95, 0x5a, 0x35, 0x71, 0x2c, 0x4a, 0x06,
 0x8e, 0x3c, 0x0b, 0x44, 0xaf, 0x12, 0x81, 0xa3, 0x0d, 0x12, 0xb8, 0x98, 0x71, 0x2d, 0x69, 0xb4,
 0x2d, 0x1a, 0xb8, 0x93, 0x38, 0x9a, 0xb4, 0x4d, 0xad, 0x68, 0x9a, 0x35, 0x71, 0x26, 0x68, 0xd5,
 0xa2, 0x6d, 0x36, 0x85, 0xa3, 0x0d, 0x13, 0x38, 0x9a, 0xb4, 0x5a, 0xd3, 0x68, 0x5a, 0x35, 0x68,
 0x99, 0xc4, 0xd5, 0xa2, 0x6d, 0x6b, 0x44, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4d, 0xa6, 0xd0,
 0xb8, 0x9a, 0xb4, 0x4c, 0xe2, 0x61, 0xa2, 0xd6, 0xb5, 0xa1, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x56,
 0x89, 0xb4, 0xda, 0x27, 0x13, 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x26, 0xd6, 0xb4, 0x2d, 0x1a, 0xb8,
 0x93, 0x38, 0x98, 0x71, 0x26, 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0xd6, 0x9b,
 0x44, 0xe2, 0x6a, 0xe2, 0x4a, 0xd1, 0x86, 0x89, 0xb5, 0xad, 0x0f, 0x03, 0x57, 0x12, 0x66, 0x8c,
 0x38, 0x93, 0x69, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x45, 0xad, 0x6b, 0x44, 0xd1, 0xab,
 0x89, 0x33, 0x89, 0xab, 0x44, 0xda, 0x62, 0x50, 0xb8, 0x9a, 0xb4, 0x4c, 0xd1, 0x86, 0x89, 0xb5,
 0xa2, 0x50, 0xb4, 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x45, 0xad, 0x36, 0x85, 0xa3, 0x0d, 0x12, 0xb8,
 0x98, 0x68, 0x9b, 0x4d, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8b, 0x5a, 0xd1, 0x28, 0x9a,
 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xc4, 0x98, 0x94, 0xda, 0x16, 0x8c, 0x34, 0x4a, 0xd1, 0x86, 0x89,
 0xb5, 0xa2, 0x50, 0xb8, 0x9a, 0xb8, 0x93, 0x38, 0x9a, 0xb4, 0x5a, 0xd3, 0x68, 0x9a, 0x35, 0x68,
 0x99, 0xc4, 0xd5, 0xc4, 0x9b, 0x5a, 0xd0, 0xb4, 0x61, 0xc4, 0x95, 0xa3, 0x0d, 0x13, 0x69, 0xb4,
 0x2d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xd1, 0x6b, 0x4d, 0xa1, 0x68, 0xe3, 0x76, 0x83, 0x18, 0xb0,
 0x78, 0x26, 0xa2, 0xfe, 0xab, 0x55, 0x38, 0xc3, 0x4f, 0x0b, 0x39, 0x1c, 0x6e, 0x22, 0x96, 0x13,
 0x0f, 0x3a, 0xf5, 0xa5, 0xc2, 0x31, 0x5e, 0xdb, 0x7e, 0x04, 0x74, 0x6c, 0xcf, 0x19, 0x53, 0x1d,
 0x8a, 0x95, 0x7a, 0x9d, 0x0b, 0xaa, 0x31, 0xfe, 0x2a, 0xf0, 0x1a, 0x3e, 0x39, 0xc5, 0x23, 0x69,
 0xa3, 0x3a, 0x78, 0x4f, 0xd3, 0xcb, 0xfc, 0x47, 0xb7, 0xf6, 0x6c, 0x36, 0x3b, 0x79, 0xd5, 0xcf,
 0xce, 0x9f, 0x54, 0x2a, 0x80, 0x0f, 0x9d, 0xba, 0x00, 0xef, 0x8d, 0x1d, 0x0c, 0xf4, 0x07, 0x13,
 0xb2, 0xf2, 0x4b, 0xfb, 0xdf, 0xed, 0xfd, 0x5a, 0x9e, 0x29, 0x3f, 0x57, 0xe3, 0xfa, 0x22, 0x68,
 0xc1, 0x2b, 0x89, 0xab, 0x47, 0x67, 0x6d, 0x5d, 0xb4, 0x06, 0x5a, 0x30, 0x48, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, 0x96, 0x15, 0xb5, 0x27, 0x85, 0x6d, 0x4e, 0x22,
 0x15, 0x75, 0x27, 0x85, 0x63, 0xf3, 0x94, 0x4b, 0x63, 0x19, 0xb9, 0x8a, 0x75, 0xb5, 0x27, 0xa7,
 0x5b, 0x53, 0x86, 0x85, 0x6d, 0x4b, 0x10, 0xad, 0xa9, 0x31, 0x2c, 0x91, 0x9b, 0x99, 0xa7, 0x5f,
 0x52, 0xcd, 0x3a, 0xfa, 0x9c, 0x25, 0x3a, 0xda, 0x93, 0xd3, 0xad, 0xa9, 0x68, 0x96, 0x48, 0xcd,
 0xce, 0xd2, 0xc4, 0x6a, 0x59, 0xa5, 0x89, 0xd4, 0xe0, 0x69, 0xd7, 0xd4, 0xb1, 0x4e, 0xbe, 0xa5,
 0xa2, 0x59, 0x63, 0x37, 0x62, 0xa5, 0x8a, 0xd4, 0xbb, 0x43, 0x18, 0xd7, 0x0e, 0x12, 0x3a, 0xcd,
 0x3c, 0x46, 0xa5, 0x9a, 0x58, 0x9d, 0x4b, 0x46, 0x4c, 0xb8, 0xea, 0x3b, 0x5d, 0x2c, 0x64, 0x66,
 0xb8, 0x4d, 0x26, 0x48, 0xe1, 0x4a, 0xaa, 0xf4, 0xad, 0x7b, 0x07, 0x5b, 0xa5, 0x8a, 0xe1, 0xdf,
 0x2e, 0x51, 0xc5, 0xb5, 0xdf, 0x2f, 0x19, 0xcc, 0x32, 0x79, 0xd1, 0x97, 0xad, 0xf1, 0x27, 0xfd,
 0xa1, 0x94, 0xed, 0x6f, 0xa7, 0x28, 0x8f, 0x0f, 0xf8, 0x76, 0x8b, 0xfc, 0xe7, 0x12, 0x7c, 0xde,
 0x7d, 0x19, 0xff, 0x00, 0x68, 0x25, 0x57, 0x5b, 0x7c, 0xb9, 0x44, 0x9b, 0xe3, 0xc3, 0x67, 0x68,
 0xaf, 0xce, 0x71, 0x27, 0xce, 0x66, 0xe3, 0x46, 0x6f, 0x4e, 0x25, 0x68, 0x88, 0x88, 0xf4, 0x00,
 0x03, 0x2a, 0x5e, 0xab, 0x2f, 0x33, 0xb6, 0xf8, 0xd7, 0x5e, 0xc7, 0xfe, 0x92, 0xc2, 0x7d, 0x29,
 0xab, 0xf3, 0x3d, 0xef, 0x7d, 0x75, 0xec, 0x87, 0xe9, 0x1c, 0x2f, 0xd2, 0x9f, 0xa2, 0xb5, 0xb0,
 0x9a, 0x14, 0xeb, 0x61, 0x34, 0x30, 0xe3, 0xad, 0x6d, 0x3e, 0xa6, 0xf7, 0x73, 0x8f, 0xaa, 0x23,
 0xfc, 0xfe, 0xef, 0xcf, 0x47, 0xe6, 0x7e, 0xde, 0xea, 0xeb, 0xd9, 0x1f, 0xd2, 0x38, 0x5f, 0xa5,
 0x35, 0x7b, 0x80, 0xde, 0xda, 0xeb, 0xd9, 0x2f, 0xd2, 0x38, 0x5f, 0xa5, 0x3f, 0x40, 0x6a, 0xe1,
 0x5a, 0xef, 0x15, 0x6a, 0x50, 0x6b, 0xad, 0x19, 0x23, 0x28, 0x97, 0x8b, 0x3e, 0x2d, 0xba, 0xc7,
 0xfa, 0x63, 0xb4, 0xfe, 0xef, 0x81, 0x9e, 0xe0, 0xf7, 0xb2, 0xbf, 0xe1, 0x3f, 0xd2, 0x18, 0x5f,
 0xa4, 0x30, 0xf7, 0x0d, 0xbd, 0x85, 0xd7, 0xb2, 0x9f, 0xa4, 0x30, 0xbf, 0x48, 0x7d, 0xe7, 0x3a,
 0x5a, 0x10, 0xce, 0x96, 0x86, 0x48, 0xa7, 0x9b, 0x2e, 0x3b, 0xbb, 0x8f, 0xe9, 0xc7, 0xb4, 0xfe,
 0xef, 0x84, 0x1e, 0xe2, 0x37, 0xac, 0xba, 0xf6, 0x57, 0xf4, 0x86, 0x1b, 0xe9, 0x0c, 0x3d, 0xc5,
 0xef, 0x51, 0x75, 0xec, 0xb7, 0xe7, 0xf8, 0x6f, 0xa4, 0x3e, 0xe9, 0x9d, 0x2d, 0x08, 0x67, 0x48,
 0xb4, 0x63, 0x8b, 0x06, 0x5e, 0x51, 0x6f, 0x23, 0xfa, 0x71, 0xed, 0x3f, 0xbb, 0xe5, 0x0d, 0xc7,
 0xee, 0xa7, 0x6f, 0x76, 0x6f, 0x79, 0xb9, 0x66, 0x71, 0x9d, 0xe4, 0x3e, 0x74, 0xc0, 0x50, 0x8d,
 0x65, 0x52, 0xaf, 0x9e, 0xe8, 0x4f, 0x97, 0x9a, 0x94, 0xe2, 0xba, 0x23, 0x36, 0xdf, 0x4b, 0x4b,
 0xa8, 0xfa, 0x4e, 0x74, 0x74, 0x39, 0x69, 0xd1, 0xd0, 0x82, 0x74, 0xb4, 0x33, 0xe9, 0xcc, 0x63,
 0x15, 0x0e, 0x73, 0x8a, 0x6e, 0x75, 0x78, 0x86, 0xac, 0x6a, 0xea, 0xc4, 0x44, 0xc4, 0x57, 0xa3,
 0xff, 0x00, 0xec, 0xfb, 0x5c, 0x54, 0xe9, 0x68, 0x43, 0x3a, 0x47, 0x2b, 0x3a, 0x5a, 0x10, 0xce,
 0x96, 0x86, 0x68, 0xcd, 0xa5, 0xcf, 0x6f, 0x4e, 0x2e, 0x54, 0xf4, 0x23, 0x95, 0x3d, 0x0e, 0x46,
 0x74, 0x88, 0x67, 0x48, 0xcb, 0x19, 0xb0, 0x4e, 0x39, 0x62, 0xe3, 0xe5, 0x02, 0x39, 0x53, 0x2f,
 0xca, 0x99, 0x14, 0xa9, 0xe8, 0x5e, 0x32, 0x44, 0x64, 0xa3, 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x95,
 0x32, 0x39, 0x53, 0x32, 0x46, 0x4c, 0x91, 0x92, 0x8c, 0xa9, 0x91, 0xca, 0x99, 0x7a, 0x54, 0xc8,
 0xe5, 0x4c, 0xbc, 0x64, 0xbc, 0x64, 0xa3, 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x95, 0x32, 0x29, 0x53,
 0xd0, 0xbc, 0x64, 0xbc, 0x64, 0xa3, 0x28, 0x68, 0x47, 0x2a, 0x65, 0xe9, 0x40, 0x8e, 0x54, 0xcc,
 0x91, 0x93, 0x24, 0x66, 0xa3, 0x2a, 0x64, 0x72, 0x86, 0x85, 0xe9, 0x40, 0x8e, 0x54, 0xcb, 0xc6,
 0x4b, 0xc6, 0x4a, 0x32, 0xa6, 0x47, 0x2a, 0x7a, 0x17, 0xa5, 0x02, 0x39, 0x40, 0xbc, 0x64, 0xc9,
 0x19, 0x28, 0xca, 0x99, 0x1c, 0xa9, 0x97, 0xa5, 0x4c, 0x8a, 0x50, 0x2f, 0x19, 0x2f, 0x19, 0x28,
 0xca, 0x99, 0x1c, 0xa0, 0x5e, 0x95, 0x32, 0x39, 0x53, 0x32, 0x46, 0x4c, 0x91, 0x92, 0x8c, 0xa9,
 0x91, 0xca, 0x99, 0x7a, 0x50, 0x23, 0x95, 0x32, 0xf1, 0x92, 0xf1, 0x92, 0x8c, 0xa9, 0x91, 0xb8,
 0x17, 0xa5, 0x4c, 0x8a, 0x50, 0x2f, 0x19, 0x32, 0x46, 0x4a, 0x6e, 0x26, 0xae, 0x25, 0xa9, 0x53,
 0x23, 0x94, 0x0b, 0xc6, 0x4b, 0xc6, 0x48, 0x1c, 0x4d, 0x5a, 0x26, 0x71, 0xe0, 0x6a, 0xd1, 0x68,
 0x95, 0xad, 0x0b, 0x46, 0x1a, 0x25, 0x71, 0x30, 0xd1, 0x31, 0x29, 0xb4, 0x2e, 0x26, 0xae, 0x24,
 0xcd, 0x18, 0x68, 0xb5, 0xad, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x6d, 0x36, 0x85,
 0xa3, 0x0d, 0x12, 0xb8, 0x98, 0x71, 0x26, 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8b,
 0x5a, 0xd6, 0x89, 0xa3, 0x57, 0x12, 0x66, 0x8d, 0x5c, 0x49, 0xb4, 0xda, 0x16, 0x8c, 0x34, 0x4a,
 0xd1, 0x87, 0x12, 0x6d, 0x6b, 0x42, 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x16, 0xb4, 0xda, 0x17,
 0x13, 0x0d, 0x13, 0x34, 0x6a, 0xe2, 0x4d, 0xa6, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x89, 0x86, 0x89,
 0xb5, 0xad, 0x0b, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x5a, 0x25, 0x31, 0x28, 0x9c, 0x4d, 0x5a,
 0x26, 0x68, 0xd5, 0xa2, 0x6d, 0x68, 0x94, 0x2e, 0x26, 0xad, 0x13, 0x38, 0x98, 0x68, 0x9b, 0x4d,
 0xa1, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x2d, 0x6b, 0x5a, 0x27, 0x13, 0x56, 0x89, 0x9a, 0x35,
 0xe0, 0x4d, 0xa6, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x89, 0x36, 0x9b, 0x44, 0xd1, 0xab,
 0x44, 0xcd, 0x1a, 0xb4, 0x5a, 0xd6, 0x89, 0x44, 0xe2, 0x6a, 0xe2, 0x4a, 0xd1, 0x86, 0x89, 0xb4,
 0xda, 0x16, 0x8d, 0x5a, 0x26, 0x68, 0xd5, 0xc4, 0x9b, 0x5a, 0xd1, 0x34, 0x6a, 0xd1, 0x33, 0x46,
 0xad, 0x16, 0xb4, 0xc4, 0xa2, 0x68, 0xd5, 0xc4, 0x95, 0xa3, 0x4a, 0x8e, 0x14, 0xe0, 0xe7, 0x39,
 0x28, 0xc5, 0x74, 0xb6, 0xdf, 0x04, 0x89, 0xf3, 0xa9, 0x68, 0x9b, 0x46, 0xd1, 0x4f, 0x33, 0xc7,
 0x61, 0xb2, 0xfa, 0x37, 0x31, 0x13, 0xe0, 0xdf, 0xd6, 0xc1, 0x7d, 0x74, 0xbd, 0x83, 0x8c, 0xce,
 0x36, 0x9a, 0x85, 0x14, 0xe9, 0x60, 0x12, 0xad, 0x53, 0xaa, 0xe3, 0x5e, 0x95, 0x7b, 0x1e, 0x13,
 0xa9, 0xe2, 0xb1, 0x15, 0xb1, 0x35, 0xa5, 0x5a, 0xbd, 0x49, 0x54, 0x9c, 0xba, 0xdb, 0x39, 0xee,
 0x23, 0xe5, 0x06, 0x9e, 0x84, 0x4e, 0x1a, 0x1f, 0x4b, 0x2f, 0x6f, 0xdd, 0x1f, 0xbb, 0x69, 0xb5,
 0xe1, 0xd9, 0xea, 0x7d, 0x2d, 0x4f, 0x44, 0x7f, 0x95, 0x8c, 0xdb, 0x31, 0xaf, 0x98, 0xd7, 0xe7,
 0xaa, 0xf9, 0x60, 0xbe, 0xb2, 0x0b, 0xaa, 0x3f, 0xe6, 0x52, 0x00, 0xe2, 0x75, 0x75, 0x73, 0xd6,
 0xce, 0x73, 0xce, 0x6e, 0x65, 0xbe, 0xc3, 0x0c, 0x70, 0x8f, 0x37, 0x18, 0xf4, 0x00, 0x03, 0x1a,
 0xc1, 0xe8, 0x8d, 0x1e, 0x76, 0x7a, 0x43, 0x47, 0x61, 0xe4, 0x9f, 0xf7, 0x7f, 0xdb, 0xfa, 0xb5,
 0x1c, 0x56, 0x7e, 0xa7, 0xc7, 0xf4, 0x42, 0xd1, 0x86, 0x89, 0x9c, 0x4d, 0x5a, 0x3b, 0x2b, 0x6a,
 0x22, 0x50, 0xb8, 0x9a, 0xb4, 0x4c, 0xd1, 0x86, 0x89, 0xb5, 0xad, 0x0b, 0x46, 0x38, 0x32, 0x56,
 0x8d, 0x5a, 0x26, 0x25, 0x36, 0x8c, 0x1b, 0xb8, 0x9a, 0xb4, 0x5a, 0xd2, 0xc0, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x0f, 0xb1, 0xa1, 0x57, 0x52, 0x68, 0x55, 0xd4, 0xe2, 0xe1, 0x54, 0x9a, 0x15, 0x4f,
 0xcd, 0xd6, 0xf4, 0xc6, 0x4e, 0x56, 0x15, 0x49, 0xa1, 0x5b, 0x53, 0x8a, 0x85, 0x52, 0x68, 0x55,
 0xd4, 0xb5, 0xaf, 0x19, 0x39, 0x68, 0x56, 0xd4, 0x9e, 0x9d, 0x6d, 0x4e, 0x22, 0x15, 0x75, 0x26,
 0x85, 0x6d, 0x49, 0xb5, 0xe3, 0x27, 0x2f, 0x4e, 0xb6, 0xa5, 0x88, 0x57, 0xd4, 0xe1, 0xe1, 0x5b,
 0x52, 0x78, 0x56, 0xd4, 0xb4, 0x4b, 0x24, 0x66, 0xe6, 0x69, 0xd7, 0xd4, 0xb1, 0x4e, 0xbe, 0xa7,
 0x0b, 0x0a, 0xc4, 0xf4, 0xeb, 0x6a, 0x4c, 0x4b, 0x24, 0x66, 0xe6, 0xe9, 0xe2, 0x35, 0x2d, 0x53,
 0xc4, 0x6a, 0x70, 0x54, 0xeb, 0x6a, 0x4f, 0x4e, 0xbe, 0xa5, 0xad, 0x96, 0x33, 0x7c, 0x8b, 0xe6,
 0xef, 0x9d, 0xcd, 0xee, 0xe5, 0x4f, 0xd6, 0x0a, 0x2b, 0xf3, 0x8c, 0x41, 0xf3, 0xf1, 0xef, 0x3e,
 0x6e, 0x09, 0xf3, 0xef, 0x5f, 0x2b, 0x7e, 0xb1, 0x52, 0xf9, 0x7a, 0xe7, 0x83, 0x1b, 0xdd, 0xbf,
 0xd9, 0x62, 0xf6, 0x61, 0x37, 0x8c, 0x00, 0x03, 0x32, 0xcf, 0xd8, 0x39, 0x51, 0x85, 0x45, 0xc6,
 0x0d, 0x32, 0xad, 0x6c, 0x26, 0x85, 0x4a, 0x18, 0xc6, 0xb8, 0x74, 0x97, 0xa8, 0xe3, 0x53, 0x5c,
 0x25, 0xc1, 0xa3, 0x4b, 0x8e, 0xa4, 0xc3, 0x1e, 0x5a, 0x78, 0x66, 0xa1, 0x5b, 0x09, 0xa1, 0x4a,
 0xb6, 0x17, 0x43, 0xb1, 0xab, 0x35, 0x57, 0x43, 0xe0, 0xf5, 0x22, 0xad, 0x85, 0xd0, 0xf4, 0x61,
 0xac, 0xf0, 0xeb, 0x6c, 0x22, 0x7d, 0x4e, 0xab, 0x5b, 0x0b, 0xa1, 0x56, 0xa6, 0x1d, 0xae, 0xf1,
 0xda, 0x2b, 0x61, 0x34, 0x29, 0xd6, 0xc2, 0x68, 0x7a, 0x31, 0xd6, 0x6a, 0x75, 0xb6, 0x14, 0xeb,
 0x73, 0xa3, 0xa1, 0x04, 0xe9, 0x68, 0x73, 0xd5, 0xb0, 0xba, 0x15, 0x2a, 0xe1, 0x9a, 0xef, 0x19,
 0xf1, 0xd4, 0xb6, 0xb3, 0x57, 0x69, 0x31, 0xf7, 0x38, 0x69, 0xd2, 0x21, 0x9d, 0x2d, 0x0e, 0x5a,
 0xa5, 0x16, 0xbb, 0xc4, 0x13, 0xa5, 0xa1, 0x9a, 0x33, 0x78, 0x35, 0x36, 0xee, 0x26, 0x74, 0xb4,
 0x28, 0x67, 0x18, 0x9c, 0x26, 0x57, 0x95, 0xe2, 0xf3, 0x3c, 0x7d, 0x5b, 0x38, 0x4c, 0x25, 0x09,
 0xd7, 0xaf, 0x53, 0x95, 0xcb, 0x92, 0x9c, 0x22, 0xe5, 0x27, 0xc1, 0x26, 0xdf, 0x04, 0x9f, 0x42,
 0x5c, 0x4e, 0x7e, 0x74, 0x8e, 0xa5, 0xbd, 0xaa, 0x5c, 0x37, 0x5b, 0xb5, 0xaf, 0x87, 0x56, 0x49,
 0x8c, 0xf9, 0x09, 0x99, 0x23, 0x37, 0x9e, 0x36, 0xb1, 0x96, 0x71, 0x8c, 0xfd, 0xf2, 0xe8, 0xf2,
 0xdf, 0x76, 0xeb, 0x1f, 0x56, 0xd4, 0x7e, 0x8f, 0xc4, 0xfd, 0x19, 0x1c, 0xb7, 0xd9, 0xba, 0xd7,
 0xff, 0x00, 0x13, 0xfe, 0x61, 0x89, 0xfa, 0x33, 0xe3, 0x00, 0x47, 0x3b, 0x27, 0x55, 0x3e, 0x49,
 0x6c, 0xa7, 0xfa, 0xb2, 0xef, 0x1f, 0xb3, 0xec, 0xa9, 0x6f, 0xa7, 0x75, 0xef, 0xfe, 0x27, 0xfc,
 0xc3, 0x13, 0xf4, 0x67, 0x76, 0xcb, 0xb1, 0x18, 0x5c, 0xcf, 0x2d, 0xc2, 0xe6, 0x58, 0x1a, 0x97,
 0x70, 0xb8, 0xba, 0x30, 0xaf, 0x42, 0xa7, 0x2b, 0x8f, 0x3c, 0x25, 0x15, 0x28, 0xbe, 0x0f, 0x83,
 0x5c, 0x53, 0x5d, 0x0f, 0xa4, 0xfc, 0xff, 0x00, 0x3e, 0xd0, 0xa1, 0xb5, 0x99, 0x66, 0xc4, 0x6e,
 0x2b, 0x67, 0x73, 0xcc, 0xc9, 0xf3, 0xb5, 0x93, 0x60, 0xe1, 0x87, 0xa0, 0x9f, 0x09, 0x57, 0xaa,
 0xe8, 0x47, 0x84, 0x17, 0xeb, 0x6f, 0xbc, 0x93, 0x66, 0x5d, 0x3d, 0x69, 0x9f, 0x5b, 0x43, 0xc6,
 0xbc, 0x9c, 0xd2, 0xda, 0xc6, 0x9c, 0x6d, 0xee, 0x72, 0xca, 0x6a, 0xa6, 0xbf, 0x48, 0x87, 0x3b,
 0xb5, 0x59, 0xfe, 0x47, 0xb3, 0x19, 0x7f, 0x9f, 0xb3, 0xdc, 0xca, 0x86, 0x0a, 0x8f, 0x4a, 0x8f,
 0x3b, 0xf4, 0xd3, 0x7e, 0x08, 0xc5, 0x74, 0xc9, 0xe8, 0x91, 0xe4, 0x99, 0xd7, 0x9a, 0x17, 0x20,
 0xa1, 0x5a, 0x50, 0xca, 0xb2, 0x2c, 0x7e, 0x3a, 0x29, 0xf0, 0xe7, 0xab, 0x52, 0x34, 0x54, 0xb5,
 0x5f, 0x5c, 0xfd, 0xde, 0x07, 0x83, 0xed, 0x9e, 0xd3, 0xe6, 0xfb, 0x5b, 0x9e, 0xd6, 0xce, 0x33,
 0x9c, 0x4b, 0xab, 0x5a, 0xa3, 0xe1, 0x08, 0x2e, 0x88, 0x52, 0x87, 0x7a, 0x10, 0x5d, 0xe4, 0xbf,
 0xcd, 0xf1, 0x67, 0x0a, 0x57, 0x2d, 0xce, 0x5f, 0xd2, 0xda, 0xec, 0x3c, 0x8f, 0xda, 0xe9, 0xe1,
 0x13, 0xb9, 0x99, 0xcb, 0x2f, 0x65, 0xd4, 0x47, 0x6f, 0x4b, 0xe8, 0x3c, 0x37, 0x9a, 0x27, 0x05,
 0x39, 0xa5, 0x8a, 0xd9, 0x4a, 0xf4, 0xa1, 0xdf, 0x74, 0xf1, 0xaa, 0x6f, 0xdc, 0x70, 0x89, 0xdc,
 0x76, 0x6b, 0x7b, 0xfb, 0x0d, 0x9e, 0x54, 0x8d, 0x17, 0x98, 0x4f, 0x2c, 0xaf, 0x2e, 0x85, 0x4f,
 0x1d, 0x0b, 0x69, 0xbf, 0xed, 0xa6, 0xe3, 0xee, 0xb4, 0x7c, 0x96, 0x08, 0xc7, 0x75, 0xa9, 0x1e,
 0xb7, 0xaf, 0x5f, 0xc9, 0x3e, 0x1f, 0xa9, 0x15, 0x84, 0x4e, 0x33, 0xf9, 0x4c, 0xcf, 0xce, 0xdf,
 0x78, 0x45, 0x42, 0xa4, 0x23, 0x52, 0x9c, 0xa3, 0x38, 0x49, 0x71, 0x8c, 0xa2, 0xf8, 0xa6, 0xbc,
 0x28, 0xd2, 0x54, 0xce, 0xa3, 0xb8, 0x6c, 0x8e, 0xb6, 0x4f, 0xbb, 0x0c, 0xb2, 0x18, 0x99, 0x54,
 0x75, 0xb1, 0x69, 0xe2, 0xdc, 0x65, 0x26, 0xf9, 0x14, 0xfa, 0x62, 0x97, 0x1e, 0xa5, 0xcb, 0xca,
 0xf8, 0x78, 0x5b, 0x3b, 0xc4, 0xa9, 0x9b, 0x2c, 0x33, 0xb8, 0x89, 0x7c, 0xd7, 0x73, 0x86, 0x3a,
 0x3a, 0xf9, 0xe9, 0xe3, 0x95, 0xc6, 0x33, 0x31, 0x7e, 0xda, 0x51, 0x95, 0x32, 0x2a, 0xaa, 0x34,
 0xe1, 0x29, 0xce, 0x51, 0x84, 0x22, 0xb8, 0xca, 0x52, 0x7c, 0x12, 0x5e, 0x16, 0x57, 0xdb, 0x1c,
 0xff, 0x00, 0x2b, 0xd9, 0x6c, 0x8e, 0xb6, 0x6f, 0x9b, 0x56, 0xb7, 0x42, 0x9f, 0x44, 0x62, 0xba,
 0x65, 0x52, 0x6f, 0xaa, 0x11, 0x5d, 0xf6, 0xff, 0x00, 0xcd, 0xf4, 0x23, 0xe5, 0x6d, 0xe2, 0xef,
 0x17, 0x3e, 0xdb, 0x1c, 0x54, 0xe1, 0x5a, 0xb4, 0xb0, 0x99, 0x6a, 0x97, 0xd4, 0xb0, 0x54, 0xa5,
 0xe9, 0x78, 0x77, 0x9c, 0xdf, 0xd9, 0xbf, 0x67, 0xa3, 0xc0, 0x91, 0x5d, 0x5d, 0xce, 0x3a, 0x71,
 0xf9, 0xb6, 0xdc, 0x23, 0x82, 0xeb, 0xf1, 0x29, 0xbc, 0x7d, 0x18, 0x47, 0xae, 0x7f, 0x6f, 0x6b,
 0xdc, 0xb6, 0x97, 0x7a, 0xdb, 0x17, 0x93, 0x4e, 0x54, 0x96, 0x61, 0x2c, 0xc6, 0xbc, 0x7a, 0xe1,
 0x82, 0x8d, 0xc5, 0xf9, 0x6d, 0xa8, 0xfb, 0x8c, 0xe8, 0xf9, 0x96, 0xfe, 0x13, 0x93, 0x8e, 0x5f,
 0xb3, 0x9d, 0x1d, 0xe9, 0xd7, 0xc4, 0xfe, 0xea, 0x8f, 0xed, 0x3c, 0x48, 0x1e, 0x2c, 0xb7, 0xba,
 0xb3, 0xea, 0xf4, 0x3b, 0x8d, 0xbf, 0x92, 0xfb, 0x0d, 0x28, 0xfa, 0x71, 0x39, 0x4f, 0xe7, 0x3f,
 0xb5, 0x3d, 0x56, 0xb6, 0xfc, 0x76, 0x8e, 0x4f, 0xea, 0x59, 0x4e, 0x53, 0x05, 0xfd, 0x28, 0xd4,
 0x97, 0xef, 0xa2, 0x28, 0xef, 0xbb, 0x6a, 0x38, 0xfa, 0x7c, 0xb7, 0x26, 0x6b, 0x4a, 0x55, 0x17,
 0xef, 0x9e, 0x5e, 0x0a, 0x78, 0xad, 0x6e, 0xa7, 0xb6, 0x38, 0x26, 0xc2, 0x3f, 0xb5, 0x0f, 0x5a,
 0xc3, 0x6f, 0xc3, 0x34, 0x4d, 0x79, 0xe7, 0x22, 0xc1, 0x54, 0x5d, 0xfb, 0x75, 0x65, 0x0f, 0xd7,
 0xc4, 0xe7, 0xb2, 0xbd, 0xf5, 0x64, 0x55, 0xe4, 0xa3, 0x98, 0xe5, 0x78, 0xdc, 0x1b, 0x7f, 0x65,
 0x4e, 0x51, 0xab, 0x15, 0xec, 0xf5, 0x3f, 0x80, 0xf0, 0x70, 0x5f, 0x1d, 0xf6, 0xbe, 0x3f, 0x7b,
 0x16, 0xa7, 0x93, 0xdb, 0x0c, 0xe3, 0xea, 0x57, 0xba, 0x65, 0xf5, 0x96, 0x41, 0xb4, 0x19, 0x1e,
 0xd0, 0x52, 0x75, 0x32, 0x8c, 0xca, 0x86, 0x2b, 0x82, 0xe3, 0x28, 0x45, 0xf0, 0x9c, 0x56, 0xb1,
 0x7c, 0x1a, 0xf7, 0x0e, 0x4a, 0x50, 0x3e, 0x41, 0xc1, 0xe2, 0xb1, 0x38, 0x3c, 0x4d, 0x3c, 0x4e,
 0x12, 0xbd, 0x5a, 0x15, 0xe9, 0xbe, 0x30, 0xa9, 0x4e, 0x4e, 0x32, 0x8b, 0xd1, 0xa3, 0xdc, 0x37,
 0x53, 0xbc, 0xee, 0xeb, 0x57, 0xa5, 0x92, 0x6d, 0x14, 0xa1, 0x0c, 0x6c, 0xfd, 0x2e, 0x1f, 0x15,
 0xc3, 0x96, 0x35, 0x9f, 0xf1, 0x64, 0xba, 0x94, 0xbc, 0x0f, 0xa9, 0xf5, 0x75, 0xf5, 0xec, 0x76,
 0xdc, 0x42, 0x33, 0x9f, 0x37, 0x3f, 0x44, 0xb9, 0xae, 0x27, 0xe4, 0xee, 0xa6, 0xd7, 0x19, 0xd5,
 0xd0, 0x9f, 0x3b, 0x18, 0xf5, 0xc7, 0xdf, 0x1f, 0xbb, 0xd2, 0xa5, 0x02, 0x39, 0x53, 0x2f, 0x4a,
 0x1a, 0x11, 0xca, 0x99, 0xb3, 0x8c, 0x9c, 0xdc, 0x64, 0xa3, 0x2a, 0x64, 0x52, 0xa6, 0x5f, 0x94,
 0x34, 0x22, 0x95, 0x32, 0xf1, 0x92, 0xf1, 0x93, 0xa5, 0x63, 0xb6, 0xef, 0x64, 0xb0, 0x78, 0xda,
 0xf8, 0x3c, 0x4e, 0x6d, 0xc9, 0x5e, 0x85, 0x49, 0x53, 0xa9, 0x1f, 0x3b, 0xd5, 0x7c, 0xb2, 0x8b,
 0xe0, 0xd7, 0x15, 0x1e, 0x0f, 0xa5, 0x15, 0xe5, 0xbc, 0x3d, 0x8c, 0x7f, 0x76, 0x3f, 0x36, 0xad,
 0xf3, 0x4f, 0x17, 0xdb, 0x65, 0xc3, 0x6c, 0xf3, 0xc5, 0xeb, 0x8e, 0x23, 0xe5, 0x24, 0x70, 0xe6,
 0x93, 0x2e, 0x2d, 0xad, 0x8e, 0x53, 0x11, 0x11, 0xfe, 0x7f, 0x77, 0x77, 0xa3, 0xe4, 0xe6, 0xd7,
 0x3c, 0x31, 0xca, 0x72, 0xcb, 0xd3, 0x1e, 0xd8, 0xfd, 0x9e, 0xf9, 0x2d, 0xe0, 0xec, 0x73, 0xfb,
 0xb1, 0xf9, 0xb5, 0x5f, 0x9a, 0x72, 0xf9, 0x26, 0x6d, 0x96, 0xe7, 0x98, 0x39, 0xe2, 0xf2, 0xbc,
 0x4f, 0x9e, 0x28, 0xc2, 0xa3, 0xa7, 0x29, 0x72, 0x4a, 0x3c, 0x24, 0x92, 0x7c, 0x38, 0x49, 0x27,
 0xd4, 0xd1, 0xf3, 0x61, 0xed, 0x7b, 0x88, 0x8f, 0x1d, 0x8f, 0xc5, 0xbf, 0xeb, 0xf3, 0xf9, 0x3a,
 0x67, 0xab, 0x63, 0xc4, 0xb5, 0x75, 0xf5, 0x7c, 0xcc, 0xa2, 0x2b, 0xfe, 0xfe, 0x6f, 0x17, 0x14,
 0xe0, 0xfa, 0x1b, 0x3d, 0xbf, 0x37, 0x09, 0x99, 0x9b, 0x8f, 0x5d, 0x7e, 0xce, 0xe8, 0xe0, 0x71,
 0x99, 0xd6, 0x75, 0x95, 0x64, 0xf4, 0xd4, 0xf3, 0x2c, 0x75, 0x1c, 0x3f, 0x1e, 0x95, 0x16, 0xf8,
 0xca, 0x5e, 0xc4, 0x57, 0x4b, 0x3a, 0x66, 0xf0, 0x37, 0x8c, 0xa8, 0x55, 0xa9, 0x96, 0xec, 0xf4,
 0xe3, 0x2a, 0x91, 0x6e, 0x35, 0x31, 0x7c, 0x13, 0x49, 0xf8, 0x21, 0xe1, 0xf6, 0x7a, 0xbc, 0x1e,
 0x13, 0xca, 0xb1, 0x35, 0xeb, 0x62, 0x6b, 0xce, 0xbe, 0x22, 0xac, 0xeb, 0x55, 0x9b, 0xe3, 0x29,
 0xce, 0x4d, 0xca, 0x4f, 0x56, 0xcc, 0x9b, 0xae, 0x2f, 0x8e, 0x9c, 0xf9, 0xba, 0x71, 0x73, 0xfe,
 0x15, 0xe1, 0xfc, 0x07, 0x53, 0x5b, 0x18, 0xcf, 0x5a, 0x7c, 0xd8, 0xf6, 0x7d, 0xff, 0x00, 0xf0,
 0xf5, 0x9c, 0x7e, 0xf4, 0x32, 0x7a, 0x52, 0x71, 0xc1, 0xe0, 0x71, 0x78, 0x9e, 0x1f, 0x65, 0x2e,
 0x10, 0x8b, 0xf6, 0x3a, 0xdf, 0xc0, 0x50, 0x5b, 0xd5, 0xa7, 0xcd, 0xd3, 0x91, 0xc9, 0x2f, 0x0f,
 0x9e, 0xbf, 0xff, 0x00, 0x27, 0x98, 0x83, 0x59, 0x97, 0x16, 0xdd, 0x4c, 0xfa, 0x32, 0xaf, 0x84,
 0x37, 0xb8, 0xf0, 0x3d, 0x9e, 0x31, 0x53, 0x8d, 0xfc, 0x65, 0xeb, 0xf9, 0x7e, 0xf2, 0xf2, 0x3a,
 0xf2, 0x50, 0xc5, 0xd0, 0xc5, 0x61, 0x1b, 0xeb, 0x93, 0x8a, 0x9c, 0x57, 0xb9, 0xd3, 0xf0, 0x1d,
 0xb7, 0x2d, 0xcc, 0x30, 0x39, 0x96, 0x1f, 0xcf, 0x18, 0x0c, 0x55, 0x2c, 0x45, 0x3e, 0xfb, 0x84,
 0xb8, 0xf0, 0xd1, 0xae, 0xb4, 0xfd, 0x93, 0xe7, 0x32, 0xde, 0x55, 0x98, 0xe3, 0x72, 0xbc, 0x64,
 0x71, 0x78, 0x0c, 0x44, 0xe8, 0x56, 0x8f, 0x7e, 0x2f, 0xa1, 0xaf, 0x03, 0x5d, 0x4d, 0x68, 0xcf,
 0x4e, 0x87, 0x1a, 0xd5, 0xc6, 0x6b, 0x56, 0x2e, 0x3f, 0xcb, 0xcb, 0xb9, 0xf2, 0x7f, 0x47, 0x28,
 0xbd, 0x19, 0xa9, 0xfc, 0xfd, 0x31, 0xfb, 0xbe, 0x89, 0x68, 0xc3, 0x89, 0xd7, 0xb6, 0x17, 0x6a,
 0xa8, 0x6d, 0x1e, 0x11, 0xc2, 0xa4, 0x63, 0x47, 0x1f, 0x46, 0x2a, 0xed, 0x35, 0xd5, 0x25, 0xfc,
 0x68, 0xe9, 0xfa, 0x8e, 0x73, 0x33, 0xc6, 0x61, 0x72, 0xec, 0x15, 0x5c, 0x66, 0x32, 0xb4, 0x68,
 0xd0, 0xa6, 0xb8, 0xca, 0x52, 0xfd, 0x5a, 0xbd, 0x0e, 0x87, 0x4f, 0x5f, 0x0d, 0x4c, 0x39, 0x98,
 0xcf, 0xa1, 0xcb, 0x6a, 0xe8, 0x6a, 0x69, 0x6a, 0x72, 0xb2, 0x8f, 0xa4, 0xdd, 0xa3, 0xaf, 0xe7,
 0x5b, 0x5b, 0x90, 0xe5, 0x52, 0x95, 0x3a, 0xf8, 0xd5, 0x56, 0xb4, 0x7a, 0xe9, 0x51, 0x5c, 0xf2,
 0xf6, 0x1f, 0x0e, 0x84, 0xfd, 0x96, 0x79, 0xe6, 0xd8, 0x6d, 0xc6, 0x3f, 0x38, 0x9c, 0xf0, 0xd8,
 0x29, 0x4f, 0x07, 0x80, 0xea, 0xe5, 0x8b, 0xe1, 0x3a, 0x8b, 0xfa, 0x4d, 0x7e, 0xa5, 0xf0, 0x9d,
 0x44, 0xd3, 0x6e, 0xb8, 0xdf, 0x9b, 0x3e, 0x6e, 0x8c, 0x5f, 0xe7, 0x2e, 0x87, 0x67, 0xc0, 0x27,
 0x28, 0xf3, 0xb5, 0xe6, 0xbf, 0x28, 0xfd, 0x65, 0xe9, 0xd8, 0x9d, 0xe6, 0xe0, 0xd4, 0xbf, 0xee,
 0xf9, 0x55, 0x7a, 0x91, 0xf0, 0xd4, 0xaa, 0xa0, 0xfe, 0x04, 0xc8, 0xa9, 0xef, 0x36, 0x8b, 0x7f,
 0x54, 0xc9, 0xea, 0x45, 0x7f, 0x47, 0x10, 0x9f, 0xee, 0xa3, 0xcd, 0x81, 0xaf, 0xfe, 0x2f, 0xbb,
 0xbf, 0xad, 0xfe, 0x21, 0xb5, 0x8e, 0x0d, 0xb3, 0x88, 0xaf, 0x37, 0xfc, 0xcf, 0xee, 0xf5, 0xfc,
 0xbb, 0x6f, 0xb2, 0x0c, 0x5c, 0x94, 0x2a, 0xce, 0xbe, 0x12, 0x4f, 0xf9, 0x68, 0x7a, 0x5f, 0x76,
 0x3c, 0x7e, 0x1e, 0x07, 0x66, 0xa1, 0x56, 0x8e, 0x22, 0x8c, 0x6b, 0x61, 0xea, 0xc2, 0xad, 0x39,
 0x2e, 0x31, 0x9c, 0x24, 0x9a, 0x7e, 0xda, 0x3e, 0x7a, 0x39, 0x3c, 0x83, 0x3c, 0xcc, 0x72, 0x4c,
 0x4a, 0xad, 0x82, 0xac, 0xd4, 0x5b, 0xf4, 0xf4, 0xa5, 0xd3, 0x09, 0xfb, 0x2b, 0xf6, 0xf5, 0x9e,
 0xdd, 0xbf, 0x1d, 0xce, 0x26, 0xb5, 0xa2, 0xe3, 0xdb, 0x0f, 0x0e, 0xe7, 0x80, 0xe1, 0x31, 0x7a,
 0x33, 0x53, 0xec, 0x97, 0xba, 0x38, 0x9a, 0xb4, 0x71, 0xfb, 0x2f, 0x9e, 0x61, 0x33, 0xfc, 0xb9,
 0x62, 0x70, 0xfe, 0x92, 0xa4, 0x7a, 0x2b, 0x52, 0x6f, 0xa6, 0x12, 0xfd, 0xab, 0xc0, 0xce, 0x51,
 0xa3, 0xa4, 0xd3, 0xd4, 0xc7, 0x53, 0x18, 0xcb, 0x19, 0xb8, 0x97, 0x35, 0xa9, 0x86, 0x5a, 0x79,
 0x4e, 0x19, 0xc5, 0x4c, 0x22, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x56, 0x8c, 0x96, 0xad, 0xa1, 0x68,
 0xc3, 0x44, 0xae, 0x26, 0x1a, 0x26, 0xd3, 0x68, 0x5c, 0x48, 0x31, 0x98, 0x8c, 0x3e, 0x12, 0x84,
 0xab, 0xe2, 0xab, 0x53, 0xa3, 0x4d, 0x75, 0xca, 0x72, 0xe0, 0x8e, 0x1b, 0x6c, 0x36, 0xa7, 0x0d,
 0x92, 0x45, 0xe1, 0xe8, 0xa8, 0xd7, 0xc7, 0x35, 0xc5, 0x53, 0xe3, 0xe9, 0x61, 0xac, 0xbb, 0x0f,
 0x2e, 0xcd, 0x73, 0x3c, 0x76, 0x69, 0x89, 0x78, 0x8c, 0x76, 0x22, 0x55, 0x67, 0xde, 0x4f, 0xeb,
 0x62, 0xbc, 0x09, 0x75, 0x23, 0x55, 0xbe, 0xe2, 0xfa, 0x7b, 0x69, 0xf3, 0x31, 0xfa, 0x59, 0x7f,
 0x88, 0x6e, 0x36, 0x3c, 0x2b, 0x53, 0x71, 0x1e, 0x7e, 0x5e, 0x8c, 0x7e, 0x6f, 0x40, 0xcc, 0xb6,
 0xef, 0x2a, 0xa1, 0x27, 0x0c, 0x25, 0x2a, 0xd8, 0xb9, 0x2e, 0xfa, 0x5c, 0x91, 0x7e, 0xdb, 0xe9,
 0xf8, 0x0e, 0x1a, 0xbe, 0xf0, 0x31, 0xd2, 0x7f, 0x51, 0xcb, 0xf0, 0xd0, 0x5f, 0xd3, 0x94, 0xa5,
 0xfa, 0xb8, 0x1d, 0x30, 0x1c, 0xfe, 0xa7, 0x19, 0xdd, 0xe7, 0x3e, 0x8c, 0xab, 0xdd, 0x0d, 0xf6,
 0x9f, 0x09, 0xda, 0xe1, 0x1f, 0x56, 0xfd, 0xee, 0xdc, 0xb6, 0xfb, 0x35, 0xe3, 0xe9, 0xb0, 0x98,
 0x26, 0xb4, 0x8c, 0x97, 0xef, 0x16, 0xb0, 0xdb, 0xc0, 0x97, 0x14, 0xb1, 0x39, 0x6c, 0x5a, 0xef,
 0xba, 0x75, 0x78, 0x7c, 0x0d, 0x7e, 0xd3, 0xa3, 0x82, 0x98, 0xf1, 0x6d, 0xe6, 0x33, 0xe8, 0xcf,
 0xe4, 0xc9, 0x97, 0x0c, 0xda, 0xe5, 0xfd, 0x1f, 0x37, 0xaa, 0xe5, 0xbb, 0x57, 0x92, 0xe3, 0x9a,
 0x87, 0x9e, 0x1e, 0x1a, 0xa3, 0xfb, 0x1a, 0xeb, 0x97, 0xe1, 0xea, 0xf8, 0x4e, 0x73, 0x82, 0x69,
 0x34, 0xd3, 0x4f, 0xa9, 0x9e, 0x1c, 0x73, 0x39, 0x06, 0xd1, 0xe6, 0x19, 0x44, 0xd4, 0x69, 0xcd,
 0xd6, 0xc3, 0xf7, 0xe8, 0xcd, 0xf4, 0x7b, 0x5e, 0x06, 0x6d, 0xb6, 0x9e, 0x50, 0x4d, 0xf9, 0xba,
 0xf1, 0xf1, 0x8f, 0xd9, 0xad, 0xdc, 0xf0, 0x58, 0xab, 0xd1, 0x9f, 0x84, 0xfe, 0xef, 0x56, 0x68,
 0xc3, 0x45, 0x6c, 0x93, 0x35, 0xc1, 0xe7, 0x18, 0x45, 0x88, 0xc2, 0x4f, 0x8f, 0x0e, 0x89, 0xc1,
 0xfd, 0x74, 0x1f, 0x81, 0x97, 0x5c, 0x4e, 0x9b, 0x4f, 0x53, 0x1d, 0x4c, 0x63, 0x2c, 0x66, 0xe2,
 0x5a, 0x1c, 0xb1, 0xcb, 0x0c, 0xa7, 0x1c, 0xa2, 0xa6, 0x10, 0xb4, 0x61, 0xa2, 0x56, 0x8d, 0x5c,
 0x4c, 0x96, 0x8b, 0x44, 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x13, 0x69, 0xb4, 0x2d, 0x18, 0x68,
 0x99, 0xa3, 0x57, 0x12, 0xd6, 0xb4, 0x4a, 0x16, 0x8c, 0x34, 0x4a, 0xe2, 0x6a, 0xd1, 0x31, 0x29,
 0xb4, 0x4d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xd1, 0x36, 0xb5, 0xa1, 0x71, 0x3c, 0xc3, 0x32, 0xc7,
 0xe3, 0x31, 0x95, 0xa5, 0xe7, 0x9c, 0x44, 0xea, 0x25, 0x27, 0xc2, 0x3c, 0x78, 0x45, 0x7b, 0x5d,
 0x47, 0xa9, 0xb4, 0x79, 0x1d, 0x6f, 0xf5, 0xd3, 0xfe, 0xd3, 0x39, 0x8f, 0x29, 0xb5, 0x32, 0x8c,
 0x34, 0xf1, 0x89, 0xf4, 0x4d, 0xfe, 0x8d, 0xdf, 0x06, 0x88, 0x99, 0xca, 0x66, 0x3d, 0x55, 0xfa,
 0xb4, 0x00, 0x1c, 0x83, 0x7c, 0x1b, 0x38, 0x4d, 0x42, 0x33, 0x71, 0x6a, 0x32, 0x6d, 0x27, 0xc3,
 0xa1, 0xb5, 0xd7, 0xfa, 0xd1, 0xcf, 0x6c, 0xfe, 0xce, 0x56, 0xc6, 0x4a, 0x38, 0x8c, 0x64, 0x65,
 0x4b, 0x0f, 0xd6, 0x93, 0xe8, 0x94, 0xfb, 0x16, 0xa5, 0x9d, 0xbb, 0xa3, 0x4e, 0x85, 0x2c, 0xbe,
 0x95, 0x28, 0x46, 0x10, 0x8a, 0xa8, 0xa3, 0x14, 0xba, 0x17, 0xd6, 0x9b, 0x38, 0xe1, 0x7a, 0xb1,
 0xb5, 0xcb, 0x73, 0x9f, 0xa2, 0x22, 0xaa, 0x3d, 0xb7, 0x31, 0x1d, 0x9e, 0x4f, 0x19, 0x84, 0xeb,
 0x46, 0x96, 0x3e, 0x99, 0x75, 0x60, 0x01, 0xac, 0x7a, 0xc3, 0xd3, 0x1a, 0x3c, 0xcc, 0xf5, 0x07,
 0x13, 0xaf, 0xf2, 0x57, 0xfb, 0xbf, 0xed, 0xfd, 0x5a, 0x6e, 0x2f, 0x3f, 0x53, 0xe3, 0xfa, 0x22,
 0x71, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8e, 0xbe, 0xda, 0x7b, 0x42, 0xd1, 0x87, 0x12, 0x56, 0x8c,
 0x34, 0x5a, 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0x6d, 0x6b, 0x44, 0xd1, 0xab,
 0x89, 0x2b, 0x89, 0x86, 0x8b, 0x5a, 0x6d, 0x0b, 0x46, 0x38, 0x12, 0xb4, 0x61, 0xc4, 0x9b, 0x5a,
 0xd1, 0x70, 0x30, 0x48, 0xd1, 0xab, 0x44, 0xda, 0x6d, 0xa8, 0x32, 0xd1, 0x82, 0x47, 0xd5, 0x70,
 0xaa, 0x4b, 0x0a, 0xba, 0x9c, 0x6c, 0x2a, 0x12, 0xc6, 0xae, 0xa7, 0xe6, 0xbb, 0x4c, 0x64, 0xe4,
 0xe1, 0x54, 0x9a, 0x15, 0x75, 0x38, 0xb8, 0xd5, 0x26, 0x8d, 0x5d, 0x4b, 0x5a, 0xf1, 0x93, 0x93,
 0x85, 0x52, 0x68, 0x55, 0x38, 0xc8, 0x55, 0x25, 0x85, 0x5d, 0x49, 0xb5, 0xe3, 0x27, 0x29, 0x0a,
 0xba, 0x93, 0xc2, 0xae, 0xa7, 0x15, 0x0a, 0xa4, 0xd0, 0xab, 0xa9, 0x36, 0xc9, 0x19, 0x39, 0x58,
 0x56, 0xd4, 0x9e, 0x9d, 0x6d, 0x4e, 0x26, 0x15, 0x75, 0x26, 0x85, 0x6d, 0x4b, 0x5a, 0xf1, 0x93,
 0x97, 0x85, 0x6d, 0x49, 0xe9, 0xd6, 0xd4, 0xe1, 0xe1, 0x5b, 0x52, 0x78, 0x56, 0xd4, 0x9b, 0x64,
 0x8c, 0xdf, 0x2c, 0x79, 0xb4, 0xa5, 0xcf, 0xbd, 0x2c, 0xb1, 0xfa, 0xc9, 0x4b, 0xe5, 0xeb, 0x9e,
 0x1c, 0x7b, 0x5f, 0x9b, 0x1e, 0x5c, 0xdb, 0xcd, 0xcb, 0x5f, 0xac, 0xb4, 0xbe, 0x5a, 0xb9, 0xe2,
 0x87, 0x41, 0xb6, 0xfb, 0x2c, 0x5b, 0x4d, 0x19, 0xbc, 0x20, 0x00, 0x19, 0xd9, 0x1f, 0xaa, 0x54,
 0xb1, 0x1a, 0x96, 0xe9, 0x62, 0x75, 0x3f, 0x32, 0xd6, 0xf1, 0xf7, 0x84, 0xba, 0xb6, 0xf3, 0x6a,
 0x7f, 0xf9, 0x7a, 0xff, 0x00, 0x3c, 0xca, 0xde, 0x46, 0xf1, 0x17, 0x56, 0xde, 0xed, 0x57, 0xff,
 0x00, 0x2f, 0x88, 0xf9, 0xe6, 0xb3, 0xc0, 0xe5, 0xed, 0x62, 0x8c, 0x26, 0x3e, 0xf7, 0xe9, 0xf5,
 0x1c, 0x5f, 0x0e, 0xf9, 0x7e, 0x86, 0x39, 0xae, 0x8e, 0x3d, 0x07, 0xe5, 0x9a, 0xde, 0x5e, 0xf1,
 0x97, 0x56, 0xdf, 0xed, 0x5f, 0xff, 0x00, 0x31, 0x88, 0xf9, 0xe6, 0xcb, 0x79, 0xbb, 0xc9, 0x5d,
 0x5b, 0xc1, 0xda, 0xc5, 0xff, 0x00, 0xbc, 0xe2, 0x3e, 0x79, 0x68, 0xd9, 0x65, 0xed, 0x64, 0x8b,
 0x87, 0xea, 0xac, 0x2b, 0xd1, 0xa8, 0xb8, 0x49, 0x70, 0x62, 0xa6, 0x1e, 0x33, 0x5c, 0x63, 0xc1,
 0xfb, 0x07, 0xe5, 0x5a, 0xde, 0x86, 0xf2, 0xd7, 0x56, 0xf1, 0x36, 0xb9, 0x7f, 0xef, 0x58, 0x8f,
 0x9e, 0x6c, 0xb7, 0xa9, 0xbc, 0xf8, 0xf5, 0x6f, 0x1f, 0x6c, 0x17, 0xb1, 0x9d, 0xe2, 0x7e, 0x79,
 0x78, 0xda, 0xe7, 0x1f, 0x79, 0x38, 0xc6, 0x5e, 0xb8, 0x7e, 0xa3, 0xd6, 0xc2, 0x68, 0x53, 0xad,
 0x84, 0xd0, 0xfc, 0xc5, 0x7b, 0xd5, 0xde, 0x83, 0xeb, 0xde, 0x46, 0xd8, 0xbf, 0xfd, 0xef, 0x13,
 0xf3, 0xcf, 0xa6, 0xbc, 0xc0, 0xdb, 0x53, 0xb5, 0x3b, 0x51, 0x9f, 0x6d, 0x5d, 0x2d, 0xa3, 0xda,
 0x7c, 0xe7, 0x39, 0x85, 0x0c, 0x2e, 0x1e, 0x54, 0x63, 0x98, 0x63, 0xea, 0xd7, 0x54, 0xdb, 0x9c,
 0xf8, 0xb8, 0xa9, 0xc9, 0xf0, 0x6f, 0x82, 0xea, 0x2d, 0x96, 0x9e, 0x5a, 0x78, 0xdc, 0xcb, 0xcb,
 0xa9, 0xb4, 0xc7, 0x2f, 0x53, 0xe9, 0x3a, 0xd8, 0x4d, 0x0a, 0x75, 0x70, 0xba, 0x1d, 0xaa, 0xb6,
 0x13, 0x42, 0x9d, 0x6c, 0x26, 0x84, 0x61, 0xac, 0xd5, 0xeb, 0xf0, 0xff, 0x00, 0xc9, 0xd5, 0xea,
 0x50, 0x6b, 0xbc, 0x75, 0x0d, 0xef, 0xd2, 0xe1, 0xba, 0x9d, 0xaf, 0x7c, 0x3a, 0xb2, 0x3c, 0x6f,
 0xc8, 0x4c, 0xf4, 0xaa, 0xd8, 0x4d, 0x0e, 0x93, 0xbe, 0x7c, 0x37, 0x2e, 0xe8, 0xf6, 0xca, 0x5c,
 0x3a, 0xb2, 0x1c, 0x73, 0xfc, 0xde, 0x67, 0xa3, 0x1d, 0x5b, 0x6b, 0xbc, 0x14, 0xe3, 0xa9, 0x13,
 0xf9, 0xbf, 0x34, 0x80, 0x06, 0x57, 0x60, 0x1d, 0xa3, 0x6e, 0xf6, 0xc7, 0x1b, 0xb5, 0x18, 0x7c,
 0x8f, 0x03, 0x53, 0x9a, 0x96, 0x07, 0x26, 0xcb, 0x30, 0xf8, 0x2c, 0x3d, 0x1e, 0x3d, 0x1c, 0xd0,
 0xa7, 0x18, 0xd4, 0x9b, 0xd6, 0x52, 0x8f, 0xb8, 0xa2, 0x8e, 0xae, 0x02, 0x99, 0x69, 0xe3, 0x96,
 0x51, 0x94, 0xc7, 0xa6, 0x3d, 0x40, 0x39, 0x6d, 0x95, 0xd9, 0xac, 0xfb, 0x6a, 0x73, 0x35, 0x96,
 0xec, 0xfe, 0x57, 0x89, 0xcc, 0x31, 0x4d, 0x71, 0x71, 0xa5, 0x1e, 0x88, 0x2f, 0x0c, 0xa4, 0xfa,
 0x22, 0xb5, 0x6d, 0x23, 0xd4, 0xf0, 0x9e, 0x66, 0x9d, 0xe2, 0xd6, 0xc3, 0xaa, 0xb5, 0x6b, 0x64,
 0x78, 0x59, 0xb5, 0xc6, 0xd5, 0x5c, 0x54, 0xdc, 0x96, 0x9e, 0x92, 0x12, 0x5f, 0x09, 0x31, 0x13,
 0x2c, 0x3a, 0xdb, 0xcd, 0x0d, 0x09, 0xad, 0x4c, 0xe2, 0x1e, 0x2c, 0x73, 0x9b, 0x03, 0x91, 0x54,
 0xda, 0x6d, 0xb2, 0xca, 0xb2, 0x2a, 0x6a, 0x5c, 0x31, 0x78, 0x98, 0xc2, 0xa3, 0x5d, 0x71, 0xa6,
 0xba, 0x66, 0xfd, 0xa8, 0xa9, 0x3f, 0x68, 0xec, 0x1b, 0x69, 0xba, 0x2d, 0xbe, 0xd9, 0x3a, 0x13,
 0xc5, 0x66, 0x39, 0x1d, 0x4a, 0xf8, 0x38, 0x2e, 0x32, 0xc4, 0xe0, 0xe4, 0xab, 0x42, 0x2b, 0xc2,
 0xf9, 0x7d, 0x34, 0x56, 0xb2, 0x49, 0x1e, 0x83, 0xe6, 0x3a, 0xd9, 0xa7, 0x8b, 0xcf, 0x73, 0x5d,
 0xa8, 0xad, 0x4f, 0x8d, 0x3c, 0x15, 0x25, 0x85, 0xc3, 0xb6, 0xba, 0x2e, 0x4f, 0xa6, 0x4d, 0x6a,
 0xa2, 0x92, 0xff, 0x00, 0x9c, 0x9c, 0x71, 0xbc, 0xaa, 0x5e, 0x5d, 0xee, 0xff, 0x00, 0x4f, 0x4f,
 0x67, 0x9e, 0xb6, 0x96, 0x51, 0x35, 0x1e, 0x8a, 0xf6, 0xcf, 0xa9, 0xf4, 0x44, 0x30, 0xd0, 0xa3,
 0x4a, 0x14, 0xa9, 0x41, 0x42, 0x10, 0x8a, 0x8c, 0x62, 0x97, 0x42, 0x4b, 0xa9, 0x11, 0xd5, 0x8a,
 0x84, 0x5c, 0xa4, 0xd4, 0x62, 0x97, 0x16, 0xdb, 0xe0, 0x92, 0x39, 0x59, 0xd2, 0xd0, 0xf2, 0xff,
 0x00, 0x34, 0x96, 0xd0, 0xcb, 0x66, 0xf7, 0x69, 0x8a, 0xa7, 0x42, 0x7c, 0x98, 0xbc, 0xce, 0x6b,
 0x05, 0x49, 0xa7, 0xd2, 0xa3, 0x24, 0xdc, 0xdf, 0xe4, 0xa6, 0xbd, 0x99, 0x23, 0xdf, 0xcc, 0xa8,
 0xb7, 0xc9, 0xb4, 0x36, 0x19, 0xee, 0x75, 0xf1, 0xd2, 0xc7, 0xd7, 0x94, 0xd3, 0xe7, 0x4d, 0xf5,
 0x6d, 0xbd, 0x5d, 0xb2, 0xda, 0xca, 0xb2, 0xc3, 0xd5, 0x97, 0x72, 0x70, 0x72, 0x95, 0x2c, 0x14,
 0x38, 0xf4, 0x49, 0x71, 0xe9, 0xa8, 0xf5, 0x97, 0x0f, 0x73, 0x82, 0x3a, 0x20, 0x06, 0xbf, 0x2c,
 0xa7, 0x29, 0xb9, 0x7d, 0x97, 0x6b, 0xb6, 0xd3, 0xda, 0xe9, 0x63, 0xa3, 0xa7, 0x15, 0x10, 0x00,
 0x7b, 0x9e, 0xe9, 0xb7, 0x25, 0x4f, 0x34, 0xcb, 0x28, 0x67, 0x9b, 0x5b, 0x3a, 0xf4, 0xe8, 0xd7,
 0x8a, 0x9d, 0x0c, 0x0d, 0x37, 0xc9, 0x29, 0x41, 0xf5, 0x4a, 0x72, 0xeb, 0x5c, 0x7a, 0xf8, 0x2e,
 0x0f, 0xab, 0xa7, 0xbc, 0x5b, 0x0c, 0x27, 0x39, 0xa8, 0x60, 0xdf, 0xf1, 0x1d, 0x0d, 0x86, 0x97,
 0x33, 0x5e, 0x6a, 0x3e, 0xef, 0x6c, 0xfb, 0x9e, 0x18, 0x0f, 0xb3, 0xf0, 0x7b, 0xb9, 0xd8, 0x7c,
 0x1d, 0x35, 0x4e, 0x8e, 0xca, 0xe5, 0x52, 0x8a, 0xef, 0xd6, 0xc3, 0xaa, 0xaf, 0xdd, 0x9f, 0x16,
 0x6b, 0x8c, 0xdd, 0xee, 0xc4, 0xe2, 0x60, 0xe3, 0x53, 0x65, 0xb2, 0x98, 0xa7, 0xfc, 0x96, 0x1a,
 0x34, 0xdf, 0xbb, 0x1e, 0x07, 0xa3, 0xc2, 0x65, 0xed, 0x73, 0x7f, 0xfe, 0x69, 0xb6, 0xbf, 0xb3,
 0xca, 0xbe, 0x0f, 0x8c, 0x81, 0xf4, 0x46, 0xf0, 0xb7, 0x1b, 0x95, 0xd5, 0xcb, 0xeb, 0x63, 0x76,
 0x4e, 0xee, 0x17, 0x19, 0x4e, 0x2e, 0x4b, 0x09, 0x3a, 0x8e, 0x74, 0xea, 0xf0, 0xfb, 0x18, 0xb9,
 0x74, 0xc5, 0xf8, 0x38, 0xb6, 0xbd, 0x8e, 0xb3, 0xe7, 0x99, 0xc6, 0x50, 0x9c, 0xa1, 0x38, 0xb8,
 0xca, 0x2f, 0x83, 0x4d, 0x70, 0x69, 0xf8, 0x0c, 0x1a, 0x9a, 0x59, 0x69, 0xcd, 0x4b, 0xa1, 0xe1,
 0xdc, 0x53, 0x6f, 0xc4, 0x70, 0x9c, 0xf4, 0x67, 0xd5, 0xeb, 0x89, 0xf5, 0xc3, 0x53, 0x31, 0x93,
 0x8c, 0x94, 0xa2, 0xda, 0x92, 0x7c, 0x53, 0x4f, 0xa5, 0x18, 0x06, 0x36, 0xc5, 0xf5, 0x46, 0xea,
 0x33, 0xe9, 0xed, 0x36, 0xc4, 0xe1, 0x31, 0xd5, 0xe5, 0xcf, 0x8b, 0xa4, 0xde, 0x1f, 0x12, 0xfc,
 0x33, 0x8f, 0x0e, 0x9f, 0x65, 0xa7, 0x17, 0xed, 0x9d, 0xa2, 0x54, 0xcf, 0x20, 0xf3, 0x2e, 0xe2,
 0xdc, 0xe8, 0x67, 0x99, 0x74, 0x9f, 0x44, 0x65, 0x4a, 0xb4, 0x17, 0xb2, 0xa5, 0x19, 0x7e, 0xa8,
 0x9e, 0xd3, 0x2a, 0x67, 0x43, 0xb6, 0xd5, 0x9c, 0xf4, 0xa2, 0x65, 0xf2, 0x7e, 0x31, 0xa1, 0x1b,
 0x6d, 0xee, 0xa6, 0x9e, 0x3e, 0xab, 0xb8, 0xf8, 0xfa, 0x54, 0x25, 0x02, 0x39, 0x53, 0x2f, 0x4a,
 0x04, 0x72, 0xa6, 0x7a, 0x63, 0x26, 0xbe, 0x32, 0x7c, 0x8f, 0xb7, 0x3d, 0x1b, 0x6d, 0x9e, 0xaf,
 0x5c, 0xb1, 0x1f, 0x29, 0x23, 0x86, 0x39, 0xad, 0xbc, 0xe8, 0xdb, 0x8c, 0xf9, 0x7a, 0xe5, 0x88,
 0xf9, 0x59, 0x1c, 0x29, 0xcc, 0x6a, 0x7d, 0x79, 0x7d, 0x8b, 0x6d, 0xf6, 0x38, 0x7b, 0xa3, 0xe4,
 0x1d, 0x87, 0x03, 0xb5, 0x18, 0xbc, 0x06, 0xc6, 0x56, 0xd9, 0xec, 0x17, 0x35, 0x27, 0x89, 0xc5,
 0x4e, 0xad, 0x7a, 0xc9, 0xf0, 0x6e, 0x0e, 0x10, 0x8a, 0x82, 0xf6, 0x79, 0x5f, 0x1d, 0x3a, 0x3c,
 0x27, 0x5e, 0x04, 0x61, 0x9e, 0x58, 0x7d, 0x59, 0x5b, 0x53, 0x4b, 0x0d, 0x58, 0x88, 0xce, 0x2e,
 0xa6, 0xc0, 0x73, 0x1b, 0x29, 0xb3, 0x79, 0xae, 0xd2, 0xe6, 0x3e, 0x73, 0xcb, 0x28, 0x73, 0x72,
 0xf4, 0xd5, 0xab, 0x3e, 0x88, 0x52, 0x5e, 0x19, 0x3f, 0xd9, 0xd6, 0xcf, 0x5b, 0xc9, 0x77, 0x43,
 0x91, 0x61, 0x69, 0x45, 0xe6, 0x78, 0x8c, 0x4e, 0x3e, 0xb7, 0x0f, 0x4c, 0xa3, 0x2b, 0x74, 0xfd,
 0xa4, 0xba, 0x7e, 0x13, 0x3e, 0x86, 0xd3, 0x57, 0x5f, 0xd3, 0x8c, 0x7a, 0x1e, 0x1d, 0xef, 0x16,
 0xdb, 0x6c, 0xe7, 0xcd, 0xd4, 0x9f, 0x4f, 0xb2, 0x3d, 0x6f, 0x0c, 0x07, 0xd0, 0x58, 0xbd, 0xd7,
 0xec, 0x85, 0x5a, 0x4e, 0x14, 0xf0, 0x35, 0xb0, 0xf2, 0x6b, 0xeb, 0xe9, 0xe2, 0x26, 0xda, 0xfc,
 0xa6, 0xd7, 0xc0, 0x79, 0x56, 0xf0, 0xf6, 0x2b, 0x15, 0xb2, 0xb5, 0xe1, 0x56, 0x15, 0x5e, 0x27,
 0x2f, 0xad, 0x2e, 0x5a, 0x75, 0x9c, 0x78, 0x38, 0xcb, 0xaf, 0x96, 0x5a, 0xf0, 0xef, 0xf7, 0xf8,
 0x33, 0x26, 0xbe, 0xc3, 0x57, 0x47, 0x1f, 0x3a, 0x7d, 0x31, 0xf9, 0x31, 0x6c, 0xf8, 0xd6, 0xd7,
 0x77, 0x9f, 0x2f, 0x09, 0x98, 0x9f, 0xcf, 0xfe, 0xcb, 0xa9, 0x00, 0x0f, 0x13, 0x6e, 0xb9, 0x92,
 0xe6, 0x58, 0x9c, 0xa7, 0x34, 0xa1, 0x98, 0x61, 0x65, 0xc2, 0xad, 0x19, 0x71, 0xe1, 0xde, 0x92,
 0xef, 0xc5, 0xe8, 0xd7, 0x41, 0xcc, 0x6d, 0xce, 0xd4, 0xd7, 0xda, 0x3c, 0x6c, 0x79, 0x54, 0xe8,
 0xe0, 0xa9, 0x7f, 0xaa, 0xa2, 0xdf, 0x7f, 0xbf, 0x29, 0x6b, 0xfa, 0xbd, 0xd3, 0xad, 0x83, 0x2c,
 0x6b, 0x67, 0x8e, 0x9c, 0xe9, 0xc4, 0xfa, 0x25, 0x87, 0x2d, 0xbe, 0x9e, 0x5a, 0xb1, 0xab, 0x31,
 0xf4, 0xa3, 0xef, 0x01, 0xcd, 0xec, 0xa6, 0xcc, 0x66, 0x5b, 0x47, 0x89, 0x70, 0xc1, 0xc1, 0x42,
 0x84, 0x1f, 0xd5, 0x6b, 0xcf, 0xeb, 0x21, 0xa6, 0xaf, 0x43, 0xd2, 0xf2, 0xcd, 0xda, 0x64, 0x18,
 0x6a, 0x49, 0x63, 0x1e, 0x23, 0x1b, 0x53, 0x87, 0xa6, 0x72, 0x9b, 0x84, 0x7d, 0xa5, 0x1e, 0x95,
 0xee, 0xb3, 0xd1, 0xb6, 0xd8, 0x6b, 0x6e, 0x22, 0xf1, 0x8f, 0x47, 0xb6, 0x5e, 0x4d, 0xdf, 0x15,
 0xdb, 0xed, 0x67, 0xcd, 0xce, 0x6e, 0x7d, 0x90, 0xf1, 0x90, 0x7b, 0x46, 0x63, 0xbb, 0x6d, 0x9d,
 0xc4, 0x52, 0x6b, 0x0d, 0x0c, 0x46, 0x0e, 0x7d, 0xe9, 0x42, 0xab, 0x92, 0xf6, 0xd4, 0xb8, 0x9e,
 0x5d, 0xb5, 0x59, 0x06, 0x37, 0x67, 0xb3, 0x1f, 0x3a, 0x62, 0xd2, 0x9c, 0x64, 0xb9, 0xa9, 0x55,
 0x8a, 0xf4, 0xb5, 0x17, 0x6f, 0x85, 0x0d, 0xce, 0xc3, 0x5b, 0x6f, 0x1e, 0x76, 0x51, 0xe8, 0xf6,
 0xc1, 0xb3, 0xe2, 0x9b, 0x7d, 0xdc, 0xf9, 0xb8, 0x4d, 0x4f, 0xb2, 0x5c, 0x40, 0x00, 0xf1, 0x36,
 0x2e, 0x67, 0x63, 0x73, 0xaa, 0x99, 0x1e, 0x79, 0x47, 0x15, 0xcc, 0xec, 0x4d, 0xf2, 0x57, 0x8a,
 0xef, 0xc1, 0xf7, 0xfd, 0x95, 0xd7, 0xed, 0x1e, 0xe7, 0x17, 0x19, 0x45, 0x4a, 0x2d, 0x38, 0xb5,
 0xc5, 0x35, 0xdf, 0x47, 0xce, 0x67, 0xba, 0x6c, 0x0e, 0x29, 0xe3, 0x76, 0x43, 0x2e, 0xab, 0x27,
 0xc6, 0x51, 0xa5, 0x6d, 0xff, 0x00, 0xc8, 0xdc, 0x7f, 0x52, 0x47, 0x43, 0xc0, 0xb7, 0x13, 0x79,
 0x69, 0x4f, 0xbe, 0x1c, 0xcf, 0x94, 0x3b, 0x78, 0x88, 0xc7, 0x5a, 0x3d, 0x7e, 0xa9, 0xfd, 0x1c,
 0xc3, 0x89, 0xab, 0x44, 0xce, 0x26, 0xae, 0x27, 0x49, 0x6e, 0x66, 0xd0, 0xb8, 0x9d, 0x6f, 0x6e,
 0xb6, 0x86, 0x39, 0x16, 0x5e, 0xa3, 0x45, 0xa9, 0x63, 0x6b, 0xa6, 0xa8, 0xc7, 0xaf, 0x95, 0x77,
 0xe4, 0xfd, 0x8f, 0xd7, 0xed, 0x9d, 0x96, 0xbc, 0xe9, 0xd0, 0xa3, 0x52, 0xb5, 0x59, 0x28, 0x53,
 0xa7, 0x17, 0x29, 0xc9, 0xf5, 0x24, 0xba, 0x5b, 0x3c, 0x23, 0x69, 0x73, 0x5a, 0xb9, 0xce, 0x73,
 0x5f, 0x1d, 0x51, 0xbe, 0x59, 0x4b, 0x85, 0x28, 0xbf, 0xb1, 0x82, 0xea, 0x5f, 0xff, 0x00, 0x77,
 0xf8, 0x9a, 0xce, 0x29, 0xbd, 0x9d, 0xb6, 0x95, 0x63, 0xf5, 0xa7, 0xfe, 0xdb, 0x6f, 0xc2, 0x36,
 0x51, 0xba, 0xd5, 0xbc, 0xbe, 0xae, 0x3f, 0xf6, 0x94, 0x2b, 0xd5, 0xa9, 0x5e, 0xb4, 0xeb, 0x56,
 0x9c, 0xaa, 0x54, 0x9b, 0x72, 0x94, 0xa4, 0xf8, 0xb6, 0xfc, 0x26, 0x80, 0x1c, 0x6c, 0xcd, 0xbb,
 0x58, 0x8a, 0x01, 0x7b, 0x24, 0xca, 0xb1, 0x99, 0xc6, 0x3e, 0x38, 0x3c, 0x15, 0x3e, 0x69, 0xbe,
 0x99, 0x49, 0xf4, 0x46, 0x0b, 0xc2, 0xdf, 0x80, 0xf4, 0xbc, 0x9b, 0x61, 0x32, 0x7c, 0x1d, 0x28,
 0xcb, 0x19, 0x09, 0x63, 0x6b, 0xf7, 0xdc, 0xdb, 0x51, 0x4f, 0x48, 0xaf, 0xdb, 0xc4, 0xf7, 0x6d,
 0x38, 0x7e, 0xb6, 0xeb, 0xd3, 0x84, 0x7a, 0x3d, 0xb2, 0xf0, 0xee, 0xf8, 0x8e, 0x8e, 0xd7, 0xd1,
 0x9c, 0xfa, 0x7d, 0x90, 0xf2, 0x60, 0x7b, 0x84, 0xb6, 0x7b, 0x23, 0x70, 0xe4, 0xee, 0x46, 0x07,
 0x87, 0xf7, 0x11, 0xe3, 0xee, 0xf0, 0x3a, 0xfe, 0x7d, 0xb0, 0x59, 0x7e, 0x26, 0x9c, 0xaa, 0x65,
 0x8d, 0xe1, 0x2b, 0xf5, 0xa8, 0xb6, 0xdd, 0x39, 0x7b, 0xbd, 0x2b, 0xda, 0xf7, 0x0f, 0x6e, 0xaf,
 0x02, 0xd7, 0xc3, 0x1b, 0xc6, 0x62, 0x5e, 0x3d, 0x2e, 0x3b, 0xa1, 0x9e, 0x55, 0x94, 0x4c, 0x3c,
 0xbc, 0x13, 0xe3, 0xf0, 0x98, 0x8c, 0x0e, 0x2e, 0xa6, 0x17, 0x17, 0x4a, 0x54, 0xab, 0x53, 0x7c,
 0x25, 0x17, 0xff, 0x00, 0xf7, 0x51, 0x01, 0xa5, 0x98, 0x9c, 0x66, 0xa5, 0xb9, 0x89, 0x8c, 0xa2,
 0xe1, 0x7b, 0x24, 0xcc, 0xf1, 0x39, 0x4e, 0x3e, 0x18, 0xbc, 0x34, 0xba, 0x57, 0x44, 0xe0, 0xfa,
 0xa7, 0x1e, 0xfa, 0x67, 0xaf, 0x65, 0x58, 0xda, 0x19, 0x96, 0x5f, 0x4b, 0x1b, 0x86, 0x97, 0x18,
 0x54, 0x5c, 0x78, 0x3e, 0xb8, 0xbe, 0xfa, 0x7a, 0xa3, 0xc4, 0xce, 0xdf, 0xbb, 0x3c, 0xd5, 0xe1,
 0xf3, 0x29, 0x65, 0x95, 0x65, 0xf5, 0x1c, 0x4f, 0x4c, 0x38, 0xf7, 0xa6, 0x97, 0xed, 0x5f, 0xa9,
 0x1b, 0xae, 0x0b, 0xbe, 0x9d, 0x1d, 0x5e, 0x56, 0x53, 0xf4, 0x72, 0xff, 0x00, 0x13, 0xff, 0x00,
 0x2d, 0x47, 0x16, 0xd9, 0xc6, 0xae, 0x9f, 0x37, 0x1f, 0xad, 0x1f, 0xe6, 0x1e, 0x8a, 0xd1, 0x87,
 0x12, 0x56, 0x8d, 0x5a, 0x3b, 0x38, 0x97, 0x2b, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x89,
 0xb4, 0xda, 0x26, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x68, 0xb5, 0xa6, 0xd0, 0xb4, 0x61, 0xc4, 0x95,
 0xa3, 0x56, 0x89, 0xb5, 0xad, 0x13, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4d, 0xa6, 0xd0, 0xb8,
 0x9e, 0x3f, 0x5b, 0xfd, 0x74, 0xff, 0x00, 0xb4, 0xcf, 0x65, 0x71, 0x3a, 0xfe, 0x03, 0x65, 0x32,
 0xcc, 0x34, 0xee, 0x56, 0x84, 0xb1, 0x55, 0x1b, 0xe3, 0xc6, 0xa7, 0xd6, 0xaf, 0x6b, 0xb7, 0x89,
 0xa5, 0xe3, 0x1b, 0x0d, 0x5d, 0xec, 0xe9, 0xc6, 0x15, 0xe8, 0xbb, 0xbf, 0x83, 0x69, 0xc3, 0xb7,
 0x9a, 0x7b, 0x68, 0xca, 0x72, 0xfb, 0xeb, 0xf5, 0x74, 0x5c, 0xaf, 0x2a, 0xc7, 0x66, 0x53, 0xe5,
 0xc2, 0xd0, 0x72, 0x8f, 0x1e, 0x99, 0xbe, 0x88, 0xaf, 0x6c, 0xee, 0x59, 0x26, 0xcb, 0xe1, 0x70,
 0x32, 0x8d, 0x6c, 0x4b, 0x58, 0x9a, 0xeb, 0xa5, 0x71, 0x5e, 0x96, 0x2f, 0x45, 0xdf, 0xf6, 0x59,
 0xd8, 0xe3, 0x4e, 0x30, 0x82, 0x84, 0x23, 0x18, 0x45, 0x2e, 0x09, 0x25, 0xc1, 0x23, 0x0d, 0x17,
 0xd8, 0xf0, 0x4d, 0x0d, 0xb4, 0xc6, 0x59, 0x7d, 0x2c, 0xbf, 0x3f, 0x57, 0x63, 0x73, 0xc4, 0xf5,
 0x75, 0xbd, 0x18, 0xfa, 0x21, 0x13, 0x89, 0xd4, 0x37, 0x8a, 0xb8, 0x79, 0xc7, 0xf1, 0x9f, 0xba,
 0x77, 0x36, 0x8e, 0x9d, 0xbc, 0x85, 0xc3, 0xce, 0x1f, 0x8c, 0xfd, 0xd3, 0x2f, 0x1c, 0x9f, 0xe4,
 0x73, 0xf8, 0x7c, 0xe1, 0x1c, 0x36, 0x7f, 0x99, 0xc7, 0xe3, 0xf2, 0x97, 0x4f, 0x00, 0x1f, 0x3e,
 0x75, 0x41, 0xea, 0xad, 0x1e, 0x54, 0x7a, 0xc3, 0x47, 0x5b, 0xe4, 0xb4, 0xfd, 0xaf, 0xfb, 0x7f,
 0x56, 0x93, 0x8c, 0x4f, 0xd4, 0xf8, 0xfe, 0x88, 0x9a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa3, 0xae,
 0xb6, 0x9a, 0xd0, 0xf0, 0x30, 0xd1, 0x33, 0x46, 0xae, 0x25, 0xad, 0x36, 0x85, 0xa3, 0x57, 0x12,
 0x66, 0x8d, 0x5a, 0x26, 0xd6, 0xb4, 0x4d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xe2, 0x4d, 0xa6, 0xd0,
 0xb4, 0x6a, 0xd1, 0x33, 0x46, 0x1a, 0x2d, 0x69, 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x38, 0x9a, 0xb4,
 0x4d, 0xad, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x89, 0xb4, 0xdb, 0xe8, 0xa8, 0xd5, 0x25,
 0x85, 0x43, 0x8e, 0x8d, 0x4d, 0x49, 0x63, 0x50, 0xfc, 0xd9, 0x6c, 0x71, 0x93, 0x91, 0x85, 0x5d,
 0x49, 0xa1, 0x54, 0xe3, 0x61, 0x50, 0x96, 0x35, 0x49, 0xb5, 0xe3, 0x27, 0x25, 0x0a, 0xa4, 0xd0,
 0xaa, 0x71, 0x90, 0xa9, 0xa9, 0x34, 0x2a, 0xea, 0x4d, 0xaf, 0x19, 0x39, 0x28, 0x55, 0x26, 0x85,
 0x5d, 0x4e, 0x32, 0x15, 0x49, 0x61, 0x54, 0x9b, 0x5e, 0x32, 0x72, 0x90, 0xab, 0xa9, 0x2c, 0x2a,
 0xea, 0x71, 0x90, 0xab, 0xa9, 0x34, 0x2a, 0xea, 0x4d, 0xaf, 0x19, 0x39, 0x48, 0x55, 0xd4, 0x9a,
 0x15, 0x75, 0x38, 0xa8, 0x55, 0xd4, 0x9a, 0x15, 0x4b, 0x5a, 0xf1, 0x93, 0xe6, 0xaf, 0x35, 0xdc,
 0xb9, 0xb7, 0x93, 0x97, 0x3f, 0x59, 0xe9, 0x7c, 0xb5, 0x63, 0xc6, 0x8f, 0x5f, 0xf3, 0x58, 0xcb,
 0x9b, 0x78, 0xb9, 0x7b, 0xf5, 0xa2, 0x9f, 0xcb, 0x56, 0x3c, 0x80, 0xe8, 0xb6, 0xbf, 0x63, 0x8b,
 0x77, 0xb7, 0xfb, 0x38, 0x00, 0x07, 0xa1, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xa8,
 0xff, 0x00, 0xb3, 0xc6, 0xad, 0xad, 0xa2, 0xda, 0xe7, 0xc7, 0xaf, 0x09, 0x86, 0xf8, 0xf3, 0x3e,
 0x57, 0x3e, 0x9c, 0xf3, 0x02, 0xd4, 0xb7, 0x9f, 0xed, 0x53, 0xf0, 0xe1, 0x70, 0xff, 0x00, 0x1e,
 0x66, 0x0d, 0xcf, 0xd9, 0x4a, 0x32, 0x9a, 0x8b, 0x7d, 0xbd, 0x43, 0x1d, 0xd4, 0x9b, 0xe2, 0xb5,
 0x2c, 0xc6, 0xa5, 0x1a, 0xab, 0xf8, 0xac, 0xea, 0xd4, 0xb1, 0x3a, 0x97, 0x28, 0xe2, 0xb8, 0x77,
 0xcd, 0x44, 0x67, 0x4a, 0xc6, 0xa4, 0x4f, 0xad, 0xcd, 0x55, 0xc2, 0xa6, 0xb8, 0xae, 0x0d, 0x1d,
 0x1b, 0x7e, 0x18, 0x6e, 0x5d, 0xcd, 0xed, 0xb4, 0xb8, 0x75, 0x6c, 0xf6, 0x3d, 0xfe, 0x6f, 0x50,
 0xed, 0x94, 0x31, 0xad, 0x75, 0x48, 0xeb, 0x9b, 0xec, 0xc4, 0xc2, 0xa6, 0xe5, 0x76, 0xe5, 0x34,
 0xb8, 0xbd, 0x9c, 0xcc, 0x3a, 0xbf, 0x06, 0xa8, 0x67, 0xd3, 0xd4, 0x9b, 0x85, 0x72, 0xd1, 0xc3,
 0x2f, 0x4c, 0x3f, 0x2b, 0xc0, 0x06, 0xdd, 0x94, 0x2e, 0x64, 0xb9, 0x6e, 0x33, 0x38, 0xce, 0x30,
 0x79, 0x4e, 0x5f, 0x49, 0xd6, 0xc5, 0xe3, 0x2b, 0xc2, 0x85, 0x08, 0x2f, 0xb2, 0x9c, 0x9a, 0x49,
 0x7b, 0xac, 0xa6, 0x7b, 0x97, 0x98, 0x9f, 0x66, 0xa1, 0x9e, 0xef, 0x8d, 0x66, 0x15, 0xa9, 0xf3,
 0x52, 0xc9, 0xf0, 0x35, 0x31, 0x4b, 0x8a, 0xe2, 0xae, 0x4b, 0x85, 0x38, 0xfc, 0x79, 0x35, 0xfd,
 0x92, 0x26, 0x6a, 0x2d, 0x8f, 0x57, 0x3f, 0x33, 0x09, 0xca, 0x3e, 0xe7, 0xd4, 0x7b, 0xb0, 0xd8,
 0x3c, 0xab, 0x60, 0x76, 0x4b, 0x0d, 0x91, 0xe5, 0xb4, 0xa0, 0xea, 0x28, 0xa9, 0x62, 0xf1, 0x3c,
 0xbc, 0x25, 0x88, 0xab, 0xc3, 0xd3, 0x4d, 0xe9, 0xe0, 0x5d, 0xe5, 0xc1, 0x1d, 0x92, 0x74, 0xb4,
 0x39, 0xba, 0xd8, 0x5d, 0x0a, 0xb5, 0x30, 0xed, 0x77, 0x86, 0x3a, 0x8e, 0x1f, 0x71, 0xa1, 0x9e,
 0x59, 0x4e, 0x59, 0x7a, 0x66, 0x5c, 0x3c, 0xe9, 0x68, 0x71, 0xb9, 0x6e, 0x4b, 0x96, 0xe5, 0x50,
 0xaf, 0x0c, 0xb3, 0x01, 0x86, 0xc1, 0xc3, 0x11, 0x59, 0xd7, 0xab, 0x1a, 0x14, 0xd4, 0x14, 0xea,
 0x34, 0x93, 0x93, 0x4b, 0xbe, 0xf8, 0x2e, 0x9d, 0x0e, 0xc5, 0x3a, 0x3a, 0x10, 0x4e, 0x96, 0x86,
 0x58, 0xcd, 0xe0, 0xcf, 0x42, 0x62, 0x26, 0x1c, 0x54, 0xe9, 0x68, 0x75, 0x4d, 0xbd, 0xd8, 0x2d,
 0x9b, 0xdb, 0x5c, 0x3e, 0x1e, 0x86, 0xd0, 0xe0, 0x67, 0x89, 0x58, 0x67, 0x27, 0x42, 0x50, 0xaf,
 0x3a, 0x6e, 0x9b, 0x97, 0x0e, 0x2f, 0xd2, 0xb4, 0x9f, 0x52, 0xeb, 0xe2, 0x77, 0xa9, 0xd2, 0xd0,
 0x86, 0x74, 0x74, 0x2f, 0x19, 0x5b, 0xcb, 0x1a, 0x79, 0xe9, 0x65, 0x19, 0xe1, 0x35, 0x31, 0xf7,
 0xc3, 0xe7, 0xac, 0xeb, 0xcc, 0xd3, 0xb2, 0xd5, 0xf9, 0xa5, 0x95, 0xe7, 0x59, 0xae, 0x06, 0x4f,
 0xa9, 0x55, 0xe4, 0xad, 0x05, 0xed, 0x70, 0x8b, 0xf8, 0x4e, 0x93, 0x9c, 0xf9, 0x9a, 0xb6, 0x96,
 0x87, 0x33, 0xca, 0xb3, 0xec, 0xb3, 0x1b, 0x15, 0xd4, 0xab, 0xc2, 0x74, 0x24, 0xfd, 0xa4, 0xa4,
 0xbe, 0x13, 0xeb, 0x49, 0xd1, 0xd0, 0x86, 0x74, 0xb4, 0x27, 0xcd, 0xc6, 0x5e, 0xcc, 0x38, 0xd7,
 0x11, 0xd2, 0xf5, 0x67, 0x7e, 0xf8, 0x89, 0xff, 0x00, 0x97, 0xc8, 0xbb, 0x09, 0xb8, 0xed, 0xab,
 0xa1, 0xb7, 0x79, 0x72, 0xda, 0x6c, 0xaa, 0x9c, 0x72, 0x7a, 0x55, 0x2e, 0xd7, 0xab, 0x0a, 0xf0,
 0xa9, 0x0a, 0x8a, 0x2b, 0x8a, 0x87, 0x04, 0xf8, 0xf0, 0x93, 0xe0, 0x9f, 0x14, 0xba, 0x1b, 0x3e,
 0x9e, 0x95, 0x1e, 0x1d, 0x09, 0x1c, 0xac, 0xe9, 0x68, 0x43, 0x3a, 0x46, 0x6d, 0x3a, 0xc3, 0xd4,
 0xd5, 0xf1, 0x5d, 0xee, 0xbf, 0x11, 0xcf, 0x1c, 0xb5, 0xab, 0xd1, 0x15, 0xe8, 0xf5, 0x38, 0xb9,
 0x53, 0xd0, 0x8a, 0x54, 0xce, 0x4e, 0x74, 0x74, 0x3a, 0xd6, 0xd0, 0xed, 0x76, 0xca, 0x64, 0x3c,
 0xcb, 0x36, 0xda, 0x0c, 0xbb, 0x0b, 0x38, 0xf5, 0xd3, 0x95, 0x78, 0xba, 0x9f, 0x90, 0xb8, 0xcb,
 0xe0, 0x33, 0x46, 0x71, 0x0d, 0x3e, 0x3b, 0x6d, 0x5c, 0xf2, 0xf3, 0x70, 0x89, 0x99, 0xfc, 0x97,
 0xa5, 0x03, 0xe3, 0x7d, 0xf4, 0xe0, 0x29, 0xe5, 0xbb, 0xd2, 0xcf, 0xb0, 0xb4, 0xa2, 0xa3, 0x07,
 0x88, 0x55, 0xb8, 0x2e, 0xf3, 0xa9, 0x08, 0xd4, 0x7f, 0x0c, 0x8f, 0x6f, 0xda, 0x7d, 0xff, 0x00,
 0xec, 0xa6, 0x09, 0x4a, 0x9e, 0x49, 0x82, 0xc6, 0xe6, 0xf5, 0x57, 0xd6, 0xcd, 0xc6, 0xc5, 0x27,
 0xed, 0xcb, 0xd3, 0x7f, 0xf5, 0x3e, 0x7a, 0xdb, 0x8d, 0xa2, 0xc4, 0xed, 0x5e, 0xd4, 0xe3, 0x73,
 0xfc, 0x5d, 0x0a, 0x34, 0x2b, 0x62, 0x9c, 0x38, 0xd3, 0xa5, 0xc7, 0x96, 0x2a, 0x30, 0x8c, 0x17,
 0x5f, 0x4f, 0x54, 0x57, 0xb6, 0x79, 0xf7, 0x3a, 0xb8, 0xe7, 0x8c, 0x44, 0x3b, 0xaf, 0x24, 0xf8,
 0x6e, 0xf3, 0x6d, 0xad, 0x96, 0xa6, 0xb6, 0x13, 0x8e, 0x33, 0x15, 0xe9, 0xf6, 0xdc, 0x7d, 0xde,
 0xbf, 0x6b, 0x85, 0x00, 0x1e, 0x37, 0x76, 0xf5, 0xef, 0x32, 0xdc, 0xdf, 0xf0, 0xbb, 0x34, 0xa1,
 0xde, 0x96, 0x03, 0x9f, 0xdc, 0xa9, 0x15, 0xfb, 0xc7, 0xd0, 0xb2, 0xa6, 0x7c, 0xef, 0xe6, 0x57,
 0x5c, 0x77, 0x81, 0x8f, 0x5e, 0xb5, 0x54, 0x7f, 0xe2, 0xd2, 0x3e, 0x92, 0x94, 0x0d, 0xb6, 0xcf,
 0x2a, 0xd3, 0x7c, 0xbf, 0xca, 0x99, 0xae, 0x23, 0x97, 0xba, 0x14, 0x65, 0x4c, 0x8e, 0x54, 0xcb,
 0xd2, 0xa6, 0x47, 0x2a, 0x7a, 0x1e, 0xd8, 0xc9, 0xcf, 0xc6, 0x4f, 0x8d, 0x76, 0xff, 0x00, 0xa3,
 0x6e, 0xf6, 0x81, 0x7a, 0xe7, 0x89, 0xf9, 0x59, 0x1c, 0x21, 0xce, 0xef, 0x0b, 0xa3, 0x6f, 0xb6,
 0x85, 0x7a, 0xe9, 0x89, 0xf9, 0x59, 0x1c, 0x11, 0xcf, 0x67, 0xf5, 0xa5, 0xf6, 0x9d, 0xaf, 0xd8,
 0xe1, 0xee, 0x8f, 0x90, 0x6f, 0x46, 0x9d, 0x4a, 0xd5, 0xa1, 0x46, 0x94, 0x1c, 0xea, 0x4e, 0x4a,
 0x31, 0x8a, 0xeb, 0x6d, 0xf4, 0x24, 0x68, 0x76, 0xcd, 0xd0, 0xe0, 0x63, 0x98, 0x6f, 0x1f, 0x26,
 0xa1, 0x28, 0xf1, 0x8c, 0x2b, 0x3a, 0xcf, 0xf1, 0x71, 0x73, 0x5f, 0x0c, 0x50, 0xc3, 0x1f, 0x3b,
 0x28, 0xc7, 0xda, 0x9d, 0xc6, 0xac, 0x68, 0xe9, 0x65, 0xa9, 0x3f, 0xd3, 0x13, 0x3d, 0x9e, 0xfb,
 0xb0, 0xdb, 0x33, 0x87, 0xd9, 0x9d, 0x9c, 0xc3, 0xe5, 0xd4, 0xa3, 0x17, 0x5b, 0x95, 0x4f, 0x13,
 0x51, 0x2e, 0x9a, 0x95, 0x1f, 0x5b, 0xf6, 0x3b, 0xcb, 0x44, 0x73, 0x32, 0x81, 0x7a, 0x54, 0xc8,
 0xe5, 0x03, 0xa9, 0xc2, 0xb1, 0x88, 0xc6, 0x3d, 0x4f, 0x91, 0xea, 0x6b, 0xe5, 0xab, 0x9c, 0xe7,
 0x9c, 0xdc, 0xca, 0x8c, 0xa9, 0xe8, 0x75, 0xdd, 0xe2, 0x65, 0x70, 0xcc, 0xf6, 0x2f, 0x34, 0xc3,
 0x4e, 0x2a, 0x52, 0x8e, 0x1e, 0x55, 0x69, 0xe9, 0x38, 0x2e, 0x65, 0xf0, 0xae, 0x1e, 0xd9, 0xdb,
 0x25, 0x4c, 0xa9, 0x99, 0x50, 0x55, 0x70, 0x38, 0x8a, 0x4d, 0x71, 0x53, 0xa5, 0x28, 0xfb, 0xa8,
 0xb6, 0x75, 0x96, 0x33, 0x8c, 0xfd, 0xec, 0x9b, 0x7d, 0x69, 0xd3, 0xd4, 0xc7, 0x38, 0xfb, 0xa6,
 0x25, 0xf2, 0x10, 0x00, 0xe4, 0x9f, 0x5e, 0x0b, 0x59, 0x56, 0x0a, 0xb6, 0x65, 0x99, 0x61, 0xb0,
 0x18, 0x75, 0xc6, 0xae, 0x22, 0xa4, 0x69, 0xc7, 0x46, 0xdf, 0x5b, 0xd0, 0xaa, 0x77, 0xbd, 0xc7,
 0xe0, 0x56, 0x2f, 0x6d, 0x6f, 0xc9, 0x71, 0x58, 0x5c, 0x34, 0xea, 0xaf, 0x65, 0xf0, 0x87, 0xea,
 0x93, 0x32, 0xe8, 0x69, 0xf3, 0x35, 0x31, 0xc3, 0xdb, 0x2f, 0x36, 0xf3, 0x5f, 0xc3, 0xe8, 0x67,
 0xab, 0xec, 0x87, 0xae, 0xe4, 0x99, 0x46, 0x17, 0x26, 0xca, 0xa8, 0x65, 0xd8, 0x38, 0x28, 0xd3,
 0xa5, 0x1e, 0x1c, 0x78, 0x74, 0xc9, 0xf7, 0xe4, 0xf5, 0x65, 0x99, 0x40, 0xbd, 0x2a, 0x64, 0x72,
 0x81, 0xd9, 0xe1, 0x58, 0xc5, 0x47, 0xa9, 0xf3, 0x29, 0xd5, 0xcb, 0x3c, 0xa7, 0x2c, 0xa6, 0xe6,
 0x54, 0x9c, 0x4e, 0x9b, 0xbd, 0xec, 0x04, 0x31, 0x5b, 0x21, 0x57, 0x11, 0xca, 0x9d, 0x4c, 0x25,
 0x48, 0xd4, 0x8b, 0xef, 0xf0, 0x6f, 0x95, 0xfe, 0xbe, 0x3e, 0xd1, 0xde, 0xe5, 0x4f, 0x43, 0x81,
 0xdb, 0xca, 0x0a, 0xa6, 0xc7, 0x66, 0xd1, 0x6b, 0xab, 0x0b, 0x39, 0x7b, 0x8b, 0x8f, 0xec, 0x29,
 0xb9, 0x88, 0xcf, 0x47, 0x3c, 0x67, 0xd9, 0x2f, 0x5e, 0xc7, 0x56, 0x70, 0xdc, 0x61, 0x94, 0x7b,
 0x61, 0xf3, 0xb0, 0x00, 0xe2, 0x9f, 0x4b, 0x0f, 0x63, 0xdc, 0xfc, 0xdd, 0x4d, 0x91, 0x71, 0xfe,
 0x4f, 0x13, 0x38, 0xaf, 0x71, 0x3f, 0xda, 0x78, 0xe1, 0xec, 0x1b, 0x95, 0xe9, 0xd9, 0x5c, 0x4e,
 0x98, 0xd9, 0xfc, 0x48, 0x1b, 0x5e, 0x0f, 0x35, 0xb9, 0xf8, 0x4b, 0x4b, 0xc7, 0xa3, 0xf9, 0x4f,
 0x8c, 0x3b, 0xa3, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x75, 0x96, 0xe2, 0x6d, 0xd3, 0x77, 0xab,
 0x98, 0x3c, 0x0e, 0xcb, 0xca, 0x85, 0x39, 0x70, 0xa9, 0x8b, 0x9a, 0xa5, 0xaf, 0x2f, 0x5c, 0xbf,
 0x57, 0x0f, 0x6c, 0xf1, 0xb3, 0xd0, 0x37, 0xd7, 0x89, 0xe6, 0xcd, 0xb0, 0x18, 0x24, 0xfa, 0x29,
 0x50, 0x75, 0x1a, 0xd6, 0x52, 0xe1, 0xfb, 0xa7, 0x9f, 0x9c, 0x8f, 0x16, 0xd5, 0xe6, 0x6e, 0x66,
 0x3d, 0x9e, 0x87, 0x75, 0xc1, 0x74, 0xb9, 0x7b, 0x4c, 0x67, 0xef, 0x9f, 0x48, 0x01, 0x7b, 0x20,
 0xc3, 0x47, 0x17, 0x9e, 0x60, 0x30, 0xb2, 0x5c, 0x63, 0x57, 0x11, 0x4e, 0x12, 0xf6, 0x1c, 0x97,
 0x1f, 0x80, 0xd7, 0x63, 0x8c, 0xe5, 0x94, 0x44, 0x7d, 0xed, 0xa6, 0x79, 0x46, 0x38, 0xce, 0x53,
 0xf7, 0x3d, 0x6f, 0x60, 0xf2, 0x48, 0x64, 0xf9, 0x0d, 0x2e, 0x78, 0x70, 0xc5, 0x62, 0x22, 0xaa,
 0x56, 0x7c, 0x3a, 0x78, 0xbe, 0xa8, 0xfb, 0x4b, 0xe1, 0xe2, 0x73, 0xee, 0x24, 0xcd, 0x1a, 0xb4,
 0x77, 0xfa, 0x3a, 0x78, 0xe9, 0x61, 0x18, 0x63, 0xea, 0x87, 0xce, 0xb5, 0x75, 0xb2, 0xd6, 0xd4,
 0x9c, 0xf2, 0xf5, 0xca, 0x16, 0x8c, 0x38, 0x92, 0xb4, 0x61, 0xc4, 0xcd, 0x6a, 0x5b, 0xa4, 0xef,
 0x47, 0x27, 0x86, 0x2b, 0x28, 0xee, 0x9d, 0x38, 0x7d, 0x5f, 0x0b, 0xf5, 0xcd, 0x2e, 0x99, 0x53,
 0x6f, 0xa5, 0x7b, 0x4f, 0xa7, 0xdd, 0x3c, 0xb0, 0xf7, 0xfc, 0xd3, 0x0c, 0xb1, 0x59, 0x6e, 0x2b,
 0x0d, 0x25, 0xc5, 0x55, 0xa3, 0x28, 0x7b, 0xa9, 0xa3, 0xc0, 0x0e, 0x53, 0x8e, 0xe8, 0xc6, 0x1a,
 0xd1, 0x9c, 0x7f, 0x57, 0xe8, 0xeb, 0x78, 0x0e, 0xbc, 0xe7, 0xa3, 0x96, 0x13, 0xfd, 0x3f, 0xa8,
 0x49, 0x86, 0xad, 0x53, 0x0f, 0x89, 0xa7, 0x88, 0xa4, 0xf9, 0x6a, 0x52, 0x9a, 0x9c, 0x5f, 0x81,
 0xa7, 0xc5, 0x11, 0x83, 0x49, 0x13, 0x31, 0x37, 0x0d, 0xe4, 0xc5, 0xc5, 0x4b, 0xdd, 0xb0, 0x35,
 0xe1, 0x8b, 0xc1, 0x50, 0xc5, 0x53, 0xfa, 0xca, 0xd4, 0xe3, 0x35, 0xec, 0x35, 0xc4, 0x91, 0xa3,
 0x81, 0xdd, 0xbe, 0x25, 0xe2, 0x76, 0x52, 0x84, 0x5b, 0xe2, 0xe8, 0x4e, 0x54, 0x9f, 0xbb, 0xc5,
 0x7c, 0x0d, 0x1d, 0x8d, 0xa3, 0xe8, 0x9b, 0x6d, 0x6e, 0x6e, 0x96, 0x39, 0xfb, 0x62, 0x1c, 0x06,
 0xe3, 0x4f, 0x95, 0xab, 0x96, 0x1e, 0xc9, 0x42, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xad, 0x19, 0xe2,
 0x58, 0xa2, 0x51, 0x34, 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x44, 0xda, 0xd6, 0x85, 0xc4, 0xd5, 0xa2,
 0x66, 0x8c, 0x34, 0x5a, 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x6d, 0x6b, 0x44,
 0xd1, 0xab, 0x44, 0xad, 0x18, 0x68, 0x98, 0x94, 0xda, 0x17, 0x13, 0x56, 0x89, 0x9a, 0x30, 0xd1,
 0x6b, 0x5a, 0xd0, 0xb4, 0x74, 0xcd, 0xe5, 0xae, 0x1d, 0xcf, 0xfc, 0x67, 0xee, 0x9d, 0xdd, 0xa3,
 0xa5, 0x6f, 0x39, 0x70, 0xee, 0x7f, 0xe3, 0x7f, 0x70, 0xd5, 0xf1, 0xb9, 0xfe, 0x47, 0x3f, 0x87,
 0xce, 0x1b, 0x0e, 0x19, 0x3f, 0xcd, 0x63, 0xf1, 0xf9, 0x4b, 0xa5, 0x80, 0x0e, 0x01, 0xd6, 0x87,
 0xae, 0x38, 0x9e, 0x46, 0x7b, 0x03, 0x89, 0xd6, 0x79, 0x31, 0x3f, 0x6b, 0xfe, 0xdf, 0xd5, 0xa3,
 0xe3, 0x53, 0xf5, 0x3e, 0x3f, 0xa2, 0x26, 0x8d, 0x5a, 0x26, 0x68, 0xd5, 0xc4, 0xeb, 0x2d, 0xa3,
 0xb4, 0x2d, 0x18, 0x68, 0x95, 0xc4, 0xc3, 0x44, 0xda, 0xd6, 0x85, 0xa3, 0x57, 0x12, 0x66, 0x8d,
 0x5a, 0x2d, 0x69, 0xb4, 0x4e, 0x26, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x36, 0xb5, 0xa1, 0x68, 0xc3,
 0x44, 0xae, 0x26, 0x1c, 0x4b, 0x5a, 0x6d, 0x0b, 0x46, 0xbc, 0x09, 0x9a, 0x35, 0x68, 0x9b, 0x4d,
 0xa2, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x89, 0xb5, 0xad, 0xed, 0x51, 0xa8, 0x4b, 0x1a, 0x87,
 0x1f, 0x1a, 0x9a, 0x92, 0xc6, 0xa1, 0xf9, 0xb2, 0xd8, 0x23, 0x27, 0x21, 0x1a, 0x84, 0xb1, 0xa8,
 0x71, 0xd1, 0xa9, 0xa9, 0x2c, 0x6a, 0x6a, 0x4d, 0xad, 0x19, 0x39, 0x18, 0xd4, 0xd4, 0x96, 0x35,
 0x4e, 0x3a, 0x35, 0x09, 0x63, 0x50, 0x9b, 0x5e, 0x32, 0x72, 0x31, 0xa9, 0xa9, 0x34, 0x6a, 0xea,
 0x71, 0xb1, 0xa9, 0xa9, 0x2c, 0x6a, 0x13, 0x6b, 0xc6, 0x4e, 0x4a, 0x15, 0x75, 0x25, 0x8d, 0x53,
 0x8d, 0x8d, 0x52, 0x58, 0x54, 0x26, 0xd7, 0x8c, 0x9c, 0x9c, 0x2a, 0x6a, 0x4b, 0x0a, 0xa7, 0x1b,
 0x0a, 0xba, 0x92, 0xc2, 0xae, 0xa5, 0xad, 0x78, 0xc9, 0xf3, 0xd7, 0x9a, 0x9e, 0x5c, 0xdb, 0xc1,
 0xc0, 0x3f, 0x5a, 0x69, 0xfc, 0xad, 0x63, 0xc9, 0x4f, 0x55, 0xf3, 0x4f, 0x4b, 0x9b, 0x6f, 0x70,
 0x2f, 0xd6, 0xba, 0x7f, 0x2b, 0x54, 0xf2, 0xa3, 0xa5, 0xda, 0x7d, 0x8e, 0x2e, 0x87, 0x6d, 0xf6,
 0x58, 0x80, 0x03, 0xd0, 0xce, 0xfb, 0x1a, 0x3b, 0x98, 0xdd, 0x8b, 0xff, 0x00, 0x86, 0x7f, 0x3e,
 0xc4, 0xfd, 0x21, 0x2c, 0x77, 0x2b, 0xba, 0xf7, 0xd7, 0xb3, 0x1f, 0x9f, 0xe2, 0x7e, 0x90, 0xee,
 0x10, 0xaa, 0x4d, 0x0a, 0xba, 0x9c, 0xd7, 0x88, 0xd5, 0xea, 0x9e, 0xed, 0x24, 0x6b, 0xe7, 0xd5,
 0x2e, 0x9b, 0x1d, 0xc9, 0xee, 0xb5, 0xf5, 0xec, 0xbf, 0xe7, 0xf8, 0x9f, 0xa4, 0x26, 0x8e, 0xe4,
 0x37, 0x56, 0xff, 0x00, 0xe1, 0x6f, 0xd2, 0x18, 0x9f, 0xa4, 0x3b, 0x94, 0x2a, 0xea, 0x4f, 0x0a,
 0xba, 0x96, 0xf1, 0x1a, 0xbd, 0x53, 0xdd, 0x78, 0xd6, 0xcf, 0xdb, 0x2e, 0x97, 0x1d, 0xc6, 0xee,
 0xa5, 0xf5, 0xec, 0xaf, 0xe9, 0x0c, 0x4f, 0xd2, 0x12, 0xc3, 0x71, 0x5b, 0xa6, 0x7d, 0x7b, 0x29,
 0xfa, 0x43, 0x15, 0xf4, 0x87, 0x75, 0x85, 0x6d, 0x49, 0xe1, 0x5b, 0x52, 0x79, 0xfa, 0x9d, 0x53,
 0xdd, 0x78, 0xd6, 0xcb, 0xda, 0xe9, 0x30, 0xdc, 0x46, 0xe9, 0x1f, 0x5e, 0xc9, 0xfe, 0x91, 0xc5,
 0x7d, 0x21, 0xda, 0xf6, 0x03, 0x60, 0x36, 0x37, 0x61, 0xab, 0xe2, 0xab, 0xec, 0xb6, 0x4f, 0xdc,
 0xfa, 0x98, 0xb8, 0xc6, 0x15, 0xdf, 0x9e, 0x6a, 0xd5, 0xe7, 0x51, 0x6d, 0xaf, 0xf5, 0x92, 0x97,
 0x0e, 0xb7, 0xd4, 0x72, 0x50, 0xad, 0xa9, 0x3d, 0x3a, 0xda, 0x89, 0xd6, 0xcf, 0x28, 0xa9, 0x99,
 0x5e, 0x35, 0x72, 0x9f, 0x5c, 0xb9, 0xba, 0x75, 0xf5, 0x2c, 0xd3, 0xc4, 0x6a, 0x70, 0x54, 0xeb,
 0x6a, 0x58, 0xa7, 0x5f, 0x52, 0xb1, 0x2b, 0xc6, 0x6e, 0x7a, 0x96, 0x27, 0x53, 0xae, 0xef, 0x8b,
 0x13, 0xcd, 0xb9, 0xed, 0xb4, 0x8f, 0x1e, 0xbd, 0x9f, 0xc7, 0xaf, 0xcd, 0xe6, 0x5c, 0xa7, 0x5f,
 0x53, 0xaf, 0x6f, 0x72, 0xbf, 0x1d, 0xd2, 0x6d, 0x8a, 0xe3, 0xd7, 0x90, 0xe3, 0xbe, 0x42, 0x66,
 0x5c, 0x27, 0xe9, 0x43, 0x2e, 0x39, 0xbf, 0x38, 0x00, 0x06, 0xfd, 0xea, 0x0f, 0xaf, 0xbf, 0xec,
 0xe6, 0xca, 0xd5, 0x55, 0xb6, 0xb9, 0x9c, 0xa3, 0xc5, 0xc7, 0xce, 0x74, 0x20, 0xfd, 0x9b, 0xd2,
 0x97, 0xee, 0x9f, 0x20, 0x9f, 0x6c, 0xff, 0x00, 0xd9, 0xda, 0xfc, 0xef, 0xb0, 0xbb, 0x4d, 0x88,
 0x5f, 0xef, 0x73, 0x48, 0x41, 0xff, 0x00, 0xcb, 0x49, 0x3f, 0xde, 0x30, 0x6e, 0x32, 0xf3, 0x74,
 0xe6, 0x51, 0x96, 0x31, 0x94, 0x54, 0xbe, 0x99, 0xad, 0x84, 0xd0, 0xa7, 0x5b, 0x09, 0xa1, 0xce,
 0x42, 0xbd, 0x2a, 0x8b, 0x84, 0x97, 0x06, 0x27, 0x87, 0x8c, 0xd7, 0x18, 0xb4, 0xcf, 0x16, 0x3a,
 0xcf, 0x16, 0xae, 0xc6, 0x32, 0xf5, 0x3a, 0xb5, 0x6c, 0x26, 0x85, 0x4a, 0xb8, 0x66, 0xbb, 0xc7,
 0x69, 0xad, 0x84, 0xd0, 0xa7, 0x5b, 0x09, 0xa1, 0xe8, 0xc7, 0x59, 0xaa, 0xd6, 0xe1, 0xff, 0x00,
 0x93, 0xac, 0xd4, 0xa2, 0xd7, 0x5a, 0x20, 0x9d, 0x2d, 0x0e, 0xc1, 0x5b, 0x09, 0xa1, 0x4e, 0xb6,
 0x1b, 0x95, 0x36, 0xfa, 0x12, 0xef, 0x9e, 0x8c, 0x75, 0x5a, 0xbd, 0x5d, 0x9c, 0xc3, 0x85, 0x9d,
 0x23, 0xab, 0x6d, 0xa6, 0xd9, 0x6c, 0x9e, 0xc8, 0x51, 0xb9, 0xb4, 0x59, 0xe6, 0x0f, 0x03, 0x26,
 0xb8, 0xc6, 0x94, 0xa5, 0xcd, 0x56, 0x6b, 0xc3, 0x1a, 0x71, 0xe3, 0x27, 0xed, 0x23, 0xc4, 0x77,
 0xfd, 0xe6, 0x87, 0xad, 0x4f, 0x1d, 0x89, 0xd9, 0xbd, 0xde, 0xe2, 0x21, 0x08, 0xd2, 0x93, 0xa7,
 0x89, 0xcd, 0xe3, 0xc2, 0x5c, 0xef, 0xa9, 0xc6, 0x8f, 0x7b, 0x87, 0xf4, 0xfb, 0xff, 0x00, 0x63,
 0xde, 0x93, 0xf9, 0x93, 0x1b, 0x8a, 0xc4, 0xe3, 0x71, 0x75, 0x71, 0x78, 0xcc, 0x45, 0x6c, 0x4e,
 0x22, 0xac, 0x9c, 0xaa, 0x55, 0xab, 0x37, 0x39, 0xcd, 0xf8, 0x5b, 0x7d, 0x2d, 0x99, 0xa3, 0x29,
 0x7a, 0xb6, 0xdc, 0x02, 0x75, 0x63, 0xce, 0xd5, 0x9a, 0x8f, 0x67, 0xdf, 0xff, 0x00, 0x0f, 0xa8,
 0x76, 0xab, 0xcd, 0x37, 0x90, 0xe1, 0xe5, 0x3a, 0x5b, 0x39, 0xb3, 0xf8, 0xcc, 0xc2, 0x4b, 0xa1,
 0x56, 0xc5, 0x54, 0x54, 0x21, 0xec, 0xa4, 0xb9, 0xa4, 0xd7, 0xb3, 0xca, 0x79, 0x9e, 0x7f, 0xe6,
 0x84, 0xde, 0x1e, 0x64, 0xe4, 0xb0, 0x75, 0xf2, 0xfc, 0xa6, 0x0f, 0xa1, 0x2c, 0x2e, 0x19, 0x4a,
 0x5c, 0x3d, 0x9a, 0x9c, 0xdd, 0x3e, 0xc7, 0x03, 0xc9, 0x00, 0xf3, 0xe5, 0xb9, 0xd1, 0xe0, 0xbb,
 0x2d, 0x2f, 0xed, 0xc4, 0xfb, 0xfd, 0x3f, 0xf0, 0xe7, 0xf3, 0xcd, 0xb4, 0xda, 0xdc, 0xef, 0x99,
 0x66, 0xbb, 0x49, 0x9a, 0x62, 0xe1, 0x2e, 0xba, 0x73, 0xc4, 0xca, 0xdf, 0xe4, 0xa7, 0xcb, 0xf0,
 0x1c, 0x00, 0x05, 0x6d, 0xb1, 0xc3, 0x4f, 0x0d, 0x38, 0xac, 0x22, 0xa3, 0xf2, 0x01, 0xd9, 0x76,
 0x6b, 0x60, 0xb6, 0xcb, 0x68, 0xdc, 0x5e, 0x4d, 0xb3, 0x79, 0x8e, 0x2a, 0x9c, 0xba, 0xab, 0x59,
 0x70, 0xa5, 0xf9, 0x72, 0xe1, 0x1f, 0x84, 0xa1, 0xb5, 0xfb, 0x3d, 0x99, 0x6c, 0xae, 0xd0, 0xe2,
 0x72, 0x1c, 0xe2, 0x9d, 0x3a, 0x78, 0xec, 0x32, 0x83, 0xab, 0x18, 0x4d, 0x4d, 0x47, 0x9e, 0x11,
 0x9a, 0x5c, 0x57, 0x43, 0xe8, 0x92, 0x14, 0xac, 0x6b, 0x69, 0xe5, 0x9f, 0x2e, 0x32, 0x8b, 0xf6,
 0x7d, 0xee, 0x24, 0x00, 0x19, 0x5e, 0xbd, 0xe6, 0x51, 0x5c, 0xdb, 0xc4, 0xc7, 0xaf, 0x5a, 0x6a,
 0x7c, 0xb5, 0x13, 0xe9, 0x99, 0x53, 0x3e, 0x6a, 0xf3, 0x24, 0xc7, 0x9b, 0x78, 0xf9, 0x82, 0xf5,
 0xa2, 0xa7, 0xcb, 0x51, 0x3e, 0xa0, 0x95, 0x33, 0x61, 0xb6, 0xca, 0xb0, 0x7c, 0xaf, 0xca, 0xdb,
 0x8e, 0x23, 0x3e, 0xe8, 0x50, 0x94, 0x08, 0xe5, 0x4c, 0xbd, 0x2a, 0x64, 0x72, 0xa6, 0x7a, 0xe3,
 0x27, 0x35, 0x19, 0x3e, 0x24, 0xde, 0x27, 0x46, 0xf0, 0x36, 0x8d, 0x7a, 0xeb, 0x8a, 0xf9, 0x59,
 0x1c, 0x09, 0xcf, 0xef, 0x1f, 0xa3, 0x78, 0x7b, 0x48, 0xbd, 0x76, 0xc5, 0x7c, 0xb4, 0x8e, 0x00,
 0xd3, 0x65, 0xf5, 0xa5, 0xf7, 0x2d, 0xaf, 0xd8, 0x61, 0xee, 0x8f, 0x90, 0x7a, 0x37, 0x99, 0xda,
 0x8a, 0xab, 0xbc, 0x7a, 0x72, 0xe1, 0xfe, 0xab, 0x09, 0x56, 0x6b, 0xe0, 0x5f, 0xb4, 0xf3, 0x93,
 0xd4, 0x7c, 0xcc, 0xb1, 0xe6, 0xde, 0x25, 0x7d, 0x32, 0xea, 0xaf, 0xff, 0x00, 0xbd, 0x33, 0x26,
 0xdf, 0xed, 0x71, 0x78, 0xf8, 0xcc, 0xf9, 0xbb, 0x0d, 0x59, 0xff, 0x00, 0xe3, 0x2f, 0xa2, 0x65,
 0x02, 0x39, 0x40, 0xbd, 0x2a, 0x64, 0x72, 0x81, 0xbf, 0x8c, 0x9f, 0x24, 0x8c, 0x94, 0x65, 0x4c,
 0x8a, 0xa5, 0x3e, 0x31, 0x6b, 0x87, 0x59, 0x7e, 0x54, 0xc8, 0xe5, 0x4c, 0xbc, 0x64, 0xbc, 0x66,
 0xf8, 0x9c, 0x00, 0x72, 0xef, 0xb5, 0x87, 0xab, 0x79, 0x9d, 0x68, 0x29, 0xe6, 0x39, 0xc5, 0x6e,
 0x1d, 0x30, 0xa3, 0x4e, 0x3e, 0xeb, 0x93, 0xfd, 0xd3, 0xca, 0x4f, 0x63, 0xf3, 0x35, 0x43, 0x99,
 0xe7, 0xef, 0xc1, 0xe7, 0x7f, 0xfa, 0xa7, 0xaf, 0x61, 0xff, 0x00, 0xa8, 0xc7, 0xfe, 0xfd, 0xcd,
 0x47, 0x1e, 0xcb, 0xcd, 0xe1, 0xfa, 0x93, 0xee, 0xf9, 0xc3, 0xd5, 0xa5, 0x4c, 0x8e, 0x50, 0xd0,
 0xbd, 0x2a, 0x7a, 0x11, 0xca, 0x07, 0x4f, 0x19, 0x3e, 0x6d, 0x19, 0x28, 0xca, 0x99, 0xc2, 0xed,
 0xa4, 0x3f, 0xf0, 0x86, 0x73, 0xf8, 0x05, 0x7f, 0x93, 0x91, 0xd9, 0x25, 0x4c, 0xe1, 0x36, 0xda,
 0x1c, 0x36, 0x3b, 0x3b, 0x7e, 0xb7, 0xd7, 0xf9, 0x39, 0x0d, 0x4c, 0xbe, 0x84, 0xfb, 0x9e, 0x9d,
 0xb6, 0x5f, 0xea, 0xe3, 0xef, 0x8f, 0x9b, 0xe5, 0xf0, 0x01, 0xc6, 0xbe, 0xae, 0x1e, 0xc5, 0xb9,
 0x25, 0xc7, 0x65, 0x31, 0x4f, 0xfa, 0xf4, 0xfe, 0x4e, 0x99, 0xe3, 0xa7, 0xb3, 0xee, 0x32, 0x3c,
 0xdb, 0x23, 0x8a, 0x7f, 0xd7, 0xe7, 0xf2, 0x74, 0xcd, 0x9f, 0x09, 0x9a, 0xdc, 0xc7, 0xba, 0x5a,
 0x4e, 0x3f, 0x35, 0xb3, 0x9f, 0x7c, 0x3b, 0xab, 0x89, 0xab, 0x89, 0x62, 0x50, 0x34, 0x71, 0x3a,
 0xb8, 0x97, 0x0f, 0x12, 0xf0, 0xed, 0xed, 0xd4, 0x73, 0xdb, 0x4a, 0xf0, 0x7f, 0xee, 0xe9, 0x53,
 0x8a, 0xfc, 0x9e, 0x3f, 0xb4, 0xea, 0x27, 0x69, 0xde, 0xaf, 0x15, 0xb7, 0x79, 0x87, 0x1f, 0x05,
 0x2e, 0x1e, 0x4a, 0x27, 0x56, 0x38, 0xad, 0xe4, 0xde, 0xe3, 0x3f, 0x7c, 0xfc, 0xdf, 0x48, 0xe1,
 0xf1, 0x5b, 0x5d, 0x3f, 0xfe, 0xb1, 0xf2, 0x09, 0xb0, 0x58, 0x9a, 0xf8, 0x2c, 0x5d, 0x2c, 0x5e,
 0x1a, 0x7c, 0x95, 0xa9, 0x49, 0x4e, 0x12, 0xe0, 0x9f, 0x06, 0xba, 0x9f, 0x07, 0xd0, 0x42, 0x0f,
 0x3c, 0x4c, 0xc4, 0xdc, 0x3d, 0x53, 0x11, 0x31, 0x52, 0xec, 0x9f, 0xc3, 0xad, 0xaa, 0xf1, 0xa7,
 0xe6, 0xf4, 0xbe, 0x68, 0xfe, 0x1c, 0xed, 0x4f, 0x8d, 0x3f, 0x37, 0xa5, 0xf3, 0x4e, 0xb6, 0x0c,
 0xfe, 0x33, 0x71, 0xf8, 0x93, 0xde, 0x5e, 0x6f, 0x05, 0xb6, 0xfc, 0x3c, 0x7b, 0x43, 0xb1, 0xff,
 0x00, 0x0e, 0x36, 0xa7, 0xc6, 0x9f, 0x9b, 0xd2, 0xf9, 0xa3, 0xf8, 0x71, 0xb5, 0x1e, 0x33, 0xfc,
 0xde, 0x9f, 0xcd, 0x3a, 0xe0, 0x27, 0xc6, 0x6e, 0x3f, 0x12, 0x7b, 0xc9, 0xe0, 0xb6, 0xdf, 0x87,
 0x8f, 0x68, 0x76, 0x27, 0xb6, 0xfb, 0x4f, 0xe3, 0x3f, 0xf0, 0x29, 0xfc, 0xd3, 0xae, 0x80, 0x62,
 0xd4, 0xd6, 0xd4, 0xd5, 0xaf, 0x3f, 0x29, 0x9f, 0x7c, 0xdb, 0x2e, 0x9e, 0x8e, 0x9e, 0x95, 0xf9,
 0x98, 0xc4, 0x5f, 0xb2, 0x28, 0x00, 0x18, 0xd9, 0x5e, 0x95, 0xb9, 0xfa, 0xbc, 0xd9, 0x76, 0x3e,
 0x87, 0x1f, 0xac, 0xab, 0x19, 0xfe, 0x52, 0xe1, 0xfb, 0xa7, 0x79, 0x68, 0xf3, 0xdd, 0xcd, 0x4b,
 0xea, 0xf9, 0x9c, 0x3c, 0x31, 0xa6, 0xfd, 0xc7, 0x2e, 0xd3, 0xd1, 0x9a, 0x3b, 0x6e, 0x13, 0x95,
 0xed, 0x30, 0xf8, 0xfc, 0xe5, 0xc4, 0x71, 0x68, 0xf3, 0x77, 0x99, 0xfc, 0x3e, 0x50, 0x85, 0xa3,
 0x0e, 0x24, 0xae, 0x26, 0xad, 0x1b, 0x3b, 0x6b, 0xad, 0x13, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4,
 0x4d, 0xad, 0x68, 0x5c, 0x4c, 0x38, 0x92, 0xb8, 0x98, 0x71, 0x26, 0xd3, 0x68, 0x5a, 0x35, 0x68,
 0x99, 0xa3, 0x57, 0x12, 0xd6, 0x98, 0x94, 0x4e, 0x26, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x4d, 0xad,
 0x68, 0x5a, 0x35, 0x68, 0x9d, 0xa3, 0x47, 0x12, 0xd1, 0x29, 0xb4, 0x4d, 0x1d, 0x23, 0x7a, 0x2b,
 0x87, 0x73, 0xbf, 0x1b, 0xfb, 0x87, 0x7b, 0x68, 0xe8, 0xdb, 0xd4, 0x5c, 0x3b, 0x9b, 0xf8, 0xdf,
 0xdc, 0x35, 0x9c, 0x6a, 0x7f, 0x92, 0xcf, 0xe1, 0xf3, 0x86, 0xc7, 0x85, 0x4f, 0xf3, 0x58, 0xfc,
 0x7e, 0x52, 0xe8, 0xe0, 0x03, 0x82, 0x76, 0x01, 0xec, 0x8d, 0x1e, 0x36, 0x7b, 0x4b, 0x89, 0xd5,
 0x79, 0x33, 0xfd, 0xdf, 0x87, 0xea, 0xd0, 0xf1, 0xb9, 0xfa, 0x9f, 0x1f, 0xd1, 0x0b, 0x46, 0xad,
 0x13, 0x38, 0x9a, 0xb4, 0x75, 0x76, 0xd1, 0x5a, 0x26, 0x8d, 0x5a, 0x25, 0x68, 0xc3, 0x44, 0xda,
 0x6d, 0x0b, 0x89, 0xab, 0x44, 0xce, 0x26, 0x1a, 0x26, 0xd6, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2,
 0x6a, 0xd1, 0x68, 0x94, 0xda, 0x16, 0x8c, 0x34, 0x4b, 0xc0, 0xc3, 0x89, 0x36, 0xb5, 0xa1, 0x71,
 0x35, 0x71, 0x26, 0x68, 0xc3, 0x45, 0xad, 0x36, 0x81, 0xa3, 0x0d, 0x13, 0x34, 0x6a, 0xe2, 0x4d,
 0xa6, 0x25, 0xe9, 0x91, 0xa9, 0xa9, 0x2c, 0x6a, 0x6a, 0x71, 0xf1, 0xa8, 0x4b, 0x1a, 0x87, 0xe6,
 0xdb, 0x79, 0xa3, 0x25, 0xf8, 0xd4, 0x25, 0x8d, 0x43, 0x8f, 0x8d, 0x42, 0x58, 0xd4, 0x26, 0xd6,
 0x8c, 0x9c, 0x84, 0x6a, 0x12, 0xc6, 0xa1, 0xc7, 0x46, 0xa1, 0x2c, 0x6a, 0x6a, 0x4d, 0xaf, 0x19,
 0x39, 0x08, 0xd4, 0x25, 0x8d, 0x4d, 0x4e, 0x3e, 0x35, 0x09, 0x63, 0x50, 0x9b, 0x5a, 0x32, 0x72,
 0x11, 0xa8, 0x4b, 0x0a, 0x9a, 0x9c, 0x74, 0x6a, 0x6a, 0x4b, 0x1a, 0x84, 0xda, 0xf1, 0x93, 0x91,
 0x85, 0x42, 0x58, 0xd4, 0xd4, 0xe3, 0xa3, 0x50, 0x96, 0x35, 0x35, 0x26, 0xd7, 0x8c, 0x9e, 0x13,
 0xe6, 0x95, 0x97, 0x36, 0xdd, 0x60, 0x9f, 0xad, 0x94, 0xfe, 0x56, 0xa9, 0xe5, 0xe7, 0xa6, 0x79,
 0xa3, 0x25, 0xcd, 0xb6, 0xf8, 0x37, 0xeb, 0x6c, 0x3e, 0x56, 0xa9, 0xe6, 0x67, 0x4f, 0xb3, 0xfb,
 0x0c, 0x7d, 0xce, 0x9b, 0x69, 0xf6, 0x38, 0x80, 0x03, 0xd2, 0xf4, 0xbe, 0xed, 0x85, 0x52, 0x68,
 0x55, 0xd4, 0xe3, 0x21, 0x57, 0x52, 0x68, 0x55, 0xd4, 0xe4, 0xad, 0xcc, 0xc6, 0x4e, 0x4e, 0x15,
 0x49, 0xa1, 0x57, 0x53, 0x8b, 0x85, 0x52, 0x68, 0x55, 0xd4, 0xb5, 0xaf, 0x19, 0x39, 0x48, 0x55,
 0xd4, 0x9a, 0x15, 0x75, 0x38, 0xb8, 0x55, 0x25, 0x85, 0x5d, 0x49, 0xb5, 0xe3, 0x27, 0x2d, 0x0a,
 0xda, 0x93, 0x42, 0xb6, 0xa7, 0x13, 0x0a, 0xa4, 0xf0, 0xab, 0xa9, 0x36, 0xbc, 0x64, 0xe5, 0xa1,
 0x5b, 0x52, 0x78, 0x56, 0xd4, 0xe2, 0x21, 0x57, 0x52, 0x78, 0x56, 0xd4, 0xb5, 0xb2, 0x46, 0x4e,
 0x5e, 0x9d, 0x6d, 0x4e, 0x03, 0x7a, 0xd5, 0xb8, 0xee, 0xab, 0x6b, 0x97, 0x1e, 0xbc, 0x8f, 0x1b,
 0xf2, 0x13, 0x2f, 0x42, 0xb6, 0xa7, 0x03, 0xbd, 0x2a, 0xbc, 0x77, 0x5f, 0xb5, 0x6b, 0xc3, 0x92,
 0xe3, 0x3e, 0x42, 0x66, 0x4d, 0x39, 0xfa, 0x50, 0xcb, 0x86, 0x5e, 0x98, 0x7c, 0x02, 0x00, 0x3a,
 0x36, 0xd0, 0x3e, 0xd4, 0xf3, 0x05, 0x4a, 0xd6, 0xeb, 0x73, 0x89, 0xff, 0x00, 0x1b, 0x3b, 0xa8,
 0xbd, 0xca, 0x14, 0x7b, 0x4f, 0x8a, 0xcf, 0xb2, 0xfc, 0xc3, 0xb5, 0x2d, 0xee, 0xa3, 0x33, 0x5e,
 0x1c, 0xf2, 0xab, 0xff, 0x00, 0x02, 0x81, 0xe5, 0xde, 0x4f, 0xfa, 0x4a, 0x6a, 0x4d, 0x43, 0xe9,
 0x8a, 0x38, 0xa7, 0xe1, 0x2e, 0xd0, 0xc6, 0x35, 0xf6, 0x47, 0x5a, 0xa7, 0x88, 0xd4, 0xb3, 0x4b,
 0x11, 0xa9, 0xa9, 0x8c, 0x98, 0xf1, 0xd4, 0x76, 0xba, 0x58, 0xc8, 0xc9, 0x70, 0x9a, 0x4c, 0x97,
 0x92, 0x95, 0x55, 0xe9, 0x5a, 0xf6, 0x0e, 0xb5, 0x4b, 0x12, 0xfc, 0x25, 0xca, 0x38, 0xb6, 0xbb,
 0xe5, 0xe3, 0x39, 0x86, 0x4f, 0x3a, 0x32, 0xf5, 0xb9, 0x1a, 0xd8, 0x4d, 0x0f, 0x9a, 0xbc, 0xdc,
 0x1b, 0xc5, 0xab, 0xb2, 0x5b, 0x25, 0x87, 0xd8, 0xfc, 0xa2, 0xbb, 0xa5, 0x9a, 0x67, 0xb0, 0x93,
 0xc4, 0x4e, 0x2f, 0xd3, 0x51, 0xc2, 0x2e, 0x89, 0x70, 0xf0, 0x39, 0xbe, 0x31, 0xe3, 0xe0, 0x8c,
 0xf4, 0x3e, 0x92, 0xa1, 0x8e, 0x7d, 0x4d, 0xf1, 0x5a, 0x9f, 0x9c, 0x5e, 0x6b, 0xed, 0xa1, 0xa9,
 0xb4, 0x5e, 0x68, 0x0d, 0xa3, 0xa8, 0xe6, 0xdd, 0x0c, 0x04, 0xe1, 0x80, 0xa1, 0x1e, 0x3f, 0x59,
 0x1a, 0x50, 0x4a, 0x4b, 0xf2, 0xdc, 0xdf, 0xb6, 0x7b, 0x36, 0xd3, 0xe7, 0xe4, 0xa4, 0xe8, 0x69,
 0xcc, 0xdb, 0xc8, 0xc0, 0x06, 0xc5, 0x98, 0x3d, 0x6b, 0x75, 0xdb, 0x83, 0xdb, 0x5d, 0xb7, 0xc1,
 0x51, 0xcd, 0x67, 0x1a, 0x59, 0x2e, 0x53, 0x59, 0x29, 0x53, 0xc4, 0xe2, 0xd3, 0xe7, 0xab, 0x1f,
 0xe3, 0x42, 0x9a, 0xe9, 0x6b, 0xc0, 0xdb, 0x8a, 0x7d, 0xe6, 0xc8, 0x7c, 0xcb, 0x1b, 0x11, 0x83,
 0xdb, 0xcd, 0xef, 0xe0, 0x72, 0xec, 0xca, 0x94, 0x6b, 0xe5, 0xf8, 0x1a, 0x33, 0xc7, 0xe2, 0xa8,
 0xc9, 0x71, 0x55, 0x63, 0x4d, 0xc5, 0x46, 0x2f, 0x47, 0x39, 0x43, 0x8a, 0xef, 0xae, 0x28, 0xfd,
 0x07, 0xa9, 0x83, 0x8c, 0x62, 0xa3, 0x18, 0x28, 0xc5, 0x2e, 0x09, 0x25, 0xc1, 0x24, 0x53, 0x2c,
 0xe2, 0x26, 0x9a, 0xfd, 0xf6, 0xe3, 0x53, 0x4e, 0x3c, 0xdd, 0x3f, 0x5b, 0xe7, 0x0d, 0x99, 0xf3,
 0x30, 0x6c, 0x2e, 0x5b, 0x18, 0xcf, 0x39, 0xc5, 0x66, 0x59, 0xdd, 0x65, 0xf5, 0xca, 0x55, 0x2c,
 0x52, 0x7e, 0xc4, 0x61, 0xe9, 0x97, 0xe5, 0x33, 0xd1, 0x72, 0x0d, 0xde, 0x6c, 0x56, 0xcf, 0xf2,
 0xbc, 0x9f, 0x65, 0xf2, 0xbc, 0x2d, 0x48, 0xf5, 0x55, 0x58, 0x78, 0xca, 0xa7, 0xe5, 0xcb, 0x8c,
 0xbe, 0x13, 0xbf, 0xd5, 0xc2, 0xb5, 0xde, 0x2a, 0xd4, 0xa0, 0xd7, 0x78, 0xb6, 0x39, 0xc3, 0x97,
 0xdc, 0xe7, 0xb8, 0xd4, 0xfa, 0xf9, 0x4c, 0xb8, 0x99, 0xd2, 0xd0, 0xf8, 0x67, 0xcd, 0x3f, 0xd1,
 0xbf, 0x3d, 0xa2, 0x5e, 0x07, 0x86, 0x5f, 0x9b, 0x52, 0x3e, 0xf5, 0x9d, 0x2d, 0x0f, 0x80, 0x3c,
 0xd1, 0x78, 0xa8, 0xe2, 0xf7, 0xd9, 0xb5, 0x15, 0x60, 0xd3, 0x51, 0xc5, 0xaa, 0x5e, 0xdc, 0x21,
 0x18, 0x3f, 0x86, 0x25, 0xe7, 0x2b, 0x87, 0xa7, 0x80, 0x68, 0xf9, 0x9b, 0x9c, 0xb2, 0xff, 0x00,
 0xe3, 0xfa, 0xc3, 0xcf, 0xc0, 0x05, 0x5d, 0x7b, 0xda, 0x3c, 0xc7, 0xd1, 0xe6, 0xde, 0x5e, 0x62,
 0xbd, 0x66, 0xab, 0xf2, 0xd4, 0x4f, 0xaa, 0x27, 0x4b, 0x43, 0xe5, 0xcf, 0x31, 0xa4, 0x79, 0xb7,
 0x9f, 0x99, 0x2f, 0x59, 0x6a, 0xfc, 0xbd, 0x03, 0xeb, 0x39, 0xd2, 0xd0, 0xf5, 0x68, 0xe5, 0x58,
 0xbe, 0x6f, 0xe5, 0x46, 0x8f, 0x9f, 0xbe, 0x99, 0xfc, 0xa1, 0xc4, 0xce, 0x91, 0x0c, 0xa9, 0x1c,
 0xac, 0xe9, 0x68, 0x43, 0x3a, 0x5a, 0x19, 0xe3, 0x37, 0x2b, 0x9e, 0xde, 0x9f, 0x06, 0x6f, 0x2b,
 0xa3, 0x78, 0xdb, 0x4c, 0xbd, 0x77, 0xc5, 0x7c, 0xb4, 0x8e, 0xbe, 0x76, 0x2d, 0xe7, 0x2e, 0x1b,
 0xca, 0xda, 0x85, 0xe0, 0xce, 0x31, 0x7f, 0x2d, 0x33, 0xae, 0x9a, 0xfc, 0xbd, 0x72, 0xfb, 0x5e,
 0xd7, 0xec, 0x30, 0xf7, 0x47, 0xc8, 0x3d, 0x57, 0xcc, 0xbc, 0xb8, 0xef, 0x1b, 0x10, 0xbd, 0x6d,
 0xab, 0xf1, 0xe9, 0x9e, 0x54, 0x7a, 0xcf, 0x99, 0x5d, 0x71, 0xde, 0x4e, 0x21, 0x7a, 0xd9, 0x57,
 0xe3, 0xd3, 0x32, 0x68, 0xfd, 0xa4, 0x3c, 0x3c, 0x73, 0xff, 0x00, 0x6e, 0xd6, 0xf7, 0x4b, 0xe9,
 0x59, 0x53, 0x23, 0x95, 0x32, 0xf4, 0xa9, 0x91, 0xca, 0x99, 0xb8, 0x8c, 0x9f, 0x1d, 0x8c, 0x94,
 0x65, 0x4c, 0x8e, 0x50, 0x2f, 0x4a, 0x99, 0x1c, 0xa0, 0x5e, 0x32, 0x64, 0x8c, 0x9f, 0x09, 0x80,
 0x0e, 0x7d, 0xf7, 0x30, 0xf6, 0x8f, 0x33, 0x14, 0x79, 0xbf, 0x84, 0x3f, 0xfa, 0x6f, 0xfa, 0xa7,
 0x8b, 0x9e, 0xdb, 0xe6, 0x5b, 0x8f, 0x32, 0xda, 0x3f, 0xfd, 0x2f, 0xfd, 0x53, 0xd5, 0xb2, 0x9a,
 0xd7, 0xc7, 0xfe, 0xfd, 0xcd, 0x27, 0x94, 0x53, 0x5c, 0x37, 0x53, 0xe1, 0xff, 0x00, 0x94, 0x3d,
 0x82, 0x50, 0x23, 0x95, 0x32, 0xf4, 0xa0, 0x47, 0x2a, 0x67, 0x41, 0x19, 0x3e, 0x63, 0x19, 0x28,
 0xca, 0x99, 0xc1, 0xed, 0xcc, 0x38, 0x6c, 0x5e, 0x78, 0xfd, 0x6e, 0xc4, 0x7c, 0x9c, 0x8e, 0xcd,
 0x2a, 0x67, 0x05, 0xb7, 0x90, 0xe1, 0xb1, 0x19, 0xf3, 0xf5, 0xb7, 0x11, 0xf2, 0x72, 0x19, 0xe5,
 0xf4, 0x25, 0xea, 0xda, 0xe5, 0xfe, 0xb6, 0x1e, 0xf8, 0xf9, 0xbe, 0x4d, 0x00, 0x1c, 0xab, 0xeb,
 0xe1, 0xed, 0xdb, 0x85, 0x8f, 0x36, 0xc7, 0x62, 0xdf, 0xae, 0x13, 0xf9, 0x3a, 0x67, 0x88, 0x9e,
 0xe9, 0xe6, 0x7e, 0x8f, 0x1d, 0x8c, 0xc5, 0xbf, 0x5c, 0x67, 0xf2, 0x74, 0xcd, 0x8f, 0x0b, 0x9a,
 0xdc, 0x47, 0xb9, 0xa2, 0xf2, 0x8a, 0x6b, 0x65, 0x3e, 0xf8, 0x77, 0x89, 0x53, 0x23, 0x95, 0x32,
 0xf4, 0xa9, 0x91, 0xca, 0x99, 0xd3, 0x46, 0x4e, 0x06, 0x33, 0x7c, 0xff, 0x00, 0xbe, 0x4a, 0x0e,
 0x8e, 0xdc, 0x56, 0x93, 0x5c, 0x2e, 0xd1, 0xa7, 0x3f, 0x83, 0x97, 0xf7, 0x4e, 0x9a, 0x7a, 0x86,
 0xff, 0x00, 0xf0, 0x0e, 0x9e, 0x63, 0x96, 0x66, 0x29, 0x74, 0x54, 0xa5, 0x2a, 0x32, 0x7e, 0x07,
 0x17, 0xcc, 0xbe, 0x33, 0xf7, 0x0f, 0x2f, 0x39, 0x3d, 0xf6, 0x3e, 0x6e, 0xe3, 0x3f, 0x7f, 0xcd,
 0xf4, 0xae, 0x13, 0xa9, 0x1a, 0x9b, 0x3d, 0x39, 0x8f, 0x65, 0x76, 0xf4, 0x07, 0x25, 0xb2, 0xf8,
 0x0a, 0x19, 0x9e, 0xd0, 0x60, 0xb2, 0xfc, 0x4c, 0xea, 0x42, 0x95, 0x7a, 0x9c, 0x92, 0x70, 0x69,
 0x49, 0x7b, 0x1c, 0x53, 0x38, 0xd2, 0xe6, 0x49, 0x8b, 0xf3, 0x86, 0x73, 0x82, 0xc7, 0x3e, 0x3c,
 0x28, 0x57, 0x85, 0x47, 0xaa, 0x52, 0x4d, 0x9e, 0x7d, 0x39, 0x88, 0xce, 0x3c, 0xef, 0x55, 0xbd,
 0xba, 0xd1, 0x94, 0xe9, 0xe5, 0x18, 0xfa, 0xea, 0x69, 0xea, 0xbe, 0x85, 0xd9, 0x07, 0xf3, 0xcc,
 0xcf, 0xca, 0x43, 0xe6, 0x18, 0xf4, 0x2f, 0xc8, 0x3f, 0x9d, 0xe6, 0x7e, 0x52, 0x1f, 0x30, 0xef,
 0xb1, 0xe1, 0x28, 0x46, 0x70, 0x6a, 0x51, 0x92, 0xe2, 0x9a, 0xea, 0x68, 0xc3, 0x47, 0x61, 0x1b,
 0x0d, 0xb7, 0x44, 0x38, 0x0f, 0xe2, 0xbb, 0xbf, 0xc4, 0x97, 0x42, 0x7b, 0xb0, 0xc8, 0x7f, 0x9d,
 0xe6, 0x7e, 0x52, 0x1f, 0x30, 0xd5, 0xee, 0xc7, 0x21, 0xfe, 0x77, 0x99, 0xf9, 0x48, 0x7c, 0xc3,
 0xbe, 0xb8, 0x98, 0x68, 0x9f, 0x01, 0xb6, 0xe8, 0x84, 0xff, 0x00, 0x15, 0xdd, 0xfe, 0x24, 0xba,
 0x1f, 0xa1, 0x8e, 0x43, 0xfc, 0xef, 0x32, 0xf2, 0x90, 0xf9, 0x86, 0xaf, 0x76, 0x59, 0x17, 0xf3,
 0xbc, 0xcb, 0xca, 0x43, 0xe6, 0x1d, 0xdf, 0x1b, 0x88, 0xc3, 0xe0, 0xf0, 0xd3, 0xc4, 0xe2, 0xaa,
 0xc2, 0x8d, 0x1a, 0x6b, 0x8c, 0xe7, 0x27, 0xc1, 0x22, 0xbe, 0x0f, 0x33, 0xcb, 0x31, 0xbc, 0x3c,
 0xe9, 0x98, 0x61, 0x71, 0x1c, 0x7b, 0xd4, 0xeb, 0x46, 0x4f, 0xe0, 0x64, 0x4e, 0xcb, 0x69, 0x13,
 0x53, 0x8c, 0x5a, 0xf1, 0xc4, 0x77, 0xb3, 0x1e, 0x74, 0x67, 0x34, 0xea, 0x1e, 0x86, 0x79, 0x17,
 0xf3, 0xbc, 0xcb, 0xca, 0x43, 0xe6, 0x1a, 0xbd, 0xda, 0x64, 0x7f, 0xce, 0xf3, 0x2f, 0x29, 0x0f,
 0x98, 0x77, 0xb6, 0x8d, 0x5c, 0x4b, 0xff, 0x00, 0x0f, 0xda, 0xf4, 0x42, 0x3f, 0x8a, 0x6e, 0xff,
 0x00, 0x12, 0x5d, 0x77, 0x66, 0x76, 0x5b, 0x2f, 0xd9, 0xfa, 0xb5, 0xea, 0x60, 0xeb, 0x62, 0xaa,
 0x3a, 0xd1, 0x51, 0x95, 0xd9, 0x45, 0xa5, 0xc3, 0xc1, 0xc1, 0x23, 0x9b, 0x68, 0x95, 0xc4, 0xc3,
 0x89, 0xeb, 0xd2, 0xd3, 0xc3, 0x4b, 0x1f, 0x37, 0x08, 0xa8, 0x79, 0xb5, 0x35, 0xb3, 0xd5, 0xcb,
 0xcf, 0xce, 0x6e, 0x50, 0xb4, 0x6a, 0xd1, 0x33, 0x46, 0xbc, 0x0c, 0xb6, 0xad, 0xa2, 0x68, 0xd5,
 0xc4, 0x99, 0xa3, 0x57, 0x12, 0x6d, 0x36, 0x85, 0xa3, 0x0d, 0x12, 0xb4, 0x63, 0x94, 0x9b, 0x5a,
 0xd0, 0xb4, 0x6a, 0xe2, 0x4c, 0xd1, 0xab, 0x45, 0xad, 0x36, 0x85, 0xc4, 0xc3, 0x44, 0xcd, 0x1a,
 0xb8, 0x93, 0x69, 0xb4, 0x2e, 0x26, 0x1a, 0x25, 0x71, 0x35, 0x68, 0x9b, 0x5a, 0xd1, 0x34, 0x74,
 0x4d, 0xeb, 0xae, 0x1d, 0xcd, 0xfc, 0x6f, 0xee, 0x1d, 0xfd, 0xc4, 0xe8, 0x5b, 0xda, 0x5c, 0x3b,
 0x99, 0xf8, 0xdf, 0xdc, 0x35, 0xbc, 0x66, 0x7f, 0x92, 0xcf, 0xe1, 0xf3, 0x86, 0xcb, 0x84, 0xcf,
 0xf3, 0x78, 0x7c, 0x7e, 0x52, 0xe8, 0x60, 0x03, 0x85, 0x76, 0x41, 0xed, 0x8d, 0x1e, 0x26, 0x7b,
 0x83, 0x47, 0x51, 0xe4, 0xd7, 0xf7, 0x7e, 0x1f, 0xab, 0x9f, 0xe3, 0xbf, 0xdb, 0xf8, 0xfe, 0x88,
 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8e, 0xaa, 0xda, 0x1b, 0x42, 0xe2, 0x61, 0xa2, 0x66, 0x8d,
 0x5a, 0x26, 0xd3, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0x6d, 0x36, 0x89, 0xa3, 0x56,
 0x89, 0x9a, 0x35, 0x68, 0xb5, 0xad, 0x68, 0x9c, 0x4d, 0x5c, 0x49, 0x5a, 0x30, 0xe2, 0x4c, 0x4a,
 0x6d, 0x0b, 0x89, 0x86, 0x89, 0x5a, 0x35, 0x71, 0x26, 0xd6, 0x89, 0x44, 0xd1, 0xab, 0x44, 0xcd,
 0x1a, 0xb4, 0x5a, 0xd3, 0x6e, 0xdf, 0x1a, 0x84, 0x91, 0xa8, 0x51, 0x8d, 0x42, 0x48, 0xd4, 0x3f,
 0x37, 0x5b, 0xc7, 0x19, 0x2f, 0xc6, 0xa1, 0x24, 0x6a, 0x14, 0x23, 0x50, 0x92, 0x35, 0x09, 0xb5,
 0xe3, 0x25, 0xf8, 0xd4, 0x25, 0x8d, 0x42, 0x84, 0x6a, 0x12, 0x46, 0xa6, 0xa4, 0xda, 0xd1, 0x93,
 0x90, 0x8d, 0x4d, 0x49, 0x23, 0x50, 0xa1, 0x1a, 0x84, 0x91, 0xa9, 0xa9, 0x36, 0xb4, 0x64, 0xe4,
 0x23, 0x50, 0x92, 0x35, 0x0a, 0x11, 0xa8, 0x49, 0x1a, 0x84, 0xda, 0xf1, 0x93, 0x90, 0x85, 0x42,
 0x58, 0xd4, 0x38, 0xf8, 0xd4, 0x25, 0x8d, 0x42, 0x6d, 0x68, 0xc9, 0xe2, 0xfe, 0x68, 0x49, 0x73,
 0x6d, 0x9e, 0x0d, 0xfa, 0xdd, 0x0f, 0x94, 0xa8, 0x79, 0xc1, 0xe8, 0x7b, 0xfc, 0x97, 0x36, 0xd8,
 0x61, 0x1f, 0xad, 0xf0, 0xf9, 0x4a, 0x87, 0x9e, 0x1d, 0x4e, 0xcf, 0xec, 0x31, 0xf7, 0x3a, 0xcd,
 0x97, 0xd8, 0x63, 0xee, 0x00, 0x07, 0xa5, 0xea, 0x7d, 0xa7, 0x0a, 0x84, 0xb0, 0xaa, 0x71, 0xd1,
 0xa9, 0xa9, 0x2c, 0x6a, 0x1c, 0x7d, 0xb9, 0x28, 0xc9, 0xc9, 0x42, 0xa9, 0x2c, 0x6a, 0xea, 0x71,
 0xb1, 0xa9, 0xa9, 0x2c, 0x6a, 0x96, 0xb5, 0xa3, 0x27, 0x27, 0x0a, 0xa4, 0xd0, 0xaa, 0x71, 0x90,
 0xaa, 0x4b, 0x0a, 0xba, 0x93, 0x6b, 0xc6, 0x4e, 0x4e, 0x15, 0x75, 0x26, 0x85, 0x53, 0x8c, 0x85,
 0x52, 0x58, 0x55, 0xd4, 0x9b, 0x5e, 0x32, 0x72, 0x90, 0xab, 0xa9, 0x34, 0x2a, 0xea, 0x71, 0x70,
 0xaa, 0x4d, 0x0a, 0xa4, 0xdb, 0x24, 0x64, 0xe5, 0x61, 0x5b, 0x53, 0x82, 0xde, 0x6d, 0x5e, 0x3b,
 0xb3, 0xda, 0x95, 0xc7, 0xaf, 0x26, 0xc5, 0xfc, 0x8c, 0xcb, 0xd0, 0xab, 0xa9, 0xc2, 0x6f, 0x26,
 0xaf, 0x1d, 0xdc, 0x6d, 0x32, 0xf5, 0xa3, 0x17, 0xf2, 0x32, 0x32, 0x69, 0xcf, 0xd2, 0x86, 0x5d,
 0x3c, 0xbe, 0x94, 0x3e, 0x1c, 0x00, 0x1d, 0x3b, 0x78, 0x1f, 0x5f, 0xf9, 0x8a, 0xea, 0x72, 0x6e,
 0xb7, 0x31, 0x5e, 0xbd, 0x55, 0xf9, 0x1a, 0x07, 0xc8, 0x07, 0xd6, 0x9e, 0x63, 0x8a, 0x9c, 0x9b,
 0xb1, 0xcc, 0x17, 0x1f, 0xbb, 0x35, 0x7e, 0x46, 0x89, 0xe3, 0xdf, 0x7d, 0x93, 0x06, 0xe2, 0x6b,
 0x07, 0xd0, 0x54, 0xeb, 0xea, 0x59, 0xa7, 0x5f, 0x53, 0x84, 0x85, 0x6d, 0x4b, 0x10, 0xac, 0x69,
 0xad, 0xe3, 0x8c, 0xdc, 0xdd, 0x3a, 0xfa, 0x96, 0x69, 0xe2, 0x35, 0x38, 0x2a, 0x75, 0xf5, 0x2c,
 0x53, 0xaf, 0xa9, 0x68, 0x96, 0x48, 0xcd, 0xcf, 0xd2, 0xc4, 0xea, 0x7e, 0x6a, 0xef, 0xb9, 0x4d,
 0x6f, 0x8f, 0x6c, 0xdd, 0x4e, 0x3c, 0x5e, 0x7b, 0x8c, 0x97, 0x4f, 0x81, 0xd6, 0x9b, 0x5f, 0x07,
 0x03, 0xf4, 0x52, 0x9d, 0x7d, 0x4f, 0x84, 0xfc, 0xd6, 0x59, 0x1d, 0x4c, 0x9b, 0x7d, 0x59, 0xae,
 0x23, 0x91, 0xc6, 0x86, 0x69, 0x0a, 0x78, 0xea, 0x2f, 0xc3, 0xcd, 0x1e, 0x59, 0xff, 0x00, 0xf7,
 0x8c, 0xfe, 0x03, 0xdf, 0xb1, 0xcb, 0xe9, 0xcc, 0x3d, 0x3a, 0x59, 0xdc, 0xd3, 0xc9, 0xc0, 0x06,
 0xd1, 0x99, 0xee, 0x3e, 0x62, 0x0d, 0xa1, 0xc1, 0xe4, 0x5b, 0xf8, 0xc1, 0xe1, 0xf1, 0xb5, 0x23,
 0x4a, 0x9e, 0x71, 0x83, 0xab, 0x97, 0x42, 0x72, 0x7c, 0x12, 0xa9, 0x27, 0x09, 0xc1, 0x7f, 0xcd,
 0x2a, 0x6a, 0x2b, 0x59, 0x23, 0xf4, 0x26, 0xb6, 0x13, 0xaf, 0xa0, 0xfc, 0x88, 0xc3, 0xd6, 0xab,
 0x87, 0xaf, 0x4e, 0xbd, 0x0a, 0xb3, 0xa5, 0x5a, 0x9c, 0x94, 0xe9, 0xce, 0x12, 0x6a, 0x51, 0x92,
 0x7c, 0x53, 0x4d, 0x75, 0x34, 0xcf, 0xb6, 0x37, 0x13, 0xe6, 0xb4, 0xc9, 0x71, 0x79, 0x56, 0x1b,
 0x25, 0xde, 0x65, 0x49, 0xe0, 0x73, 0x1a, 0x31, 0x54, 0xd6, 0x69, 0x1a, 0x4e, 0x74, 0x71, 0x1c,
 0x3a, 0x14, 0xa6, 0xa2, 0x9b, 0x84, 0xfc, 0x3c, 0x13, 0x8b, 0xe9, 0x7e, 0x97, 0xa8, 0xf2, 0xee,
 0x30, 0xca, 0xfc, 0xec, 0x54, 0xcf, 0x4b, 0x1c, 0xfd, 0x6f, 0xa4, 0xab, 0x61, 0x34, 0x29, 0xd6,
 0xc2, 0x68, 0x71, 0x70, 0xde, 0xee, 0xe9, 0xeb, 0x61, 0x7c, 0xf0, 0xb7, 0x89, 0xb2, 0xd1, 0x8b,
 0x5c, 0x78, 0x4b, 0x34, 0xa4, 0xa5, 0xf9, 0x2e, 0x5c, 0xdf, 0x01, 0xe6, 0x5b, 0xcb, 0xf3, 0x52,
 0x6e, 0xcf, 0x67, 0x70, 0xd5, 0x69, 0x6c, 0xfd, 0x7a, 0xdb, 0x51, 0x98, 0xa4, 0xd4, 0x29, 0xe1,
 0x60, 0xe9, 0xd0, 0x52, 0xfe, 0x95, 0x59, 0xae, 0xaf, 0xec, 0xa9, 0x18, 0xb4, 0xf2, 0xce, 0x7d,
 0x14, 0xf0, 0xea, 0xec, 0x22, 0x7d, 0x4e, 0xdb, 0xbd, 0x6d, 0xaa, 0xca, 0xb6, 0x03, 0x63, 0x31,
 0xdb, 0x47, 0x9a, 0xce, 0x29, 0x51, 0x8b, 0x8e, 0x1e, 0x8b, 0x97, 0x09, 0x62, 0x2b, 0x34, 0xf9,
 0x29, 0xc7, 0x56, 0xfa, 0xfc, 0x09, 0x37, 0xde, 0x3f, 0x36, 0xf3, 0x5c, 0x76, 0x27, 0x34, 0xcd,
 0x31, 0x79, 0x96, 0x36, 0xa3, 0xa9, 0x8a, 0xc5, 0xd6, 0x9d, 0x7a, 0xd3, 0x7f, 0x65, 0x39, 0xc9,
 0xca, 0x4f, 0xdd, 0x6c, 0xed, 0x5b, 0xd8, 0xde, 0x56, 0xd4, 0x6f, 0x2f, 0x3e, 0xee, 0xa6, 0xd0,
 0xe2, 0xa3, 0x6e, 0x97, 0x15, 0x85, 0xc1, 0xd1, 0x4e, 0x34, 0x30, 0xd1, 0x7d, 0xe8, 0xc7, 0xc2,
 0xfb, 0xf2, 0x7c, 0x5b, 0xe0, 0xba, 0x78, 0x24, 0x97, 0x4c, 0x3d, 0xb8, 0xc4, 0xc4, 0x7a, 0x59,
 0x76, 0x9b, 0x4c, 0x76, 0xf1, 0x33, 0xf7, 0xc8, 0x00, 0x2c, 0xf6, 0x3d, 0xc3, 0xcc, 0x5c, 0xd7,
 0xa2, 0xb6, 0x3a, 0x3f, 0xc6, 0xc9, 0xab, 0x25, 0xe5, 0x68, 0xbf, 0xd8, 0x7d, 0x7f, 0x3a, 0x5a,
 0x1f, 0x1a, 0x79, 0x8e, 0x71, 0x0a, 0x96, 0xfa, 0xb0, 0xd4, 0x5b, 0xe0, 0xf1, 0x38, 0x1c, 0x45,
 0x25, 0xaf, 0x08, 0xa9, 0xfe, 0xe1, 0xf6, 0xd4, 0xe9, 0x68, 0x5b, 0x1c, 0xa9, 0xc6, 0x71, 0xed,
 0x0f, 0x3b, 0x73, 0x7f, 0x94, 0x38, 0x99, 0xd2, 0xd0, 0x86, 0x74, 0xb4, 0x39, 0x69, 0xd2, 0x20,
 0x9d, 0x2d, 0x0c, 0xb1, 0x9b, 0x9c, 0xcf, 0x6e, 0xfc, 0xf2, 0xde, 0x9a, 0xe1, 0xbc, 0xed, 0xaa,
 0x5e, 0x0c, 0xeb, 0x19, 0xf2, 0xd3, 0x3a, 0xd9, 0xd9, 0xb7, 0xae, 0xb8, 0x6f, 0x4b, 0x6b, 0x17,
 0x83, 0x3b, 0xc6, 0x7c, 0xbc, 0xce, 0xb2, 0x61, 0x9f, 0x5b, 0xea, 0x1b, 0x78, 0xad, 0x2c, 0x7d,
 0xd1, 0xf2, 0x0f, 0x5d, 0xf3, 0x28, 0x47, 0x9b, 0x79, 0x98, 0x85, 0xeb, 0x5d, 0x5f, 0x8f, 0x4c,
 0xf2, 0x23, 0xd8, 0xbc, 0xc8, 0xb1, 0xe6, 0xde, 0x8e, 0x25, 0x7a, 0xd5, 0x57, 0xe5, 0x29, 0x96,
 0xd3, 0x9a, 0xca, 0x1e, 0x1e, 0x37, 0x1e, 0x77, 0x0f, 0xd5, 0x8f, 0xca, 0x5f, 0x50, 0xce, 0x91,
 0x14, 0xa9, 0x9c, 0x9c, 0xe8, 0xe8, 0x43, 0x3a, 0x46, 0xc6, 0x33, 0x7c, 0x73, 0x2d, 0x29, 0x87,
 0x1d, 0x2a, 0x64, 0x72, 0xa6, 0x5f, 0x9d, 0x2d, 0x08, 0xa5, 0x4f, 0x43, 0x24, 0x64, 0xa5, 0xcc,
 0x7a, 0xdf, 0x9f, 0xe0, 0x03, 0x4e, 0xfb, 0xd0, 0x7b, 0x97, 0x99, 0x4e, 0x3c, 0xcb, 0x69, 0x7f,
 0xf4, 0xbf, 0xf5, 0x8f, 0x0d, 0x3d, 0xdf, 0xcc, 0x99, 0x1e, 0x65, 0xb4, 0xdf, 0xfa, 0x4f, 0xfa,
 0xc7, 0xa3, 0x6b, 0x35, 0xab, 0x0d, 0x17, 0x94, 0xb3, 0x5c, 0x33, 0x57, 0xe1, 0xff, 0x00, 0x94,
 0x3d, 0xaa, 0x54, 0xc8, 0xe5, 0x4c, 0xbd, 0x2a, 0x64, 0x72, 0xa6, 0x6e, 0xa3, 0x27, 0xca, 0xe3,
 0x25, 0x19, 0x53, 0x38, 0x0d, 0xbf, 0x87, 0xfe, 0x06, 0xcf, 0xdf, 0xad, 0x98, 0x9f, 0x92, 0x91,
 0xda, 0x65, 0x0d, 0x0e, 0xbf, 0xbc, 0x28, 0x70, 0xd8, 0x3d, 0xa1, 0xff, 0x00, 0xf5, 0x78, 0x9f,
 0x92, 0x91, 0x39, 0x65, 0xf4, 0x65, 0xea, 0xda, 0xe5, 0xfe, 0xb6, 0x1e, 0xf8, 0xf9, 0xbe, 0x3c,
 0x00, 0x1c, 0xe3, 0xec, 0xe1, 0xef, 0x5e, 0x67, 0x78, 0xf1, 0xd8, 0x9c, 0x63, 0xf5, 0xca, 0x7f,
 0x27, 0x48, 0xf0, 0x53, 0xe8, 0x0f, 0x33, 0x84, 0x78, 0xec, 0x3e, 0x31, 0xfa, 0xe5, 0x53, 0xe4,
 0xa9, 0x1e, 0xee, 0x1d, 0x35, 0xac, 0xe7, 0xfc, 0xa5, 0x9a, 0xd8, 0xcf, 0xbe, 0x1e, 0x81, 0x28,
 0x11, 0xca, 0x99, 0x7a, 0x50, 0x23, 0x95, 0x33, 0xa1, 0x8c, 0x9f, 0x3c, 0x8c, 0x9d, 0x07, 0x7c,
 0x19, 0x2c, 0xb3, 0x5d, 0x8a, 0xc4, 0xca, 0x94, 0x39, 0xab, 0x60, 0xda, 0xc4, 0xc3, 0x87, 0x5f,
 0x08, 0xf1, 0xe6, 0xff, 0x00, 0xea, 0xdf, 0xb8, 0x8f, 0x9d, 0xcf, 0xb0, 0x6a, 0xd2, 0x8c, 0xe2,
 0xe1, 0x28, 0xa9, 0x45, 0xae, 0x0d, 0x35, 0xc5, 0x34, 0x7c, 0xc9, 0xbc, 0x9d, 0x9a, 0xa9, 0xb3,
 0x1b, 0x4f, 0x5f, 0x09, 0x18, 0x3f, 0x3a, 0x55, 0x6e, 0xae, 0x16, 0x5d, 0xe7, 0x06, 0xfa, 0xbd,
 0x95, 0xd5, 0xee, 0x3e, 0xf9, 0xa8, 0xe2, 0x9a, 0x57, 0x31, 0xab, 0x1e, 0xe9, 0x76, 0x9e, 0x4b,
 0xef, 0xa2, 0x71, 0xcb, 0x6d, 0x94, 0xfa, 0x7d, 0x71, 0xfa, 0xba, 0xc8, 0x00, 0xd3, 0xba, 0xf7,
 0xb5, 0xee, 0x8f, 0x69, 0x69, 0x66, 0x99, 0x44, 0x32, 0x7c, 0x55, 0x44, 0xb1, 0xd8, 0x48, 0x72,
 0xc1, 0x49, 0xf4, 0xd4, 0xa6, 0xba, 0x9a, 0xd5, 0x75, 0x3f, 0x69, 0x9d, 0xe2, 0x54, 0xcf, 0x98,
 0x70, 0x78, 0x9c, 0x46, 0x0f, 0x13, 0x4f, 0x13, 0x85, 0xad, 0x3a, 0x35, 0xa9, 0xcb, 0x9a, 0x13,
 0x83, 0xe0, 0xe2, 0xcf, 0x50, 0xd9, 0xbd, 0xeb, 0xc5, 0x52, 0x8d, 0x0c, 0xff, 0x00, 0x07, 0x39,
 0x4d, 0x74, 0x79, 0xe3, 0x0e, 0x97, 0xa6, 0xd5, 0xc5, 0xf0, 0xf8, 0x1f, 0xb4, 0x74, 0x1b, 0x1e,
 0x27, 0x8c, 0x63, 0x18, 0x6a, 0xcd, 0x4c, 0x7d, 0xee, 0x43, 0x8a, 0xf0, 0x4d, 0x4e, 0x64, 0xea,
 0xed, 0xe2, 0xe2, 0x7d, 0x71, 0xec, 0xf7, 0x3d, 0x2d, 0xc0, 0xd1, 0xc4, 0xeb, 0xab, 0x78, 0xbb,
 0x1f, 0x2a, 0x7c, 0xcf, 0x32, 0x9c, 0x5f, 0xf1, 0x5e, 0x1a, 0xa7, 0x1f, 0x82, 0x3c, 0x0e, 0xbd,
 0xb4, 0x7b, 0xd2, 0xc1, 0x42, 0x8c, 0xa9, 0x64, 0x78, 0x5a, 0x95, 0xab, 0x35, 0xc1, 0x56, 0xaf,
 0x1e, 0x58, 0x47, 0x55, 0x1e, 0xb7, 0xed, 0xf0, 0x36, 0x59, 0x6f, 0xf6, 0xf8, 0x45, 0xce, 0x51,
 0xf0, 0x6a, 0x34, 0xb8, 0x66, 0xef, 0x53, 0x2f, 0x36, 0x34, 0xe6, 0x3d, 0xf1, 0x5f, 0x34, 0x7b,
 0xe7, 0xce, 0xa1, 0x4b, 0x05, 0x4b, 0x23, 0xa3, 0x34, 0xea, 0xd6, 0x6a, 0xa5, 0x74, 0x9f, 0xd6,
 0xc1, 0x7d, 0x6a, 0x7e, 0xcb, 0xe9, 0xf6, 0xb5, 0x3c, 0xa4, 0x9b, 0x1d, 0x8a, 0xc4, 0x63, 0x71,
 0x75, 0x71, 0x78, 0xba, 0xb2, 0xad, 0x5e, 0xac, 0xb9, 0xa7, 0x39, 0x3e, 0x96, 0xc8, 0x4e, 0x5b,
 0x77, 0xb9, 0x9d, 0xc6, 0xac, 0xe7, 0x3f, 0x07, 0x75, 0xb0, 0xda, 0x46, 0xd3, 0x42, 0x34, 0xe3,
 0xd7, 0xf7, 0xfb, 0xd7, 0xb0, 0x79, 0xc6, 0x6d, 0x83, 0xe1, 0xe7, 0x5c, 0xcb, 0x17, 0x45, 0x2e,
 0xf4, 0x2b, 0x49, 0x2f, 0x73, 0x8f, 0x03, 0x9a, 0xc1, 0xed, 0xee, 0xd3, 0xe1, 0xf8, 0x27, 0x8e,
 0x8d, 0x78, 0xae, 0xf5, 0x5a, 0x51, 0x7f, 0x0a, 0x49, 0xfc, 0x27, 0x57, 0x39, 0xbd, 0x8a, 0xc8,
 0xea, 0x67, 0xf9, 0xf5, 0x1c, 0x1f, 0x2c, 0xac, 0x45, 0xf3, 0xe2, 0x24, 0xbe, 0xc6, 0x0b, 0xaf,
 0xdb, 0x7d, 0x5e, 0xd8, 0xd0, 0xd5, 0xd7, 0xf3, 0xa3, 0x0d, 0x3c, 0xa6, 0xe7, 0xf3, 0x4e, 0xe7,
 0x4b, 0x6f, 0x18, 0x4e, 0x7a, 0xb8, 0xc5, 0x47, 0xe4, 0xf6, 0x6d, 0x95, 0xc5, 0xe3, 0xb3, 0x0c,
 0x83, 0x0b, 0x8e, 0xcc, 0x69, 0xd2, 0xa7, 0x5e, 0xbc, 0x39, 0xf9, 0x69, 0xc5, 0xa4, 0xa2, 0xdf,
 0xa5, 0xeb, 0x6f, 0xad, 0x70, 0x7e, 0xd9, 0xc9, 0x38, 0x92, 0x46, 0x9c, 0x61, 0x05, 0x08, 0x45,
 0x46, 0x31, 0x5c, 0x12, 0x4b, 0xa1, 0x20, 0xd1, 0xdb, 0x69, 0xc4, 0xe3, 0x8c, 0x44, 0xcd, 0xbe,
 0x7b, 0xa9, 0x9c, 0x65, 0x9c, 0xe5, 0x11, 0x51, 0x3f, 0x72, 0x16, 0x8d, 0x5a, 0x26, 0x68, 0xd5,
 0xc4, 0xbd, 0xab, 0x68, 0x9a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xc4, 0xb5, 0xad, 0x68, 0x9a, 0x35,
 0x71, 0x25, 0x68, 0xc3, 0x89, 0x36, 0x9b, 0x42, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xad, 0x16, 0xb5,
 0xad, 0x13, 0x46, 0xae, 0x24, 0xce, 0x26, 0xad, 0x13, 0x69, 0xb4, 0x2d, 0x18, 0x68, 0x95, 0xc4,
 0xc3, 0x44, 0xda, 0x62, 0x50, 0xb8, 0x9d, 0x03, 0x7b, 0xab, 0x87, 0x72, 0xff, 0x00, 0x1b, 0xfb,
 0x87, 0xa1, 0xb4, 0x79, 0xf6, 0xf8, 0x57, 0x0e, 0xe5, 0xfe, 0x3b, 0xf7, 0x0d, 0x77, 0x18, 0x9f,
 0xe4, 0xf3, 0xf8, 0x7c, 0xe1, 0xb3, 0xe1, 0x13, 0xfc, 0xe6, 0x1f, 0x1f, 0x94, 0xbc, 0xfc, 0x00,
 0x70, 0xee, 0xd4, 0x3d, 0xd5, 0xa3, 0xc2, 0x8f, 0x79, 0x68, 0xe9, 0xfc, 0x9c, 0xfe, 0xe7, 0xc3,
 0xf5, 0x73, 0xdc, 0x7b, 0xfb, 0x7f, 0x1f, 0xd1, 0x0b, 0x89, 0xab, 0x89, 0x33, 0x46, 0xad, 0x1d,
 0x45, 0xb9, 0xeb, 0x42, 0xd1, 0x86, 0x89, 0x9c, 0x4d, 0x5c, 0x49, 0xb4, 0xc4, 0xa1, 0x68, 0xc3,
 0x44, 0xad, 0x1a, 0xb4, 0x4d, 0xad, 0x68, 0x9a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa2, 0x6d, 0x36,
 0x85, 0xa3, 0x0d, 0x13, 0x34, 0x6a, 0xe2, 0x5a, 0xd6, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a,
 0xd1, 0x36, 0x9b, 0x44, 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x13, 0x6b, 0x5b, 0x92, 0x8d, 0x42,
 0x58, 0xd4, 0x28, 0xa9, 0x70, 0x24, 0x8d, 0x43, 0xf3, 0x85, 0xbc, 0x31, 0x92, 0xf4, 0x6a, 0x12,
 0x46, 0xa6, 0xa5, 0x18, 0xd4, 0x24, 0x8d, 0x41, 0x6b, 0x46, 0x4b, 0xd1, 0xa9, 0xa9, 0x2c, 0x6a,
 0x6a, 0x50, 0x8d, 0x42, 0x58, 0xcc, 0xb5, 0xad, 0x19, 0x2f, 0x46, 0xa1, 0x24, 0x6a, 0x14, 0x23,
 0x32, 0x58, 0xd4, 0x16, 0xb4, 0x64, 0xbf, 0x1a, 0x9a, 0x92, 0x46, 0xa1, 0x42, 0x35, 0x09, 0x63,
 0x50, 0x9b, 0x5e, 0x32, 0x5f, 0x8d, 0x42, 0x48, 0xd4, 0x28, 0x46, 0xa1, 0x24, 0x6a, 0x13, 0x6b,
 0x46, 0x4f, 0x26, 0xdf, 0xa3, 0xe6, 0xda, 0xdc, 0x2b, 0xfe, 0xa1, 0x0f, 0x94, 0xa8, 0x74, 0x03,
 0xbd, 0x6f, 0xb1, 0xf3, 0x6d, 0x56, 0x15, 0xff, 0x00, 0x51, 0x87, 0xca, 0x54, 0x3a, 0x29, 0xd5,
 0xec, 0xbe, 0xc3, 0x1f, 0x73, 0xb1, 0xd8, 0xff, 0x00, 0xe9, 0xf0, 0xf7, 0x00, 0x03, 0xd4, 0xf5,
 0xbe, 0xbb, 0x8d, 0x4d, 0x49, 0x61, 0x53, 0x53, 0x8f, 0x8d, 0x42, 0x48, 0xd4, 0xd4, 0xe3, 0x6d,
 0xc5, 0xc6, 0x4e, 0x46, 0x35, 0x09, 0x63, 0x50, 0xe3, 0xa3, 0x50, 0x96, 0x35, 0x09, 0xb5, 0xe3,
 0x27, 0x23, 0x1a, 0x9a, 0x92, 0xc2, 0xa6, 0xa7, 0x1d, 0x1a, 0x84, 0xb1, 0xa8, 0x4d, 0xad, 0x19,
 0x39, 0x28, 0xd5, 0x25, 0x85, 0x5d, 0x4e, 0x36, 0x35, 0x09, 0x61, 0x50, 0x9b, 0x5e, 0x32, 0x72,
 0x70, 0xaa, 0x4b, 0x0a, 0xba, 0x9c, 0x64, 0x6a, 0x6a, 0x4d, 0x0a, 0xa4, 0xda, 0xf1, 0x93, 0x93,
 0x85, 0x53, 0x85, 0xde, 0x2d, 0x4e, 0x3b, 0xbb, 0xda, 0x45, 0xc7, 0xaf, 0x29, 0xc5, 0x7c, 0x8c,
 0x8b, 0x91, 0xaa, 0x71, 0x1b, 0xc1, 0xa9, 0xc7, 0x77, 0xfb, 0x44, 0xb8, 0xfd, 0xca, 0xc5, 0x7c,
 0x94, 0x8c, 0x9a, 0x73, 0xf4, 0xe1, 0x97, 0x4f, 0x2f, 0xa5, 0x0f, 0x8d, 0x00, 0x07, 0x54, 0xe9,
 0x03, 0xea, 0xaf, 0x32, 0x14, 0xf9, 0x77, 0x6d, 0x8f, 0x5e, 0xbb, 0xd5, 0xf9, 0x1a, 0x27, 0xca,
 0xa7, 0xd4, 0x3e, 0x64, 0xd9, 0xf2, 0xee, 0xeb, 0x1c, 0xbd, 0x76, 0xa9, 0xf2, 0x54, 0x4f, 0x16,
 0xff, 0x00, 0xec, 0x5e, 0x6d, 0xdc, 0xd6, 0x9b, 0xdc, 0xe1, 0x5b, 0x52, 0x78, 0x56, 0xd4, 0xe2,
 0x61, 0x57, 0x52, 0x68, 0x55, 0xd4, 0xd1, 0xdb, 0x59, 0x19, 0x39, 0x7a, 0x75, 0x89, 0xe9, 0xd6,
 0xd4, 0xe2, 0x21, 0x57, 0x52, 0x68, 0x56, 0x2d, 0x6c, 0x91, 0x9b, 0x98, 0xa7, 0x5b, 0x53, 0xc9,
 0xfc, 0xd4, 0x3b, 0xbf, 0xab, 0xb6, 0xfb, 0x19, 0x0c, 0xc7, 0x2b, 0xa2, 0xea, 0xe7, 0x39, 0x47,
 0x35, 0x5a, 0x30, 0x8a, 0xf4, 0xd5, 0xe9, 0x3e, 0x1c, 0xf4, 0xd7, 0x85, 0xf4, 0x29, 0x2d, 0x53,
 0x5f, 0x64, 0x7a, 0x3c, 0x2b, 0x13, 0xc2, 0xb6, 0xa6, 0x4d, 0x3d, 0x49, 0xc3, 0x28, 0xca, 0x19,
 0x70, 0xd4, 0xf3, 0x66, 0xdf, 0x9b, 0x4d, 0x34, 0xf8, 0x35, 0xc1, 0xa3, 0x07, 0xd5, 0xdb, 0xf5,
 0xdc, 0x55, 0x3d, 0xa2, 0xc5, 0x57, 0xda, 0x4d, 0x8d, 0x8d, 0x1c, 0x3e, 0x67, 0x51, 0xb9, 0xe2,
 0x70, 0x32, 0x6a, 0x14, 0xf1, 0x32, 0xef, 0xca, 0x0f, 0xaa, 0x33, 0x7d, 0xf4, 0xfa, 0x1f, 0x5f,
 0x43, 0xe3, 0xc7, 0xe5, 0xec, 0xeb, 0x29, 0xcc, 0xf2, 0x4c, 0xc2, 0xa6, 0x5f, 0x9b, 0xe0, 0x31,
 0x38, 0x1c, 0x5d, 0x37, 0xe9, 0xa9, 0x57, 0xa6, 0xe1, 0x25, 0xaf, 0x4f, 0x5a, 0xd7, 0xa8, 0xde,
 0xe8, 0xeb, 0xe1, 0xab, 0x17, 0x0d, 0x86, 0x1a, 0x91, 0x9c, 0x7a, 0x14, 0x80, 0x06, 0x65, 0xc0,
 0x0e, 0x4b, 0x67, 0x32, 0x0c, 0xeb, 0x68, 0xf3, 0x28, 0x65, 0xb9, 0x0e, 0x57, 0x8b, 0xcc, 0xb1,
 0x73, 0xea, 0xa5, 0x87, 0xa4, 0xe6, 0xd2, 0xf0, 0xbe, 0x1d, 0x4b, 0x57, 0xd0, 0x26, 0x68, 0x71,
 0xa7, 0x66, 0xcc, 0xf6, 0x13, 0x69, 0xf2, 0xdd, 0x81, 0xc0, 0x6d, 0xc6, 0x3f, 0x2c, 0xa9, 0x86,
 0xc9, 0x33, 0x1c, 0x53, 0xc2, 0xe1, 0x2b, 0x54, 0xe8, 0x75, 0x64, 0xa2, 0xe5, 0xcc, 0xa3, 0xd7,
 0xca, 0xd4, 0x65, 0xc1, 0xf7, 0xf8, 0x3e, 0x1d, 0x47, 0xd2, 0xdb, 0x8b, 0xf3, 0x31, 0x61, 0xb0,
 0x18, 0x8c, 0x3e, 0x7d, 0xbc, 0x87, 0x47, 0x17, 0x5a, 0x0d, 0x4e, 0x96, 0x4f, 0x4e, 0x4a, 0x54,
 0xa2, 0xfb, 0xd7, 0xa4, 0xba, 0x27, 0xfd, 0x95, 0xe9, 0x7c, 0x2e, 0x4b, 0xa0, 0xf5, 0xdf, 0x35,
 0x1e, 0xce, 0x43, 0x69, 0xb7, 0x0d, 0x9e, 0x65, 0xf8, 0x5a, 0x11, 0x55, 0x72, 0xda, 0x31, 0xc7,
 0xe1, 0x21, 0x08, 0xf0, 0x50, 0xb1, 0xd2, 0xd4, 0x52, 0xff, 0x00, 0xf1, 0xf3, 0xc5, 0x25, 0xe1,
 0x3c, 0x99, 0x6e, 0xf1, 0xf3, 0xe3, 0x1c, 0x51, 0x19, 0x43, 0xf3, 0x98, 0x00, 0x7a, 0xd2, 0xef,
 0x1b, 0x84, 0xce, 0xa1, 0xb3, 0xfb, 0xe3, 0xd9, 0x7c, 0xce, 0xac, 0xd4, 0x29, 0x2c, 0x7c, 0x28,
 0x55, 0x93, 0xea, 0x8c, 0x2a, 0xa7, 0x4a, 0x4d, 0xe8, 0x94, 0xdb, 0x3f, 0x46, 0xaa, 0xe1, 0x74,
 0x3f, 0x2b, 0xa2, 0xdc, 0x64, 0xa5, 0x16, 0xd3, 0x4f, 0x8a, 0x6b, 0xbc, 0x7e, 0x9c, 0x6e, 0x43,
 0x6a, 0x29, 0xed, 0xf6, 0xea, 0xb2, 0x3d, 0xa4, 0x55, 0x23, 0x3c, 0x4d, 0x6c, 0x3a, 0xa5, 0x8c,
 0x4b, 0xae, 0x38, 0x88, 0x7a, 0x5a, 0x9c, 0x57, 0x7b, 0x8c, 0x93, 0x92, 0xd2, 0x48, 0xc5, 0xa9,
 0x97, 0x9b, 0x52, 0xd5, 0xf1, 0x0d, 0xa7, 0x3a, 0xb2, 0x5f, 0xa9, 0x41, 0xae, 0xf1, 0x04, 0xe9,
 0x68, 0x76, 0x2a, 0xd8, 0x4e, 0xbe, 0x82, 0x9d, 0x6c, 0x26, 0x83, 0x1d, 0x57, 0x3f, 0xab, 0xb2,
 0x98, 0x7e, 0x68, 0x6f, 0x71, 0x70, 0xde, 0xb6, 0xd7, 0xaf, 0x06, 0x79, 0x8d, 0xf9, 0x79, 0x9d,
 0x5c, 0xed, 0x5b, 0xe1, 0x5c, 0xbb, 0xdc, 0xdb, 0x18, 0xf8, 0x33, 0xec, 0x72, 0xfc, 0xe2, 0x67,
 0x55, 0x32, 0xbb, 0x0d, 0x28, 0xad, 0x3c, 0x63, 0xf2, 0x80, 0xf6, 0x8f, 0x31, 0xdc, 0x79, 0xb7,
 0xab, 0x89, 0x5e, 0xb4, 0xd6, 0xf9, 0x4a, 0x47, 0x8b, 0x9e, 0xdb, 0xe6, 0x31, 0x8f, 0x36, 0xf6,
 0xb1, 0x4b, 0xd6, 0x8a, 0xdf, 0x29, 0x48, 0x9c, 0x66, 0xa5, 0xe4, 0xe2, 0x91, 0xe7, 0x6c, 0xf5,
 0x23, 0xf2, 0x7d, 0x69, 0x3a, 0x3a, 0x10, 0x4e, 0x8e, 0x87, 0x2d, 0x3a, 0x5a, 0x10, 0xce, 0x96,
 0x87, 0xa6, 0x33, 0x7c, 0xc7, 0x53, 0x6e, 0xe2, 0x67, 0x47, 0x42, 0x19, 0xd2, 0xd0, 0xe5, 0x67,
 0x4b, 0x42, 0x19, 0xd2, 0xd0, 0xc9, 0x19, 0xbc, 0x79, 0xed, 0xdf, 0x9c, 0x40, 0x03, 0xc2, 0xfb,
 0x48, 0x7b, 0xe7, 0x99, 0x12, 0x3c, 0xdf, 0xc2, 0x8f, 0xfd, 0x27, 0xfd, 0x63, 0xc0, 0xcf, 0xa0,
 0x7c, 0xc7, 0x91, 0xe6, 0x5b, 0x53, 0xa7, 0x9c, 0xff, 0x00, 0xeb, 0x99, 0xb6, 0xf3, 0x5a, 0x90,
 0xd0, 0x79, 0x4f, 0xff, 0x00, 0xb5, 0xea, 0xff, 0x00, 0xb7, 0xff, 0x00, 0x28, 0x7b, 0xa4, 0xa0,
 0x47, 0x28, 0x17, 0xa5, 0x4f, 0x42, 0x39, 0x53, 0x36, 0x91, 0x93, 0xe4, 0xb1, 0x92, 0x8c, 0xa9,
 0x9d, 0x7b, 0x78, 0xb0, 0xe1, 0xb0, 0x1b, 0x44, 0xfd, 0x6a, 0xc4, 0xfc, 0x94, 0x8e, 0xd7, 0x2a,
 0x67, 0x5c, 0xde, 0x3c, 0x38, 0x6e, 0xf7, 0x68, 0xdf, 0xad, 0x58, 0xaf, 0x92, 0x91, 0x39, 0x65,
 0xf4, 0x65, 0xea, 0xda, 0x65, 0xfe, 0xbe, 0x1e, 0xf8, 0xf9, 0xbe, 0x2b, 0x00, 0x1a, 0x47, 0xdb,
 0xc3, 0xe8, 0x6f, 0x33, 0x54, 0x78, 0xec, 0x26, 0x35, 0xfa, 0xe7, 0x53, 0xe4, 0xa9, 0x1f, 0x3c,
 0x9f, 0x46, 0xf9, 0x98, 0xe3, 0xc7, 0x60, 0x71, 0xdf, 0xfe, 0xd2, 0xa7, 0xc9, 0x52, 0x3d, 0x9b,
 0x19, 0xad, 0x57, 0x3b, 0xe5, 0x44, 0xd6, 0xc2, 0x7d, 0xf0, 0xf4, 0x79, 0x53, 0x23, 0x95, 0x32,
 0xf4, 0xa9, 0xe8, 0x47, 0x2a, 0x66, 0xee, 0x32, 0x7c, 0xda, 0x33, 0x51, 0x95, 0x33, 0xac, 0x6f,
 0x07, 0x64, 0xb0, 0xbb, 0x57, 0x91, 0xcb, 0x05, 0x55, 0xaa, 0x58, 0x9a, 0x7c, 0x67, 0x86, 0xad,
 0xc3, 0xfd, 0x5c, 0xf5, 0xfe, 0x8b, 0xea, 0x6b, 0xb1, 0x1d, 0xc6, 0x50, 0x22, 0x95, 0x32, 0x72,
 0xac, 0xf1, 0x9c, 0x72, 0xf5, 0x33, 0xe8, 0x6e, 0x33, 0xd1, 0xce, 0x35, 0x30, 0x9a, 0x98, 0x7c,
 0x77, 0x9d, 0xe5, 0x58, 0xfc, 0x97, 0x33, 0xad, 0x97, 0x66, 0x58, 0x79, 0x50, 0xc4, 0x52, 0x7c,
 0x25, 0x17, 0xd4, 0xd7, 0x79, 0xa7, 0xdf, 0x4f, 0xc2, 0x52, 0x3e, 0xaf, 0xdb, 0x4d, 0x8f, 0xca,
 0x36, 0xab, 0x03, 0x63, 0x31, 0xa2, 0xd5, 0x58, 0x2f, 0xa8, 0xe2, 0x29, 0xf4, 0x54, 0xa6, 0xf4,
 0x7d, 0xf5, 0xa3, 0xe8, 0x3c, 0x23, 0x6b, 0xf7, 0x63, 0xb4, 0xb9, 0x0c, 0xe7, 0x56, 0x8e, 0x1e,
 0x59, 0x9e, 0x09, 0x74, 0xaa, 0xd8, 0x68, 0xb7, 0x24, 0xbf, 0xa5, 0x0e, 0xb5, 0xed, 0x71, 0x5a,
 0x9a, 0x4d, 0xc6, 0xcb, 0x3d, 0x39, 0xbc, 0x7d, 0x30, 0xfa, 0x2f, 0x0c, 0xe3, 0xfa, 0x1b, 0xbc,
 0x63, 0x1d, 0x49, 0xf3, 0x73, 0xf6, 0x7d, 0xd3, 0xee, 0xfd, 0x9d, 0x1c, 0x19, 0x92, 0x71, 0x6d,
 0x34, 0xd3, 0x5d, 0x0d, 0x3e, 0xf1, 0x83, 0xc4, 0xdf, 0x80, 0x00, 0x00, 0x1d, 0xab, 0x65, 0xb6,
 0x0f, 0x68, 0x33, 0xe9, 0x42, 0xa4, 0x70, 0xb2, 0xc1, 0xe1, 0x1f, 0x4b, 0xc4, 0x62, 0x22, 0xe2,
 0x9a, 0xfe, 0x8a, 0xeb, 0x97, 0xb5, 0xd1, 0xa9, 0x7d, 0x3d, 0x3c, 0xf5, 0x26, 0xb1, 0x8b, 0x96,
 0x2d, 0x6d, 0x7d, 0x3d, 0x0c, 0x7c, 0xed, 0x4c, 0xaa, 0x1d, 0x7b, 0x2d, 0xc0, 0xe2, 0xb3, 0x2c,
 0x6d, 0x2c, 0x16, 0x0a, 0x8c, 0xab, 0x57, 0xaa, 0xf8, 0x46, 0x31, 0x5f, 0x0e, 0x8b, 0x53, 0xdd,
 0xf6, 0x27, 0x66, 0xa8, 0xec, 0xde, 0x52, 0xb0, 0xe9, 0xc6, 0xa6, 0x2a, 0xaf, 0x09, 0x62, 0x2a,
 0xa5, 0xf5, 0xd2, 0xf0, 0x2d, 0x17, 0x7b, 0xdd, 0xef, 0x97, 0xb6, 0x47, 0x64, 0x72, 0xcd, 0x9a,
 0xc2, 0xb8, 0x61, 0x20, 0xea, 0xe2, 0x26, 0xb8, 0x55, 0xc4, 0x4d, 0x7a, 0x79, 0xe9, 0xa2, 0xd1,
 0x7c, 0x27, 0x35, 0x2a, 0x67, 0x49, 0xc3, 0xf6, 0x31, 0xb7, 0xfa, 0x79, 0xfd, 0x6f, 0x93, 0x8a,
 0xe2, 0xbc, 0x67, 0xc5, 0xcf, 0x2f, 0x4f, 0xd1, 0x87, 0xcd, 0x51, 0xa3, 0x57, 0x12, 0xcc, 0xa9,
 0x91, 0xb8, 0x1b, 0x78, 0x96, 0x96, 0x32, 0x40, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xae, 0x24, 0xda,
 0xd6, 0x89, 0xc4, 0xd5, 0xa2, 0x67, 0x13, 0x56, 0x8b, 0x5a, 0xd6, 0x85, 0xc4, 0xc3, 0x44, 0xad,
 0x18, 0x68, 0x9b, 0x4c, 0x4a, 0x17, 0x13, 0x56, 0x89, 0xb8, 0x1a, 0xb4, 0x4d, 0xa6, 0xd1, 0x34,
 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x45, 0xad, 0x6b, 0x42, 0xd1, 0x86, 0x89, 0x5a, 0x30, 0xd1, 0x36,
 0x9b, 0x42, 0xe2, 0x79, 0xe6, 0xf9, 0x17, 0x0e, 0xe5, 0x7e, 0x3b, 0xf7, 0x0f, 0x47, 0x68, 0xf3,
 0xad, 0xf3, 0xae, 0x1d, 0xc9, 0xfc, 0x77, 0xee, 0x1a, 0xee, 0x2f, 0x3f, 0xc9, 0xe7, 0xf0, 0xf9,
 0xc3, 0x69, 0xc1, 0xe7, 0xf9, 0xcc, 0x3e, 0x3f, 0x29, 0x79, 0xd8, 0x00, 0xe2, 0x9d, 0xb8, 0x7b,
 0xeb, 0x89, 0xe0, 0x47, 0xd0, 0x2d, 0x1d, 0x2f, 0x93, 0xbf, 0xdc, 0xf8, 0x7e, 0xae, 0x73, 0xca,
 0x0f, 0xed, 0xfc, 0x7f, 0x44, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x89, 0xd3, 0x5b, 0x9d, 0xb4,
 0x4d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x44, 0xda, 0x6d, 0x0b, 0x46, 0x1c, 0x49, 0x5a, 0x30, 0xd1,
 0x6b, 0x4d, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0x6d, 0x68, 0x94, 0x4d, 0x1a, 0xb4,
 0x4c, 0xe2, 0x6a, 0xd1, 0x6b, 0x4d, 0xa1, 0x68, 0xc3, 0x44, 0xad, 0x18, 0x68, 0x9b, 0x5a, 0xd0,
 0xb8, 0x9a, 0xb8, 0x93, 0x34, 0x6a, 0xd1, 0x36, 0x9b, 0x7d, 0xb3, 0xfe, 0x8f, 0x7b, 0xae, 0xf1,
 0x36, 0x2b, 0xdf, 0xd5, 0x7e, 0x70, 0xff, 0x00, 0x47, 0xcd, 0xd7, 0x78, 0x9b, 0x15, 0xef, 0xea,
 0xbf, 0x38, 0xf5, 0x4e, 0x74, 0x39, 0x91, 0xf2, 0x4f, 0x09, 0xa1, 0xd1, 0x1d, 0x9d, 0x9f, 0x81,
 0xdb, 0x7e, 0x1c, 0x76, 0x87, 0x96, 0x7f, 0xa3, 0xee, 0xeb, 0xfc, 0x4d, 0x8a, 0xf7, 0xf5, 0x5f,
 0x9c, 0x65, 0x79, 0x9f, 0xf7, 0x60, 0xbe, 0xe3, 0xe2, 0xbd, 0xfd, 0x57, 0xe7, 0x1e, 0xa5, 0xcc,
 0x8c, 0xf3, 0x21, 0xe1, 0x34, 0x3a, 0x23, 0xb1, 0xe0, 0x76, 0xdf, 0x87, 0x1d, 0xa1, 0xe5, 0xab,
 0x70, 0x1b, 0xb1, 0x5f, 0x71, 0xf1, 0x5e, 0xfe, 0xab, 0xf3, 0x8d, 0x96, 0xe0, 0xb7, 0x64, 0xbe,
 0xe3, 0xe2, 0xbd, 0xfd, 0x57, 0xe7, 0x1e, 0xa1, 0xcc, 0x8c, 0x73, 0xa1, 0xe1, 0x34, 0x3a, 0x23,
 0xb1, 0xe0, 0xb6, 0xdf, 0x87, 0x1d, 0xa1, 0xe6, 0x2b, 0x70, 0x9b, 0xb3, 0x5f, 0x72, 0x31, 0x5e,
 0xfe, 0xab, 0xf3, 0x8c, 0xfa, 0x03, 0x6e, 0xd7, 0xc5, 0x18, 0x9f, 0x7e, 0xd5, 0xf9, 0xc7, 0xa6,
 0xf3, 0x23, 0x3c, 0xc8, 0x78, 0x4d, 0x0e, 0x88, 0xec, 0x78, 0x2d, 0xbf, 0x44, 0x76, 0x87, 0x99,
 0x2d, 0xc4, 0x6e, 0xd9, 0x7d, 0xc8, 0xc4, 0xfb, 0xf6, 0xaf, 0xce, 0x32, 0xb7, 0x15, 0xbb, 0x75,
 0xf7, 0x27, 0x13, 0xef, 0xda, 0xbf, 0x38, 0xf4, 0xbe, 0x64, 0x39, 0x90, 0xf0, 0x9a, 0x1d, 0x11,
 0xd9, 0x3e, 0x0b, 0x6f, 0xd1, 0x1d, 0xa1, 0xe6, 0xcb, 0x71, 0x7b, 0xb8, 0x5f, 0x72, 0x71, 0x3e,
 0xfd, 0xab, 0xf3, 0x8c, 0xad, 0xc6, 0xee, 0xe7, 0xc5, 0x38, 0x9f, 0x7e, 0xd5, 0xf9, 0xc7, 0xa4,
 0xf3, 0x21, 0xcc, 0x87, 0x84, 0xd0, 0xe8, 0x8e, 0xc7, 0x83, 0xdb, 0xf4, 0x47, 0x67, 0x82, 0x6d,
 0xc6, 0xe9, 0xb6, 0x0f, 0x2f, 0xcd, 0xa9, 0x51, 0xa3, 0x93, 0x4e, 0x51, 0x74, 0x14, 0x9f, 0x3e,
 0x2e, 0xab, 0x7c, 0x79, 0xa4, 0xbf, 0x8d, 0xa1, 0xc1, 0x2d, 0xda, 0xec, 0x52, 0xfb, 0x8b, 0xf9,
 0xd5, 0x6f, 0x9e, 0x7a, 0xae, 0xf2, 0xa4, 0xbb, 0xbb, 0x47, 0xf0, 0x68, 0xfc, 0x69, 0x1d, 0x5f,
 0x99, 0x16, 0x8d, 0xbe, 0x94, 0x7f, 0x4c, 0x76, 0x5e, 0x36, 0xda, 0x31, 0xea, 0xc2, 0x3b, 0x43,
 0xa9, 0xfa, 0x1b, 0x6c, 0x5f, 0x89, 0xbf, 0x3a, 0xad, 0xf3, 0xc7, 0xa1, 0xc6, 0xc6, 0x78, 0x9b,
 0xf3, 0xaa, 0xdf, 0x3c, 0xed, 0x9c, 0xc8, 0x73, 0x22, 0x79, 0x1a, 0x5d, 0x31, 0xd9, 0x3e, 0x1f,
 0x4b, 0xa6, 0x3b, 0x3b, 0x42, 0xdc, 0xbe, 0xef, 0xd7, 0xdc, 0xbc, 0x47, 0xbe, 0xea, 0x76, 0x9b,
 0x2d, 0xcc, 0xec, 0x02, 0xfb, 0x99, 0x88, 0xf7, 0xdd, 0x4e, 0xd3, 0xd0, 0x79, 0x91, 0x8e, 0x64,
 0x57, 0xc2, 0xe8, 0xf4, 0x47, 0x65, 0x3c, 0x26, 0x87, 0x44, 0x76, 0x74, 0x05, 0xb9, 0xbd, 0x82,
 0x5f, 0x73, 0x31, 0x1e, 0xfb, 0xa9, 0xda, 0x67, 0xd0, 0x77, 0x60, 0xfc, 0x59, 0x88, 0xf7, 0xdd,
 0x4e, 0xd3, 0xbf, 0x73, 0x21, 0xcc, 0x87, 0x85, 0xd1, 0xe8, 0x8e, 0xc7, 0x85, 0xd0, 0xe8, 0x8e,
 0xce, 0x86, 0xb7, 0x3f, 0xb0, 0x8b, 0xee, 0x6e, 0x23, 0xdf, 0x75, 0x3b, 0x4c, 0xad, 0xd0, 0xec,
 0x32, 0xfb, 0x9b, 0x5f, 0xdf, 0x55, 0x3b, 0x4e, 0xf7, 0xcc, 0x8c, 0xf3, 0x21, 0xe1, 0x74, 0x7a,
 0x23, 0xb2, 0x7c, 0x2e, 0x8f, 0x44, 0x76, 0x74, 0x55, 0xba, 0x4d, 0x87, 0x5f, 0x73, 0xab, 0xfb,
 0xea, 0xa7, 0x69, 0x95, 0xba, 0x6d, 0x88, 0x5f, 0x73, 0xab, 0xfb, 0xea, 0xa7, 0x69, 0xde, 0x79,
 0x90, 0xe6, 0x43, 0xc3, 0x68, 0xf4, 0xc7, 0x63, 0xc3, 0x68, 0xf4, 0xc7, 0x67, 0x47, 0x5b, 0xa8,
 0xd8, 0xa5, 0xf7, 0x3a, 0xbf, 0xbe, 0xaa, 0x76, 0x9b, 0x2d, 0xd5, 0x6c, 0x5a, 0xfb, 0x9f, 0x5f,
 0xdf, 0x33, 0xed, 0x3b, 0xaf, 0x32, 0x1c, 0xc8, 0x78, 0x6d, 0x1e, 0x98, 0xec, 0x9f, 0x0d, 0xa5,
 0xd3, 0x1d, 0x9d, 0x2d, 0x6e, 0xb7, 0x63, 0x17, 0xdc, 0xfa, 0xfe, 0xf9, 0x9f, 0x69, 0x47, 0x69,
 0x77, 0x55, 0xb1, 0x35, 0xf6, 0x6f, 0x33, 0xa1, 0x5b, 0x2c, 0xad, 0x52, 0x95, 0x4c, 0x1d, 0x58,
 0x4e, 0x2f, 0x15, 0x51, 0x73, 0x45, 0xc1, 0xa6, 0xb8, 0xa9, 0x71, 0xf7, 0x0f, 0x42, 0xe6, 0x45,
 0x2c, 0xfe, 0x4b, 0xb8, 0x59, 0x87, 0xe0, 0xd5, 0x3e, 0x2b, 0x26, 0x36, 0xfa, 0x51, 0xfd, 0x31,
 0xd8, 0x8d, 0xbe, 0x94, 0x7f, 0x4c, 0x3e, 0x58, 0xf4, 0x07, 0xdd, 0x47, 0xde, 0xaf, 0xe9, 0x0c,
 0x57, 0xd2, 0x0f, 0x40, 0x7d, 0xd4, 0x7d, 0xea, 0xfe, 0x90, 0xc5, 0x7d, 0x21, 0xe9, 0x5c, 0xc8,
 0x73, 0x23, 0x33, 0x33, 0xcd, 0x7d, 0x01, 0xf7, 0x51, 0xf7, 0xab, 0xfa, 0x43, 0x15, 0xf4, 0x87,
 0xab, 0x6e, 0x83, 0x74, 0xdb, 0x09, 0x95, 0x6c, 0xd6, 0x23, 0x0f, 0x96, 0xe4, 0xf5, 0x30, 0xb4,
 0x65, 0x8c, 0x94, 0xdc, 0x23, 0x8b, 0xab, 0x2e, 0x32, 0xe4, 0x82, 0xe3, 0xc6, 0x52, 0x6f, 0xa9,
 0x22, 0x9f, 0x32, 0x3d, 0x0f, 0x76, 0xb2, 0x5d, 0xc2, 0xad, 0xf8, 0x4c, 0xbe, 0x2c, 0x4a, 0xe5,
 0x86, 0x39, 0xc5, 0x65, 0x16, 0xae, 0x58, 0xc6, 0x51, 0x53, 0x0d, 0x16, 0xee, 0xf6, 0x55, 0x7d,
 0xa5, 0x57, 0xdf, 0x13, 0xed, 0x36, 0x5b, 0xbe, 0xd9, 0x75, 0xf6, 0x9d, 0x5f, 0x2f, 0x3e, 0xd3,
 0xb4, 0xf3, 0x23, 0x1c, 0xe8, 0xc7, 0xe1, 0xf4, 0xba, 0x63, 0xb2, 0x9c, 0x9d, 0x3e, 0x98, 0x75,
 0x85, 0xb0, 0x3b, 0x32, 0xbe, 0xd3, 0xab, 0xe5, 0xe7, 0xda, 0x6c, 0xb6, 0x0f, 0x66, 0x97, 0xda,
 0x95, 0x7c, 0xbc, 0xbb, 0x4e, 0xcd, 0xcc, 0x87, 0x32, 0x1e, 0x1f, 0x4b, 0xa6, 0x3b, 0x27, 0x93,
 0xa7, 0xec, 0x87, 0x5b, 0x5b, 0x0d, 0xb3, 0x8b, 0xed, 0x4a, 0xbe, 0x5a, 0x5d, 0xa6, 0xcb, 0x62,
 0x76, 0x79, 0x75, 0x61, 0x6a, 0xf9, 0x69, 0x76, 0x9d, 0x87, 0x99, 0x1c, 0x6e, 0xd1, 0xe6, 0xf4,
 0xf2, 0x9c, 0xb6, 0x78, 0x87, 0xc2, 0x55, 0x65, 0xe9, 0x69, 0x45, 0xfd, 0x94, 0xbb, 0x17, 0x58,
 0xf0, 0xfa, 0x5d, 0x31, 0xd8, 0xe5, 0x61, 0xec, 0x75, 0xcd, 0xa0, 0xca, 0xb6, 0x53, 0x26, 0xa6,
 0x95, 0x4c, 0x35, 0x5a, 0xb8, 0x89, 0x2e, 0x30, 0xa5, 0x1a, 0xf2, 0xe2, 0xf5, 0x7d, 0x3d, 0x08,
 0xf2, 0xfd, 0xba, 0xd9, 0x0d, 0x98, 0xdb, 0x4c, 0x3c, 0x30, 0xb9, 0xfe, 0x51, 0x1c, 0x46, 0x1a,
 0x94, 0xb9, 0xa9, 0xd2, 0x8e, 0x22, 0xac, 0x39, 0x5f, 0xb3, 0x19, 0x26, 0xce, 0x7f, 0x15, 0x89,
 0xab, 0x8a, 0xc4, 0x4f, 0x11, 0x88, 0xa8, 0xea, 0x55, 0x9b, 0xe3, 0x29, 0x3e, 0xf9, 0x1f, 0x32,
 0x2d, 0x8e, 0x8e, 0x9e, 0x33, 0x71, 0x8c, 0x26, 0x30, 0xc6, 0x3d, 0x31, 0x0f, 0x35, 0xf4, 0x07,
 0xdd, 0x47, 0xde, 0xaf, 0xe9, 0x0c, 0x57, 0xd2, 0x0f, 0x40, 0x7d, 0xd4, 0x7d, 0xea, 0xfe, 0x90,
 0xc5, 0x7d, 0x21, 0xe9, 0x5c, 0xc8, 0x73, 0x23, 0x22, 0xef, 0x35, 0xf4, 0x07, 0xdd, 0x47, 0xde,
 0xaf, 0xe9, 0x0c, 0x57, 0xd2, 0x1d, 0xf7, 0x60, 0xf2, 0x4c, 0x93, 0x62, 0xb2, 0xf5, 0x96, 0xe4,
 0x39, 0x6c, 0x68, 0x60, 0x14, 0xb9, 0x9d, 0x09, 0x56, 0xa9, 0x3e, 0x9f, 0xed, 0x4a, 0x4d, 0xfc,
 0x25, 0xde, 0x64, 0x39, 0x91, 0x5c, 0xb1, 0x8c, 0xa2, 0xa6, 0x11, 0x31, 0x12, 0xf4, 0x0d, 0x9f,
 0x9e, 0xcf, 0xe6, 0xa9, 0x53, 0x85, 0x39, 0xd1, 0xc4, 0xf0, 0xe9, 0xa3, 0x3a, 0x8f, 0x8b, 0xf6,
 0x1f, 0x7c, 0xb1, 0xb5, 0x19, 0x66, 0x59, 0x86, 0xd9, 0xec, 0x74, 0xea, 0x51, 0x94, 0xa3, 0x2a,
 0x2e, 0x9f, 0x07, 0x51, 0xf4, 0xf3, 0x7a, 0x5f, 0x0e, 0xa7, 0x9c, 0x42, 0xa4, 0xa9, 0xce, 0x33,
 0x84, 0x9c, 0x65, 0x17, 0xc5, 0x49, 0x3e, 0x0d, 0x33, 0x9a, 0xcd, 0x76, 0x93, 0x11, 0x99, 0x64,
 0x94, 0xb0, 0x18, 0x85, 0xc6, 0xac, 0x2a, 0x29, 0x4a, 0xa2, 0xfb, 0x34, 0x97, 0x47, 0x1d, 0x7a,
 0x4a, 0x72, 0x74, 0xfa, 0x60, 0xf3, 0x61, 0xe3, 0x5e, 0x80, 0xfb, 0xa8, 0xfb, 0xd5, 0xfd, 0x21,
 0x8a, 0xfa, 0x41, 0xe8, 0x0f, 0xba, 0x8f, 0xbd, 0x5f, 0xd2, 0x18, 0xaf, 0xa4, 0x3d, 0x2b, 0x99,
 0x0e, 0x64, 0x65, 0x4b, 0xcd, 0x7d, 0x01, 0xf7, 0x51, 0xf7, 0xab, 0xfa, 0x43, 0x15, 0xf4, 0x87,
 0xbe, 0xee, 0x77, 0x77, 0xbb, 0x37, 0xb0, 0x7b, 0x1b, 0x0c, 0xaf, 0x20, 0xcb, 0x5e, 0x06, 0x86,
 0x2a, 0xb3, 0xc6, 0x55, 0xa7, 0x7e, 0xa5, 0x4f, 0xaa, 0x4a, 0x31, 0x5c, 0x78, 0xce, 0x4d, 0xaf,
 0x4b, 0x18, 0xae, 0x1a, 0x1d, 0x5f, 0x26, 0xc3, 0xac, 0x66, 0x6b, 0x85, 0xc2, 0xbf, 0xad, 0xa9,
 0x55, 0x29, 0x7b, 0x1c, 0x7a, 0x7e, 0x0e, 0x27, 0xaf, 0xa9, 0x24, 0xb8, 0x25, 0xc1, 0x11, 0x31,
 0x13, 0xe8, 0x91, 0x04, 0xb0, 0x18, 0x69, 0x75, 0xd3, 0x7e, 0xeb, 0x23, 0x96, 0x57, 0x82, 0x97,
 0x5d, 0x27, 0xf9, 0x4c, 0xb7, 0xce, 0x8c, 0xf3, 0x22, 0x3c, 0xcc, 0x7d, 0x8a, 0x4e, 0x9e, 0x13,
 0xeb, 0x87, 0xcb, 0xfb, 0x61, 0xb9, 0x3d, 0xd8, 0xe6, 0x3b, 0x5d, 0x9c, 0xe6, 0x18, 0xdd, 0x99,
 0xbb, 0x89, 0xc5, 0x63, 0xeb, 0xd6, 0xad, 0x3f, 0x3f, 0x62, 0x63, 0xcd, 0x39, 0x54, 0x93, 0x93,
 0xe0, 0xaa, 0x24, 0xb8, 0xb6, 0xfa, 0x12, 0xe0, 0x71, 0x5e, 0x80, 0xfb, 0xa8, 0xfb, 0xd5, 0xfd,
 0x21, 0x8a, 0xfa, 0x43, 0xd5, 0xf3, 0xf9, 0x2e, 0xee, 0xe6, 0x1f, 0x85, 0x54, 0xf8, 0xcc, 0xa5,
 0xcc, 0x8b, 0x2e, 0xf3, 0x5f, 0x40, 0x7d, 0xd4, 0x7d, 0xea, 0xfe, 0x90, 0xc5, 0x7d, 0x21, 0xdd,
 0xf7, 0x2d, 0xba, 0x3d, 0xdf, 0x6c, 0xf6, 0xd7, 0x55, 0xc7, 0x64, 0xd9, 0x0b, 0xc2, 0x62, 0x65,
 0x83, 0x9d, 0x37, 0x35, 0x8c, 0xaf, 0x3f, 0x4a, 0xe5, 0x06, 0xd7, 0x09, 0xcd, 0xae, 0xf2, 0xef,
 0x1c, 0x9f, 0x32, 0x3b, 0x2e, 0xee, 0x24, 0xbb, 0xbf, 0x3f, 0xc1, 0xe5, 0xfa, 0xe2, 0x15, 0xcb,
 0x1c, 0x73, 0x8f, 0x37, 0x28, 0xb8, 0x76, 0xd7, 0xb2, 0xd9, 0x33, 0xeb, 0xc3, 0xcf, 0xca, 0x4b,
 0xb4, 0xd5, 0xec, 0x9e, 0x48, 0xfe, 0xd6, 0x9f, 0x95, 0x97, 0x69, 0xcd, 0xf3, 0x21, 0xcc, 0x89,
 0xb7, 0x9b, 0xc0, 0x6d, 0xa7, 0xfb, 0x71, 0xda, 0x1c, 0x13, 0xd9, 0x1c, 0x89, 0xf5, 0xe1, 0xa7,
 0xe5, 0x65, 0xda, 0x6a, 0xf6, 0x3b, 0x21, 0x7d, 0x78, 0x59, 0xf9, 0x59, 0x76, 0x9c, 0xff, 0x00,
 0x32, 0x1c, 0xc8, 0x79, 0xd2, 0x8f, 0xe1, 0xdb, 0x49, 0xfe, 0xd6, 0x3d, 0xa1, 0xf2, 0x57, 0xa0,
 0x3e, 0xea, 0x3e, 0xf5, 0x7f, 0x48, 0x62, 0xbe, 0x90, 0x7a, 0x03, 0xee, 0xa3, 0xef, 0x57, 0xf4,
 0x86, 0x2b, 0xe9, 0x0f, 0x4a, 0xe6, 0x43, 0x99, 0x10, 0xf6, 0x3c, 0xd7, 0xd0, 0x1f, 0x75, 0x1f,
 0x7a, 0xbf, 0xa4, 0x31, 0x5f, 0x48, 0x7a, 0x3e, 0xe4, 0xf7, 0x49, 0xb0, 0x39, 0x27, 0x75, 0xfb,
 0x93, 0x92, 0x4b, 0x09, 0x7a, 0xcd, 0xde, 0x18, 0xba, 0xd3, 0xe6, 0xe5, 0xb9, 0xc3, 0xeb, 0xe6,
 0xf8, 0x75, 0xbe, 0xaf, 0x09, 0xbf, 0x32, 0x3b, 0xae, 0xeb, 0xa4, 0xbd, 0x51, 0xfc, 0x57, 0xef,
 0x93, 0x13, 0x31, 0xe9, 0x86, 0x3d, 0x5d, 0x1d, 0x3d, 0x6c, 0x27, 0x0d, 0x48, 0x89, 0x89, 0xfb,
 0xa7, 0xd4, 0xbc, 0xf6, 0x03, 0x66, 0x1f, 0xda, 0x75, 0x7c, 0xbc, 0xfb, 0x4c, 0x3d, 0xdf, 0x6c,
 0xbb, 0xfb, 0x4a, 0xaf, 0x97, 0x9f, 0x69, 0xda, 0x79, 0x91, 0x8e, 0x74, 0x5b, 0x99, 0x9f, 0xb5,
 0xe2, 0xfe, 0x0f, 0xb0, 0xfc, 0x1c, 0x7f, 0xfd, 0x61, 0xd5, 0x5e, 0xef, 0x36, 0x57, 0xf9, 0x95,
 0x5f, 0x2f, 0x3e, 0xd3, 0x8d, 0xda, 0x8d, 0xda, 0x6c, 0x7e, 0x27, 0x66, 0xb3, 0x4c, 0x3e, 0x23,
 0x2e, 0xa9, 0x52, 0x8d, 0x5c, 0x1d, 0x68, 0x54, 0x83, 0xc4, 0x54, 0x5c, 0xd1, 0x70, 0x69, 0xae,
 0x29, 0xf1, 0xea, 0xf0, 0x1d, 0xf7, 0x99, 0x14, 0x73, 0xf9, 0x2e, 0xe1, 0x66, 0x1f, 0x83, 0x54,
 0xf8, 0xac, 0x73, 0x73, 0xf6, 0xa7, 0x1e, 0x13, 0xb1, 0xc6, 0x6e, 0x34, 0x71, 0xbf, 0x74, 0x3e,
 0x58, 0xf4, 0x07, 0xdd, 0x47, 0xde, 0xaf, 0xe9, 0x0c, 0x57, 0xd2, 0x0f, 0x40, 0x7d, 0xd4, 0x7d,
 0xea, 0xfe, 0x90, 0xc5, 0x7d, 0x21, 0xe9, 0x5c, 0xc8, 0x73, 0x22, 0x8d, 0x83, 0xcd, 0x7d, 0x01,
 0xf7, 0x51, 0xf7, 0xab, 0xfa, 0x43, 0x15, 0xf4, 0x87, 0xa9, 0x6e, 0x8f, 0x74, 0x5b, 0x03, 0x96,
 0xec, 0xde, 0x22, 0x86, 0x5f, 0x93, 0x54, 0xc3, 0x52, 0x96, 0x32, 0x53, 0x70, 0x8e, 0x2e, 0xb4,
 0xb8, 0xcb, 0x92, 0x0b, 0x8f, 0x19, 0x49, 0xbe, 0xa4, 0x8a, 0xfc, 0xc8, 0xf4, 0x2d, 0xda, 0xc9,
 0x2c, 0x8a, 0xbf, 0xe1, 0x52, 0xf8, 0xb1, 0x27, 0x1c, 0xa7, 0x19, 0xb8, 0x96, 0x2d, 0x6d, 0x0d,
 0x3d, 0x7c, 0x7c, 0xcd, 0x5c, 0x63, 0x28, 0xf6, 0x4f, 0xa5, 0x59, 0xee, 0xc7, 0x63, 0xdf, 0xda,
 0x15, 0xbd, 0xf1, 0x3e, 0xd3, 0x1e, 0x85, 0xfb, 0x1d, 0xe2, 0xfa, 0xde, 0xf9, 0x9f, 0x69, 0xdc,
 0xb9, 0x91, 0x9e, 0x64, 0x64, 0xe7, 0xea, 0x75, 0x4b, 0xc9, 0xfc, 0x27, 0x63, 0xf8, 0x38, 0xf6,
 0x87, 0x4b, 0x7b, 0xad, 0xd8, 0xd7, 0xf7, 0x3e, 0xb7, 0xbe, 0x67, 0xda, 0x61, 0xee, 0xb3, 0x63,
 0x1f, 0xdc, 0xfa, 0xde, 0xf9, 0x9f, 0x69, 0xdd, 0x39, 0x91, 0x06, 0x3f, 0x1b, 0x87, 0xc0, 0xe1,
 0x2a, 0x62, 0xb1, 0x33, 0xe4, 0xa7, 0x05, 0xc5, 0xbf, 0x0e, 0x8b, 0x51, 0xcf, 0xd5, 0xea, 0x94,
 0xff, 0x00, 0x0a, 0xd9, 0x7e, 0x0e, 0x3d, 0xa1, 0xd3, 0x71, 0x3b, 0xb0, 0xd8, 0x5a, 0x14, 0x65,
 0x5a, 0xbe, 0x0a, 0xa5, 0x3a, 0x71, 0x5c, 0x65, 0x29, 0x62, 0xa6, 0x92, 0xf8, 0x4e, 0x9f, 0x9c,
 0x6c, 0xfe, 0xc3, 0xc6, 0x4e, 0x9e, 0x59, 0x93, 0xd5, 0xa9, 0xc3, 0xfd, 0xed, 0x5c, 0x4d, 0x44,
 0x9f, 0xb0, 0xb8, 0xf1, 0xf7, 0x4e, 0x53, 0x68, 0xb3, 0xdc, 0x4e, 0x71, 0x89, 0x72, 0xa8, 0xdc,
 0x30, 0xf1, 0x7f, 0x53, 0xa4, 0x9f, 0x42, 0xd5, 0xf8, 0x59, 0xc5, 0x73, 0x22, 0x7c, 0x46, 0xaf,
 0x54, 0xf7, 0x3f, 0x85, 0xec, 0xbf, 0x0b, 0x1e, 0xd0, 0xe8, 0xd9, 0xfe, 0xe8, 0xb7, 0x79, 0x9f,
 0x63, 0x7c, 0xf9, 0x9a, 0xec, 0xf7, 0x9e, 0x2b, 0xf5, 0x73, 0x79, 0xf2, 0xbc, 0x3e, 0x08, 0xcd,
 0x23, 0x8e, 0xf4, 0x07, 0xdd, 0x47, 0xde, 0xaf, 0xe9, 0x0c, 0x57, 0xd2, 0x1e, 0x95, 0xcc, 0x87,
 0x32, 0x31, 0x4c, 0xcc, 0xcd, 0xcb, 0xdb, 0x86, 0x18, 0xe1, 0x8c, 0x63, 0x8c, 0x54, 0x43, 0xcd,
 0x7d, 0x01, 0xf7, 0x51, 0xf7, 0xab, 0xfa, 0x43, 0x15, 0xf4, 0x83, 0xd0, 0x1f, 0x75, 0x1f, 0x7a,
 0xbf, 0xa4, 0x31, 0x5f, 0x48, 0x7a, 0x57, 0x32, 0x1c, 0xc8, 0x85, 0x9e, 0x7f, 0x95, 0x6e, 0x5f,
 0x76, 0x99, 0x5e, 0x36, 0x18, 0xcc, 0x0e, 0xcd, 0x59, 0xaf, 0x0f, 0xad, 0x97, 0x9f, 0xb1, 0x12,
 0xe1, 0xed, 0x3a, 0x8d, 0x1d, 0xdb, 0x29, 0xd9, 0x4d, 0x85, 0x73, 0x54, 0xf3, 0x4c, 0x92, 0xaf,
 0x2b, 0xff, 0x00, 0x79, 0x47, 0x15, 0x53, 0xa3, 0xd9, 0x4e, 0x5f, 0xa8, 0xb5, 0xcc, 0x87, 0x32,
 0x32, 0x61, 0xad, 0xa9, 0xa7, 0x15, 0x8e, 0x53, 0x0f, 0x3e, 0xb6, 0xd3, 0x43, 0x5a, 0x6f, 0x53,
 0x08, 0x99, 0xfc, 0xe1, 0xd9, 0xb0, 0xbb, 0xa4, 0xdd, 0xde, 0x2e, 0x84, 0x6b, 0xe1, 0xf0, 0x35,
 0x6a, 0xd2, 0x97, 0x54, 0xa3, 0x8c, 0xa9, 0xc3, 0xf5, 0x92, 0x3d, 0xcd, 0x6c, 0x07, 0x8a, 0xeb,
 0xfb, 0xee, 0xa7, 0x69, 0xc3, 0xe4, 0x19, 0xd6, 0x2b, 0x28, 0xc5, 0x2a, 0x94, 0x65, 0xcd, 0x4a,
 0x4f, 0xea, 0x94, 0x9b, 0xe8, 0x92, 0xfd, 0x8f, 0x53, 0xd4, 0x32, 0xdc, 0x7e, 0x1f, 0x30, 0xc1,
 0xc3, 0x15, 0x86, 0x9f, 0x35, 0x39, 0xaf, 0x6d, 0x3e, 0xfa, 0x7a, 0x99, 0x3c, 0x5e, 0xbf, 0x5c,
 0xf7, 0x62, 0xfe, 0x1b, 0xb4, 0xfc, 0x2c, 0x7b, 0x43, 0xa3, 0x3d, 0xcc, 0x6e, 0xff, 0x00, 0xc5,
 0x78, 0x8f, 0x7d, 0xd4, 0xed, 0x30, 0xf7, 0x2d, 0xbb, 0xe7, 0xf7, 0x2b, 0x11, 0xef, 0xba, 0x9d,
 0xa7, 0xa1, 0xf3, 0x23, 0x1c, 0xc8, 0x78, 0xbd, 0x7e, 0xb9, 0xee, 0x9f, 0xe1, 0xdb, 0x4f, 0xc3,
 0xc7, 0xb4, 0x3c, 0xed, 0xee, 0x53, 0x77, 0xbe, 0x2a, 0xc4, 0x7b, 0xf2, 0xa7, 0x68, 0xf4, 0x13,
 0xdd, 0xe7, 0x8a, 0xb1, 0x1e, 0xfc, 0xa9, 0xda, 0x7a, 0x2f, 0x32, 0x31, 0xcc, 0x89, 0xf1, 0x9b,
 0x8e, 0xb9, 0xee, 0x7f, 0x0f, 0xda, 0xfe, 0x1e, 0x3d, 0xa1, 0xe7, 0x5e, 0x82, 0x5b, 0xbc, 0xf1,
 0x56, 0x23, 0xdf, 0x95, 0x3b, 0x47, 0xa0, 0x8e, 0xee, 0xfc, 0x55, 0x88, 0xf7, 0xe5, 0x4e, 0xd3,
 0xd1, 0x79, 0x90, 0xe6, 0x43, 0xc6, 0x6e, 0x3a, 0xe7, 0xb9, 0xfc, 0x3f, 0x6b, 0xf8, 0x71, 0xda,
 0x1e, 0x73, 0xe8, 0x21, 0xbb, 0xbf, 0x14, 0xe2, 0x3d, 0xf9, 0x53, 0xb4, 0x7a, 0x08, 0x6e, 0xef,
 0xc5, 0x38, 0x8f, 0x7e, 0x54, 0xed, 0x3d, 0x1f, 0x99, 0x0e, 0x64, 0x3c, 0x66, 0xe3, 0xae, 0x7b,
 0xa7, 0xf8, 0x7e, 0xd7, 0xf0, 0xe3, 0xb4, 0x3c, 0xdf, 0xd0, 0x3f, 0x77, 0x5e, 0x29, 0xc4, 0x7b,
 0xf2, 0xa7, 0x68, 0xf4, 0x0e, 0xdd, 0xd7, 0x8a, 0x71, 0x3e, 0xfc, 0xab, 0xda, 0x7a, 0x3f, 0x32,
 0x1c, 0xc8, 0x78, 0xdd, 0xc7, 0x5c, 0xf7, 0x3c, 0x06, 0xd7, 0xf0, 0xe3, 0xb4, 0x3c, 0xdf, 0xd0,
 0x37, 0x77, 0x3e, 0x29, 0xc4, 0xfb, 0xf2, 0xaf, 0x68, 0xf4, 0x0d, 0xdd, 0xcf, 0x8a, 0x71, 0x3e,
 0xfc, 0xab, 0xf3, 0x8f, 0x49, 0xe6, 0x46, 0x39, 0x90, 0xf1, 0xbb, 0x8e, 0xb9, 0xef, 0x27, 0x80,
 0xda, 0xfe, 0x1c, 0x76, 0x87, 0x9b, 0x7a, 0x06, 0x6e, 0xe3, 0xc5, 0x18, 0x9f, 0x7e, 0x55, 0xf9,
 0xc3, 0xd0, 0x2f, 0x77, 0x1e, 0x28, 0xc4, 0xfb, 0xf6, 0xaf, 0xce, 0x3d, 0x27, 0x9d, 0x19, 0xe6,
 0x44, 0xf8, 0xdd, 0xc7, 0x5c, 0xf7, 0x93, 0xc0, 0x6d, 0xbf, 0x0e, 0x3b, 0x43, 0xcd, 0x3d, 0x02,
 0xf7, 0x6f, 0xe2, 0x8c, 0x4f, 0xbf, 0x6a, 0xfc, 0xe3, 0xa5, 0x6f, 0x43, 0x71, 0x1b, 0xb0, 0x97,
 0x73, 0xaf, 0xec, 0xf5, 0x4a, 0xff, 0x00, 0xeb, 0x78, 0x73, 0xe3, 0xab, 0xae, 0x1f, 0x59, 0xfc,
 0x59, 0xa3, 0xdf, 0xf9, 0x91, 0xd2, 0xb7, 0xa3, 0x25, 0xea, 0x77, 0xe3, 0x7f, 0x70, 0xa6, 0x7b,
 0xad, 0x6c, 0xf1, 0xf3, 0x72, 0xce, 0x66, 0x3d, 0xeb, 0xe1, 0xb4, 0xd0, 0xd3, 0xcb, 0xce, 0xc3,
 0x08, 0x89, 0xf7, 0x3c, 0x03, 0xd0, 0x1f, 0x75, 0x1f, 0x7a, 0xbf, 0xa4, 0x31, 0x5f, 0x48, 0x3d,
 0x01, 0xf7, 0x51, 0xf7, 0xab, 0xfa, 0x43, 0x15, 0xf4, 0x87, 0xa5, 0x73, 0x21, 0xcc, 0x8c, 0x0f,
 0x43, 0xcd, 0x7d, 0x01, 0xf7, 0x51, 0xf7, 0xab, 0xfa, 0x43, 0x15, 0xf4, 0x87, 0xb4, 0x7a, 0x03,
 0xee, 0xd7, 0xc5, 0x18, 0x9f, 0x7e, 0xd5, 0xf9, 0xc7, 0x03, 0xcc, 0x8f, 0x6a, 0xe6, 0x46, 0x5d,
 0x2d, 0x7d, 0x4d, 0x2b, 0xe5, 0xe5, 0x31, 0x7e, 0xc6, 0x2d, 0x5d, 0x0d, 0x3d, 0x5a, 0xe6, 0x63,
 0x13, 0x5e, 0xd7, 0x99, 0x7a, 0x03, 0x6e, 0xd7, 0xc4, 0xf8, 0x9f, 0x7e, 0xd5, 0xf9, 0xc3, 0xd0,
 0x1b, 0x76, 0x9e, 0x28, 0xc4, 0xfb, 0xf6, 0xaf, 0xce, 0x3d, 0x3b, 0x99, 0x18, 0xe6, 0x46, 0x5f,
 0x1d, 0xb9, 0xfc, 0x49, 0xef, 0x2c, 0x5e, 0x07, 0x6d, 0xf8, 0x71, 0xda, 0x1e, 0x65, 0xe8, 0x0b,
 0xbb, 0x4f, 0x13, 0xe2, 0x7d, 0xfb, 0x57, 0xe7, 0x18, 0xf4, 0x04, 0xdd, 0x9f, 0x89, 0xf1, 0x3e,
 0xfd, 0xab, 0xf3, 0x8f, 0x4f, 0xe6, 0x46, 0x39, 0xd1, 0x3e, 0x3b, 0x73, 0xf8, 0x93, 0xde, 0x4f,
 0x03, 0xb6, 0xfc, 0x38, 0xed, 0x0f, 0x30, 0xf4, 0x03, 0xdd, 0x9f, 0x89, 0xf1, 0x3e, 0xfd, 0xab,
 0xf3, 0x87, 0xa0, 0x1e, 0xec, 0xbc, 0x4f, 0x89, 0xf7, 0xed, 0x5f, 0x9c, 0x7a, 0x7f, 0x32, 0x33,
 0xcc, 0x87, 0x8f, 0xdc, 0xfe, 0x24, 0xf7, 0x93, 0xc1, 0x6d, 0xfa, 0x23, 0xb4, 0x3c, 0xbb, 0xd0,
 0x0b, 0x76, 0x5e, 0x27, 0xc5, 0x7b, 0xfa, 0xaf, 0xce, 0x1e, 0x80, 0x3b, 0xb2, 0xf1, 0x3e, 0x2b,
 0xdf, 0xd5, 0x7e, 0x71, 0xea, 0x1c, 0xc8, 0x73, 0x21, 0xe3, 0xf7, 0x5f, 0x89, 0x3d, 0xe5, 0x3e,
 0x0b, 0x6f, 0xd1, 0x1d, 0xa1, 0xe5, 0xfe, 0x80, 0x3b, 0xb1, 0xf1, 0x3e, 0x2b, 0xdf, 0xd5, 0x7e,
 0x71, 0x8f, 0x40, 0x0d, 0xd8, 0xf8, 0x9b, 0x15, 0xef, 0xea, 0xbf, 0x38, 0xf5, 0x1e, 0x64, 0x67,
 0x99, 0x0f, 0x1f, 0xba, 0xfc, 0x49, 0xef, 0x27, 0x82, 0xdb, 0xf4, 0x47, 0x68, 0x79, 0x6f, 0xfa,
 0x3f, 0xee, 0xc3, 0xc4, 0xd8, 0xaf, 0x7f, 0x55, 0xf9, 0xc6, 0x3f, 0xd1, 0xfb, 0x76, 0x1e, 0x26,
 0xc5, 0x7b, 0xfa, 0xaf, 0xce, 0x3d, 0x4b, 0x99, 0x0e, 0x64, 0x3c, 0x7e, 0xeb, 0xf1, 0x27, 0xbc,
 0x9e, 0x0f, 0x6f, 0xd1, 0x1d, 0x9e, 0x5b, 0xfe, 0x8f, 0xdb, 0xaf, 0xf1, 0x36, 0x2b, 0xdf, 0xd5,
 0x7e, 0x71, 0x8f, 0xf4, 0x7d, 0xdd, 0x7f, 0x89, 0xb1, 0x5e, 0xfe, 0xab, 0xf3, 0x8f, 0x53, 0xe6,
 0x43, 0x99, 0x13, 0xfc, 0x43, 0x75, 0xf8, 0x93, 0xde, 0x4f, 0x07, 0xb7, 0xe8, 0x8e, 0xca, 0xb7,
 0x05, 0xc2, 0xa5, 0xc1, 0x73, 0x53, 0xc6, 0xf4, 0xad, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d,
 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x35, 0x17, 0x00, 0xb7, 0x70,
 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0xd4, 0x5c, 0x03, 0xa4, 0xef, 0x26,
 0xa7, 0x1c, 0xf6, 0x8f, 0xe0, 0xd1, 0xf8, 0xd2, 0x3a, 0xc7, 0x39, 0xce, 0xef, 0x1e, 0xa7, 0xab,
 0x94, 0x7f, 0x06, 0x8f, 0xc6, 0x91, 0xd6, 0x79, 0xc0, 0xb3, 0xce, 0x39, 0xca, 0xdc, 0xe3, 0x9c,
 0x0f, 0x71, 0xb8, 0x2e, 0x14, 0xee, 0x6a, 0x66, 0xe6, 0xa0, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x18,
 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x0b,
 0x9a, 0x81, 0x6e, 0xe8, 0xb9, 0xa9, 0x52, 0xe1, 0x8b, 0x80, 0x5c, 0xb8, 0x52, 0xcf, 0xaa, 0x7a,
 0x87, 0x8f, 0xfc, 0x1a, 0xa7, 0xc5, 0x66, 0xd7, 0x35, 0x29, 0x67, 0xb5, 0x3d, 0x44, 0xc7, 0xfe,
 0x0d, 0x53, 0xe2, 0xb0, 0x3c, 0xbf, 0x9c, 0x73, 0x95, 0xb9, 0xc7, 0x38, 0x16, 0x79, 0xcf, 0x41,
 0xdd, 0xbd, 0x4e, 0x19, 0x15, 0x6f, 0xc2, 0x65, 0xf1, 0x62, 0x79, 0xaf, 0x39, 0xe8, 0x1b, 0xb9,
 0xa9, 0xc3, 0x23, 0xad, 0xf8, 0x4c, 0xbe, 0x2c, 0x40, 0xee, 0x37, 0x05, 0xc2, 0x9d, 0xc3, 0x37,
 0x00, 0xb7, 0x73, 0x51, 0x70, 0xa9, 0x73, 0x51, 0x73, 0x50, 0x2d, 0xdc, 0x3c, 0xef, 0x78, 0x39,
 0x84, 0xb1, 0x19, 0xd7, 0x9d, 0x94, 0xbe, 0xa7, 0x86, 0x82, 0x5c, 0x3f, 0xa4, 0xfa, 0x5b, 0xfd,
 0x4b, 0xda, 0x3b, 0xcd, 0xc3, 0xca, 0x36, 0x8a, 0xb3, 0x9e, 0x7b, 0x8e, 0x93, 0x7c, 0x7e, 0xaf,
 0x35, 0xee, 0x3e, 0x00, 0x43, 0xce, 0x39, 0xca, 0xdc, 0xe3, 0x9c, 0x0b, 0x3c, 0xe7, 0x61, 0xc8,
 0x76, 0x67, 0x17, 0x99, 0x52, 0x8e, 0x22, 0xbc, 0xd6, 0x1b, 0x0f, 0x2e, 0x98, 0xb6, 0xb8, 0xca,
 0x4b, 0xc2, 0x97, 0x83, 0x53, 0x8a, 0xd9, 0x4c, 0x1c, 0x33, 0x0c, 0xee, 0x8d, 0x1a, 0xab, 0x8d,
 0x28, 0xf1, 0xa9, 0x51, 0x78, 0x52, 0xef, 0x7b, 0xbc, 0x0f, 0x50, 0x53, 0x49, 0x70, 0x5d, 0x08,
 0x0e, 0x09, 0x6c, 0x66, 0x59, 0xc9, 0xc1, 0xe2, 0xb1, 0x7c, 0xde, 0x1e, 0x68, 0xf0, 0xf7, 0x38,
 0x1c, 0x66, 0x67, 0xb1, 0xb8, 0x9a, 0x51, 0x75, 0x30, 0x38, 0x88, 0xe2, 0x38, 0x7d, 0x84, 0xd7,
 0x2c, 0xbd, 0xa7, 0xd4, 0xfe, 0x03, 0xb8, 0xdc, 0xd4, 0x5c, 0xd4, 0x0f, 0x25, 0xaf, 0x1a, 0xb4,
 0x2a, 0xca, 0x95, 0x6a, 0x72, 0xa7, 0x52, 0x2f, 0x84, 0xa3, 0x25, 0xc1, 0xa3, 0x4e, 0x73, 0xd0,
 0xb6, 0xab, 0x28, 0xa5, 0x9a, 0x60, 0xe5, 0x3a, 0x71, 0x4b, 0x17, 0x4d, 0x71, 0xa7, 0x25, 0xf6,
 0x5f, 0xd1, 0x7a, 0x1e, 0x6a, 0xe5, 0xc1, 0xb4, 0xf8, 0xa6, 0x80, 0xb1, 0xce, 0x39, 0xca, 0xdc,
 0xe3, 0x9c, 0x0e, 0xcf, 0xb0, 0x49, 0x4f, 0x69, 0x28, 0xc9, 0xfd, 0x84, 0x27, 0x2f, 0x83, 0x87,
 0xed, 0x3d, 0x2a, 0xe1, 0xe6, 0x5b, 0xbb, 0x97, 0x1c, 0xf6, 0x6f, 0xc1, 0x87, 0x93, 0xf8, 0x62,
 0x7a, 0x15, 0xcd, 0x40, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0xd4, 0xc5, 0xc0, 0x3c, 0xc3, 0x3e, 0x9f,
 0xab, 0x98, 0xff, 0x00, 0xc2, 0x6a, 0x7c, 0x66, 0x52, 0xe7, 0x24, 0xcf, 0x67, 0xea, 0xde, 0x3f,
 0xf0, 0x9a, 0x9f, 0x19, 0x94, 0xb9, 0xc0, 0xb3, 0xce, 0x76, 0x5d, 0xdc, 0xcf, 0xd5, 0xe9, 0xfe,
 0x0f, 0x2f, 0xd7, 0x13, 0xa8, 0xf3, 0x9d, 0x93, 0x77, 0x75, 0x3d, 0x5e, 0x9f, 0xf7, 0x12, 0xfd,
 0x71, 0x03, 0xd3, 0x6e, 0x0b, 0x9a, 0x95, 0x2e, 0x18, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x52, 0xe0,
 0xb9, 0xa8, 0x1e, 0x45, 0xce, 0x39, 0xca, 0xdc, 0xe3, 0x9c, 0x0b, 0x3c, 0xe7, 0x74, 0xdd, 0x84,
 0xf8, 0x77, 0x47, 0xf1, 0x5f, 0xbe, 0x74, 0x2e, 0x73, 0xb9, 0xee, 0xce, 0xa7, 0xfe, 0x61, 0xf8,
 0xbf, 0xdf, 0x03, 0xbf, 0x5c, 0x17, 0x0a, 0x97, 0x05, 0xcd, 0x40, 0xb7, 0x73, 0x52, 0x96, 0x7d,
 0x53, 0xd4, 0x3c, 0x7a, 0xfe, 0xad, 0x53, 0xe2, 0xb3, 0x6b, 0x9a, 0x94, 0xb3, 0xda, 0x9e, 0xa2,
 0x63, 0xff, 0x00, 0x06, 0xa9, 0xf1, 0x58, 0x1e, 0x5f, 0xce, 0x39, 0xca, 0xdc, 0xe3, 0x9c, 0x0b,
 0x3c, 0xe7, 0xa0, 0xee, 0xda, 0xa7, 0xa8, 0x75, 0xbf, 0x09, 0x97, 0xc5, 0x89, 0xe6, 0xbc, 0xe7,
 0xa0, 0x6e, 0xe2, 0xa7, 0x0c, 0x92, 0xb7, 0xe1, 0x32, 0xf8, 0xb1, 0x03, 0xb8, 0xdc, 0xd4, 0x5c,
 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xc3, 0xce, 0xb6, 0xeb, 0x3a, 0x96, 0x3b, 0x30, 0x78, 0x3a,
 0x52, 0xff, 0x00, 0xbb, 0xe1, 0xdf, 0x0e, 0x87, 0xd1, 0x29, 0xf7, 0xdf, 0xb5, 0xd5, 0xee, 0x9d,
 0xa3, 0x69, 0x33, 0x27, 0x97, 0xe4, 0xd5, 0xf1, 0x11, 0x7c, 0x2a, 0x72, 0xf2, 0xd3, 0xfe, 0xd3,
 0xe8, 0x5e, 0xe7, 0x5f, 0xb4, 0x79, 0x5b, 0x9f, 0x1e, 0x97, 0xc4, 0x0b, 0x3c, 0xe3, 0x9c, 0xad,
 0xce, 0x39, 0xc0, 0xb3, 0xce, 0x73, 0x59, 0x4e, 0xce, 0x66, 0x79, 0x8c, 0x15, 0x58, 0xd3, 0x8d,
 0x0a, 0x4f, 0xaa, 0x75, 0x5f, 0x0e, 0x3e, 0xc2, 0xeb, 0x2d, 0xec, 0x46, 0x4b, 0x4e, 0xbc, 0x56,
 0x67, 0x8c, 0x82, 0x94, 0x13, 0xfa, 0x8c, 0x25, 0xd4, 0xda, 0xfb, 0x26, 0x77, 0x8b, 0x9a, 0x81,
 0xd5, 0x23, 0xb1, 0x13, 0xe5, 0xe9, 0xcc, 0xe2, 0xa5, 0xe0, 0x54, 0x7a, 0x3e, 0x31, 0xc6, 0x66,
 0xbb, 0x2f, 0x99, 0x60, 0x69, 0xca, 0xad, 0x35, 0x0c, 0x55, 0x38, 0xf4, 0xb7, 0x4f, 0x8f, 0x32,
 0x5e, 0xc7, 0x67, 0x13, 0xbf, 0x5c, 0x17, 0x00, 0xf2, 0x2e, 0x71, 0xce, 0x76, 0x1d, 0xbd, 0xcb,
 0x21, 0x86, 0xaf, 0x1c, 0xc7, 0x0f, 0x05, 0x1a, 0x75, 0x9f, 0x0a, 0x91, 0x5d, 0x4a, 0x7e, 0x1f,
 0x6f, 0xf6, 0x6a, 0x75, 0x5e, 0x70, 0x2c, 0xf3, 0x9d, 0x87, 0x62, 0x33, 0xa7, 0x97, 0xe6, 0x4b,
 0x0d, 0x56, 0x7c, 0x30, 0xd8, 0x86, 0xa3, 0x2e, 0x2f, 0xa2, 0x32, 0xef, 0x3f, 0xd8, 0xff, 0x00,
 0xc8, 0xea, 0xbc, 0xe6, 0xf4, 0x63, 0x56, 0xac, 0xb9, 0x69, 0x53, 0x9d, 0x49, 0x78, 0x23, 0x16,
 0xd8, 0x1e, 0xdd, 0x70, 0x5c, 0xd4, 0xe1, 0x72, 0x0c, 0x56, 0x22, 0xbe, 0x51, 0x87, 0x9e, 0x2a,
 0x9d, 0x4a, 0x75, 0xd4, 0x79, 0x66, 0xa7, 0x16, 0x9b, 0x6b, 0xa3, 0x8f, 0x4f, 0x87, 0xac, 0xbd,
 0x70, 0x0b, 0x97, 0x05, 0xc2, 0xa5, 0xc3, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x70, 0xa9, 0x73, 0x51,
 0x70, 0x0b, 0x77, 0x35, 0x17, 0x0a, 0x77, 0x35, 0x33, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97,
 0x35, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x29, 0xdc, 0x33, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97,
 0x35, 0x17, 0x00, 0xb7, 0x70, 0xe9, 0x7b, 0xcf, 0xa9, 0xc7, 0xb9, 0xdf, 0x8d, 0xfd, 0xc3, 0xb4,
 0xdc, 0x3a, 0x66, 0xf3, 0x6a, 0x7f, 0xe5, 0xff, 0x00, 0x8d, 0xfd, 0xc0, 0x3a, 0xaf, 0x38, 0xe7,
 0x2b, 0x73, 0x8e, 0x70, 0x2c, 0xf3, 0x9e, 0xd1, 0x70, 0xf0, 0xee, 0x73, 0xd9, 0x6e, 0x6a, 0x05,
 0xcb, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b,
 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x66, 0xe6, 0xa0, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b,
 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e,
 0x15, 0x2e, 0x0b, 0x80, 0x53, 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xd3, 0xd6, 0x2e, 0x01, 0x72, 0xe6,
 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x9a, 0x94, 0xee, 0x6a, 0x2e, 0x01, 0x72,
 0xe6, 0xa2, 0xe1, 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x6a, 0x54, 0xb9, 0xa9, 0x8b,
 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0xd3, 0xb7, 0x89, 0x3f, 0x56, 0xe8, 0xfe,
 0x0d, 0x1f, 0x8d, 0x23, 0xad, 0x73, 0x9c, 0xde, 0xf0, 0xaa, 0x7a, 0xb5, 0x47, 0xf0, 0x68, 0xfc,
 0x69, 0x1d, 0x6f, 0x9c, 0x0b, 0x3c, 0xe3, 0x9c, 0xad, 0xce, 0x39, 0xc0, 0xf6, 0xbb, 0x82, 0xe1,
 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x9a,
 0x8b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe0,
 0xb8, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x85, 0x3c, 0xf6, 0xa7, 0xa8, 0x98, 0xee, 0x9f, 0xb5,
 0xaa, 0x7c, 0x56, 0x2e, 0x6a, 0x54, 0xcf, 0x2a, 0x7a, 0x8b, 0x8e, 0xfc, 0x1e, 0xa7, 0xc5, 0x60,
 0x79, 0xa7, 0x38, 0xe7, 0x2b, 0x73, 0x8e, 0x70, 0x2c, 0xf3, 0x9d, 0xfb, 0x77, 0x75, 0x3d, 0x44,
 0xad, 0xf8, 0x4c, 0xbe, 0x2c, 0x4f, 0x38, 0xe7, 0x3b, 0xde, 0xef, 0x2a, 0x7a, 0x8f, 0x59, 0x71,
 0xfb, 0x61, 0xfc, 0x58, 0x81, 0xdc, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe0,
 0xb8, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x87, 0x97, 0xed, 0x44, 0x5d, 0x1d, 0xa0, 0xc6, 0x45,
 0xae, 0xba, 0x8e, 0x7f, 0x95, 0xd3, 0xfb, 0x4f, 0x44, 0xb8, 0x74, 0xfd, 0xe0, 0x60, 0xe4, 0xdd,
 0x2c, 0xca, 0x9a, 0x6d, 0x70, 0xb7, 0x57, 0x87, 0x7b, 0xc0, 0xff, 0x00, 0x67, 0xb8, 0x07, 0x59,
 0xe7, 0x1c, 0xe5, 0x6e, 0x7d, 0x47, 0x38, 0x1d, 0xa3, 0x60, 0xf1, 0x70, 0xa1, 0x9f, 0x28, 0xcd,
 0xa5, 0x7a, 0x94, 0xa9, 0xc5, 0xbf, 0x0f, 0x14, 0xff, 0x00, 0x61, 0xe8, 0x77, 0x35, 0x3c, 0x56,
 0x15, 0x65, 0x09, 0x29, 0xc6, 0x4e, 0x32, 0x8b, 0xe2, 0x9a, 0x7d, 0x29, 0x9d, 0xc7, 0x27, 0xdb,
 0x2a, 0x76, 0xe3, 0x4b, 0x32, 0x84, 0x94, 0x97, 0x45, 0xd8, 0x2e, 0x29, 0xfb, 0x2b, 0xb0, 0x0e,
 0xf3, 0x70, 0x5c, 0xd4, 0xe2, 0x70, 0x79, 0xb6, 0x03, 0x16, 0x97, 0x9d, 0xb1, 0x74, 0xaa, 0x37,
 0xf6, 0x2a, 0x5e, 0x9b, 0xdc, 0xeb, 0x2d, 0x5c, 0x02, 0xe5, 0xc3, 0xcb, 0x76, 0x96, 0x2a, 0x8e,
 0x7d, 0x8c, 0xa7, 0x15, 0xc1, 0x5d, 0x72, 0x4b, 0xd9, 0xe9, 0xfd, 0xa7, 0xa3, 0x5c, 0x3c, 0xdf,
 0x6c, 0x67, 0xff, 0x00, 0x89, 0x31, 0x7f, 0xf2, 0x7c, 0x48, 0x81, 0x47, 0x9c, 0x73, 0x95, 0xb9,
 0xc7, 0x38, 0x1d, 0xbb, 0x77, 0x73, 0xf5, 0x6e, 0xb7, 0xe0, 0xd2, 0xf8, 0xd1, 0x3b, 0xed, 0xc3,
 0xce, 0x37, 0x7b, 0x53, 0xd5, 0xaa, 0xdf, 0x83, 0xcb, 0xe3, 0x44, 0xef, 0x77, 0x35, 0x02, 0xe5,
 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x03, 0xcd, 0x73, 0xc9, 0xfa, 0xb7, 0x8e, 0xfc, 0x26, 0xa7, 0xc6,
 0x65, 0x3e, 0x73, 0x7c, 0xf2, 0x7e, 0xad, 0x63, 0xbf, 0x08, 0xa9, 0xf1, 0x99, 0x4f, 0x9c, 0x0b,
 0x3c, 0xe7, 0x63, 0xdd, 0xec, 0xfd, 0x5c, 0x9f, 0xf7, 0x12, 0xfd, 0x71, 0x3a, 0x9f, 0x3e, 0xa7,
 0x62, 0xdd, 0xfc, 0xfd, 0x5c, 0x9f, 0xf7, 0x12, 0xfd, 0x71, 0x03, 0xd2, 0x6e, 0x0b, 0x85, 0x3b,
 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x1e, 0x53, 0xce, 0x39, 0xca, 0xdc, 0xfa,
 0x8e, 0x70, 0x2c, 0xf3, 0x9d, 0xc7, 0x76, 0xb3, 0xff, 0x00, 0x6f, 0xfc, 0x5f, 0xef, 0x1d, 0x17,
 0x9c, 0xee, 0x1b, 0xb7, 0xa9, 0xc3, 0xcf, 0xff, 0x00, 0x8b, 0xfd, 0xe0, 0x3b, 0xdd, 0xcd, 0x45,
 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0xa7, 0x9e, 0x54, 0xf5, 0x13, 0x1f, 0xf8, 0x35,
 0x4f, 0x8a, 0xc5, 0xc2, 0xa6, 0x77, 0x53, 0xd4, 0x5c, 0x77, 0x4f, 0xda, 0xd5, 0x3e, 0x2b, 0x03,
 0xcd, 0x39, 0xc7, 0x39, 0x5b, 0x9c, 0x73, 0x81, 0x67, 0x9c, 0xef, 0xbb, 0xbb, 0xa9, 0xea, 0x25,
 0x6f, 0xc2, 0x65, 0xf1, 0x62, 0x79, 0xcf, 0x39, 0xdf, 0x37, 0x7b, 0x53, 0x86, 0x4b, 0x5b, 0xf0,
 0x99, 0x7c, 0x58, 0x81, 0xdb, 0xee, 0x0b, 0x9a, 0x94, 0xee, 0x6a, 0x2e, 0x6a, 0x07, 0x5b, 0xde,
 0x3e, 0x33, 0xd2, 0xe1, 0x30, 0x89, 0xf4, 0x36, 0xea, 0x49, 0x7c, 0x0b, 0xf6, 0x9d, 0x37, 0x9c,
 0xe5, 0xf6, 0xf7, 0x11, 0xcf, 0x9e, 0xf2, 0xf1, 0xe8, 0xa7, 0x4a, 0x31, 0xfd, 0x6f, 0xf6, 0x9d,
 0x7f, 0x9c, 0x0b, 0x3c, 0xe4, 0x98, 0x68, 0xca, 0xbe, 0x22, 0x9d, 0x18, 0x7d, 0x75, 0x49, 0xa8,
 0x2f, 0x65, 0xbe, 0x05, 0x2e, 0x72, 0xfe, 0xcf, 0x55, 0xa5, 0x0c, 0xef, 0x09, 0x3a, 0xd3, 0x8c,
 0x21, 0x1a, 0x8a, 0x4e, 0x52, 0x7c, 0x12, 0xe1, 0xd3, 0xd6, 0x07, 0xac, 0x61, 0xa3, 0x4f, 0x0f,
 0x87, 0xa7, 0x42, 0x92, 0xe1, 0x0a, 0x71, 0x51, 0x8a, 0xd1, 0x12, 0x5c, 0x38, 0x8e, 0xec, 0x65,
 0x9e, 0x32, 0xc1, 0xf9, 0x78, 0xf6, 0x8e, 0xec, 0x65, 0x9e, 0x32, 0xc1, 0xf9, 0x78, 0xf6, 0x81,
 0xcb, 0xdc, 0xd4, 0x5c, 0xd4, 0xe2, 0x3b, 0xb1, 0x96, 0x78, 0xcb, 0x07, 0xe5, 0xe3, 0xda, 0x3b,
 0xb1, 0x96, 0x78, 0xcb, 0x07, 0xe5, 0xe3, 0xda, 0x05, 0xdc, 0xdb, 0x0b, 0x4b, 0x31, 0xc0, 0x54,
 0xc2, 0x56, 0x6e, 0x31, 0x9f, 0x0f, 0x4c, 0xba, 0xd3, 0x4f, 0x8f, 0x13, 0x89, 0xc3, 0xec, 0xa6,
 0x51, 0x4f, 0x85, 0xc5, 0x5e, 0xb7, 0xf6, 0xea, 0x70, 0xfd, 0x5c, 0x0b, 0x3d, 0xd9, 0xcb, 0x3c,
 0x65, 0x83, 0xf2, 0xf1, 0xed, 0x1d, 0xd8, 0xcb, 0x3c, 0x65, 0x83, 0xf2, 0xf1, 0xed, 0x02, 0xc6,
 0x1f, 0x29, 0xca, 0x68, 0x70, 0xb7, 0x80, 0xc3, 0xf1, 0x5d, 0xf9, 0x43, 0x99, 0xfb, 0xac, 0xbd,
 0x09, 0x46, 0x11, 0xe5, 0x84, 0x54, 0x52, 0xea, 0x49, 0x70, 0x47, 0x13, 0xdd, 0x8c, 0xb3, 0xc6,
 0x58, 0x3f, 0x2f, 0x1e, 0xd1, 0xdd, 0x8c, 0xb3, 0xc6, 0x58, 0x3f, 0x2f, 0x1e, 0xd0, 0x39, 0x7b,
 0x82, 0xe1, 0xc6, 0xe1, 0xb1, 0xf8, 0x4c, 0x4b, 0x6b, 0x0f, 0x8a, 0xa3, 0x59, 0xc7, 0xa5, 0xaa,
 0x75, 0x14, 0xb8, 0x7b, 0x84, 0xd7, 0x35, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xc0,
 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02,
 0xe5, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0xe9, 0xdb, 0xca, 0xa9, 0xff, 0x00, 0x97,
 0xfe, 0x33, 0xf7, 0x4e, 0xcb, 0x70, 0xea, 0x1b, 0xc8, 0xa9, 0xfe, 0xc1, 0xf8, 0xcf, 0xdd, 0x03,
 0xac, 0x73, 0x8e, 0x72, 0xb7, 0x38, 0xe7, 0xd4, 0x0b, 0x3c, 0xe7, 0xb1, 0x5c, 0xd4, 0xf1, 0x4e,
 0x73, 0xd7, 0xee, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x9a,
 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe6,
 0xa5, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe6, 0xa2,
 0xe1, 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x6a, 0x05, 0x4b,
 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b,
 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa8, 0xba, 0x53, 0xb9, 0xa8, 0xb9, 0xa8, 0x17, 0x2e,
 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x1d,
 0x47, 0x78, 0x13, 0xe3, 0x9c, 0xd1, 0xe9, 0xfb, 0x5e, 0x3f, 0x1a, 0x47, 0x5d, 0xe7, 0x39, 0x9d,
 0xbe, 0x9f, 0xab, 0x14, 0xba, 0x7e, 0xd7, 0x5f, 0x1a, 0x47, 0x5d, 0xe7, 0xd4, 0x0b, 0x3c, 0xfa,
 0x8e, 0x7d, 0x4a, 0xdc, 0xfa, 0x8e, 0x7d, 0x40, 0xf6, 0x5b, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05,
 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c,
 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb,
 0x85, 0x3c, 0xee, 0xa7, 0xa8, 0xd8, 0xef, 0xc1, 0xea, 0x7c, 0x56, 0x2e, 0x15, 0x33, 0xaa, 0x9e,
 0xa3, 0xe3, 0x7f, 0x07, 0xa9, 0xf1, 0x58, 0x1e, 0x75, 0xce, 0x39, 0xf5, 0x2b, 0x73, 0xea, 0x39,
 0xf5, 0x02, 0xcf, 0x39, 0xdd, 0xb7, 0x7b, 0x57, 0xd4, 0xec, 0x44, 0x78, 0xf5, 0x56, 0xe3, 0xf0,
 0x2e, 0xc3, 0xa0, 0x73, 0xea, 0x76, 0xfd, 0xde, 0xd7, 0xfa, 0x9e, 0x32, 0x1c, 0x7a, 0x9c, 0x1f,
 0xbb, 0xc7, 0xb0, 0x0e, 0xed, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2,
 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x08, 0xf1, 0x0a, 0x9d, 0x7a, 0x33, 0xa3, 0x5a, 0x2a, 0x74, 0xe6,
 0x9c, 0x64, 0x9f, 0x7d, 0x15, 0xee, 0x0b, 0x80, 0x74, 0x6d, 0xa0, 0xc9, 0xb1, 0x19, 0x65, 0x57,
 0x38, 0xa9, 0x54, 0xc2, 0xb7, 0xe9, 0x67, 0xe0, 0xd1, 0x9c, 0x47, 0x39, 0xea, 0x12, 0x9a, 0x94,
 0x5c, 0x64, 0x93, 0x4d, 0x70, 0x69, 0xf5, 0x33, 0x80, 0xcc, 0xb6, 0x6b, 0x01, 0x89, 0x6e, 0x78,
 0x79, 0x4b, 0x0b, 0x37, 0xfc, 0x5e, 0x98, 0xfb, 0x9d, 0x80, 0x74, 0xee, 0x71, 0xce, 0x72, 0x78,
 0xcd, 0x9b, 0xcc, 0xe8, 0x71, 0x74, 0x94, 0x31, 0x11, 0xf0, 0xc2, 0x5c, 0x1f, 0xb8, 0xce, 0x27,
 0x11, 0x43, 0x15, 0x87, 0x7c, 0x31, 0x14, 0x2a, 0xd2, 0xfe, 0xdc, 0x1a, 0x03, 0x7e, 0x7d, 0x4b,
 0x98, 0x5c, 0xdf, 0x31, 0xc2, 0xf0, 0xb1, 0x8d, 0xaf, 0x14, 0xbe, 0xc7, 0x9b, 0x8a, 0xf7, 0x1f,
 0x41, 0xc5, 0x73, 0xea, 0x39, 0xf5, 0x03, 0xb6, 0x60, 0xf6, 0xcb, 0x30, 0xa5, 0xc1, 0x62, 0x29,
 0xd2, 0xc4, 0x47, 0xbe, 0xf8, 0x72, 0xcb, 0xe0, 0xe8, 0xf8, 0x0e, 0x27, 0x3b, 0xcc, 0x23, 0x98,
 0x66, 0x95, 0x71, 0x91, 0x84, 0xa9, 0xaa, 0x9c, 0xbe, 0x95, 0xbe, 0x3c, 0x38, 0x45, 0x2f, 0xd8,
 0x71, 0x3c, 0xfa, 0x8e, 0x70, 0x2c, 0xf3, 0x8e, 0x72, 0xb7, 0x3e, 0xa3, 0x9f, 0x50, 0x3b, 0x5e,
 0xef, 0xe7, 0xc3, 0x39, 0xad, 0xf8, 0x3c, 0xbe, 0x34, 0x4e, 0xf5, 0x70, 0xf3, 0xcd, 0x81, 0xa9,
 0xc3, 0x38, 0xab, 0xd3, 0xf6, 0xbc, 0xbe, 0x34, 0x4e, 0xef, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x35,
 0x29, 0xdc, 0x17, 0x00, 0xf3, 0xac, 0xee, 0x7e, 0xac, 0xe3, 0xba, 0x7e, 0xd8, 0xa9, 0xf1, 0x99,
 0x53, 0x9f, 0x53, 0x6c, 0xea, 0x7e, 0xac, 0x63, 0x7a, 0x7e, 0xd8, 0xa9, 0xf1, 0x99, 0x53, 0x9f,
 0x50, 0x2c, 0xf3, 0x9d, 0x83, 0x60, 0xa7, 0xea, 0xdc, 0xff, 0x00, 0xb8, 0x97, 0xeb, 0x47, 0x56,
 0xe7, 0xd4, 0xe7, 0xb6, 0x1a, 0xaf, 0x2e, 0x79, 0xc3, 0x8f, 0x5d, 0x29, 0x2f, 0xd4, 0x07, 0xa3,
 0xdc, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5d, 0x03, 0xcb,
 0xf9, 0xc7, 0x3e, 0xa5, 0x6e, 0x7d, 0x47, 0x3e, 0xa0, 0x59, 0xe7, 0xd4, 0xed, 0xdb, 0xb9, 0xa9,
 0xc3, 0xcf, 0xeb, 0xfb, 0xbf, 0xde, 0x3a, 0x47, 0x3e, 0xa7, 0x6a, 0xdd, 0xed, 0x5e, 0x15, 0x71,
 0x91, 0xe3, 0xd7, 0x18, 0x3f, 0xd7, 0xda, 0x07, 0x7b, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c,
 0xb9, 0xa9, 0x4f, 0x3b, 0xa9, 0xea, 0x36, 0x3b, 0xf0, 0x7a, 0x9f, 0x15, 0x8b, 0x85, 0x4c, 0xea,
 0xa7, 0xa8, 0xf8, 0xdf, 0xc1, 0xea, 0x7c, 0x56, 0x07, 0x9d, 0x73, 0x8e, 0x7d, 0x4a, 0xdc, 0xfa,
 0x8e, 0x7d, 0x40, 0xb3, 0xce, 0x77, 0x9d, 0xdf, 0xd4, 0xe1, 0x93, 0x56, 0xfc, 0x22, 0x5f, 0x16,
 0x27, 0x9e, 0xf3, 0xea, 0x77, 0x8d, 0x81, 0xa9, 0xea, 0x3d, 0x5e, 0x9f, 0xb6, 0x1f, 0xc5, 0x88,
 0x1d, 0xb6, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0xd1, 0xf6, 0xca, 0xa7, 0x1d, 0xa3, 0xc4, 0xe8,
 0xa1, 0xf1, 0x11, 0xc3, 0xf3, 0x9c, 0x86, 0xd9, 0xcb, 0x86, 0xd0, 0x56, 0x7f, 0xc6, 0x8c, 0x5f,
 0xff, 0x00, 0x54, 0xbf, 0x61, 0xc3, 0x73, 0xea, 0x05, 0x9e, 0x71, 0xcf, 0xa9, 0x5b, 0x9f, 0x51,
 0xcf, 0xa8, 0x16, 0x79, 0xf5, 0x1c, 0xe5, 0x6e, 0x7d, 0x4c, 0xf3, 0xea, 0x05, 0x8e, 0x71, 0xce,
 0x56, 0xe7, 0xd4, 0x73, 0xea, 0x05, 0x9e, 0x71, 0xcf, 0xa9, 0x5b, 0x9f, 0x51, 0xcf, 0xa8, 0x16,
 0x79, 0xf5, 0x1c, 0xe5, 0x6e, 0x7d, 0x47, 0x3e, 0xa0, 0x77, 0x4d, 0xdd, 0xcb, 0xea, 0xf8, 0xc9,
 0x7f, 0x46, 0x1f, 0xad, 0x9d, 0xc6, 0xe1, 0xd2, 0xb7, 0x7a, 0xf8, 0x51, 0xc6, 0x54, 0xfe, 0x34,
 0xa3, 0x1f, 0x73, 0x8f, 0x69, 0xda, 0x6e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb9, 0xa8, 0xb9, 0xa8,
 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81,
 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb,
 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x1d, 0x47, 0x78, 0xd5, 0x38, 0xf9, 0xc3, 0xf1,
 0x9f, 0xba, 0x76, 0x2b, 0x87, 0x53, 0xde, 0x1d, 0x4f, 0xf6, 0x1e, 0x9f, 0xe5, 0x3f, 0x74, 0x0e,
 0xb7, 0xcf, 0xa8, 0xe7, 0xd4, 0xad, 0xcf, 0xa8, 0xe7, 0xd4, 0x0b, 0x3c, 0xe7, 0xae, 0x5c, 0x3c,
 0x6b, 0x9f, 0x53, 0xd6, 0x6e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x82,
 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85,
 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b,
 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x54, 0xb9, 0xa8, 0xb8,
 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x81, 0xd4, 0xd4,
 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02, 0xe5, 0xc1,
 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x03, 0xaa, 0xed, 0xe5, 0x4f,
 0x55, 0xe9, 0x74, 0xfd, 0xae, 0xbe, 0x34, 0x8e, 0xbf, 0xcf, 0xa9, 0xcb, 0x6d, 0xd4, 0xfd, 0x57,
 0xa5, 0xd3, 0xfe, 0xe1, 0x7c, 0x69, 0x1c, 0x07, 0x38, 0x16, 0x79, 0xf5, 0x1c, 0xfa, 0x95, 0xb9,
 0xc7, 0x3e, 0xa0, 0x59, 0xe7, 0xd4, 0x73, 0xea, 0x56, 0xe7, 0x1c, 0xfa, 0x81, 0x67, 0x9f, 0x51,
 0xcf, 0xa9, 0x5b, 0x9c, 0x73, 0x81, 0x67, 0x9f, 0x51, 0xcf, 0xa9, 0x5b, 0x9c, 0x73, 0xea, 0x05,
 0x9e, 0x73, 0xb3, 0xec, 0x04, 0xff, 0x00, 0xef, 0x18, 0xbe, 0x9f, 0xb0, 0x8f, 0xeb, 0x67, 0x4f,
 0xe7, 0xd4, 0xec, 0xdb, 0x05, 0x53, 0x85, 0x7c, 0x5f, 0xf6, 0x63, 0xfa, 0xd8, 0x1d, 0xe6, 0xe0,
 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x9a, 0x95, 0x33, 0x9a, 0x9e, 0xa4, 0x63, 0x7a, 0x7e,
 0xd7, 0x9f, 0xc5, 0x66, 0x2e, 0x6a, 0x55, 0xce, 0x2a, 0x7a, 0x91, 0x8c, 0xfe, 0xe2, 0x7f, 0x15,
 0x81, 0xe7, 0xfc, 0xe3, 0x9f, 0x52, 0xb7, 0x3e, 0xa3, 0x9f, 0x50, 0x2c, 0xf3, 0xea, 0x76, 0x1d,
 0x84, 0xc5, 0x28, 0x66, 0x75, 0x68, 0xb7, 0xc2, 0xed, 0x3e, 0x8d, 0x5a, 0x7d, 0x9c, 0x4e, 0xab,
 0xcf, 0xa9, 0x63, 0x2e, 0xc6, 0x4b, 0x07, 0x8d, 0xa3, 0x89, 0x87, 0x4b, 0xa7, 0x2e, 0x3c, 0x3c,
 0x2b, 0xbe, 0xbd, 0xc0, 0x3d, 0x5e, 0xe0, 0xb8, 0x50, 0xc3, 0xe2, 0xa9, 0xd7, 0xa1, 0x0a, 0xd4,
 0xa6, 0xa5, 0x09, 0xae, 0x31, 0x66, 0xf7, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x73, 0x51, 0x70,
 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x35, 0x31, 0x2a, 0xca, 0x2b, 0x8c, 0xa4, 0x92, 0xf0, 0xb6,
 0x05, 0xdb, 0x9a, 0x8b, 0x87, 0x0f, 0x5f, 0x39, 0xcb, 0xa8, 0x71, 0xb9, 0x8d, 0xa3, 0xc5, 0x77,
 0x94, 0xb8, 0xbf, 0x71, 0x14, 0x2b, 0xed, 0x5e, 0x5b, 0x4f, 0xfd, 0x5b, 0xad, 0x57, 0xfb, 0x30,
 0xe0, 0xbe, 0x1e, 0x00, 0x76, 0x7b, 0x86, 0x39, 0xd3, 0x5c, 0x1f, 0x4a, 0x3a, 0xae, 0x5d, 0xb5,
 0x34, 0xf1, 0x79, 0x85, 0x3c, 0x37, 0x9d, 0xdd, 0x28, 0xd4, 0x7c, 0x14, 0xdc, 0xf8, 0xf4, 0xf7,
 0xba, 0x38, 0x1c, 0xfd, 0xc0, 0x31, 0x89, 0xcb, 0xf2, 0xec, 0x47, 0x1b, 0xb8, 0x3a, 0x2d, 0xbe,
 0xfa, 0x8f, 0x07, 0xee, 0xa3, 0x8c, 0xc5, 0x6c, 0xc6, 0x5f, 0x53, 0x8b, 0xa3, 0x52, 0xad, 0x07,
 0xe0, 0x52, 0xe6, 0x5f, 0x0f, 0x4f, 0xc2, 0x72, 0x97, 0x05, 0xc0, 0x3a, 0xa6, 0x33, 0x66, 0x31,
 0xf4, 0xb8, 0xcb, 0x0f, 0x52, 0x9e, 0x22, 0x3e, 0x0f, 0xad, 0x97, 0xb8, 0xfa, 0x3e, 0x13, 0x83,
 0xaf, 0x0a, 0xb4, 0x2a, 0xca, 0x95, 0x68, 0x4a, 0x9d, 0x48, 0xf5, 0xc6, 0x4b, 0x83, 0x47, 0xa3,
 0xdc, 0xd4, 0xf3, 0xfd, 0xa9, 0xac, 0xa7, 0x9f, 0x62, 0xa4, 0x9f, 0x7e, 0x2b, 0xdc, 0x8a, 0x40,
 0x55, 0xe7, 0xd4, 0x73, 0x95, 0xb9, 0xf5, 0x1c, 0xfa, 0x81, 0xda, 0x76, 0x0e, 0x7e, 0xab, 0xd5,
 0xfc, 0x1d, 0xfc, 0x68, 0x9d, 0xda, 0xe1, 0xd0, 0x76, 0x16, 0x5e, 0xa9, 0xd7, 0x97, 0x82, 0x8b,
 0x5f, 0xfd, 0x91, 0xdc, 0xae, 0x6a, 0x05, 0xcb, 0x86, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x79, 0xfe,
 0x73, 0x3f, 0x56, 0x31, 0xbd, 0x3f, 0x6c, 0x54, 0xf8, 0xcc, 0xab, 0xcf, 0xa9, 0x9c, 0xe2, 0x7e,
 0xab, 0xe3, 0x3f, 0xbf, 0x9f, 0xc6, 0x65, 0x5e, 0x70, 0x2c, 0xf3, 0xea, 0x72, 0xbb, 0x27, 0x88,
 0xb5, 0x9f, 0xe1, 0xf8, 0xbe, 0x89, 0x73, 0x47, 0xdd, 0x4f, 0x87, 0xc2, 0x70, 0x3c, 0xe4, 0x98,
 0x6c, 0x44, 0xa8, 0x62, 0x29, 0xd7, 0x83, 0xf4, 0xd4, 0xe4, 0xa4, 0xbd, 0x94, 0xc0, 0xf5, 0xbb,
 0x82, 0xe1, 0xc7, 0x61, 0x31, 0x74, 0xf1, 0x38, 0x6a, 0x75, 0xe9, 0x4b, 0x8c, 0x27, 0x1e, 0x28,
 0x96, 0xe0, 0x17, 0x2e, 0x1a, 0xd4, 0xab, 0xc2, 0x9c, 0xa5, 0xe0, 0x4d, 0x95, 0x6e, 0x6a, 0x56,
 0xcd, 0x71, 0x2a, 0x8e, 0x59, 0x89, 0xaa, 0xdf, 0x0e, 0x5a, 0x52, 0xe1, 0xec, 0xf0, 0xe8, 0x03,
 0xcf, 0xb9, 0xf5, 0x1c, 0xfa, 0x95, 0xb9, 0xc7, 0x38, 0x16, 0x79, 0xf5, 0x3b, 0x06, 0xc2, 0xe2,
 0x14, 0x33, 0x5a, 0x94, 0xdb, 0xfa, 0xfa, 0x4f, 0x87, 0xb2, 0x9a, 0xff, 0x00, 0x33, 0xab, 0x73,
 0x96, 0xb2, 0xac, 0x6b, 0xc1, 0x66, 0x34, 0x71, 0x2b, 0xaa, 0x12, 0xf4, 0xc9, 0x77, 0xd3, 0xe8,
 0x7f, 0x00, 0x1e, 0xa9, 0x70, 0xcd, 0xcd, 0x4a, 0x54, 0xeb, 0xc6, 0xa5, 0x38, 0xce, 0x12, 0x52,
 0x8c, 0x92, 0x71, 0x6b, 0xbe, 0x8c, 0xdc, 0xd4, 0x0b, 0x97, 0x35, 0x29, 0x67, 0xb5, 0xb8, 0x64,
 0xd8, 0xce, 0x9f, 0xf7, 0x32, 0x5e, 0xea, 0x33, 0x73, 0x53, 0x8a, 0xda, 0xbc, 0x4a, 0xa5, 0x91,
 0x57, 0x5c, 0x7a, 0x67, 0xc2, 0x0b, 0xdb, 0x7d, 0x9c, 0x40, 0xe9, 0x5c, 0xfa, 0x8e, 0x7d, 0x4a,
 0xdc, 0xe3, 0x9f, 0x50, 0x2c, 0xf3, 0xea, 0x77, 0x6d, 0x83, 0xa9, 0xea, 0x45, 0x5e, 0x9f, 0xb6,
 0x1f, 0xc5, 0x89, 0xd0, 0x39, 0xf5, 0x3b, 0xb6, 0xc4, 0x4b, 0x97, 0x27, 0x93, 0xfe, 0x35, 0x69,
 0x3f, 0x81, 0x01, 0xda, 0x6e, 0x0b, 0x9a, 0x94, 0xee, 0x0b, 0x9a, 0x81, 0xd5, 0xb6, 0xed, 0x72,
 0xe6, 0x94, 0xaa, 0xae, 0xa9, 0xd2, 0x4b, 0xdb, 0x4d, 0xf6, 0xa3, 0xaf, 0x73, 0xea, 0x76, 0xad,
 0xb8, 0xa5, 0x77, 0x2e, 0xa7, 0x88, 0x4b, 0x8b, 0xa3, 0x3e, 0x0f, 0xd8, 0x7f, 0xe7, 0xc0, 0xe9,
 0x9c, 0xfa, 0x81, 0x67, 0x9f, 0x52, 0xde, 0x4d, 0x59, 0x53, 0xcd, 0xb0, 0x93, 0x6f, 0xa1, 0x56,
 0x8f, 0x1f, 0x74, 0xe2, 0xf9, 0xf5, 0x32, 0xaa, 0x34, 0xd3, 0x4f, 0x83, 0x5d, 0x40, 0x7a, 0xf5,
 0xcd, 0x45, 0xc3, 0x89, 0xca, 0xb1, 0xf1, 0xc7, 0x60, 0x29, 0x62, 0x22, 0xd7, 0x19, 0x47, 0xd3,
 0x2f, 0x04, 0xbb, 0xe8, 0xb5, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0x5c, 0x02,
 0xcd, 0x6a, 0xea, 0x9d, 0x19, 0xd4, 0x6f, 0xa2, 0x31, 0x6f, 0xdc, 0x47, 0x96, 0x73, 0xea, 0x77,
 0x5d, 0xaa, 0xc7, 0xac, 0x2e, 0x51, 0x56, 0x3c, 0xdc, 0x27, 0x59, 0x5b, 0x8a, 0xf6, 0x7a, 0xfe,
 0x03, 0xa0, 0xf3, 0x81, 0x67, 0x9f, 0x51, 0xcf, 0xa9, 0x5b, 0x9c, 0xca, 0x93, 0x6f, 0x82, 0xe9,
 0x6f, 0xbc, 0x80, 0xf4, 0x1d, 0x88, 0x8d, 0xbc, 0x97, 0x9d, 0xff, 0x00, 0xbd, 0xa9, 0x29, 0x7b,
 0x5d, 0x5f, 0xb0, 0xe7, 0x6e, 0x6a, 0x71, 0x79, 0x65, 0x3f, 0x3a, 0xe5, 0xf4, 0x30, 0xfd, 0xf8,
 0x41, 0x27, 0xec, 0xf7, 0xfe, 0x12, 0xc5, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5,
 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02,
 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x3a, 0xa6, 0xf0, 0x6a, 0x7f, 0xb0,
 0xf4, 0xff, 0x00, 0x29, 0xfb, 0xa7, 0x3f, 0x70, 0xea, 0xdb, 0x7f, 0x53, 0xfd, 0x8b, 0xf1, 0x9f,
 0xba, 0x07, 0x5e, 0xe7, 0xd4, 0x73, 0xea, 0x56, 0xe7, 0xd4, 0x73, 0x81, 0x67, 0x9f, 0x53, 0xd5,
 0xae, 0x6a, 0x79, 0x07, 0x39, 0xea, 0x77, 0x00, 0xb9, 0x73, 0xa7, 0xac, 0x5c, 0xd4, 0xa7, 0x73,
 0x51, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2d, 0xdc, 0x33, 0x70, 0xa7, 0x73,
 0x51, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x73, 0x51, 0x70, 0xa7,
 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x05,
 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2a, 0x5c, 0x31, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc3, 0x37,
 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0xc5, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x97, 0x0c, 0x5c,
 0x2a, 0x5c, 0xd4, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc3, 0x37, 0x35,
 0x29, 0xdc, 0x17, 0x00, 0xeb, 0x3b, 0x71, 0x3e, 0x39, 0xb5, 0x2f, 0xee, 0x17, 0xc6, 0x91, 0xc0,
 0xf3, 0x9c, 0xa6, 0xdb, 0x54, 0xe3, 0x9a, 0xd2, 0xfe, 0xe1, 0x7c, 0x69, 0x1c, 0x17, 0x38, 0x16,
 0x79, 0xc7, 0x39, 0x5b, 0x9c, 0x73, 0x81, 0x67, 0x9c, 0x73, 0x9d, 0xeb, 0xce, 0x59, 0x7f, 0xf3,
 0x1c, 0x2f, 0x92, 0x8f, 0x60, 0xf3, 0x96, 0x5f, 0xfc, 0xc7, 0x0b, 0xe4, 0xa3, 0xd8, 0x07, 0x45,
 0xe7, 0x1c, 0xe7, 0x7a, 0xf3, 0x96, 0x5f, 0xfc, 0xc7, 0x0b, 0xe4, 0xa3, 0xd8, 0x3c, 0xe5, 0x97,
 0xff, 0x00, 0x31, 0xc2, 0xf9, 0x18, 0xf6, 0x01, 0xd1, 0x79, 0xc7, 0x39, 0xde, 0xbc, 0xe5, 0x97,
 0xff, 0x00, 0x31, 0xc2, 0xf9, 0x28, 0xf6, 0x0f, 0x39, 0x65, 0xff, 0x00, 0xcc, 0x70, 0xbe, 0x4a,
 0x3d, 0x80, 0x74, 0x5e, 0x73, 0xb2, 0x6c, 0x25, 0x4f, 0xab, 0xe2, 0xbf, 0xb3, 0x1f, 0xd6, 0xce,
 0x5b, 0xce, 0x59, 0x7f, 0xf3, 0x1c, 0x2f, 0x92, 0x8f, 0x61, 0x2d, 0x0a, 0x58, 0x6c, 0x3b, 0x6e,
 0x85, 0x0a, 0x54, 0x9b, 0xeb, 0xe4, 0x82, 0x8f, 0x1f, 0x70, 0x0e, 0x42, 0xe0, 0xb8, 0x54, 0xb8,
 0x2e, 0x01, 0x6e, 0xe1, 0x5b, 0x37, 0xa9, 0xea, 0x4e, 0x33, 0xfb, 0x89, 0xfc, 0x56, 0x6b, 0x70,
 0xab, 0x9b, 0x54, 0xf5, 0x2b, 0x17, 0xfd, 0xc4, 0xfe, 0x2b, 0x03, 0xa2, 0xf3, 0x8e, 0x72, 0xb7,
 0x38, 0xe7, 0x02, 0xcf, 0x38, 0xe7, 0x2b, 0x73, 0x92, 0x57, 0x85, 0x4a, 0x32, 0x8c, 0x6a, 0x47,
 0x87, 0x34, 0x23, 0x38, 0xea, 0x9a, 0xe2, 0x80, 0xe6, 0x32, 0x7c, 0xf3, 0x15, 0x96, 0xfa, 0x48,
 0xf0, 0xab, 0x45, 0xbe, 0x2e, 0x9c, 0x9f, 0x57, 0xb0, 0xfb, 0xc7, 0x3b, 0x0d, 0xae, 0xc1, 0xb8,
 0xfa, 0x7c, 0x3e, 0x21, 0x4b, 0xc0, 0xb8, 0x35, 0xfa, 0xce, 0x8d, 0xce, 0x39, 0xc0, 0xed, 0xb8,
 0xed, 0xad, 0xab, 0x38, 0xb8, 0xe0, 0xe8, 0x2a, 0x7f, 0xd3, 0x9b, 0xe2, 0xfd, 0xce, 0xaf, 0xd6,
 0x5a, 0xd8, 0xec, 0xd2, 0xae, 0x21, 0xe2, 0x28, 0x62, 0x2a, 0xca, 0xa5, 0x4e, 0x37, 0x13, 0x93,
 0xe2, 0xfc, 0x0f, 0xf6, 0x1d, 0x23, 0x9c, 0xbd, 0x91, 0x63, 0x7c, 0xe9, 0x9a, 0xd0, 0xaa, 0xdf,
 0x08, 0xb9, 0x72, 0xcb, 0xd8, 0x7d, 0x1f, 0xe6, 0x07, 0xa5, 0xdc, 0x38, 0x2d, 0xb4, 0xa4, 0xeb,
 0x65, 0x91, 0xaf, 0x1e, 0xba, 0x32, 0xe2, 0xfd, 0x87, 0xd0, 0xff, 0x00, 0x61, 0xc8, 0xdc, 0xd4,
 0xd2, 0xb7, 0x25, 0x6a, 0x33, 0xa5, 0x51, 0x71, 0x84, 0xd3, 0x8c, 0x97, 0x85, 0x30, 0x3c, 0xfb,
 0x9c, 0x73, 0x8c, 0xcb, 0x0f, 0x3c, 0x16, 0x32, 0xa6, 0x1e, 0x7f, 0x62, 0xfd, 0x2b, 0xfe, 0x32,
 0xef, 0x32, 0xb7, 0x38, 0x16, 0xa3, 0x56, 0x51, 0x92, 0x94, 0x5f, 0x09, 0x27, 0xc5, 0x35, 0xde,
 0x3b, 0xbe, 0x45, 0x9f, 0xd0, 0xc6, 0xd1, 0x8d, 0x3a, 0xf5, 0x23, 0x4f, 0x12, 0x97, 0x06, 0x9b,
 0xe0, 0xa5, 0xaa, 0xec, 0x3c, 0xfb, 0x9c, 0x73, 0x81, 0xeb, 0x17, 0x05, 0xc3, 0xcb, 0xa9, 0xe3,
 0xf1, 0x74, 0x97, 0x0a, 0x58, 0xaa, 0xf0, 0x5e, 0x08, 0xd4, 0x68, 0x4f, 0x30, 0xc6, 0x54, 0x5c,
 0x27, 0x8b, 0xaf, 0x25, 0xad, 0x46, 0xc0, 0xf4, 0x3c, 0xd7, 0x39, 0xc2, 0xe0, 0x28, 0xc9, 0xce,
 0xa4, 0x65, 0x57, 0x87, 0xa5, 0xa6, 0x9f, 0x4b, 0x7f, 0xb1, 0x1d, 0x06, 0xb6, 0x22, 0x75, 0xab,
 0x4e, 0xad, 0x47, 0xc6, 0x73, 0x93, 0x94, 0x9e, 0xac, 0xa7, 0xce, 0x39, 0xc0, 0xb3, 0xce, 0x39,
 0xca, 0xdc, 0xe3, 0x9c, 0x0e, 0xdf, 0xb0, 0x9f, 0xeb, 0x31, 0x55, 0x7c, 0x0a, 0x31, 0x5f, 0x0f,
 0x61, 0xda, 0x6e, 0x1d, 0x77, 0x64, 0xa9, 0x3c, 0x3e, 0x54, 0xa7, 0x25, 0xc2, 0x55, 0xa4, 0xe7,
 0xed, 0x77, 0xbb, 0x7d, 0xb3, 0x97, 0xb8, 0x05, 0xbb, 0x9a, 0x99, 0xb8, 0x53, 0xb8, 0x2e, 0x01,
 0xd1, 0x73, 0x79, 0xfa, 0xad, 0x8c, 0xfe, 0xfe, 0x7f, 0x19, 0x95, 0x79, 0xcc, 0xe6, 0xd3, 0xf5,
 0x57, 0x17, 0xfd, 0xfc, 0xfe, 0x33, 0x2a, 0xf3, 0x81, 0x67, 0x9c, 0x73, 0x95, 0xb9, 0xc9, 0x6d,
 0x55, 0xf3, 0xa2, 0xc5, 0x28, 0xf1, 0xa5, 0xce, 0xe1, 0xc5, 0x77, 0x9f, 0x04, 0xff, 0x00, 0x68,
 0x1c, 0xde, 0x41, 0x9e, 0xd4, 0xcb, 0x64, 0xe9, 0x54, 0x4e, 0xa6, 0x1e, 0x4f, 0x8b, 0x8a, 0xeb,
 0x8b, 0xf0, 0xae, 0xc3, 0xb7, 0x61, 0x33, 0x5c, 0x16, 0x2e, 0x29, 0xd0, 0xc4, 0xd3, 0x93, 0x7f,
 0x62, 0xdf, 0x09, 0x7b, 0x8c, 0xf3, 0x1e, 0x71, 0xce, 0x07, 0xab, 0x54, 0xc4, 0xd3, 0xa7, 0x1e,
 0x6a, 0x95, 0x21, 0x08, 0xf8, 0x65, 0x2e, 0x08, 0xea, 0x9b, 0x53, 0x9e, 0xd3, 0xc5, 0x53, 0xf3,
 0x96, 0x12, 0x7c, 0xd4, 0xf8, 0xf1, 0xa9, 0x3e, 0xf4, 0xb8, 0x75, 0x25, 0xa1, 0xd5, 0x39, 0xc7,
 0x38, 0x16, 0x79, 0xc7, 0x39, 0x5b, 0x9c, 0x73, 0x81, 0x67, 0x9c, 0x73, 0x95, 0xe9, 0xf3, 0x4e,
 0x71, 0x84, 0x13, 0x94, 0xa4, 0xf8, 0x24, 0xbb, 0xec, 0x9b, 0x1d, 0x87, 0xaf, 0x82, 0xc4, 0x3a,
 0x15, 0xe3, 0xc2, 0x4b, 0xa5, 0x35, 0xd4, 0xd7, 0x85, 0x01, 0xcf, 0xec, 0xf6, 0xd0, 0xcb, 0x05,
 0x15, 0x86, 0xc4, 0xf1, 0x9e, 0x1f, 0xec, 0x5a, 0xeb, 0x87, 0x6a, 0x3b, 0x5e, 0x17, 0x31, 0xc2,
 0xe2, 0xa2, 0xa5, 0x43, 0x11, 0x4e, 0xa2, 0x7d, 0xe5, 0x2e, 0x9f, 0x73, 0xac, 0xf2, 0xee, 0x71,
 0xce, 0x07, 0xa9, 0xe2, 0x31, 0xd8, 0x6c, 0x3c, 0x5c, 0xab, 0xd7, 0xa7, 0x4d, 0x2f, 0xe3, 0x48,
 0xe9, 0x9b, 0x49, 0x9d, 0x77, 0x46, 0xac, 0x69, 0x51, 0xe2, 0xb0, 0xf4, 0xdf, 0x15, 0xc7, 0xae,
 0x4f, 0xc2, 0x75, 0xfe, 0x71, 0xce, 0x05, 0x9e, 0x71, 0xce, 0x56, 0xe7, 0x1c, 0xe0, 0x59, 0xe7,
 0x3b, 0xe6, 0xcb, 0x27, 0x4b, 0x23, 0xa0, 0x9f, 0x43, 0x97, 0x19, 0x7b, 0xad, 0xf0, 0xf8, 0x0e,
 0x81, 0x81, 0xa5, 0x3c, 0x5e, 0x2e, 0x9e, 0x1e, 0x9f, 0xd7, 0x4e, 0x5c, 0x38, 0xf8, 0x17, 0x7d,
 0x9e, 0x89, 0x47, 0x96, 0x8d, 0x18, 0x52, 0x87, 0x44, 0x61, 0x15, 0x15, 0xec, 0x20, 0x2f, 0x5c,
 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x00, 0x9b, 0x19, 0x08, 0x62, 0xb0, 0xb5, 0x70, 0xf5, 0x3e, 0xb6,
 0xa4, 0x5c, 0x5e, 0x9a, 0x9e, 0x73, 0x89, 0x85, 0x4c, 0x3e, 0x22, 0xa5, 0x0a, 0x8b, 0x84, 0xe1,
 0x27, 0x16, 0x7a, 0x05, 0xc3, 0xaf, 0x6d, 0x6e, 0x5e, 0xeb, 0xc3, 0xcf, 0xd4, 0x23, 0xc6, 0xa4,
 0x17, 0x0a, 0x89, 0x7d, 0x94, 0x7c, 0x3e, 0xd0, 0x1d, 0x73, 0x9c, 0x73, 0x95, 0xb9, 0xc7, 0x38,
 0x1c, 0xe6, 0x41, 0x9c, 0xd4, 0xcb, 0x2b, 0xb4, 0xd3, 0x9d, 0x09, 0xbf, 0x4f, 0x05, 0xde, 0xd5,
 0x6a, 0x77, 0x5c, 0x16, 0x61, 0x86, 0xc6, 0x53, 0xb9, 0x87, 0xad, 0x19, 0xae, 0xfa, 0x4f, 0xa5,
 0x7b, 0x2b, 0xbc, 0x79, 0x77, 0x39, 0xb4, 0x2a, 0xca, 0x12, 0x52, 0x84, 0x9c, 0x64, 0xba, 0x9a,
 0x7c, 0x18, 0x1e, 0xad, 0x73, 0x52, 0xa6, 0x63, 0x9a, 0xe1, 0x30, 0x14, 0xdc, 0xb1, 0x15, 0x52,
 0x97, 0x0e, 0x88, 0x2e, 0x99, 0x3f, 0x68, 0xf3, 0xb7, 0x99, 0x63, 0x9c, 0x79, 0x5e, 0x33, 0x11,
 0xc3, 0xc1, 0x75, 0xf6, 0x95, 0xdd, 0x47, 0x26, 0xdc, 0x9f, 0x16, 0xfb, 0xed, 0x81, 0xca, 0xe7,
 0x19, 0xa5, 0x6c, 0xcb, 0x14, 0xeb, 0x54, 0xf4, 0xb1, 0x5d, 0x10, 0x82, 0x7d, 0x11, 0x45, 0x2e,
 0x72, 0xb7, 0x38, 0xe7, 0x02, 0xcf, 0x39, 0xca, 0xec, 0xb6, 0x19, 0xe2, 0xf3, 0x48, 0x4e, 0x4b,
 0x8d, 0x3a, 0x3e, 0x9e, 0x5e, 0xcf, 0x79, 0x7b, 0xbf, 0xa8, 0xe0, 0xe9, 0x29, 0xd5, 0xa9, 0x1a,
 0x74, 0xe2, 0xe5, 0x39, 0x3e, 0x09, 0x2e, 0xfb, 0x3b, 0xe6, 0x49, 0x83, 0x8e, 0x5f, 0x81, 0x54,
 0xb8, 0xa7, 0x52, 0x5e, 0x9a, 0xa4, 0x97, 0x7d, 0x81, 0xcd, 0xdc, 0x17, 0x0a, 0x77, 0x05, 0xc0,
 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x35, 0x02,
 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x73, 0x51, 0x74, 0x0b, 0x77,
 0x08, 0xb0, 0xd8, 0xec, 0x3e, 0x26, 0x3c, 0x70, 0xf5, 0xa1, 0x53, 0x87, 0x5f, 0x2b, 0xe9, 0x5e,
 0xca, 0x21, 0xb9, 0xa9, 0xe6, 0xd7, 0xe7, 0x4e, 0xbb, 0x9d, 0x39, 0xca, 0x12, 0x52, 0x7c, 0x1c,
 0x5f, 0x06, 0x80, 0xf5, 0x5b, 0x82, 0xe1, 0xd0, 0xf2, 0xdd, 0xa7, 0xc5, 0x50, 0x6a, 0x18, 0xb5,
 0xe7, 0x8a, 0x7e, 0x1e, 0xa9, 0x2e, 0xd3, 0xb3, 0xe0, 0x33, 0x3c, 0x2e, 0x3a, 0x9f, 0x3e, 0x1e,
 0xaa, 0x93, 0x5d, 0x71, 0x7d, 0x12, 0x5e, 0xca, 0x03, 0x94, 0xb8, 0x75, 0x8d, 0xbc, 0xa9, 0xc7,
 0xce, 0x5f, 0x8c, 0xfd, 0xd3, 0x9c, 0xb8, 0x75, 0x8d, 0xba, 0xa9, 0xc7, 0xce, 0x7f, 0xf3, 0xfe,
 0xe8, 0x1c, 0x17, 0x38, 0xe7, 0x2b, 0x73, 0x8e, 0x70, 0x2c, 0xf3, 0x9e, 0xa1, 0x73, 0x53, 0xc9,
 0xb9, 0xcf, 0x4d, 0xb8, 0x05, 0xbb, 0x86, 0x6e, 0x14, 0xee, 0x6a, 0x2e, 0x6a, 0x05, 0xbb, 0x86,
 0x6e, 0x14, 0xee, 0x0b, 0x80, 0x5b, 0xb9, 0xa8, 0xb8, 0x54, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x9a,
 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85,
 0x4b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe0, 0x15, 0x2e, 0x18,
 0xb8, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8,
 0x62, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x74, 0x19, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe0,
 0x16, 0xee, 0x19, 0xb8, 0x53, 0xb9, 0xa8, 0xb9, 0xa8, 0x16, 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x0b,
 0x9a, 0x81, 0xd7, 0x36, 0xce, 0x7c, 0x73, 0x4a, 0x7f, 0xdc, 0x2f, 0x8d, 0x23, 0x83, 0xe7, 0x39,
 0x3d, 0xb1, 0x9f, 0xaa, 0x74, 0xff, 0x00, 0xb9, 0x5f, 0x1a, 0x47, 0x09, 0xce, 0x05, 0x9e, 0x73,
 0x1c, 0xe5, 0x7e, 0x71, 0xce, 0x07, 0xa9, 0x5c, 0x17, 0x0a, 0x8e, 0xa6, 0xa2, 0xe0, 0x17, 0x2e,
 0x6a, 0x62, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x6a, 0x54, 0xb9, 0xa8, 0xb9,
 0xa8, 0x16, 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x6a, 0x2e, 0x6a, 0x05, 0xcb, 0x86, 0x2e, 0x6a, 0x54,
 0xb8, 0x2e, 0x6a, 0x05, 0xbb, 0x85, 0x6c, 0xd6, 0xa7, 0xa9, 0x78, 0xbf, 0xee, 0x27, 0xf1, 0x59,
 0xad, 0xcd, 0x48, 0xb1, 0x4a, 0xfe, 0x16, 0xad, 0x0e, 0x6e, 0x5b, 0x90, 0x94, 0x38, 0xf0, 0xe3,
 0xc3, 0x8a, 0xe0, 0x07, 0x45, 0xe7, 0x1c, 0xe7, 0x37, 0xfc, 0x1a, 0xfe, 0xbd, 0xfe, 0x17, 0xf9,
 0x8f, 0xe0, 0xd7, 0xf5, 0xef, 0xf0, 0xbf, 0xcc, 0x0e, 0x17, 0x9c, 0xed, 0xb8, 0xbc, 0x02, 0xcc,
 0x32, 0x1c, 0x23, 0x87, 0x05, 0x5e, 0x9d, 0x08, 0x38, 0x3f, 0x0f, 0xa5, 0x5d, 0x07, 0x19, 0xfc,
 0x1a, 0xfe, 0xbd, 0xfe, 0x17, 0xf9, 0x9c, 0xfe, 0x15, 0x58, 0xc2, 0xd2, 0xa1, 0xcd, 0xcd, 0x6e,
 0x0a, 0x1c, 0x78, 0x70, 0xe3, 0xc1, 0x70, 0x03, 0xa3, 0xcd, 0xca, 0x12, 0x71, 0x92, 0x71, 0x92,
 0x7c, 0x1a, 0x7d, 0xe6, 0x63, 0x9c, 0xed, 0x99, 0xb6, 0x57, 0x86, 0xc7, 0xbb, 0x9c, 0x5d, 0x2a,
 0xdc, 0x3e, 0xbe, 0x2b, 0xaf, 0xd9, 0x5d, 0xf3, 0x81, 0xaf, 0x90, 0xe6, 0x10, 0x6e, 0xda, 0xa7,
 0x55, 0x77, 0x9a, 0x97, 0x0f, 0xd6, 0x05, 0x1e, 0x71, 0xce, 0x5b, 0x86, 0x49, 0x99, 0x49, 0xf4,
 0xd1, 0x8c, 0x35, 0x75, 0x17, 0xec, 0x65, 0xec, 0x26, 0xce, 0xbe, 0x29, 0xe2, 0xb1, 0x0b, 0x87,
 0x7e, 0x34, 0xfb, 0x5f, 0x60, 0x1d, 0x93, 0x25, 0xc6, 0xf9, 0xef, 0x2c, 0xa3, 0x59, 0xcb, 0x8c,
 0xb9, 0x79, 0x65, 0xec, 0xae, 0x86, 0x5c, 0xb8, 0x71, 0xd8, 0x3a, 0x34, 0x30, 0x74, 0x6c, 0xe1,
 0xe1, 0xc9, 0x04, 0xf8, 0xf5, 0xf1, 0xe2, 0xfc, 0x24, 0xd7, 0x35, 0x02, 0x2c, 0xf3, 0x01, 0x4f,
 0x31, 0xc3, 0xf0, 0x4d, 0x46, 0xb4, 0x17, 0xa4, 0x97, 0xec, 0x7a, 0x1d, 0x2b, 0x13, 0x4e, 0xae,
 0x1a, 0xb4, 0xa8, 0xd6, 0x83, 0x84, 0xe3, 0xd6, 0x99, 0xde, 0xae, 0x6a, 0x57, 0xc6, 0xe1, 0xf0,
 0xd8, 0xca, 0x7c, 0x98, 0x8a, 0x6a, 0x6b, 0xbc, 0xfb, 0xeb, 0xd8, 0x60, 0x74, 0x9e, 0x71, 0xce,
 0x73, 0x38, 0xbd, 0x9d, 0x7c, 0x5b, 0xc2, 0xe2, 0x17, 0x0e, 0xf4, 0x6a, 0x2f, 0xda, 0xbb, 0x0e,
 0x3a, 0xae, 0x4f, 0x99, 0x53, 0x7f, 0xec, 0xfc, 0xeb, 0xc3, 0x19, 0x26, 0x05, 0x6e, 0x73, 0x3c,
 0xe6, 0x65, 0x81, 0xc7, 0xc7, 0xaf, 0x07, 0x5f, 0xda, 0x83, 0x66, 0x16, 0x0b, 0x1c, 0xfe, 0xd2,
 0xc4, 0x79, 0x36, 0x03, 0x9c, 0x73, 0x92, 0x43, 0x2d, 0xcc, 0x67, 0xd5, 0x84, 0xa8, 0xbd, 0x9e,
 0x8f, 0xd6, 0x5b, 0xc3, 0xe4, 0x18, 0xfa, 0x8f, 0xea, 0x8e, 0x95, 0x25, 0xac, 0xb8, 0xbf, 0x80,
 0x0a, 0x1c, 0xe7, 0x31, 0x90, 0x65, 0x53, 0xc6, 0x54, 0x8d, 0x7c, 0x44, 0x5c, 0x70, 0xe9, 0xf1,
 0xe9, 0xfb, 0x3f, 0x63, 0x4d, 0x4b, 0xd9, 0x7e, 0x47, 0x83, 0xc3, 0xb5, 0x3a, 0xcd, 0xe2, 0x26,
 0xbf, 0x8c, 0xb8, 0x47, 0xdc, 0x39, 0x85, 0x53, 0x82, 0xe0, 0x80, 0xb6, 0xa6, 0x92, 0xe0, 0xba,
 0x12, 0xea, 0x46, 0x6e, 0x14, 0xee, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01,
 0xd2, 0xb3, 0x59, 0xfa, 0xa9, 0x8b, 0xfe, 0xfe, 0x7f, 0x19, 0x95, 0xb9, 0xce, 0x7f, 0x15, 0x90,
 0x2a, 0xf8, 0xaa, 0xb5, 0xfc, 0xfb, 0xcb, 0x72, 0x6e, 0x7c, 0x2d, 0x71, 0xe1, 0xc5, 0xf1, 0xf0,
 0x91, 0x7f, 0x06, 0xbf, 0xaf, 0x7f, 0x85, 0xfe, 0x60, 0x70, 0xbc, 0xe7, 0x6b, 0xd9, 0x28, 0xd3,
 0xad, 0x92, 0xd7, 0xa3, 0x56, 0x2a, 0x70, 0x95, 0x66, 0x9a, 0x7f, 0xd9, 0x89, 0xc7, 0x7f, 0x06,
 0xff, 0x00, 0xaf, 0x7f, 0x85, 0xfe, 0x67, 0x2d, 0x93, 0x61, 0x3b, 0x9d, 0x85, 0x95, 0x0b, 0xd7,
 0x79, 0xa6, 0xe7, 0xc7, 0x97, 0x87, 0x79, 0x2f, 0x0e, 0x80, 0x70, 0x79, 0xd6, 0x53, 0x5b, 0x03,
 0x37, 0x52, 0x9a, 0x75, 0x30, 0xed, 0xf4, 0x4b, 0xbf, 0x1d, 0x1f, 0x69, 0xc5, 0xf3, 0x9d, 0xf9,
 0xcd, 0x3e, 0x87, 0xd2, 0x99, 0xc3, 0xe6, 0x19, 0x1e, 0x0f, 0x10, 0xdc, 0xe8, 0xb7, 0x87, 0x9b,
 0xfe, 0x2a, 0xe3, 0x1f, 0x73, 0xb0, 0x0e, 0xb3, 0xce, 0x63, 0x9c, 0xe4, 0x2b, 0x64, 0x18, 0xe8,
 0x3f, 0xa9, 0xca, 0x95, 0x55, 0xde, 0xe1, 0x2e, 0x0f, 0xe1, 0x22, 0x59, 0x2e, 0x66, 0xdf, 0x0f,
 0x3b, 0xaf, 0x66, 0xe4, 0x7b, 0x40, 0xab, 0xce, 0x39, 0x8e, 0x4b, 0x0f, 0xb3, 0xd8, 0xc9, 0xb5,
 0x7a, 0xad, 0x2a, 0x51, 0xef, 0xf4, 0xf3, 0x3f, 0xff, 0x00, 0xbd, 0xb3, 0x9a, 0xcb, 0x72, 0xac,
 0x1e, 0x09, 0xaa, 0x89, 0x3a, 0xb5, 0x57, 0xd9, 0xcf, 0xbd, 0xec, 0x2e, 0xf0, 0x1a, 0x6c, 0xce,
 0x56, 0xe8, 0x35, 0x8c, 0xc5, 0x47, 0x85, 0x4e, 0x1f, 0x53, 0x83, 0xfb, 0x1d, 0x5e, 0xa7, 0x29,
 0x9b, 0x60, 0xa8, 0xe6, 0x38, 0x7b, 0x75, 0x3d, 0x2c, 0xe3, 0xf5, 0x93, 0x5d, 0x71, 0x7d, 0x86,
 0x6e, 0x0b, 0x9a, 0x81, 0xd2, 0x71, 0xf8, 0x5c, 0x46, 0x06, 0xb5, 0xaa, 0xf0, 0xe1, 0xe0, 0x92,
 0xea, 0x97, 0xb0, 0x57, 0xe7, 0x3b, 0xd6, 0x22, 0x14, 0x71, 0x14, 0xdd, 0x2a, 0xf4, 0xe3, 0x52,
 0x0f, 0xad, 0x33, 0x82, 0xc6, 0x6c, 0xf5, 0x39, 0x37, 0x2c, 0x25, 0x77, 0x0f, 0xe8, 0x4f, 0xa5,
 0x7b, 0xa0, 0x70, 0x5c, 0xe3, 0x98, 0xb9, 0x53, 0x23, 0xcc, 0xa0, 0xfd, 0x2c, 0x29, 0xcf, 0x58,
 0xcd, 0x7e, 0xde, 0x06, 0xb1, 0xc9, 0x33, 0x37, 0xd7, 0x46, 0x31, 0xf6, 0x6a, 0x2e, 0xd0, 0x2a,
 0xf3, 0x99, 0xa7, 0xcf, 0x52, 0x6a, 0x10, 0x8b, 0x94, 0xa4, 0xf8, 0x24, 0xba, 0x5b, 0x39, 0x5c,
 0x36, 0xce, 0xd6, 0x6f, 0x8e, 0x23, 0x11, 0x08, 0x2f, 0x04, 0x38, 0xb7, 0xfb, 0x0e, 0x73, 0x2f,
 0xc0, 0xe1, 0x30, 0x2b, 0xea, 0x14, 0xfd, 0x3f, 0x0e, 0x0e, 0x72, 0xe9, 0x93, 0x01, 0xb3, 0xb9,
 0x6a, 0xc0, 0x52, 0x75, 0xab, 0x70, 0x78, 0x89, 0xae, 0x9f, 0xe8, 0x2f, 0x01, 0xcb, 0xdc, 0xd4,
 0xa9, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c,
 0x2a, 0x5c, 0xe9, 0xeb, 0x17, 0x00, 0xe1, 0x73, 0xfc, 0x95, 0xf3, 0x4b, 0x15, 0x81, 0x8f, 0x1e,
 0x3d, 0x32, 0xa4, 0xbf, 0x5a, 0xec, 0x3a, 0xdb, 0x93, 0x4f, 0x83, 0xe8, 0x6b, 0xad, 0x1d, 0xfa,
 0xe1, 0x43, 0x31, 0xcb, 0x70, 0x78, 0xee, 0x32, 0xa9, 0x0e, 0x4a, 0x9f, 0xc7, 0x87, 0x43, 0xf6,
 0xfc, 0x20, 0x75, 0x0e, 0x71, 0xce, 0x72, 0x58, 0xad, 0x9f, 0xc5, 0xd3, 0x6d, 0xd0, 0xa9, 0x4e,
 0xb4, 0x7b, 0xc9, 0xbe, 0x57, 0xd9, 0xf0, 0x94, 0x6a, 0x65, 0xb9, 0x8c, 0x1f, 0x09, 0x61, 0x2a,
 0xbf, 0xec, 0xae, 0x3f, 0xa8, 0x08, 0xf9, 0xc7, 0x39, 0x95, 0x82, 0xc7, 0xb7, 0xd1, 0x83, 0xc4,
 0x79, 0x36, 0x4d, 0x47, 0x28, 0xcc, 0xaa, 0x35, 0xc3, 0x0e, 0xe2, 0xbc, 0x32, 0x92, 0x40, 0x57,
 0xe7, 0x25, 0xc3, 0xd3, 0xad, 0x88, 0xaa, 0xa9, 0x51, 0xa7, 0x29, 0xcd, 0xf7, 0x91, 0xca, 0xe1,
 0x36, 0x75, 0xf1, 0x52, 0xc5, 0xe2, 0x17, 0x0f, 0xe2, 0xd3, 0xed, 0x7d, 0x87, 0x3d, 0x83, 0xa1,
 0x87, 0xc2, 0x53, 0xe4, 0xc3, 0xd2, 0x8c, 0x17, 0x7d, 0xae, 0xb7, 0xec, 0xb0, 0x23, 0xc8, 0x72,
 0xba, 0x79, 0x7c, 0x6e, 0xd4, 0x6a, 0x78, 0x89, 0x2e, 0xbe, 0xf4, 0x74, 0x5d, 0xa7, 0x2d, 0x73,
 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x35, 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x35, 0x02, 0xdd, 0xcd,
 0x45, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x73,
 0x51, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97, 0x05, 0xcd, 0x40, 0xb7,
 0x70, 0xf3, 0x8a, 0xb3, 0xfa, 0xa4, 0xbd, 0x96, 0x77, 0xcb, 0x87, 0x9d, 0x55, 0x9f, 0xd5, 0x65,
 0xec, 0xb0, 0x26, 0xe7, 0x24, 0xa1, 0x88, 0xab, 0x42, 0xac, 0x6a, 0xd1, 0xa9, 0x28, 0x4e, 0x3d,
 0x52, 0x4c, 0xa7, 0xce, 0x39, 0xc0, 0xee, 0xb9, 0x26, 0xd1, 0x47, 0x11, 0x28, 0xd0, 0xc6, 0x72,
 0xd3, 0xaa, 0xfa, 0x23, 0x3f, 0xb1, 0x97, 0x63, 0x2b, 0xed, 0xc4, 0xff, 0x00, 0xd8, 0xff, 0x00,
 0xe7, 0xfd, 0xd3, 0xa9, 0x73, 0x96, 0x31, 0x38, 0xfa, 0xf8, 0x9a, 0x14, 0x69, 0x56, 0x9f, 0x3a,
 0xa3, 0xc7, 0x95, 0xbe, 0xbe, 0x0f, 0x87, 0x47, 0xc0, 0x06, 0x79, 0xc7, 0x39, 0x5b, 0x9c, 0x73,
 0x81, 0x67, 0x9c, 0xf4, 0x9b, 0x87, 0x96, 0xf3, 0x9e, 0x8f, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a,
 0x77, 0x35, 0x17, 0x00, 0xb7, 0x73, 0x53, 0x37, 0x35, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xdd, 0xc1,
 0x70, 0xa9, 0x70, 0x5c, 0xd4, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x70,
 0xc5, 0xc2, 0xa5, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0xd4, 0x0b,
 0x6e, 0xa0, 0xb8, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0x3b, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb,
 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x85, 0x4b, 0x86, 0x2e, 0x01, 0x72, 0xe0,
 0xb8, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0xbb, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe1,
 0x52, 0xe0, 0xb9, 0xa8, 0x1c, 0x06, 0xd7, 0xcf, 0xd5, 0x3a, 0x7f, 0xdc, 0xaf, 0x8d, 0x23, 0x85,
 0xe7, 0x39, 0x0d, 0xad, 0xa9, 0xc7, 0x32, 0xa7, 0xfd, 0xca, 0xfd, 0x72, 0x38, 0x7e, 0x70, 0x2c,
 0x73, 0x8e, 0x72, 0xbf, 0x38, 0xe7, 0x03, 0xd3, 0x2e, 0x0b, 0x87, 0x54, 0xfe, 0x14, 0x7f, 0x52,
 0xff, 0x00, 0x17, 0xfc, 0x87, 0xf0, 0xa3, 0xfa, 0x97, 0xf8, 0xbf, 0xe4, 0x07, 0x6b, 0xb9, 0xa8,
 0xb9, 0xa9, 0xd5, 0x3f, 0x85, 0x1f, 0xd4, 0xbf, 0xc5, 0xff, 0x00, 0x21, 0xfc, 0x28, 0xfe, 0xa5,
 0xfe, 0x2f, 0xf9, 0x01, 0xda, 0xee, 0x0b, 0x87, 0x54, 0xfe, 0x14, 0x7f, 0x52, 0xff, 0x00, 0x17,
 0xfc, 0x87, 0xf0, 0xa3, 0xfa, 0x97, 0xf8, 0xbf, 0xe4, 0x07, 0x6b, 0xb8, 0x2e, 0x1d, 0x53, 0xf8,
 0x51, 0xfd, 0x4b, 0xfc, 0x5f, 0xf2, 0x1f, 0xc2, 0x8f, 0xea, 0x5f, 0xe2, 0xff, 0x00, 0x90, 0x1d,
 0xae, 0xe0, 0xb8, 0x75, 0xcc, 0xb7, 0x3f, 0xf3, 0xe6, 0x32, 0x18, 0x7f, 0x3b, 0x5b, 0xe6, 0xe3,
 0xe9, 0xae, 0x71, 0xe1, 0xc1, 0x71, 0xf0, 0x1c, 0xbd, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x97, 0x35,
 0x17, 0x40, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x17, 0x00,
 0xb7, 0x73, 0x51, 0x70, 0xa7, 0x70, 0xcd, 0xcd, 0x40, 0xb7, 0x70, 0x5c, 0x29, 0xdc, 0x33, 0x70,
 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97, 0x45, 0xc0, 0x2d,
 0xdc, 0xd4, 0x5c, 0x2a, 0x5c, 0xd4, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd,
 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x45, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05,
 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xcd, 0x40, 0xb7, 0x70, 0x5c,
 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9,
 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x73, 0x51, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97,
 0x05, 0xcd, 0x40, 0xb7, 0x70, 0x5c, 0xd4, 0xa9, 0x73, 0x51, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a,
 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x35, 0x17, 0x35, 0x02, 0xdd, 0xc1, 0x70, 0xa9,
 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c,
 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b,
 0x77, 0x05, 0xc2, 0xa5, 0xc1, 0x73, 0x50, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc,
 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a,
 0x97, 0x0c, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5,
 0xcd, 0x45, 0xc0, 0x2d, 0xdc, 0x17, 0x35, 0x2a, 0x5c, 0x31, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a,
 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x2a, 0x63, 0x70, 0x58, 0x3c, 0x62, 0x77, 0xa8, 0xae, 0x6f, 0xe3,
 0xc7, 0xa2, 0x5e, 0xe8, 0xb9, 0xa8, 0xb8, 0x07, 0x5d, 0xcc, 0xf2, 0x6c, 0x46, 0x19, 0x3a, 0x94,
 0x1b, 0xaf, 0x49, 0x74, 0xf4, 0x2f, 0x4c, 0xbd, 0xa3, 0x88, 0xe7, 0x3b, 0xcd, 0xc3, 0x89, 0xcd,
 0xf2, 0xaa, 0x58, 0xbe, 0x35, 0x68, 0xf0, 0xa5, 0x5b, 0xe0, 0x97, 0xb3, 0xda, 0x07, 0x5c, 0xe7,
 0x1c, 0xe4, 0x55, 0xe3, 0x52, 0x85, 0x59, 0x52, 0xab, 0x17, 0x19, 0xc5, 0xf4, 0xa6, 0x69, 0xce,
 0x05, 0x8e, 0x71, 0xce, 0x57, 0xe7, 0x1c, 0xe0, 0x58, 0xe7, 0x3d, 0x12, 0xe6, 0xa7, 0x99, 0xf3,
 0x9e, 0x81, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97,
 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x45, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0,
 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x35, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7,
 0x70, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xa7, 0x70, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1,
 0x70, 0xa9, 0x73, 0x53, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x73, 0x51, 0x73, 0x50, 0x2e,
 0x5c, 0xd4, 0x5c, 0xd4, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0xa5, 0xcd, 0x4c, 0x5c,
 0x02, 0xe5, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x35, 0x33, 0x73, 0x50, 0x38, 0x4d, 0xab, 0xa9, 0xea,
 0x8d, 0x3e, 0x9f, 0xf7, 0x4b, 0xf5, 0xb3, 0x87, 0xe7, 0xd4, 0xbd, 0xb5, 0x35, 0x3d, 0x50, 0x87,
 0x4f, 0xfb, 0xa5, 0xfa, 0xd9, 0xc4, 0xf3, 0xea, 0x05, 0x8e, 0x7d, 0x47, 0x3e, 0xa5, 0x7e, 0x7d,
 0x47, 0x3e, 0xa0, 0x58, 0xe7, 0xd4, 0x73, 0xea, 0x57, 0xe7, 0x1c, 0xfa, 0x81, 0x63, 0x9c, 0x73,
 0x95, 0xf9, 0xf5, 0x1c, 0xfa, 0x81, 0x63, 0x9f, 0x51, 0xcf, 0xa9, 0x5f, 0x9f, 0x51, 0xcf, 0xa8,
 0x16, 0x39, 0xf5, 0x1c, 0xfa, 0x95, 0xf9, 0xc7, 0x3e, 0xa0, 0x73, 0x3b, 0x3b, 0x3f, 0x55, 0xe8,
 0xf4, 0xf7, 0xa5, 0xf1, 0x59, 0xdb, 0x6e, 0x1d, 0x23, 0x67, 0xea, 0x7a, 0xad, 0x47, 0xd8, 0x97,
 0xea, 0x67, 0x6b, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x6a, 0x05, 0xbb,
 0x9a, 0x8b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x3b, 0x86, 0x6e, 0x6a, 0x05, 0xbb,
 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xee, 0x0b, 0x9a, 0x81, 0x72,
 0xe0, 0xb8, 0x53, 0xb8, 0x66, 0xe6, 0xa0, 0x5b, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe1, 0x9b, 0x9a,
 0x81, 0x6e, 0xe0, 0xb8, 0x54, 0xb9, 0xa9, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x6a, 0x66,
 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x14, 0xee, 0x19, 0xb8, 0x05, 0xbb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2,
 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x15, 0x2e, 0x18, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x15, 0x2e,
 0x18, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x4b, 0x82,
 0xe0, 0x16, 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x18, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x86,
 0x6e, 0x01, 0x6e, 0xe0, 0xb8, 0x53, 0x75, 0x0c, 0xdc, 0xd4, 0x0b, 0x77, 0x05, 0xc2, 0x9d, 0xc3,
 0x37, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0xd4, 0xc5, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x0c,
 0xdc, 0x02, 0xdd, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc3, 0x37,
 0x00, 0xb7, 0x73, 0x51, 0x70, 0xa7, 0x70, 0xcd, 0xc0, 0x2d, 0xdc, 0x17, 0x35, 0x2a, 0x5c, 0x31,
 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0xd4,
 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x97, 0x0c, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa9, 0x70,
 0xc5, 0xcd, 0x40, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d,
 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x2a, 0x5c, 0xd4, 0xc5, 0xc0, 0x2e, 0x5c, 0x17, 0x0a,
 0x97, 0x35, 0x17, 0x00, 0xb7, 0x73, 0x51, 0x70, 0xa9, 0x70, 0xc5, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c,
 0x29, 0xdc, 0xd4, 0xcd, 0xcd, 0x40, 0xb7, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0xcd, 0xc0, 0x2d, 0xdc,
 0x17, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x03, 0x19, 0xb6, 0x0e, 0x9e, 0x3a, 0x8f, 0x0e, 0x88, 0xd5,
 0x8a, 0xf4, 0x93, 0xfd, 0x8f, 0x43, 0xa8, 0xd6, 0x53, 0xa3, 0x56, 0x54, 0xea, 0x27, 0x19, 0xc5,
 0xf0, 0x69, 0x9d, 0xbe, 0xe6, 0xa7, 0x11, 0xb4, 0x78, 0x6b, 0xb4, 0x7c, 0xf5, 0x4d, 0x7a, 0x7a,
 0x6b, 0xd3, 0x6b, 0x1f, 0xf2, 0x03, 0x84, 0xe7, 0xd4, 0x73, 0xea, 0x57, 0xe7, 0xd4, 0x73, 0x81,
 0x67, 0x9f, 0x53, 0xbe, 0xdc, 0x3c, 0xe7, 0x9f, 0x53, 0xbd, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa9,
 0x70, 0xc5, 0xcd, 0x40, 0xb9, 0x73, 0x51, 0x70, 0xa9, 0x70, 0xc5, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c,
 0x2a, 0x5c, 0x31, 0x73, 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0xd4, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97,
 0x35, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xcd, 0x4c, 0xdc,
 0x02, 0xdd, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0a, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xc0,
 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x73, 0x51, 0x73,
 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xab, 0x9c, 0x60, 0x6b, 0xe3, 0x71, 0x51, 0xab, 0x4a,
 0x74, 0xd2, 0x50, 0x51, 0xf4, 0xcd, 0xf8, 0x5e, 0x9a, 0x94, 0xbb, 0x8d, 0x8b, 0xfe, 0x56, 0x87,
 0xe5, 0x3e, 0xc3, 0x97, 0xb8, 0x2e, 0x01, 0xc4, 0x77, 0x1b, 0x17, 0xfc, 0xad, 0x0f, 0xca, 0x7d,
 0x83, 0xb8, 0xb8, 0xbf, 0xe5, 0x68, 0x7b, 0xaf, 0xb0, 0xe5, 0xee, 0x0b, 0x80, 0x71, 0x1d, 0xc6,
 0xc5, 0xff, 0x00, 0x2b, 0x43, 0xf2, 0x9f, 0x60, 0xee, 0x2e, 0x2f, 0xf9, 0x5a, 0x1f, 0x94, 0xfb,
 0x0e, 0x5e, 0xe0, 0xb8, 0x07, 0x11, 0xdc, 0x6c, 0x5f, 0xf2, 0xb4, 0x3f, 0x29, 0xf6, 0x0e, 0xe3,
 0x62, 0xff, 0x00, 0x95, 0xa1, 0xf9, 0x4f, 0xb0, 0xe5, 0xee, 0x0b, 0x80, 0x71, 0x1d, 0xc6, 0xc5,
 0xff, 0x00, 0x2b, 0x43, 0xf2, 0x9f, 0x60, 0xee, 0x36, 0x2f, 0xf9, 0x5a, 0x1f, 0x94, 0xfb, 0x0e,
 0x5e, 0xe0, 0xb8, 0x07, 0x11, 0xdc, 0x6c, 0x5f, 0xf2, 0xb4, 0x3f, 0x29, 0xf6, 0x0e, 0xe3, 0x62,
 0xff, 0x00, 0x95, 0xa1, 0xee, 0xbe, 0xc3, 0x97, 0xb8, 0x2e, 0x6a, 0x05, 0x1c, 0xb3, 0x2d, 0xc4,
 0x61, 0x71, 0xb0, 0xaf, 0x52, 0xa5, 0x27, 0x18, 0xf1, 0xe2, 0xa2, 0xdf, 0x1e, 0x95, 0xc3, 0xc0,
 0x73, 0x57, 0x0a, 0x97, 0x0c, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1,
 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2,
 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29,
 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a,
 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc,
 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdd, 0x17, 0x00,
 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x05, 0xc0,
 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0xd4,
 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00,
 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b,
 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc,
 0x17, 0x00, 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc3,
 0x37, 0x00, 0xb7, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c,
 0x02, 0xe5, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0xd4, 0xa7, 0x70,
 0x5d, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0xd4, 0xa7,
 0x73, 0x51, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77,
 0x35, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa6, 0xaa, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53,
 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0,
 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x86, 0x25, 0x35, 0x28, 0xb8, 0xcb,
 0xa5, 0x35, 0xc1, 0xa2, 0xa5, 0xc1, 0x70, 0x0e, 0x2a, 0xa6, 0x4d, 0x89, 0xe7, 0x97, 0x25, 0x5a,
 0x3c, 0x9c, 0x5f, 0x2f, 0x16, 0xf8, 0xf0, 0xf7, 0x0d, 0x7b, 0x8d, 0x8b, 0xfe, 0x56, 0x87, 0xe5,
 0x3e, 0xc3, 0x97, 0xb9, 0xa8, 0xb8, 0x07, 0x11, 0xdc, 0x6c, 0x5f, 0xf2, 0xb4, 0x3f, 0x29, 0xf6,
 0x1d, 0x8e, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8,
 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17,
 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05,
 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0x4b, 0x82,
 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe6,
 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b,
 0x9a, 0x94, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82,
 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17,
 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8,
 0x15, 0x42, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5,
 0xc1, 0x73, 0x52, 0x9d, 0xc0, 0xea, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb,
 0x9a, 0x8b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb9, 0xa8, 0xb9, 0xa8,
 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c,
 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe6,
 0xa2, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe6,
 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2,
 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0,
 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b,
 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82,
 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xee, 0x0b, 0x80,
 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb9, 0xa8,
 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x6a,
 0x05, 0xcb, 0x9a, 0x8b, 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x2e,
 0x6a, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b,
 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x6a, 0x53,
 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94,
 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e,
 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9,
 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b,
 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x6a,
 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x9a, 0x8b, 0x9a, 0x94, 0xee,
 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x14,
 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x85,
 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1,
 0x4e, 0xe0, 0xb9, 0xa8, 0x15, 0x2e, 0x6a, 0x62, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b,
 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x62, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b,
 0x85, 0x3b, 0x82, 0xe0, 0x16, 0xee, 0x19, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b,
 0x9a, 0x94, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe6, 0xa6, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5c, 0xb8,
 0x62, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a,
 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x62, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6,
 0xa5, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x62, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b,
 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x9a,
 0x8b, 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5b, 0xb8, 0x66, 0xe6, 0xa5, 0x3b, 0x82, 0xe0, 0x16, 0xee,
 0x19, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x99, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05,
 0xcb, 0x9a, 0x98, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05,
 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x6a, 0x62, 0xe1, 0x52, 0xe0, 0xb8, 0x05,
 0xcb, 0x9a, 0x98, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x72,
 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81,
 0x6e, 0xe0, 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x98, 0xb8, 0x54, 0xb8, 0x2e, 0x01,
 0x72, 0xe6, 0xa2, 0xe6, 0xa5, 0x3b, 0x82, 0xe0, 0x16, 0xee, 0x19, 0xb8, 0x53, 0xb8, 0x2e, 0x01,
 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb9, 0xa8, 0x17,
 0x2e, 0x18, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb,
 0x9a, 0x8b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa9, 0x8b, 0x9a, 0x95, 0x2e, 0x0b, 0x80,
 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5b, 0xb8, 0x66, 0xe6, 0xa5, 0x3b, 0x82, 0xe0, 0x17,
 0x2e, 0x18, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0,
 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb9,
 0xa8, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8,
 0x05, 0xcb, 0x9a, 0x8b, 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x2e,
 0x01, 0x6e, 0xe1, 0x9b, 0x9a, 0x94, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe6,
 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x62, 0xe1, 0x52, 0xe0,
 0xb8, 0x05, 0xbb, 0x86, 0x6e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa9, 0x8b, 0x85, 0x4b, 0x82,
 0xe0, 0x16, 0xee, 0x19, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01,
 0x6e, 0xe6, 0xa2, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe6, 0xa0,
 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8,
 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x52, 0xe0, 0xb8, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x82,
 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x86, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5c, 0xb8, 0x62, 0xe6,
 0xa5, 0x4b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xbb, 0x82,
 0xe1, 0x52, 0xe6, 0xa2, 0xe0, 0x16, 0xee, 0x19, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5b,
 0xb8, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe1,
 0x8b, 0x85, 0x4b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x66,
 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xbb, 0x86, 0x6e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe1, 0x8b,
 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x66, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b,
 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe1, 0x9b,
 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa9, 0x8b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b,
 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x66, 0xe6, 0xa5, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8,
 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe1, 0x9b,
 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x80, 0x5b,
 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6,
 0xa2, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x62, 0xe1, 0x52, 0xe0, 0xb9, 0xa8, 0x16,
 0xee, 0x19, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe1, 0x8b, 0x85, 0x4b, 0x82, 0xe6, 0xa0, 0x5c,
 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa6, 0x6e, 0x14, 0xee, 0x6a, 0x2e, 0x01,
 0x72, 0xe6, 0xa6, 0x2e, 0x15, 0x2e, 0x6a, 0x2e, 0x01, 0x6e, 0xe1, 0x9b, 0x85, 0x3b, 0x82, 0xe0,
 0x16, 0xee, 0x6a, 0x66, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x16, 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x0b,
 0x80, 0x5b, 0xb8, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe1, 0x9b, 0x9a, 0x94, 0xee, 0x0b,
 0x80, 0x5b, 0xb9, 0xa9, 0x9b, 0x85, 0x3b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x0b,
 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb9, 0xa8, 0xb8,
 0x05, 0xbb, 0x9a, 0x99, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x82,
 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x6a, 0x2e,
 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x6a, 0x05, 0xbb, 0x86, 0x6e, 0x6a, 0x53, 0xb8, 0x2e,
 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x62, 0xe1, 0x52, 0xe0,
 0xb8, 0x05, 0xbb, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x99, 0xb8, 0x53, 0xb8, 0x2e,
 0x6a, 0x05, 0xbb, 0x9a, 0x99, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe0, 0x16, 0xee, 0x19, 0xb8, 0x53,
 0xb8, 0x2e, 0x01, 0x72, 0xe1, 0x8b, 0x85, 0x4b, 0x82, 0xe6, 0xa0, 0x5b, 0xb9, 0xa8, 0xb9, 0xa9,
 0x52, 0xe6, 0xa2, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x9a, 0x8b, 0x9a, 0x81, 0x6e, 0xe0, 0xb8,
 0x54, 0xb9, 0xa8, 0xb9, 0xa8, 0x16, 0xee, 0x6a, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x4e, 0xe0,
 0xb8, 0x54, 0xb8, 0x2e, 0x6a, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a,
 0x2e, 0x6a, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee,
 0x6a, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa2, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16,
 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x0b, 0x9a, 0x81, 0x6e, 0xe0, 0xb9, 0xa9, 0x52, 0xe0, 0xb9, 0xa8,
 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b,
 0xb9, 0xa8, 0xb9, 0xa9, 0x52, 0xe6, 0xa2, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x6a, 0x54, 0xb8, 0x2e,
 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e,
 0xe6, 0xa2, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee,
 0x0b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0,
 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b, 0xb9,
 0xa8, 0xb8, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee,
 0x6a, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6d, 0xd4, 0xd4, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7,
 0x73, 0x51, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x35, 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x00,
 0xb7, 0x73, 0x51, 0x73, 0x52, 0xa5, 0xcd, 0x45, 0xcd, 0x40, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x17,
 0x00, 0xb7, 0x73, 0x51, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02,
 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x45, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77,
 0x35, 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x73,
 0x51, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x45, 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2d, 0xdc,
 0xd4, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x73, 0x51, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77,
 0x35, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x35, 0x2a, 0x5d, 0x17, 0x00, 0xb7, 0x70,
 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x0c, 0xdc, 0x02, 0xdd,
 0xc1, 0x73, 0x52, 0xa5, 0xcd, 0x45, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc,
 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x35, 0x2a, 0x5c, 0xd4, 0x5c, 0xd4, 0x0b, 0x77,
 0x35, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0xc5, 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2d,
 0xdc, 0xd4, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b,
 0x77, 0x05, 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02,
 0xdd, 0xc1, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x35, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d,
 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xcd, 0x40, 0xb7, 0x73, 0x51, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b,
 0x77, 0x05, 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02,
 0xdd, 0xcd, 0x45, 0xcd, 0x4a, 0x97, 0x35, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0xd4, 0xa9, 0x70, 0x5c,
 0x02, 0x9d, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd,
 0xc1, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xcd, 0x45, 0xc0, 0x2d, 0xdc,
 0x17, 0x0a, 0x77, 0x35, 0x33, 0x70, 0x0b, 0x77, 0x35, 0x17, 0x0a, 0x97, 0x35, 0x17, 0x35, 0x02,
 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1,
 0x73, 0x52, 0xa5, 0xcd, 0x45, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70,
 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0xd4, 0xa9, 0x73, 0x51, 0x70, 0x0b, 0x77, 0x05,
 0xc2, 0xa5, 0xc3, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x2a, 0x5c, 0xd4, 0x5c, 0x02, 0xdd, 0xcd, 0x45,
 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xcd, 0x45, 0xc0, 0x2d, 0xdc, 0x17, 0x0a,
 0x77, 0x0c, 0xdc, 0xd4, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x77, 0x0c, 0xdc, 0x02, 0xdd, 0xc1, 0x70,
 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5,
 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97, 0x05,
 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x35, 0x17, 0x00,
 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0xd4, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd,
 0xcd, 0x45, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97, 0x03, 0xa9, 0xa8, 0x16,
 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb9,
 0xa8, 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe1, 0x4e, 0xe6, 0xa6, 0x6e, 0x01, 0x6e,
 0xe0, 0xb8, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee,
 0x0b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x6a, 0x2e, 0x6a, 0x05, 0xbb,
 0x9a, 0x8b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x0b, 0x9a, 0x81, 0x6e,
 0xe0, 0xb8, 0x54, 0xb9, 0xa9, 0x8b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x66, 0xe0, 0x16,
 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x18, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17,
 0x2e, 0x0b, 0x85, 0x4b, 0x9a, 0x8b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8,
 0x2e, 0x15, 0x2e, 0x18, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b,
 0x85, 0x4b, 0x9a, 0x8b, 0x9a, 0x81, 0x6e, 0xe0, 0xb8, 0x53, 0xb8, 0x66, 0xe6, 0xa0, 0x5b, 0xb9,
 0xa8, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb9, 0xa9, 0x8b, 0x9a, 0x81, 0x72,
 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x1d, 0x40, 0x2d, 0xdc, 0x17,
 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x3a, 0x45, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c,
 0x2a, 0x5c, 0x17, 0x35, 0x02, 0xdd, 0xc1, 0x70, 0xa7, 0x73, 0x53, 0x37, 0x00, 0xb7, 0x70, 0x5c,
 0x2a, 0x5c, 0xd4, 0xc5, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x97, 0x35, 0x31, 0x70, 0x0b, 0x97, 0x05,
 0xcd, 0x4a, 0x97, 0x35, 0x31, 0x73, 0x50, 0x2a, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0x02,
 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1,
 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x35, 0x33, 0x70, 0x0b, 0x77,
 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x70,
 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x35,
 0x17, 0x35, 0x2a, 0x5c, 0x31, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9,
 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97,
 0x05, 0xcd, 0x4a, 0x77, 0x35, 0x33, 0x70, 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xcd, 0x40,
 0xb9, 0x73, 0x51, 0x73, 0x52, 0xa5, 0xcd, 0x4c, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd,
 0x45, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70,
 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa9, 0x73, 0x53, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d,
 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb8, 0xaa, 0x0b, 0x9a, 0x95,
 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x9a,
 0x94, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe1, 0x9b, 0x9a, 0x81, 0x6e, 0xe6,
 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a,
 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb8, 0x54, 0xb8, 0x62, 0xe0, 0x17, 0x2e, 0x6a,
 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a,
 0x8b, 0x9a, 0x94, 0xee, 0x6a, 0x66, 0xe6, 0xa0, 0x5b, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8,
 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x52, 0xe1, 0x8b, 0x80, 0x5c,
 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb,
 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb8,
 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e,
 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8,
 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x52, 0xe6, 0xa6, 0x2e, 0x01, 0x72, 0xe6,
 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x4b, 0x86, 0x2e, 0x01, 0x72, 0xe6,
 0xa2, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x6a, 0x53, 0xb8, 0x66, 0xe0, 0x16,
 0xee, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b,
 0x9a, 0x94, 0xee, 0x19, 0xb9, 0xa8, 0x16, 0xee, 0x0b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb9,
 0xa8, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e,
 0x6a, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0,
 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x9a, 0x99, 0xb8, 0x05, 0x3b,
 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x72,
 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e,
 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb,
 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x94, 0xee, 0x6a, 0x2e, 0x6a, 0x05,
 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb9,
 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80,
 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72,
 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a,
 0x8b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb9, 0xd0, 0x2e, 0x6a, 0x54, 0xb8, 0x62, 0xe0, 0x17,
 0x2e, 0x0b, 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x6a, 0x05,
 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x80, 0x5c,
 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb,
 0x82, 0xe1, 0x52, 0xe6, 0xa6, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17,
 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72,
 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x82,
 0xe1, 0x52, 0xe1, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x82,
 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85,
 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53,
 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b,
 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b,
 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82,
 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe6,
 0xa2, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb9,
 0xa8, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xee,
 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e,
 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x99,
 0xb9, 0xa8, 0x16, 0xee, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b,
 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01,
 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x66, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e,
 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x54, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb,
 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x6a, 0x05,
 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x15, 0x42, 0x9d, 0xc1, 0x73, 0x50,
 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45,
 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x35, 0x17,
 0x35, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x70,
 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c,
 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xcd,
 0x40, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x73,
 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c,
 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0,
 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0xd4,
 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73,
 0x51, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xcd, 0x40, 0xb9,
 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x73, 0x51, 0x73, 0x50, 0x2e,
 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xcd,
 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02,
 0xe5, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x35,
 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xc0,
 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xc1, 0x73,
 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c,
 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b,
 0x97, 0x35, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xcd, 0x45,
 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0xd4, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1,
 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70,
 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xdd, 0xc3, 0x37, 0x0a,
 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17,
 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x35,
 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xa9, 0xce, 0xc7,
 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f,
 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc7, 0x3b, 0x34,
 0x00, 0x6f, 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc5,
 0xc6, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xde, 0xe3, 0x1c, 0xec, 0xd0, 0x01, 0xbf,
 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0,
 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbd, 0xc6, 0x2e, 0x33, 0x40, 0x06, 0xfc, 0xec, 0x73,
 0xb3, 0x40, 0x06, 0xfc, 0xec, 0x73, 0xb3, 0x40, 0x06, 0xfc, 0xec, 0x73, 0xb3, 0x40, 0x06, 0xfc,
 0xec, 0x73, 0xb3, 0x40, 0x06, 0xfc, 0xec, 0x73, 0xb3, 0x40, 0x06, 0xfc, 0xec, 0x73, 0xb3, 0x40,
 0x06, 0xfc, 0xec, 0x73, 0xb3, 0x40, 0x06, 0xfc, 0xec, 0x73, 0xb3, 0x40, 0x06, 0xfc, 0xec, 0x73,
 0xb3, 0x40, 0x06, 0xfc, 0xec, 0x73, 0xb3, 0x40, 0x06, 0xfc, 0xec, 0x5c, 0x66, 0x80, 0x0d, 0xf9,
 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80,
 0x0d, 0xee, 0x31, 0xce, 0xcd, 0x00, 0x1b, 0xf3, 0xb1, 0x71, 0x9a, 0x00, 0x37, 0xe7, 0x62, 0xe3,
 0x34, 0x00, 0x6f, 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc5, 0xc6, 0x68, 0x00, 0xdf, 0x9d,
 0x8e, 0x76, 0x68, 0x00, 0xde, 0xe3, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01,
 0xbf, 0x3b, 0x17, 0x19, 0xa0, 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0, 0x03, 0x7b, 0x8c, 0x73, 0xb3,
 0x40, 0x06, 0xf7, 0x18, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xb8, 0xcd, 0x00, 0x1b, 0xdc, 0x63,
 0x9d, 0x9a, 0x00, 0x37, 0xe7, 0x63, 0x9d, 0x9a, 0x00, 0x37, 0xe7, 0x63, 0x9d, 0x9a, 0x00, 0x37,
 0xe7, 0x62, 0xe3, 0x34, 0x00, 0x6f, 0xce, 0xc5, 0xc6, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68,
 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8e,
 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xde, 0xe3, 0x1c, 0xec, 0xd0, 0x01, 0xbf,
 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0,
 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x17, 0x19, 0xa0, 0x03, 0x7e, 0x76, 0x2e,
 0x33, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x17, 0x7b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x3b, 0x91, 0x9a,
 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x63, 0xe6, 0xe1, 0xd5, 0x0c, 0x5c, 0xed, 0x3e, 0xa8, 0xee,
 0xa4, 0x0b, 0xbd, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1d, 0xc8, 0xcd, 0x7c, 0x59,
 0x8d, 0xf2, 0x12, 0xec, 0x1c, 0xdc, 0x3a, 0xa0, 0xe7, 0x69, 0xf5, 0x47, 0x75, 0x20, 0x5d, 0xee,
 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97,
 0x60, 0xe6, 0xe1, 0xd5, 0x07, 0x3b, 0x4f, 0xaa, 0x3b, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16,
 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x37, 0x0e,
 0xa8, 0x39, 0xda, 0x7d, 0x51, 0xdd, 0x48, 0x17, 0x7b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25,
 0xd8, 0x3b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x39, 0xb8, 0x75, 0x41, 0xce, 0xd3,
 0xea, 0x8e, 0xea, 0x40, 0xbb, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xdc, 0x8c,
 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xcd, 0xc3, 0xaa, 0x0e, 0x76, 0x9f, 0x54, 0x77, 0x52,
 0x05, 0xde, 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0xe4, 0x66, 0xbe, 0x2c, 0xc6,
 0xf9, 0x09, 0x76, 0x0e, 0x6e, 0x1d, 0x50, 0x73, 0xb4, 0xfa, 0xa3, 0xba, 0x90, 0x2e, 0xf7, 0x23,
 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0,
 0x73, 0x70, 0xea, 0x83, 0x9d, 0xa7, 0xd5, 0x1d, 0xd4, 0x81, 0x77, 0xb9, 0x19, 0xaf, 0x8b, 0x31,
 0xbe, 0x42, 0x5d, 0x83, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0x9b, 0x87, 0x54,
 0x1c, 0xed, 0x3e, 0xa8, 0xee, 0xa4, 0x0b, 0xbd, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec,
 0x1d, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1c, 0xdc, 0x3a, 0xa0, 0xe7, 0x69, 0xf5,
 0x47, 0x75, 0x20, 0x5d, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xee, 0x46, 0x6b,
 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xe6, 0xe1, 0xd5, 0x07, 0x3b, 0x4f, 0xaa, 0x3b, 0xa9, 0x02,
 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c,
 0x84, 0xbb, 0x07, 0x37, 0x0e, 0xa8, 0x39, 0xda, 0x7d, 0x51, 0xdd, 0x48, 0x17, 0x7b, 0x91, 0x9a,
 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x3b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x39,
 0xb8, 0x75, 0x41, 0xce, 0xd3, 0xea, 0x8e, 0xea, 0x40, 0xbb, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf,
 0x21, 0x2e, 0xc1, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xcd, 0xc3, 0xaa, 0x0e,
 0x76, 0x9f, 0x54, 0x77, 0x52, 0x05, 0xde, 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e,
 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0x6e, 0x1d, 0x50, 0x73, 0xb4, 0xfa, 0xa3,
 0xba, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1,
 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x73, 0x70, 0xea, 0x83, 0x9d, 0xa7, 0xd5, 0x1d, 0xd4, 0x81, 0x77,
 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42,
 0x5d, 0x83, 0x9b, 0x87, 0x54, 0x1c, 0xed, 0x3e, 0xa8, 0xee, 0xa4, 0x0b, 0xbd, 0xc8, 0xcd, 0x7c,
 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1d, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1c, 0xdc,
 0x3a, 0xa0, 0xe7, 0x69, 0xf5, 0x47, 0x75, 0x20, 0x5d, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90,
 0x97, 0x60, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xe6, 0xe1, 0xd5, 0x07, 0x3b,
 0x4f, 0xaa, 0x3b, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72,
 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x37, 0x0e, 0xa8, 0x39, 0xda, 0x7d, 0x51, 0xdd,
 0x48, 0x17, 0x7b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x3b, 0x91, 0x9a, 0xf8, 0xb3,
 0x1b, 0xe4, 0x25, 0xd8, 0x39, 0xb8, 0x75, 0x41, 0xce, 0xd3, 0xea, 0x8e, 0xea, 0x40, 0xbb, 0xdc,
 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e,
 0xc1, 0xcd, 0xc3, 0xaa, 0x0e, 0x76, 0x9f, 0x54, 0x77, 0x52, 0x05, 0xde, 0xe4, 0x66, 0xbe, 0x2c,
 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0x6e, 0x1d,
 0x50, 0x73, 0xb4, 0xfa, 0xa3, 0xba, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b,
 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x73, 0x70, 0xea, 0x83, 0x9d, 0xa7,
 0xd5, 0x1d, 0xd4, 0x81, 0x77, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0xb9, 0x19,
 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0x9b, 0x87, 0x54, 0x1c, 0xed, 0x3e, 0xa8, 0xee, 0xa4,
 0x0b, 0xbd, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1d, 0xc8, 0xcd, 0x7c, 0x59, 0x8d,
 0xf2, 0x12, 0xec, 0x1c, 0xdc, 0x3a, 0xa0, 0xe7, 0x69, 0xf5, 0x47, 0x75, 0x20, 0x5d, 0xee, 0x46,
 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60,
 0xe6, 0xe1, 0xd5, 0x07, 0x3b, 0x4f, 0xaa, 0x3b, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63,
 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x37, 0x0e, 0xa8,
 0x39, 0xda, 0x7d, 0x51, 0xdd, 0x48, 0x17, 0x7b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8,
 0x3b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x39, 0xb8, 0x75, 0x41, 0xce, 0xd3, 0xea,
 0x8e, 0xea, 0x40, 0xbb, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xdc, 0x8c, 0xd7,
 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xcd, 0xc3, 0xaa, 0x0e, 0x76, 0x9f, 0x54, 0x77, 0x52, 0x05,
 0xde, 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9,
 0x09, 0x76, 0x0e, 0x6e, 0x1d, 0x50, 0x73, 0xb4, 0xfa, 0xa3, 0xba, 0x90, 0x2e, 0xf7, 0x23, 0x35,
 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x73,
 0x70, 0xea, 0x83, 0x9d, 0xa7, 0xd5, 0x1d, 0xd4, 0x81, 0x77, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe,
 0x42, 0x5d, 0x83, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0x9b, 0x87, 0x54, 0x1c,
 0xed, 0x3e, 0xa8, 0xee, 0xa4, 0x0b, 0xbd, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1d,
 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1c, 0xdc, 0x3a, 0xa0, 0xe7, 0x69, 0xf5, 0x47,
 0x75, 0x20, 0x5d, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xee, 0x46, 0x6b, 0xe2,
 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xe6, 0xe1, 0xd5, 0x07, 0x3b, 0x4f, 0xaa, 0x3b, 0xa9, 0x02, 0xef,
 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84,
 0xbb, 0x07, 0x37, 0x0e, 0xa8, 0x39, 0xda, 0x7d, 0x51, 0xdd, 0x48, 0x17, 0x7b, 0x91, 0x9a, 0xf8,
 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x3b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x39, 0xb8,
 0x75, 0x41, 0xce, 0xd3, 0xea, 0x8e, 0xea, 0x40, 0xbb, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21,
 0x2e, 0xc1, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xcd, 0xc3, 0xaa, 0x0e, 0x76,
 0x9f, 0x54, 0x77, 0x52, 0x05, 0xde, 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0xe4,
 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0x6e, 0x1d, 0x50, 0x73, 0xb4, 0xfa, 0xa3, 0xba,
 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66,
 0x37, 0xc8, 0x4b, 0xb0, 0x73, 0x70, 0xea, 0x83, 0x9d, 0xa7, 0xd5, 0x1d, 0xd4, 0x81, 0x77, 0xb9,
 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d,
 0x83, 0x9b, 0x87, 0x54, 0x1c, 0xed, 0x3e, 0xa8, 0xee, 0xa4, 0x0b, 0xbd, 0xc8, 0xcd, 0x7c, 0x59,
 0x8d, 0xf2, 0x12, 0xec, 0x1d, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1c, 0xdc, 0x3a,
 0xa0, 0xe7, 0x69, 0xf5, 0x47, 0x75, 0x20, 0x5d, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97,
 0x60, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xe6, 0xe1, 0xd5, 0x07, 0x3b, 0x4f,
 0xaa, 0x3b, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33,
 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x37, 0x0e, 0xa8, 0x39, 0xda, 0x7d, 0x51, 0xdd, 0x48,
 0x17, 0x7b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x3b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b,
 0xe4, 0x25, 0xd8, 0x39, 0xb8, 0x75, 0x41, 0xce, 0xd3, 0xea, 0x8e, 0xea, 0x40, 0xbb, 0xdc, 0x8c,
 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1,
 0xcd, 0xc3, 0xaa, 0x0e, 0x76, 0x9f, 0x54, 0x77, 0x52, 0x05, 0xde, 0xe4, 0x66, 0xbe, 0x2c, 0xc6,
 0xf9, 0x09, 0x76, 0x0e, 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0x6e, 0x1d, 0x50,
 0x73, 0xb4, 0xfa, 0xa3, 0xba, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0,
 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x73, 0x70, 0xea, 0x83, 0x9d, 0xa7, 0xd5,
 0x1d, 0xd4, 0x81, 0x77, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0xb9, 0x19, 0xaf,
 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0x9b, 0x87, 0x54, 0x1c, 0xed, 0x3e, 0xa8, 0xee, 0xa4, 0x0b,
 0xbd, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1d, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2,
 0x12, 0xec, 0x1c, 0xdc, 0x3a, 0xa0, 0xe7, 0x69, 0xf5, 0x47, 0x75, 0x20, 0x5d, 0xee, 0x46, 0x6b,
 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x60, 0xe6,
 0xe1, 0xd5, 0x07, 0x3b, 0x4f, 0xaa, 0x3b, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c,
 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x37, 0x0e, 0xa8, 0x39,
 0xda, 0x7d, 0x51, 0xdd, 0x48, 0x17, 0x7b, 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x3b,
 0x91, 0x9a, 0xf8, 0xb3, 0x1b, 0xe4, 0x25, 0xd8, 0x39, 0xb8, 0x75, 0x41, 0xce, 0xd3, 0xea, 0x8e,
 0xea, 0x40, 0xbb, 0xdc, 0x8c, 0xd7, 0xc5, 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xdc, 0x8c, 0xd7, 0xc5,
 0x98, 0xdf, 0x21, 0x2e, 0xc1, 0xcd, 0xc3, 0xaa, 0x0e, 0x76, 0x9f, 0x54, 0x77, 0x52, 0x05, 0xde,
 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09, 0x76, 0x0e, 0xe4, 0x66, 0xbe, 0x2c, 0xc6, 0xf9, 0x09,
 0x76, 0x0e, 0x6e, 0x1d, 0x50, 0x73, 0xb4, 0xfa, 0xa3, 0xba, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1,
 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x73, 0x70,
 0xea, 0x83, 0x9d, 0xa7, 0xd5, 0x1d, 0xd4, 0x81, 0x77, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42,
 0x5d, 0x83, 0xb9, 0x19, 0xaf, 0x8b, 0x31, 0xbe, 0x42, 0x5d, 0x83, 0x9b, 0x87, 0x54, 0x1c, 0xed,
 0x3e, 0xa8, 0xee, 0xa4, 0x0b, 0xbd, 0xc8, 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1d, 0xc8,
 0xcd, 0x7c, 0x59, 0x8d, 0xf2, 0x12, 0xec, 0x1c, 0xdc, 0x3a, 0xa0, 0xe7, 0x69, 0xf5, 0x47, 0x75,
 0x20, 0x5d, 0xee, 0x46, 0x6b, 0xe2, 0xcc, 0x6f, 0x90, 0x97, 0x61, 0x9e, 0xe4, 0x66, 0xde, 0x2b,
 0xc6, 0xfb, 0xde, 0x5d, 0x83, 0x9b, 0x87, 0x54, 0x1c, 0xed, 0x3e, 0xa8, 0xee, 0xa2, 0x0b, 0xdd,
 0xc7, 0xcd, 0xfc, 0x55, 0x8e, 0xf7, 0xbc, 0xfb, 0x0c, 0xf7, 0x1b, 0x38, 0xf1, 0x56, 0x3b, 0xde,
 0xf3, 0xec, 0x1c, 0xdc, 0x3a, 0xa1, 0x3c, 0xed, 0x3e, 0xa8, 0xee, 0xff, 0xd9};
static const unsigned char PIC_160x120_2[] = { 
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x17, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
 0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65, 0x20, 0x47, 0x49, 0x4d, 0x50, 0xff, 0xe1, 0x00,
 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x05, 0x03, 0x04, 0x04, 0x04, 0x03,
 0x05, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0c, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0f,
 0x0b, 0x0b, 0x09, 0x0c, 0x11, 0x0f, 0x12, 0x12, 0x11, 0x0f, 0x11, 0x11, 0x13, 0x16, 0x1c, 0x17,
 0x13, 0x14, 0x1a, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1a, 0x1d, 0x1d, 0x1f, 0x1f, 0x1f, 0x13,
 0x17, 0x22, 0x24, 0x22, 0x1e, 0x24, 0x1c, 0x1e, 0x1f, 0x1e, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x05,
 0x05, 0x05, 0x07, 0x06, 0x07, 0x0e, 0x08, 0x08, 0x0e, 0x1e, 0x14, 0x11, 0x14, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0xff,
 0xc0, 0x00, 0x11, 0x08, 0x00, 0x78, 0x00, 0xa0, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03,
 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1d, 0x00, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x04, 0x07, 0x03, 0x05, 0x08, 0x02, 0x01,
 0x09, 0xff, 0xc4, 0x00, 0x40, 0x10, 0x00, 0x01, 0x02, 0x04, 0x01, 0x0a, 0x04, 0x03, 0x06, 0x03,
 0x08, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x00, 0x04, 0x05, 0x11, 0x06, 0x12, 0x13,
 0x15, 0x21, 0x31, 0x41, 0x51, 0x61, 0x62, 0xa1, 0x07, 0x22, 0x52, 0x91, 0x08, 0x71, 0x81, 0x14,
 0x23, 0x32, 0x42, 0x92, 0xd1, 0x16, 0x53, 0x94, 0x25, 0x35, 0x43, 0x55, 0x72, 0x82, 0xb1, 0xd2,
 0x93, 0xa3, 0xe1, 0xff, 0xc4, 0x00, 0x1c, 0x01, 0x01, 0x00, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x02, 0x03, 0x06, 0x01, 0x07,
 0x08, 0xff, 0xc4, 0x00, 0x2e, 0x11, 0x00, 0x02, 0x02, 0x01, 0x03, 0x02, 0x03, 0x07, 0x04, 0x03,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x12, 0x31, 0x05, 0x21,
 0x51, 0x61, 0xe1, 0x06, 0x13, 0x41, 0x71, 0x81, 0xa1, 0xc1, 0x14, 0x15, 0x42, 0x43, 0x22, 0x32,
 0x91, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0x44,
 0x76, 0x5b, 0x6e, 0xa8, 0x88, 0xec, 0xb7, 0x28, 0x73, 0x9c, 0xa5, 0x6d, 0xf2, 0xc6, 0xaa, 0x66,
 0x9e, 0xb4, 0xdf, 0x54, 0x77, 0xd5, 0xea, 0x13, 0x3e, 0x57, 0x5e, 0xa5, 0x31, 0x5d, 0xd9, 0x6e,
 0x51, 0x15, 0xd9, 0x6e, 0x50, 0xc6, 0xf4, 0xb1, 0x1b, 0x53, 0x11, 0x5d, 0x96, 0xe5, 0x12, 0xa3,
 0x71, 0x2e, 0x17, 0x0b, 0x8e, 0xcb, 0x72, 0x88, 0xae, 0xcb, 0x72, 0x86, 0x27, 0x65, 0xb9, 0x44,
 0x57, 0x65, 0xb9, 0x44, 0x88, 0xda, 0x49, 0x85, 0xc2, 0xeb, 0xb2, 0xdc, 0xa2, 0x2b, 0xb2, 0xdc,
 0xa1, 0x89, 0xd9, 0x6e, 0x51, 0x15, 0xd9, 0x6e, 0x51, 0x22, 0x36, 0x92, 0x21, 0x70, 0xbc, 0xe3,
 0x04, 0x46, 0x15, 0x21, 0x43, 0x74, 0x6f, 0x5d, 0x97, 0xe5, 0x11, 0x5d, 0x97, 0xe5, 0x12, 0x23,
 0x69, 0x22, 0x36, 0xe4, 0xd5, 0x41, 0x12, 0xdc, 0x97, 0xe5, 0x18, 0x16, 0xd2, 0x93, 0x1b, 0x54,
 0x93, 0x36, 0xa9, 0x26, 0x63, 0x82, 0x02, 0x08, 0xdb, 0x04, 0x7a, 0x7a, 0x10, 0x41, 0x04, 0x00,
 0x41, 0x04, 0x10, 0x01, 0x04, 0x10, 0x40, 0x1d, 0x7d, 0x3d, 0x47, 0x52, 0x6f, 0x74, 0x46, 0x92,
 0x72, 0x95, 0xb7, 0xcb, 0x17, 0xa5, 0x43, 0x0c, 0xa1, 0xe4, 0x15, 0xca, 0xa9, 0x0f, 0x27, 0x96,
 0xd8, 0x55, 0xa9, 0xe1, 0xd5, 0x20, 0x90, 0x5b, 0x20, 0xfc, 0xa3, 0xe5, 0x3a, 0x7e, 0xa2, 0xa5,
 0xc3, 0x38, 0xed, 0x57, 0x47, 0xd5, 0xe9, 0x1f, 0x1d, 0x8a, 0x72, 0x72, 0x95, 0xb7, 0xcb, 0x1a,
 0x89, 0xaa, 0x62, 0x92, 0x4d, 0x84, 0x58, 0xf5, 0x0d, 0x10, 0x85, 0xa9, 0x0a, 0xab, 0x53, 0x02,
 0x92, 0x48, 0x20, 0xce, 0x37, 0x70, 0x78, 0x7e, 0x28, 0xd2, 0x4d, 0xae, 0x8e, 0x6f, 0x6a, 0xad,
 0x3b, 0xfa, 0xb6, 0xff, 0x00, 0xed, 0x16, 0xf4, 0xeb, 0x97, 0x89, 0x16, 0x16, 0xdd, 0x07, 0x89,
 0x45, 0xff, 0x00, 0xc1, 0x05, 0xf9, 0x35, 0x26, 0xf7, 0x4c, 0x43, 0x76, 0x5b, 0x94, 0x3f, 0x4c,
 0xd3, 0x10, 0xe2, 0x02, 0xdb, 0x29, 0x5a, 0x14, 0x2e, 0x95, 0x24, 0xdc, 0x11, 0xc4, 0x11, 0xb6,
 0x35, 0x13, 0x74, 0xb2, 0x2f, 0x64, 0xc5, 0x8d, 0x7a, 0xa4, 0xc9, 0x95, 0xea, 0x93, 0xe4, 0x4e,
 0x76, 0x5b, 0x6e, 0xa8, 0x8c, 0xec, 0xb7, 0x28, 0x66, 0x98, 0x91, 0x5a, 0x77, 0x44, 0x17, 0x65,
 0xac, 0x76, 0x44, 0xc8, 0x5c, 0x4c, 0x85, 0xd9, 0x17, 0x1d, 0x96, 0xe5, 0x11, 0x5d, 0x97, 0xe5,
 0x0c, 0x4e, 0xcb, 0x6d, 0xd5, 0x11, 0x5d, 0x96, 0xe5, 0x12, 0x63, 0x69, 0x26, 0x37, 0x0b, 0xae,
 0xcb, 0xf2, 0x88, 0xae, 0xcb, 0x72, 0x86, 0x27, 0x65, 0xb9, 0x44, 0x57, 0x65, 0xf9, 0x44, 0x88,
 0xdc, 0x49, 0x8d, 0xc2, 0xeb, 0xb2, 0xdc, 0xa2, 0x33, 0x8c, 0x11, 0xb2, 0x18, 0x5d, 0x96, 0xe5,
 0x11, 0x5d, 0x97, 0xe5, 0x12, 0x23, 0x69, 0x22, 0x37, 0x1a, 0x32, 0x92, 0x36, 0x88, 0xf9, 0x1b,
 0x37, 0x65, 0xb9, 0x44, 0x57, 0x25, 0xce, 0xe1, 0x1b, 0x94, 0xd3, 0x37, 0x29, 0xa6, 0x46, 0x82,
 0x3d, 0x38, 0x9c, 0x81, 0x75, 0x10, 0x07, 0x12, 0x6d, 0x1e, 0x01, 0x0a, 0x17, 0x49, 0x04, 0x71,
 0x06, 0xf1, 0x96, 0xe5, 0x9c, 0x19, 0xf9, 0x9f, 0x60, 0x82, 0x08, 0xf4, 0x1d, 0xe5, 0x48, 0xc4,
 0xeb, 0x6c, 0x82, 0x1d, 0x23, 0xeb, 0x0d, 0x94, 0xec, 0x43, 0x2b, 0x38, 0xb6, 0xd1, 0x36, 0xda,
 0x17, 0x75, 0x0f, 0x36, 0xfd, 0xb1, 0xcf, 0x52, 0x15, 0xb2, 0x2d, 0xe7, 0xef, 0x0c, 0x74, 0xaa,
 0xf1, 0x0e, 0xb7, 0xe7, 0xfc, 0xc3, 0x7f, 0x38, 0xfc, 0xe5, 0x0b, 0xdc, 0x78, 0x64, 0xda, 0xf5,
 0xa9, 0xac, 0x4b, 0xba, 0x39, 0x97, 0xc3, 0x0f, 0x0e, 0xa5, 0xbc, 0x50, 0xf1, 0xb6, 0xb5, 0x86,
 0x5e, 0xaa, 0x2e, 0x98, 0xde, 0x54, 0xec, 0xca, 0x5e, 0x43, 0x49, 0x70, 0x9c, 0x87, 0x75, 0x26,
 0xc4, 0x8d, 0xb9, 0x5d, 0xa2, 0xdd, 0x9f, 0xf8, 0x41, 0x92, 0x95, 0x26, 0xf8, 0xbe, 0x7c, 0xf3,
 0xfb, 0x02, 0x3f, 0xef, 0x14, 0x4e, 0x07, 0xfe, 0x35, 0x77, 0xc5, 0x2a, 0x9a, 0xb0, 0x15, 0x41,
 0xc9, 0x1a, 0xb9, 0x5c, 0xc9, 0xce, 0xa1, 0xf4, 0xb4, 0x73, 0x79, 0x7e, 0x61, 0x94, 0xad, 0x5c,
 0x35, 0x45, 0xd5, 0x86, 0x5b, 0xf8, 0x9a, 0x15, 0xba, 0x7a, 0xea, 0x18, 0xb2, 0x65, 0xe9, 0x04,
 0x4d, 0x34, 0xa9, 0x96, 0xd5, 0x55, 0x65, 0x41, 0x4d, 0x05, 0x82, 0xb1, 0x6d, 0xa7, 0xcb, 0x7d,
 0x51, 0x7f, 0x2b, 0x94, 0x25, 0xdd, 0xa2, 0xc7, 0x51, 0x17, 0x35, 0x88, 0x59, 0xb5, 0xfd, 0x3f,
 0x25, 0x83, 0x56, 0x93, 0xa2, 0x78, 0x7f, 0x84, 0x29, 0xcd, 0x56, 0xea, 0x8d, 0xcb, 0x49, 0x4a,
 0x36, 0xd4, 0x92, 0x26, 0x5e, 0x41, 0x19, 0xc5, 0x04, 0x58, 0x6a, 0x48, 0x36, 0x24, 0x24, 0x98,
 0x54, 0xae, 0x63, 0x6c, 0x09, 0x20, 0x24, 0xcc, 0xd6, 0x22, 0x94, 0x48, 0x9d, 0x68, 0x3c, 0xc5,
 0x90, 0xb5, 0x5d, 0x07, 0x50, 0x51, 0xb2, 0x6e, 0x90, 0x6c, 0x76, 0xda, 0x18, 0xbe, 0x3a, 0x26,
 0x29, 0xd3, 0x5e, 0x0d, 0x4b, 0xbb, 0x28, 0x8c, 0xdb, 0xa6, 0xb6, 0xc6, 0xa1, 0xb2, 0xd9, 0xb7,
 0xbf, 0xf9, 0x09, 0xbf, 0x0f, 0x5e, 0x01, 0x61, 0xbc, 0x57, 0xe1, 0x45, 0x37, 0x18, 0x57, 0x58,
 0x9c, 0x9c, 0x9d, 0x9d, 0x7d, 0x6e, 0x34, 0x53, 0x30, 0x52, 0x96, 0x9b, 0x69, 0xc2, 0x84, 0xa7,
 0x27, 0x61, 0xbe, 0x41, 0xbd, 0xf7, 0x1b, 0x0b, 0x44, 0xda, 0x7a, 0x8b, 0x71, 0x4d, 0x1c, 0x9d,
 0x9e, 0xcc, 0x53, 0x08, 0xbb, 0xac, 0x94, 0x9b, 0xcb, 0xff, 0x00, 0x5c, 0x7e, 0x51, 0x37, 0x17,
 0x54, 0xa8, 0x18, 0x7a, 0x4d, 0xa9, 0xba, 0xc5, 0x49, 0x89, 0x46, 0x9e, 0x17, 0x67, 0x2a, 0xe5,
 0x4e, 0x0b, 0x5e, 0xe9, 0x48, 0x04, 0x9d, 0xa3, 0x76, 0xf8, 0x51, 0x93, 0xc6, 0x78, 0x2a, 0xab,
 0x36, 0x89, 0x59, 0x4a, 0xd3, 0x61, 0xe7, 0x0e, 0x4a, 0x12, 0xf3, 0x4b, 0x68, 0x28, 0x9d, 0x80,
 0x15, 0x00, 0x3b, 0xc3, 0x37, 0x8f, 0x98, 0x33, 0xc3, 0xb9, 0x3c, 0x65, 0x2b, 0x88, 0x31, 0xce,
 0x2d, 0x98, 0x95, 0x70, 0xa1, 0x19, 0x34, 0x90, 0x9c, 0xbc, 0xe3, 0x49, 0xbe, 0xa4, 0xa5, 0x03,
 0x2d, 0x29, 0x26, 0xf7, 0x3b, 0xcd, 0xf5, 0xf0, 0xa1, 0xbc, 0x5b, 0xa8, 0xe0, 0x1a, 0x8a, 0xe5,
 0x17, 0x81, 0xe8, 0xb3, 0x52, 0x28, 0x6d, 0x4b, 0x43, 0xef, 0x29, 0xb2, 0xdb, 0x4f, 0x6a, 0x19,
 0x20, 0x24, 0xa8, 0xeb, 0x1a, 0xf8, 0x6d, 0x8b, 0x05, 0xd4, 0xac, 0x8f, 0x75, 0x8c, 0x1a, 0x3a,
 0x7f, 0x47, 0xae, 0xd5, 0x18, 0x4d, 0x4f, 0x73, 0xe5, 0xe1, 0x28, 0xa7, 0xe1, 0xdf, 0x9f, 0xa1,
 0x6f, 0xe2, 0x03, 0x27, 0x47, 0x93, 0x54, 0xe5, 0x46, 0x61, 0x12, 0xd2, 0xe1, 0x41, 0x25, 0x6b,
 0x06, 0xc0, 0x9d, 0x83, 0x50, 0x85, 0xfa, 0x86, 0x22, 0xc3, 0xd2, 0xb2, 0x6c, 0x4d, 0xbd, 0x54,
 0x60, 0x35, 0x30, 0x0a, 0x9a, 0x20, 0x28, 0x95, 0x80, 0x48, 0xb8, 0x48, 0x17, 0xb5, 0xc1, 0x17,
 0xb4, 0x4f, 0xf1, 0x85, 0x87, 0x15, 0xe0, 0x5d, 0x3e, 0x79, 0xd2, 0x54, 0xe3, 0xad, 0xc8, 0xad,
 0x4a, 0x3b, 0xca, 0x91, 0x72, 0x61, 0x77, 0xc2, 0xaf, 0x0f, 0xa8, 0xd5, 0xcc, 0x07, 0xa5, 0xaa,
 0x72, 0xeb, 0x99, 0x98, 0x99, 0x53, 0xa8, 0x6d, 0x4a, 0x71, 0x43, 0x32, 0x94, 0x12, 0x91, 0x92,
 0x01, 0xdb, 0x7b, 0x98, 0xb1, 0x5d, 0x4a, 0xd7, 0x3d, 0x95, 0xa5, 0xc6, 0x7b, 0x9a, 0xf4, 0xd4,
 0xe9, 0xe3, 0xa5, 0xfd, 0x45, 0xf2, 0x7d, 0xa5, 0xb7, 0xb6, 0x3f, 0x26, 0xc3, 0x4b, 0x51, 0x9d,
 0xa5, 0xaa, 0xa8, 0x8a, 0x8c, 0xb9, 0x93, 0x49, 0xc9, 0x2e, 0x95, 0x58, 0x03, 0xc0, 0x8d, 0xb7,
 0xe5, 0x6b, 0xc4, 0x3a, 0x6d, 0x62, 0x8b, 0x56, 0x75, 0x4c, 0xd3, 0xe7, 0x9a, 0x79, 0xd0, 0x2f,
 0x91, 0x62, 0x95, 0x11, 0xc4, 0x02, 0x05, 0xfe, 0x90, 0x8d, 0xe1, 0x2e, 0x1d, 0x97, 0xc4, 0x35,
 0xd9, 0x89, 0x69, 0xe0, 0xb7, 0x65, 0x65, 0x99, 0x2f, 0x16, 0x82, 0x88, 0x0b, 0x56, 0x50, 0x48,
 0xbd, 0xbe, 0x66, 0x32, 0xe2, 0x4a, 0x5b, 0x38, 0x7b, 0xc5, 0x39, 0x29, 0x5a, 0x72, 0x0b, 0x0d,
 0x97, 0xa5, 0xd6, 0x94, 0x02, 0x4e, 0x4e, 0x59, 0x00, 0x81, 0x7d, 0xdb, 0x7d, 0xe3, 0x28, 0x75,
 0x6b, 0xf6, 0x46, 0xc7, 0x15, 0xb7, 0x38, 0x7c, 0xe4, 0xb5, 0x7d, 0x3f, 0x4f, 0x1b, 0xa7, 0xa7,
 0x53, 0x7b, 0xd2, 0xca, 0xe3, 0x1f, 0x26, 0x3d, 0x4f, 0x25, 0x99, 0x66, 0x16, 0xfc, 0xc3, 0x88,
 0x69, 0xa4, 0x0b, 0xa9, 0x6b, 0x36, 0x02, 0x17, 0xd3, 0x88, 0xa8, 0x0f, 0x3d, 0x9a, 0x45, 0x41,
 0x01, 0x44, 0xd8, 0x15, 0x21, 0x49, 0x49, 0xfa, 0x91, 0x68, 0x81, 0xe3, 0x44, 0xd3, 0x88, 0xa8,
 0xc9, 0x52, 0xc2, 0xca, 0x19, 0x0d, 0xe7, 0x96, 0x38, 0x92, 0xa2, 0x01, 0x3f, 0x20, 0x0f, 0xbc,
 0x6b, 0x2b, 0x4b, 0xc0, 0xcb, 0xa1, 0x2d, 0x8a, 0x72, 0x9d, 0x13, 0xad, 0xa0, 0x16, 0x9d, 0x2d,
 0x28, 0x15, 0xab, 0x7e, 0x51, 0x3a, 0xb5, 0xeb, 0xf9, 0x44, 0x8b, 0xfa, 0xb5, 0x90, 0xb2, 0x51,
 0xaf, 0x6a, 0x51, 0xf1, 0x7c, 0xf9, 0x23, 0x2d, 0x26, 0x86, 0x32, 0xaa, 0x13, 0x9e, 0xe7, 0xbb,
 0xc1, 0x71, 0xf3, 0x1c, 0x9c, 0x97, 0xb8, 0xbe, 0xd1, 0x11, 0x5c, 0x96, 0xe5, 0x18, 0x3c, 0x35,
 0x7d, 0xc9, 0xec, 0x38, 0x5b, 0x74, 0x95, 0x19, 0x67, 0x4b, 0x49, 0x24, 0xfe, 0x5b, 0x02, 0x3d,
 0xb5, 0xc6, 0xfd, 0xd9, 0x6d, 0xba, 0xa2, 0xf3, 0x4b, 0xab, 0x57, 0x55, 0x1b, 0x17, 0xc4, 0x87,
 0x6e, 0x68, 0xb6, 0x55, 0xb7, 0xc1, 0x58, 0x8a, 0x6c, 0xfd, 0x62, 0xae, 0xef, 0xdb, 0x51, 0x31,
 0x2c, 0xca, 0x41, 0x29, 0xca, 0x41, 0x00, 0x0b, 0xd8, 0x01, 0x7d, 0x51, 0x12, 0x69, 0x87, 0x28,
 0x95, 0x96, 0xda, 0x6d, 0xd5, 0x2d, 0x0a, 0x09, 0x36, 0x3a, 0xae, 0x09, 0xb5, 0x88, 0x8b, 0x07,
 0x10, 0x4e, 0x4a, 0xd2, 0x64, 0xcc, 0xc4, 0xc9, 0xdb, 0xa9, 0xb6, 0xc6, 0xd5, 0x9e, 0x03, 0xf7,
 0x84, 0xea, 0x1c, 0x8c, 0xdd, 0x7a, 0xac, 0x6a, 0xd3, 0x68, 0xc9, 0x97, 0x42, 0xae, 0x35, 0x6a,
 0x24, 0x6c, 0x48, 0xe4, 0x37, 0xc5, 0x06, 0xa7, 0x4d, 0x5d, 0x76, 0x46, 0x15, 0x36, 0xee, 0x72,
 0xce, 0x7e, 0x29, 0x79, 0x97, 0x7a, 0x7d, 0x54, 0xa7, 0x07, 0x64, 0xd6, 0x2b, 0x4b, 0x18, 0xf3,
 0xf2, 0x36, 0xab, 0x64, 0xa4, 0xc6, 0x32, 0x08, 0xda, 0x23, 0x74, 0xec, 0xbf, 0x28, 0x8a, 0xec,
 0xb7, 0x28, 0xed, 0x23, 0x6a, 0x65, 0x6c, 0x6d, 0x4c, 0xb0, 0xa4, 0xeb, 0x29, 0x16, 0xbb, 0xa9,
 0x1f, 0xee, 0x11, 0xbc, 0xa7, 0x56, 0xd1, 0x96, 0x8f, 0xbe, 0x46, 0xd1, 0xf9, 0x84, 0x76, 0x66,
 0x6e, 0x8b, 0xba, 0x97, 0x21, 0xfd, 0x3a, 0x3f, 0x68, 0xf4, 0x94, 0xd1, 0xf2, 0x87, 0xf6, 0x6c,
 0x8e, 0xdf, 0xe4, 0x23, 0xf6, 0x8f, 0x81, 0x2e, 0x91, 0x25, 0xfc, 0xfe, 0xde, 0xa4, 0xf8, 0xf4,
 0x59, 0xc7, 0xfb, 0x3e, 0xde, 0xa7, 0xe6, 0xdf, 0x82, 0x73, 0x82, 0x5b, 0xc5, 0xa9, 0xd9, 0x82,
 0xa0, 0x01, 0x6a, 0x67, 0x59, 0x3c, 0x54, 0x23, 0xa4, 0xa9, 0xf5, 0xf4, 0x8b, 0x7d, 0xf2, 0x7f,
 0x54, 0x5b, 0x18, 0x31, 0x54, 0xd3, 0x8b, 0x1f, 0x0a, 0x91, 0x94, 0x29, 0xc9, 0x7b, 0x56, 0x65,
 0x3e, 0xaf, 0x94, 0x3e, 0x05, 0xd2, 0xc6, 0xc9, 0x19, 0x4f, 0xfc, 0x29, 0xfd, 0xa2, 0x5e, 0xa3,
 0x43, 0x2b, 0x67, 0xbb, 0x76, 0x0b, 0x0b, 0xb4, 0x73, 0xb2, 0x7b, 0x94, 0xb0, 0x71, 0x7f, 0xc5,
 0x25, 0x58, 0x4e, 0xf8, 0x5b, 0x2e, 0xc8, 0x70, 0x2a, 0xd5, 0x46, 0x55, 0x6b, 0xf4, 0x39, 0x16,
 0x57, 0xc2, 0xe6, 0x22, 0x54, 0x87, 0x82, 0xd8, 0x6e, 0x5d, 0x2f, 0x04, 0xe4, 0x34, 0xee, 0xab,
 0xf1, 0x7d, 0xc3, 0x17, 0x1f, 0x88, 0xaa, 0xa6, 0x2e, 0x80, 0x84, 0x99, 0x19, 0x35, 0x0f, 0xb4,
 0x23, 0x51, 0x61, 0x27, 0x72, 0xb8, 0x88, 0x9d, 0x82, 0x9e, 0xa7, 0xb7, 0x86, 0x24, 0x92, 0x99,
 0x39, 0x54, 0x80, 0x95, 0x6a, 0x4b, 0x49, 0x03, 0xf1, 0x1e, 0x02, 0x33, 0x5a, 0x39, 0x2a, 0x95,
 0x7b, 0xbe, 0x39, 0x37, 0xc2, 0x99, 0xc6, 0x0a, 0x3b, 0xbb, 0x9c, 0x35, 0xe3, 0x35, 0x41, 0xba,
 0x0f, 0xc5, 0x4a, 0xb1, 0x76, 0x36, 0xa2, 0xb9, 0x5a, 0xc3, 0xef, 0x4d, 0xb7, 0x32, 0x86, 0x08,
 0x05, 0x0f, 0xcb, 0x86, 0xc2, 0x42, 0x53, 0x7f, 0x29, 0x28, 0x23, 0xf0, 0x9d, 0x44, 0xa7, 0x5e,
 0xa3, 0x11, 0xbe, 0x25, 0x31, 0xd4, 0x97, 0x88, 0x34, 0x6a, 0x5c, 0xe6, 0x10, 0xc3, 0x15, 0x29,
 0x0c, 0x29, 0x4b, 0x98, 0x53, 0x26, 0x76, 0x66, 0x5d, 0x2d, 0x25, 0xc9, 0x97, 0x53, 0xa9, 0x09,
 0x4a, 0x09, 0x48, 0xb2, 0x5b, 0x3b, 0xc9, 0xe3, 0x6d, 0x57, 0xec, 0x7c, 0x4a, 0xf4, 0xa5, 0x5b,
 0x16, 0xe8, 0xe9, 0xf4, 0xcb, 0x37, 0x2a, 0x87, 0x42, 0x1b, 0x0e, 0x34, 0x92, 0x94, 0x0b, 0x5f,
 0x28, 0x02, 0x2d, 0x73, 0xc6, 0x31, 0xe2, 0xc9, 0x19, 0x5a, 0x55, 0x3e, 0x5e, 0x45, 0xa5, 0x34,
 0xfd, 0x31, 0xc5, 0x95, 0xa2, 0x5d, 0xc6, 0x50, 0x52, 0x85, 0xa4, 0x6d, 0x02, 0xd6, 0xdf, 0xba,
 0x25, 0x42, 0x2e, 0x29, 0x26, 0xcd, 0x8e, 0x98, 0xca, 0x51, 0x94, 0x97, 0x74, 0x73, 0xb7, 0x8c,
 0xf2, 0xcd, 0x3d, 0xf0, 0x9b, 0x87, 0xea, 0xd2, 0xe4, 0x29, 0xa7, 0x98, 0xa6, 0x80, 0xa1, 0xb2,
 0xe1, 0x05, 0x2a, 0x1f, 0x30, 0x52, 0x47, 0xd2, 0x26, 0xfc, 0x3b, 0x53, 0x4c, 0xc7, 0x82, 0xb4,
 0xb7, 0xec, 0x0d, 0xdc, 0x9a, 0xec, 0xea, 0xa3, 0xa4, 0xf1, 0x12, 0xa9, 0xc8, 0xf0, 0xee, 0x52,
 0x4d, 0x32, 0x72, 0xb9, 0x84, 0x86, 0x48, 0x6f, 0x32, 0x9c, 0x80, 0x4e, 0xb2, 0x72, 0x6d, 0x6d,
 0xa4, 0x98, 0xd8, 0xe0, 0x49, 0x89, 0x16, 0xb0, 0xac, 0xbb, 0x68, 0x96, 0x97, 0x42, 0x42, 0x9c,
 0xf2, 0xa5, 0xa4, 0x81, 0xf8, 0x8e, 0xe0, 0x22, 0x45, 0x76, 0xca, 0x12, 0xdc, 0x52, 0x6a, 0xfa,
 0x04, 0x2f, 0xd3, 0x3d, 0x3c, 0x25, 0x8f, 0xf2, 0xdc, 0x70, 0x17, 0xc3, 0x0c, 0xb0, 0x98, 0xc5,
 0x35, 0xb4, 0x9b, 0x79, 0x64, 0x81, 0xff, 0x00, 0xda, 0x98, 0x8f, 0xe2, 0xd4, 0xb8, 0x6f, 0xc7,
 0x5a, 0x63, 0x22, 0xd6, 0x2e, 0x49, 0x6f, 0xe2, 0xa1, 0x1d, 0xc9, 0xe1, 0xa2, 0xa9, 0xad, 0x55,
 0x67, 0x0a, 0x24, 0x64, 0xd0, 0x4b, 0x03, 0x5a, 0x58, 0x42, 0x7f, 0x37, 0x21, 0x1f, 0x31, 0x49,
 0xa6, 0xaf, 0x1d, 0xcb, 0x2c, 0xc8, 0x49, 0xa8, 0x85, 0x31, 0xac, 0xb0, 0x82, 0x76, 0xf1, 0xb4,
 0x6c, 0x57, 0xb5, 0x5a, 0x87, 0x83, 0xc9, 0xbf, 0xf6, 0xb9, 0x7e, 0xba, 0x7a, 0xad, 0xfd, 0xa5,
 0x1c, 0x63, 0x1f, 0x2e, 0xf9, 0xcf, 0x91, 0xc5, 0xde, 0x3d, 0xe1, 0x39, 0xd7, 0x3e, 0xcb, 0x5f,
 0xa7, 0xb2, 0x5f, 0xfb, 0x32, 0x4b, 0x53, 0x09, 0x40, 0xca, 0x29, 0x4e, 0x56, 0x52, 0x57, 0x6d,
 0xe0, 0x12, 0x41, 0xfa, 0x42, 0xd4, 0xfe, 0x3f, 0xa7, 0x3f, 0x49, 0x42, 0x29, 0xf4, 0x26, 0x91,
 0x54, 0x5e, 0x48, 0x39, 0x6c, 0x36, 0xa6, 0x81, 0xde, 0x46, 0xf3, 0x7d, 0xc2, 0xdb, 0xe3, 0xf4,
 0x23, 0x1f, 0x56, 0x65, 0xe5, 0xf3, 0x32, 0x12, 0x72, 0xf2, 0xed, 0xad, 0xe0, 0x54, 0xe2, 0x92,
 0xda, 0x41, 0xb5, 0xec, 0x00, 0x36, 0xd5, 0x7d, 0x71, 0xaf, 0x7b, 0x08, 0xd3, 0x98, 0x93, 0x4c,
 0xc4, 0xa2, 0x64, 0x55, 0x3e, 0x92, 0x14, 0x52, 0x18, 0x69, 0x02, 0xfb, 0xec, 0xab, 0x5c, 0x11,
 0xc6, 0x37, 0x4b, 0x5d, 0x35, 0x39, 0x4a, 0x1d, 0xb7, 0x72, 0x34, 0xbd, 0x2b, 0x65, 0x30, 0xaa,
 0xf9, 0x6e, 0xdb, 0xc7, 0x2b, 0xe8, 0xfb, 0xf7, 0x38, 0xef, 0x0b, 0x35, 0x3e, 0xba, 0x23, 0x6f,
 0xd5, 0x65, 0x25, 0x24, 0xe6, 0x5d, 0x25, 0x45, 0xa6, 0x5b, 0x0d, 0xd9, 0x3b, 0xb2, 0x87, 0xaa,
 0x26, 0x4c, 0x36, 0xd2, 0x10, 0xa5, 0x29, 0x68, 0x09, 0x48, 0x24, 0x9b, 0x8d, 0x40, 0x47, 0x70,
 0xd0, 0xb3, 0x22, 0x9c, 0x84, 0x54, 0xe4, 0xa9, 0xee, 0x4c, 0x24, 0x90, 0x56, 0x86, 0xd0, 0xac,
 0xa1, 0xb8, 0x9b, 0x0d, 0xb1, 0x31, 0x68, 0xa3, 0x2d, 0x25, 0x0a, 0xa6, 0xc9, 0x14, 0xa8, 0x58,
 0x8c, 0xc2, 0x76, 0x7b, 0x45, 0x95, 0x7d, 0x73, 0xdd, 0xc5, 0x47, 0x66, 0x71, 0xe7, 0xe8, 0x42,
 0x9f, 0x40, 0x9c, 0xe6, 0xe5, 0xef, 0x12, 0xcf, 0x97, 0xa9, 0xf9, 0x43, 0x5d, 0xac, 0x2a, 0xad,
 0x5c, 0x54, 0xec, 0xd2, 0x14, 0xe4, 0xb8, 0x5d, 0x90, 0xc8, 0x5e, 0x4d, 0x9b, 0x07, 0xf0, 0xdf,
 0x75, 0xf7, 0x98, 0xdf, 0xcb, 0x63, 0x64, 0x24, 0x35, 0x2c, 0xd5, 0x19, 0xa6, 0x9b, 0x16, 0x42,
 0x52, 0x97, 0xf5, 0x24, 0x7b, 0x47, 0x75, 0xd4, 0xe9, 0x74, 0xda, 0x7d, 0x51, 0x52, 0x73, 0x12,
 0x12, 0x0d, 0xa3, 0x2b, 0xca, 0xe9, 0x94, 0x41, 0x05, 0x07, 0x62, 0xad, 0x6d, 0x71, 0xbc, 0x97,
 0xc1, 0x72, 0x2a, 0xcd, 0xbc, 0x8d, 0x0c, 0xb4, 0x12, 0x14, 0x0a, 0x64, 0xd2, 0x41, 0x1b, 0x75,
 0x6a, 0x8a, 0xca, 0xba, 0x86, 0xa2, 0xa9, 0xb9, 0xc6, 0x5d, 0xdf, 0x3c, 0x17, 0x96, 0x68, 0xa9,
 0xb2, 0x2a, 0x32, 0x5d, 0x97, 0x1c, 0x9c, 0x5a, 0xf3, 0x28, 0x04, 0xf9, 0xd1, 0xfa, 0x84, 0x45,
 0x75, 0xa4, 0x7a, 0xd1, 0xfa, 0x84, 0x7e, 0x8a, 0x14, 0x51, 0x89, 0xfe, 0xec, 0x91, 0xfe, 0x9d,
 0x1f, 0xb4, 0x19, 0xba, 0x2f, 0xf9, 0x64, 0x87, 0xf4, 0xe8, 0xfd, 0xa2, 0xfd, 0x7b, 0x4c, 0x97,
 0xf5, 0xfd, 0xfd, 0x0a, 0x95, 0xd1, 0x66, 0xbf, 0x9f, 0xdb, 0xd4, 0x4a, 0xd3, 0x1d, 0x51, 0xf4,
 0x56, 0x7c, 0xc3, 0xcd, 0xbf, 0x8c, 0x57, 0x3a, 0x67, 0xae, 0x01, 0x59, 0xd6, 0x3c, 0xfb, 0xe3,
 0x93, 0x3a, 0x03, 0xdd, 0x3e, 0xb7, 0x3b, 0x2d, 0x58, 0x79, 0xda, 0x7a, 0x33, 0x8f, 0x5d, 0x63,
 0x27, 0x27, 0x2b, 0x51, 0x3a, 0xf5, 0x46, 0xe9, 0x8c, 0x55, 0x89, 0x54, 0xfb, 0x69, 0x72, 0x56,
 0xc8, 0x2b, 0x01, 0x47, 0x30, 0x75, 0x0b, 0xeb, 0xdf, 0x15, 0x85, 0x37, 0x10, 0x22, 0x42, 0xac,
 0xec, 0xc2, 0xc2, 0x96, 0x2e, 0xb4, 0xd9, 0x24, 0x5f, 0x59, 0x8d, 0xc7, 0xf1, 0xd4, 0xbf, 0xf2,
 0x5e, 0xfd, 0x42, 0x00, 0xb0, 0x71, 0xd5, 0x5b, 0x2a, 0x8c, 0x91, 0x95, 0xfe, 0x3a, 0x7f, 0xe0,
 0xc6, 0x0c, 0x33, 0x8b, 0xe4, 0xa5, 0xa9, 0x2d, 0x4a, 0xcc, 0x3e, 0x5b, 0x71, 0xb5, 0x14, 0x81,
 0x62, 0x6e, 0x09, 0xb8, 0x3d, 0xe1, 0x55, 0xda, 0x94, 0xbd, 0x4a, 0x4d, 0xbc, 0xfa, 0x4a, 0x9b,
 0x55, 0x96, 0x12, 0x55, 0x6b, 0x6a, 0xe5, 0xf3, 0x8c, 0x0e, 0x8a, 0x6b, 0x81, 0x19, 0x4c, 0xfe,
 0x04, 0xe4, 0x8b, 0x2c, 0x8b, 0x8e, 0x7c, 0x60, 0x07, 0x5c, 0x45, 0x5b, 0xa2, 0xbb, 0x50, 0x44,
 0xb5, 0x45, 0x87, 0x73, 0x96, 0x03, 0x3e, 0x9f, 0x2d, 0x92, 0x79, 0xef, 0x1f, 0x48, 0x5f, 0xaf,
 0x4d, 0xd3, 0xe5, 0xd2, 0xda, 0x24, 0x2a, 0x0b, 0x98, 0x49, 0xb9, 0x28, 0x2b, 0xca, 0x08, 0xfa,
 0xc4, 0x19, 0xd9, 0x99, 0x49, 0xc4, 0x25, 0x33, 0x08, 0x0a, 0xc9, 0x1e, 0x53, 0x7b, 0x11, 0xf5,
 0x88, 0xcc, 0x37, 0x4c, 0x65, 0xc0, 0xe0, 0x6c, 0xac, 0x83, 0x71, 0x96, 0xb2, 0x47, 0xb4, 0x00,
 0xed, 0x88, 0xea, 0x84, 0x61, 0x16, 0x1b, 0x2a, 0xb1, 0x01, 0x90, 0x47, 0xd2, 0x31, 0xe1, 0x7c,
 0x59, 0x27, 0x2b, 0x45, 0x32, 0xf3, 0x13, 0x01, 0xa7, 0x1a, 0x2a, 0x20, 0x1f, 0xcc, 0x0e, 0xb1,
 0x6e, 0x30, 0xb5, 0x39, 0x50, 0x66, 0x6d, 0x92, 0xcc, 0xc0, 0xcb, 0x41, 0x20, 0xda, 0xe4, 0x6b,
 0x1f, 0x28, 0x8a, 0xee, 0x8e, 0x71, 0xa6, 0xda, 0x53, 0x22, 0xcd, 0x8b, 0x24, 0x85, 0x10, 0x40,
 0xe1, 0x78, 0x03, 0x77, 0x84, 0x31, 0x13, 0x32, 0x15, 0x27, 0x17, 0x30, 0xe6, 0x6d, 0xb7, 0x5b,
 0xc9, 0xca, 0x3b, 0x01, 0xbd, 0xc5, 0xe3, 0x25, 0x4e, 0xb8, 0xdc, 0xf6, 0x2e, 0x61, 0xd9, 0x67,
 0x03, 0x88, 0xce, 0x34, 0x90, 0xa1, 0xb0, 0xd8, 0xeb, 0x8d, 0x22, 0x5e, 0x90, 0x4c, 0xa1, 0x95,
 0x0c, 0x23, 0x34, 0x4d, 0xc8, 0x3b, 0x49, 0xe3, 0x7d, 0xb7, 0x8f, 0x32, 0x4e, 0x48, 0xc9, 0xbb,
 0x9d, 0x61, 0xbb, 0x2f, 0x60, 0x52, 0x94, 0x49, 0x1f, 0x2b, 0xc0, 0x0c, 0x98, 0xf2, 0x79, 0x4a,
 0x9c, 0x97, 0x9b, 0xb9, 0x2d, 0x94, 0x66, 0xcf, 0xcc, 0x12, 0x6d, 0xec, 0x62, 0x3d, 0x42, 0x6b,
 0x0e, 0xa2, 0x98, 0xa7, 0xe5, 0x66, 0x5d, 0x5b, 0xea, 0x4f, 0xdd, 0xa0, 0xb9, 0x72, 0x0f, 0x31,
 0x6d, 0xd1, 0xad, 0x98, 0xa9, 0xb4, 0xfb, 0x4a, 0x69, 0xe0, 0x97, 0x10, 0xad, 0xa9, 0x56, 0xc8,
 0xd7, 0xa1, 0x9a, 0x5a, 0x1c, 0xcb, 0xcd, 0x15, 0x6f, 0xc9, 0x52, 0xc9, 0x1e, 0xd0, 0x03, 0xe6,
 0x08, 0x9f, 0x54, 0xbd, 0x21, 0x4e, 0x28, 0xdb, 0x3c, 0xe1, 0x58, 0xf9, 0x01, 0x60, 0x7f, 0xe6,
 0x37, 0xba, 0x67, 0xab, 0xbc, 0x57, 0x22, 0xb0, 0x00, 0x00, 0x28, 0x00, 0x35, 0x00, 0x23, 0xee,
 0x99, 0xeb, 0x80, 0x1d, 0xeb, 0x4e, 0xcb, 0xd5, 0x25, 0x73, 0x4f, 0x2b, 0x25, 0x69, 0xd6, 0xdb,
 0x83, 0x6a, 0x0f, 0xed, 0xca, 0x17, 0xa8, 0x18, 0x8a, 0x6a, 0x8f, 0x52, 0xd1, 0x53, 0x8b, 0xfb,
 0x95, 0x2a, 0xc3, 0x5e, 0xa4, 0x93, 0xb0, 0x8e, 0x46, 0x11, 0x1a, 0xc4, 0xf3, 0x94, 0xea, 0x9b,
 0x88, 0x9f, 0x79, 0xe7, 0x9b, 0x20, 0x84, 0xdc, 0xee, 0xbe, 0xa2, 0x37, 0x44, 0x79, 0xaa, 0xca,
 0xab, 0x35, 0x96, 0xd6, 0xc2, 0x54, 0x94, 0x8c, 0x91, 0x73, 0xb8, 0x03, 0x72, 0x4c, 0x01, 0x79,
 0x69, 0x8e, 0xa8, 0x34, 0xcf, 0x54, 0x57, 0x46, 0xb3, 0xaf, 0xf1, 0xc1, 0xa6, 0x7a, 0xe0, 0x0a,
 0xe7, 0x4c, 0xf5, 0x77, 0x83, 0x4c, 0xf5, 0x77, 0x8a, 0xeb, 0x4c, 0x75, 0x41, 0xa6, 0x7a, 0xbb,
 0xc0, 0x16, 0x01, 0x9f, 0x96, 0x26, 0xe5, 0x96, 0x89, 0xff, 0x00, 0x40, 0x83, 0xed, 0xf2, 0xdf,
 0xc9, 0x67, 0xf4, 0x08, 0xaf, 0xf4, 0xc7, 0x54, 0x1a, 0x63, 0xaa, 0x00, 0xb1, 0x53, 0x57, 0x09,
 0x01, 0x20, 0x80, 0x06, 0xa0, 0x04, 0x1a, 0x67, 0xab, 0xbc, 0x57, 0x5a, 0x63, 0xae, 0x0d, 0x33,
 0xd5, 0x00, 0x58, 0xba, 0x67, 0xab, 0xbc, 0x1a, 0x63, 0xaa, 0x2b, 0xad, 0x31, 0xd5, 0x06, 0x98,
 0xea, 0x80, 0x2c, 0x5d, 0x33, 0xd5, 0xde, 0x0d, 0x33, 0xd5, 0xde, 0x2b, 0xad, 0x33, 0xd5, 0x06,
 0x98, 0xea, 0x80, 0x2c, 0x5d, 0x33, 0xd5, 0xde, 0x0d, 0x33, 0xd7, 0xde, 0x2b, 0xad, 0x31, 0xd5,
 0x06, 0x98, 0xea, 0x80, 0x2c, 0x5d, 0x33, 0xd5, 0xde, 0x0d, 0x33, 0xd7, 0xde, 0x2b, 0xad, 0x31,
 0xd5, 0x06, 0x99, 0xea, 0x80, 0x2c, 0x5d, 0x33, 0xd7, 0xde, 0x0d, 0x33, 0xd5, 0xde, 0x2b, 0xad,
 0x31, 0xd7, 0x06, 0x99, 0xea, 0x80, 0x2c, 0x35, 0xd5, 0x50, 0xe2, 0x6c, 0xb0, 0x95, 0x8e, 0x0a,
 0x17, 0x81, 0x15, 0x54, 0x36, 0x32, 0x50, 0x12, 0x91, 0xc1, 0x22, 0xd1, 0x5e, 0x69, 0x9e, 0xae,
 0xf0, 0x69, 0x9e, 0xa8, 0x02, 0xc5, 0xd3, 0x3d, 0x5d, 0xe0, 0xd3, 0x3d, 0x5d, 0xe2, 0xba, 0xd3,
 0x3d, 0x50, 0x69, 0x9e, 0xb8, 0x02, 0xb9, 0xd3, 0x3d, 0x7d, 0xe0, 0xd3, 0x3d, 0x7d, 0xe1, 0x56,
 0xe7, 0x8c, 0x17, 0x3c, 0x60, 0x06, 0xad, 0x33, 0xd7, 0xde, 0x0d, 0x33, 0xd7, 0xde, 0x15, 0x6e,
 0x78, 0xc1, 0x73, 0xc6, 0x00, 0x6a, 0xd3, 0x3d, 0x7d, 0xe0, 0xd3, 0x3d, 0x7d, 0xe1, 0x56, 0xe7,
 0x8c, 0x17, 0x3c, 0x60, 0x06, 0xad, 0x33, 0xd7, 0xde, 0x0d, 0x33, 0xd7, 0xde, 0x15, 0x6e, 0x78,
 0xc1, 0x73, 0xc6, 0x00, 0x6a, 0xd3, 0x3d, 0x7d, 0xe0, 0xd3, 0x3d, 0x7d, 0xe1, 0x56, 0xe7, 0x8c,
 0x17, 0x3c, 0x60, 0x06, 0xad, 0x33, 0xd7, 0xde, 0x0d, 0x33, 0xd7, 0xde, 0x15, 0x6e, 0x78, 0xc1,
 0x73, 0xc6, 0x00, 0x6a, 0xd3, 0x3d, 0x7d, 0xe0, 0xd3, 0x3d, 0x7d, 0xe1, 0x56, 0xe7, 0x8c, 0x17,
 0x3c, 0x60, 0x06, 0xad, 0x33, 0xd7, 0xde, 0x0d, 0x33, 0xd7, 0xde, 0x15, 0x6e, 0x78, 0xc1, 0x73,
 0xc6, 0x00, 0x6a, 0xd3, 0x3d, 0x7d, 0xe0, 0xd3, 0x3d, 0x7d, 0xe1, 0x56, 0xe7, 0x8c, 0x17, 0x3c,
 0x60, 0x06, 0xad, 0x33, 0xd7, 0xde, 0x0d, 0x33, 0xd7, 0xde, 0x15, 0x6e, 0x78, 0xc1, 0x73, 0xc6,
 0x00, 0xf5, 0x9b, 0x73, 0xd0, 0xaf, 0x63, 0x06, 0x6d, 0xcf, 0x42, 0xbd, 0x8c, 0x10, 0x46, 0x39,
 0x30, 0xdc, 0xc3, 0x36, 0xe7, 0xa1, 0x5e, 0xc6, 0x0c, 0xdb, 0x9e, 0x85, 0x7b, 0x18, 0x20, 0x86,
 0x46, 0xe6, 0x19, 0xb7, 0x3d, 0x0a, 0xf6, 0x30, 0x66, 0xdc, 0xf4, 0x2b, 0xd8, 0xc1, 0x04, 0x32,
 0x37, 0x30, 0xcd, 0xb9, 0xe8, 0x57, 0xb1, 0x83, 0x36, 0xe7, 0xa1, 0x5e, 0xc6, 0x08, 0x21, 0x91,
 0xb9, 0x86, 0x6d, 0xcf, 0x42, 0xbd, 0x8c, 0x19, 0xb7, 0x3d, 0x0a, 0xf6, 0x30, 0x41, 0x0c, 0x8d,
 0xcc, 0x33, 0x6e, 0x7a, 0x15, 0xec, 0x60, 0xcd, 0xb9, 0xe8, 0x57, 0xb1, 0x82, 0x08, 0x64, 0x6e,
 0x61, 0x9b, 0x73, 0xd0, 0xaf, 0x63, 0x06, 0x6d, 0xcf, 0x42, 0xbd, 0x8c, 0x10, 0x43, 0x23, 0x73,
 0x0c, 0xdb, 0x9e, 0x85, 0x7b, 0x18, 0x33, 0x6e, 0x7a, 0x15, 0xec, 0x60, 0x82, 0x19, 0x1b, 0x98,
 0x66, 0xdc, 0xf4, 0x2b, 0xd8, 0xc1, 0x9b, 0x73, 0xd0, 0xaf, 0x63, 0x04, 0x10, 0xc8, 0xdc, 0xc3,
 0x36, 0xe7, 0xa1, 0x5e, 0xc6, 0x0c, 0xdb, 0x9e, 0x85, 0x7b, 0x18, 0x20, 0x86, 0x4f, 0x77, 0x1f,
 0xff, 0xd9};
static const unsigned char PIC_320x240_2[] = { 
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x17, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
 0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65, 0x20, 0x47, 0x49, 0x4d, 0x50, 0xff, 0xe1, 0x00,
 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x05, 0x03, 0x04, 0x04, 0x04, 0x03,
 0x05, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0c, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0f,
 0x0b, 0x0b, 0x09, 0x0c, 0x11, 0x0f, 0x12, 0x12, 0x11, 0x0f, 0x11, 0x11, 0x13, 0x16, 0x1c, 0x17,
 0x13, 0x14, 0x1a, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1a, 0x1d, 0x1d, 0x1f, 0x1f, 0x1f, 0x13,
 0x17, 0x22, 0x24, 0x22, 0x1e, 0x24, 0x1c, 0x1e, 0x1f, 0x1e, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x05,
 0x05, 0x05, 0x07, 0x06, 0x07, 0x0e, 0x08, 0x08, 0x0e, 0x1e, 0x14, 0x11, 0x14, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0xff,
 0xc0, 0x00, 0x11, 0x08, 0x00, 0xf0, 0x01, 0x40, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03,
 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1d, 0x00, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x05, 0x01, 0x04, 0x07, 0x08, 0x02,
 0x09, 0xff, 0xc4, 0x00, 0x57, 0x10, 0x00, 0x00, 0x04, 0x05, 0x01, 0x04, 0x05, 0x04, 0x0c, 0x09,
 0x08, 0x07, 0x09, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x11, 0x14, 0x61, 0x06,
 0x12, 0x21, 0x31, 0x51, 0x07, 0x13, 0x22, 0x41, 0x92, 0x08, 0x53, 0x71, 0x91, 0x15, 0x16, 0x32,
 0x42, 0x43, 0x52, 0x81, 0xa1, 0xb1, 0xb2, 0xd1, 0xd2, 0x23, 0x33, 0x54, 0x56, 0x62, 0x84, 0x94,
 0xa3, 0xc1, 0x24, 0x44, 0x45, 0x63, 0x72, 0x95, 0xa2, 0xb3, 0x09, 0x25, 0x26, 0x35, 0x55, 0x93,
 0xe1, 0x64, 0x65, 0x82, 0x83, 0x85, 0xc2, 0xc3, 0xe2, 0xf0, 0xff, 0xc4, 0x00, 0x1c, 0x01, 0x01,
 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x03, 0x02, 0x04, 0x05, 0x01, 0x06, 0x07, 0x08, 0xff, 0xc4, 0x00, 0x33, 0x11, 0x00, 0x02, 0x01,
 0x03, 0x02, 0x04, 0x02, 0x09, 0x04, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
 0x03, 0x04, 0x11, 0x05, 0x12, 0x13, 0x21, 0x31, 0x51, 0x41, 0x71, 0x06, 0x14, 0x22, 0x32, 0x61,
 0x81, 0xa1, 0xb1, 0xe1, 0x52, 0x91, 0xc1, 0xd1, 0x15, 0x23, 0x72, 0xf0, 0xf1, 0xff, 0xda, 0x00,
 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xe7, 0xeb, 0x6c, 0x44, 0xb6,
 0xf0, 0x2c, 0x96, 0xd6, 0x04, 0x2b, 0x6f, 0x03, 0xf4, 0x35, 0x33, 0xf3, 0x15, 0x32, 0xb9, 0x6d,
 0xe0, 0x44, 0xa6, 0xc5, 0x8a, 0xdb, 0x11, 0x2d, 0xbc, 0x0a, 0x29, 0x94, 0x53, 0x2b, 0x96, 0xde,
 0x04, 0x4a, 0x6f, 0x02, 0xc5, 0x6d, 0x88, 0x96, 0xde, 0x05, 0x14, 0xca, 0x29, 0x95, 0xca, 0x6c,
 0x44, 0xa6, 0xf0, 0x2c, 0x56, 0xd8, 0x89, 0x6d, 0xe0, 0x51, 0x4c, 0xaa, 0x99, 0x5c, 0xa6, 0xc4,
 0x4a, 0x6c, 0x58, 0xad, 0xb1, 0x12, 0x9b, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x29, 0xb1, 0x12, 0xdb,
 0xc0, 0xb1, 0x5b, 0x78, 0x11, 0x29, 0xbc, 0x0a, 0x29, 0x94, 0x53, 0x2b, 0x94, 0xd8, 0x89, 0x4d,
 0xe0, 0x58, 0xa9, 0xb1, 0x12, 0x9b, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x2d, 0xb1, 0x12, 0x9b, 0xc0,
 0xb1, 0x53, 0x62, 0x25, 0xb6, 0x28, 0xa6, 0x55, 0x4c, 0xae, 0x52, 0x07, 0xc9, 0x91, 0x90, 0xde,
 0x53, 0x78, 0x11, 0x29, 0xb1, 0x45, 0x33, 0x35, 0x23, 0x54, 0x02, 0x55, 0x36, 0x23, 0x34, 0x99,
 0x0c, 0x93, 0x33, 0xc9, 0x80, 0x00, 0x03, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xdd, 0xe8, 0x5c, 0x0d, 0x37, 0x61, 0x8c, 0xbb, 0x83, 0x53,
 0xd0, 0x98, 0x1a, 0x4f, 0x42, 0x60, 0x7c, 0x5c, 0x2b, 0x9f, 0x15, 0x0a, 0xe2, 0xcb, 0x8c, 0x99,
 0x77, 0x08, 0x56, 0xde, 0x03, 0x03, 0xd0, 0xb8, 0x1a, 0x6e, 0xc2, 0x9e, 0xfa, 0x10, 0xd9, 0x8d,
 0x54, 0xcd, 0x88, 0xd6, 0x4c, 0xa6, 0x5b, 0x62, 0x25, 0xb4, 0x2c, 0xdc, 0x60, 0xcb, 0xb8, 0x40,
 0xb6, 0x85, 0x94, 0xcb, 0xa9, 0x95, 0xca, 0x6c, 0x44, 0xb6, 0xc5, 0x8a, 0xdb, 0x11, 0x2d, 0xa1,
 0x45, 0x32, 0x8a, 0x65, 0x72, 0xdb, 0xc0, 0x89, 0x6d, 0x60, 0x58, 0xad, 0xb1, 0x12, 0xdb, 0x14,
 0x53, 0x2a, 0xa6, 0x57, 0x2d, 0xbc, 0x08, 0x94, 0xd8, 0xb1, 0x5b, 0x78, 0x11, 0x2d, 0xb1, 0x45,
 0x32, 0x8a, 0x65, 0x72, 0x9b, 0x11, 0x29, 0xb1, 0x62, 0xb6, 0xf0, 0x22, 0x5b, 0x62, 0x8a, 0x65,
 0x14, 0xca, 0xe5, 0x37, 0x81, 0x12, 0x9b, 0x16, 0x2a, 0x6c, 0x44, 0xa6, 0xc5, 0x14, 0xca, 0x29,
 0x95, 0xca, 0x6c, 0x44, 0xa6, 0xc5, 0x8a, 0x9b, 0xc0, 0x89, 0x4d, 0x8a, 0x29, 0x95, 0x53, 0x2b,
 0x94, 0xde, 0x04, 0x4a, 0x6c, 0x58, 0xa9, 0xbc, 0x08, 0x94, 0xd8, 0xa2, 0x99, 0x45, 0x32, 0xb9,
 0x4d, 0xee, 0x11, 0xa9, 0x07, 0xdc, 0x2c, 0x14, 0xde, 0x04, 0x4a, 0x6c, 0x51, 0x4c, 0xa2, 0x99,
 0xa2, 0x64, 0x64, 0x01, 0xb2, 0xa6, 0xf0, 0x22, 0x53, 0x63, 0x35, 0x23, 0x35, 0x2c, 0x91, 0x80,
 0x64, 0xd2, 0x64, 0x30, 0x32, 0xc9, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xac, 0x9e,
 0x84, 0xc0, 0xd3, 0x7a, 0x13, 0x01, 0xbe, 0x22, 0x5e, 0x65, 0x5d, 0xc2, 0xbd, 0xf8, 0x33, 0x2a,
 0xee, 0x1f, 0x99, 0xc2, 0xb9, 0xf9, 0xb3, 0xdf, 0x4f, 0xaa, 0x14, 0xde, 0x85, 0xc0, 0xd3, 0x7a,
 0x13, 0x01, 0xa9, 0xe8, 0x4c, 0x0d, 0x37, 0xa1, 0x30, 0x36, 0xe1, 0x5c, 0xac, 0x2b, 0x8a, 0xaf,
 0x42, 0x6e, 0xe0, 0x34, 0x9e, 0x84, 0xc0, 0x6b, 0x7e, 0x13, 0x03, 0x49, 0xe8, 0x4c, 0x0d, 0x98,
 0x57, 0x36, 0xa1, 0x5c, 0x56, 0x76, 0x18, 0xcb, 0xb8, 0x6b, 0xad, 0x93, 0x2e, 0xe0, 0xc8, 0xf4,
 0x2e, 0x06, 0x9b, 0xd0, 0x98, 0x1b, 0x51, 0xad, 0x93, 0x6a, 0x15, 0x8a, 0x15, 0xb7, 0x81, 0x12,
 0xdb, 0x16, 0xee, 0xc2, 0x99, 0x77, 0x0d, 0x67, 0x18, 0x32, 0xee, 0x17, 0x8d, 0x44, 0xcb, 0xc6,
 0xa6, 0x4a, 0xc5, 0xb7, 0x81, 0x12, 0x9b, 0xc0, 0xb1, 0x5b, 0x78, 0x11, 0x2d, 0xb1, 0x55, 0x32,
 0xca, 0x65, 0x72, 0xdb, 0xc0, 0x89, 0x4d, 0x8b, 0x15, 0xb7, 0x81, 0x12, 0xdb, 0x14, 0x53, 0x28,
 0xa6, 0x57, 0x2d, 0xbc, 0x08, 0x96, 0xde, 0x05, 0x8a, 0xdb, 0xc0, 0x89, 0x6d, 0xe0, 0x51, 0x4c,
 0xa2, 0x99, 0x5c, 0xb6, 0xf0, 0x22, 0x53, 0x62, 0xc5, 0x6d, 0x88, 0x96, 0xde, 0x05, 0x14, 0xca,
 0x29, 0x95, 0xca, 0x6f, 0x02, 0x25, 0x37, 0x81, 0x62, 0xb6, 0xc4, 0x4a, 0x6f, 0x02, 0x8a, 0x65,
 0x54, 0xca, 0xe5, 0x36, 0x22, 0x53, 0x62, 0xc5, 0x4d, 0x88, 0x94, 0xde, 0x05, 0x14, 0xca, 0x29,
 0x95, 0xca, 0x6f, 0x02, 0x25, 0x36, 0x2c, 0x56, 0xd8, 0x89, 0x4d, 0xf3, 0x21, 0x45, 0x32, 0x8a,
 0x65, 0x72, 0x9a, 0x11, 0x29, 0xb1, 0x62, 0xa6, 0xc4, 0x4a, 0x6f, 0x02, 0x8a, 0x65, 0x14, 0xca,
 0xf3, 0x41, 0x90, 0xf9, 0x32, 0xa0, 0xdd, 0x5b, 0x62, 0x25, 0x37, 0x81, 0x9a, 0x91, 0x45, 0x23,
 0x5c, 0x03, 0xed, 0x4d, 0x8f, 0x83, 0x23, 0x21, 0x96, 0x4c, 0xb2, 0x00, 0x00, 0x07, 0xa0, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x05, 0x8c, 0x96,
 0x29, 0x26, 0x75, 0x40, 0xaa, 0x89, 0x97, 0xf1, 0xec, 0x8e, 0x8e, 0x97, 0x20, 0x23, 0x13, 0x45,
 0x11, 0x21, 0x47, 0xea, 0x1a, 0x91, 0x92, 0x44, 0xad, 0x26, 0xa6, 0xa8, 0xa2, 0xe6, 0x43, 0xf1,
 0x2a, 0x57, 0xa9, 0x90, 0xbc, 0xf4, 0x7f, 0x3c, 0xe1, 0xcc, 0xe6, 0x11, 0x32, 0xfe, 0x3d, 0x91,
 0x5d, 0x11, 0x02, 0x65, 0x5d, 0xc3, 0xa1, 0xc6, 0xca, 0x16, 0x83, 0x3a, 0xa2, 0xa2, 0xa2, 0x2a,
 0x5d, 0xbc, 0xfb, 0x23, 0xa1, 0x4e, 0xe7, 0x27, 0xcb, 0x5d, 0x68, 0xf2, 0x83, 0xe9, 0x81, 0x11,
 0xe8, 0x4a, 0x57, 0x70, 0xd2, 0x7a, 0x13, 0x02, 0xd2, 0x67, 0xa9, 0xf4, 0x64, 0x2c, 0x53, 0xd0,
 0x91, 0x3a, 0xae, 0x44, 0xc4, 0x43, 0x2b, 0x36, 0xdd, 0x69, 0xc8, 0xf6, 0xd2, 0xb4, 0x28, 0x8e,
 0x86, 0x93, 0x23, 0x3a, 0x91, 0x91, 0xf7, 0x0a, 0xb7, 0xf5, 0x6e, 0x89, 0xf7, 0xba, 0xbf, 0x4f,
 0x9f, 0xfe, 0xa0, 0xd7, 0xda, 0x37, 0x21, 0x72, 0xbb, 0x9c, 0xf9, 0x58, 0x5d, 0x53, 0xe9, 0x06,
 0xfe, 0x4c, 0xd2, 0x7a, 0x13, 0xf4, 0x46, 0x9b, 0xd0, 0x98, 0x1b, 0x6f, 0x6a, 0xbd, 0x1b, 0xdd,
 0xaa, 0xe4, 0x47, 0xfa, 0xfb, 0x5f, 0x68, 0xd4, 0x77, 0x54, 0xe8, 0xf3, 0xe1, 0xaa, 0x64, 0x9f,
 0xb7, 0x37, 0xf6, 0x8d, 0xa8, 0x5c, 0xc7, 0xb9, 0xec, 0x68, 0xdc, 0xae, 0xb4, 0xe5, 0xfb, 0x33,
 0x4d, 0xe8, 0x4c, 0x0d, 0x27, 0xa1, 0x30, 0x18, 0xe1, 0x95, 0x09, 0x30, 0x84, 0x44, 0x5c, 0x04,
 0x43, 0x11, 0x50, 0xee, 0x57, 0x61, 0xd6, 0x56, 0x4b, 0x42, 0xa8, 0x74, 0x3a, 0x19, 0x6e, 0x3d,
 0xe4, 0x22, 0x7a, 0x13, 0x03, 0x6e, 0x9d, 0x7c, 0x99, 0x46, 0xab, 0x8b, 0xc3, 0xea, 0x2a, 0xbd,
 0x0b, 0x81, 0xa8, 0xe4, 0x39, 0x97, 0x70, 0x69, 0x7e, 0x13, 0x8e, 0xe1, 0xa4, 0xf4, 0x26, 0x06,
 0xd4, 0x2b, 0x1b, 0x30, 0xae, 0x2e, 0x2d, 0xac, 0x08, 0x56, 0xde, 0x05, 0xeb, 0xd0, 0x98, 0x1a,
 0x6e, 0xc2, 0x99, 0x77, 0x0d, 0x88, 0xd5, 0x4c, 0xd9, 0x8d, 0x54, 0xca, 0x95, 0xb6, 0x22, 0x5b,
 0x62, 0xc9, 0xc6, 0x4c, 0xbb, 0x84, 0x2a, 0x6f, 0x02, 0xca, 0x65, 0x94, 0xca, 0xe5, 0xb6, 0x22,
 0x5b, 0x78, 0x16, 0x2b, 0x6c, 0x44, 0xb6, 0xc5, 0x14, 0xca, 0x29, 0x95, 0xcb, 0x6b, 0x02, 0x25,
 0x37, 0x81, 0x62, 0xb6, 0xc4, 0x4b, 0x6f, 0x02, 0x8a, 0x65, 0x14, 0xca, 0xe5, 0x36, 0x22, 0x5b,
 0x78, 0x16, 0x2b, 0x6c, 0x44, 0xa6, 0xf0, 0x28, 0xa6, 0x55, 0x4c, 0xae, 0x53, 0x62, 0x25, 0xb7,
 0x81, 0x62, 0xb6, 0xc4, 0x4a, 0x6c, 0x51, 0x4c, 0xa2, 0x99, 0x5c, 0xa6, 0x84, 0x4a, 0x6c, 0x58,
 0xa9, 0xb1, 0x12, 0x9b, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x29, 0xbc, 0x08, 0x94, 0xde, 0x05, 0x8a,
 0xdb, 0xc0, 0x89, 0x4d, 0x0a, 0x29, 0x95, 0x53, 0x2b, 0x94, 0xd8, 0x89, 0x4d, 0x8b, 0x15, 0x37,
 0x81, 0x12, 0xdb, 0x14, 0x53, 0x28, 0xa6, 0x57, 0x29, 0xb1, 0x19, 0xa4, 0xc8, 0x58, 0x29, 0xb1,
 0x12, 0xdb, 0x14, 0x53, 0x28, 0xa6, 0x69, 0x80, 0x4e, 0xa6, 0xf0, 0x35, 0xde, 0x71, 0x96, 0xbf,
 0x18, 0xf3, 0x68, 0xc2, 0x94, 0x44, 0x3d, 0x75, 0x23, 0x15, 0x99, 0x3c, 0x19, 0xc7, 0xda, 0xe8,
 0x64, 0x02, 0x36, 0xde, 0x65, 0xc3, 0xa3, 0x6e, 0xb6, 0xb3, 0xfd, 0x15, 0x11, 0x89, 0x07, 0xb1,
 0x9c, 0x66, 0xb3, 0x17, 0x93, 0xd6, 0x9a, 0xea, 0x00, 0x00, 0x06, 0x47, 0x80, 0x00, 0x00, 0x01,
 0xef, 0xe8, 0x39, 0xa9, 0x91, 0x95, 0x14, 0x2f, 0x20, 0x27, 0x4a, 0x4d, 0x28, 0xb3, 0x2f, 0x94,
 0x73, 0x18, 0x69, 0x87, 0x0e, 0xd0, 0xb4, 0x85, 0x98, 0xf0, 0xed, 0x0f, 0xe7, 0x48, 0xcc, 0xeb,
 0x53, 0xb8, 0x3a, 0xa3, 0x13, 0x38, 0x68, 0x92, 0xd9, 0x7d, 0x09, 0x33, 0x3e, 0xf2, 0x03, 0xd2,
 0xd8, 0x68, 0x92, 0xab, 0x2a, 0x49, 0x99, 0xf7, 0x77, 0x84, 0x08, 0x49, 0x99, 0x95, 0x3b, 0x42,
 0xea, 0x06, 0x6e, 0xa4, 0xa9, 0x3d, 0xb3, 0xe2, 0x43, 0x62, 0x15, 0xe5, 0x1e, 0x85, 0x65, 0xc2,
 0xac, 0xb1, 0x34, 0x7e, 0x71, 0xf4, 0xcc, 0x8e, 0xab, 0xa5, 0xdd, 0x60, 0xd7, 0xc4, 0x9e, 0x46,
 0x27, 0xd4, 0xf2, 0x85, 0x34, 0xb7, 0x4f, 0x4f, 0xe6, 0x50, 0xb7, 0x52, 0xe9, 0x24, 0xca, 0x31,
 0x8d, 0xa3, 0x4f, 0x5a, 0xc4, 0x23, 0x8e, 0x22, 0xa5, 0xc4, 0xaa, 0x92, 0x32, 0xae, 0xf2, 0x17,
 0x1d, 0x32, 0x2c, 0xdd, 0xe9, 0x6b, 0x57, 0xb8, 0x7e, 0xfe, 0x77, 0x18, 0xaf, 0x5b, 0xca, 0x1e,
 0xce, 0xf2, 0x14, 0x6d, 0x87, 0xba, 0x08, 0xd8, 0x5b, 0xbb, 0x0b, 0xf6, 0x62, 0x2b, 0xbe, 0x9e,
 0xf5, 0xa1, 0xd8, 0x95, 0x45, 0x08, 0xa9, 0x33, 0x6e, 0x5b, 0xa3, 0x0f, 0x61, 0x1e, 0x20, 0x3d,
 0x23, 0xaa, 0xcb, 0x8e, 0x99, 0x9d, 0x17, 0xea, 0x0e, 0xfd, 0xd1, 0x8f, 0x6a, 0x7a, 0xa0, 0x8f,
 0x7e, 0x9b, 0x9c, 0x17, 0xea, 0x2e, 0xfd, 0xd1, 0xfa, 0x91, 0x1f, 0x26, 0x72, 0x86, 0xa4, 0x2d,
 0x66, 0x5c, 0xc9, 0x46, 0x28, 0xe3, 0x25, 0xaf, 0x26, 0xb5, 0x35, 0xfa, 0xcc, 0x65, 0x0a, 0x90,
 0x97, 0x89, 0xc7, 0xb8, 0xd4, 0xae, 0xa8, 0xf5, 0xa5, 0xf5, 0xfc, 0x1c, 0x07, 0xa0, 0xa9, 0x5c,
 0x54, 0x37, 0x44, 0xd2, 0x56, 0x63, 0x21, 0x5e, 0x87, 0x7d, 0x24, 0xf6, 0xd3, 0x6e, 0xb6, 0x68,
 0x52, 0x7f, 0x0c, 0xbe, 0x24, 0x7b, 0xc3, 0x63, 0xd0, 0x9c, 0x7b, 0x21, 0xea, 0x2a, 0x5e, 0x66,
 0x66, 0x66, 0x46, 0x67, 0x91, 0xc6, 0x3a, 0x4f, 0xe9, 0x7b, 0x4f, 0xe8, 0x7d, 0x58, 0xfe, 0x9d,
 0x98, 0x49, 0xe6, 0x71, 0x31, 0x0d, 0x34, 0xdb, 0x86, 0xe3, 0x0a, 0x6c, 0x90, 0x64, 0xb4, 0x92,
 0x8b, 0x89, 0xd7, 0xbc, 0x74, 0xa9, 0xdc, 0x28, 0xa4, 0x8f, 0xcf, 0xeb, 0xe9, 0xd7, 0x57, 0x97,
 0x33, 0x9d, 0x28, 0xe5, 0xc9, 0xb7, 0x8f, 0x37, 0xf9, 0x18, 0x1e, 0x84, 0xc0, 0xd3, 0x7a, 0x13,
 0x02, 0x8a, 0x17, 0xa5, 0x9d, 0x2d, 0x13, 0xa1, 0x22, 0x35, 0x7b, 0xec, 0x46, 0x41, 0xc3, 0x37,
 0x16, 0xa8, 0x36, 0xa1, 0x9c, 0xd8, 0x53, 0xcf, 0xba, 0x49, 0x4a, 0xa8, 0x82, 0x23, 0xa5, 0x28,
 0xa2, 0xa9, 0x9f, 0x0f, 0x50, 0x46, 0x67, 0xca, 0x0e, 0x56, 0xe4, 0x59, 0xa6, 0x27, 0x4b, 0xc5,
 0x37, 0x0d, 0x5f, 0x76, 0xdc, 0x52, 0x56, 0xba, 0x7f, 0x64, 0xd2, 0x45, 0xf3, 0x8d, 0x98, 0xde,
 0x41, 0x75, 0x67, 0x94, 0x74, 0x5d, 0x4a, 0x7b, 0xb6, 0xd2, 0x7c, 0xba, 0xf4, 0xfe, 0xf9, 0xfc,
 0x8e, 0x94, 0xf4, 0x27, 0x1d, 0xc3, 0x49, 0xe8, 0x4c, 0x06, 0x24, 0x1b, 0x2f, 0xcb, 0x5b, 0x98,
 0x19, 0x29, 0x86, 0x1c, 0x64, 0x9f, 0xab, 0xc5, 0xb0, 0x68, 0x49, 0xa7, 0x6b, 0xb5, 0x5e, 0x14,
 0x2e, 0x3c, 0x87, 0x21, 0xd5, 0x7d, 0x34, 0xe9, 0xe8, 0x08, 0xa7, 0x21, 0xa4, 0xf0, 0x0f, 0xcd,
 0x4d, 0x07, 0x4e, 0xb8, 0xd7, 0xd5, 0x34, 0x67, 0xfa, 0x35, 0x23, 0x33, 0x2c, 0xd0, 0x86, 0xdf,
 0xad, 0xc2, 0x0b, 0x32, 0x66, 0x36, 0x56, 0xb7, 0x37, 0x72, 0x71, 0xa3, 0x06, 0xda, 0xeb, 0xf0,
 0xf9, 0xf4, 0x1c, 0x1e, 0x84, 0xc0, 0xd3, 0x76, 0x16, 0x9d, 0xc3, 0x9b, 0x1f, 0x4e, 0x2f, 0xa9,
 0x5d, 0xad, 0x33, 0x0f, 0xb3, 0x88, 0xb5, 0x57, 0xea, 0x86, 0x4d, 0x27, 0xd2, 0x76, 0x9f, 0x9f,
 0xc5, 0xb7, 0x03, 0x12, 0xcb, 0xb2, 0xb8, 0xa7, 0x4c, 0x92, 0xdf, 0x5c, 0xa2, 0x53, 0x6b, 0x51,
 0xf0, 0x22, 0x59, 0x52, 0x87, 0xe9, 0x22, 0xf4, 0x8a, 0xd2, 0xd4, 0x69, 0x49, 0xe3, 0x71, 0xd5,
 0xa9, 0xa4, 0x5f, 0xd0, 0x8e, 0xf9, 0x53, 0xe4, 0xbb, 0x34, 0xfe, 0xc5, 0xdb, 0x90, 0xe6, 0x5d,
 0xc3, 0x5d, 0x6d, 0x60, 0x31, 0xbd, 0x09, 0xc7, 0x70, 0x45, 0xd7, 0x1a, 0xc6, 0x5d, 0xa5, 0xe6,
 0x8d, 0xc0, 0x46, 0x40, 0xc5, 0x3e, 0xe3, 0x8c, 0x93, 0xa4, 0xa6, 0x8d, 0x24, 0x44, 0x46, 0x66,
 0x54, 0xdf, 0xe8, 0x1b, 0xd2, 0xba, 0x85, 0x38, 0xee, 0x9b, 0xc2, 0x35, 0xed, 0x63, 0x52, 0xe6,
 0x7b, 0x29, 0xac, 0xb2, 0xc9, 0x6d, 0x88, 0x96, 0xde, 0x05, 0x64, 0x8b, 0x57, 0xca, 0x66, 0xf2,
 0xa8, 0xd9, 0x9a, 0x92, 0xe4, 0x0c, 0x34, 0x1a, 0x92, 0x97, 0x15, 0x10, 0xa2, 0xde, 0x6a, 0x23,
 0x32, 0xa5, 0x38, 0x9e, 0xee, 0x01, 0x6a, 0x63, 0xd2, 0x84, 0xbd, 0xb7, 0x8d, 0x10, 0x52, 0xc7,
 0xe2, 0x10, 0x47, 0x4d, 0xb7, 0x1c, 0x26, 0xeb, 0xe8, 0x2a, 0x18, 0x3d, 0x46, 0xde, 0x11, 0x52,
 0x72, 0xe4, 0xce, 0x85, 0x2d, 0x3e, 0xea, 0x73, 0x70, 0x8c, 0x1e, 0x57, 0x51, 0xcd, 0x6d, 0x88,
 0x96, 0xd8, 0xa5, 0xd3, 0x3a, 0xda, 0x53, 0x3c, 0x89, 0x4c, 0x19, 0xb6, 0xe4, 0x1c, 0x52, 0xf7,
 0x21, 0x0e, 0x19, 0x1a, 0x56, 0x7c, 0x89, 0x45, 0xdf, 0x83, 0x13, 0xea, 0x9d, 0x51, 0x29, 0x90,
 0xab, 0xaa, 0x88, 0x52, 0x9e, 0x89, 0x32, 0xa9, 0x30, 0xd5, 0x0d, 0x44, 0x5c, 0xd4, 0x7c, 0x08,
 0x5a, 0x37, 0xd4, 0x5d, 0x3e, 0x26, 0xe5, 0x81, 0xea, 0x97, 0x11, 0xab, 0xc2, 0x70, 0x7b, 0x8d,
 0xe5, 0xb7, 0x81, 0x12, 0xda, 0x09, 0xcd, 0xf4, 0x97, 0x0c, 0xa7, 0x68, 0xe4, 0xa1, 0xd4, 0xb7,
 0xcd, 0x2f, 0x91, 0x9f, 0xaa, 0x84, 0x1b, 0xa4, 0xb3, 0x48, 0x09, 0xd4, 0x1d, 0xd4, 0x03, 0xbb,
 0x69, 0x23, 0xa2, 0xd2, 0x65, 0x45, 0x20, 0xf9, 0x19, 0x0c, 0xed, 0xef, 0xe8, 0x57, 0x78, 0xa7,
 0x2c, 0xb2, 0xb5, 0xac, 0xee, 0x2d, 0xd6, 0xea, 0x91, 0xc2, 0x3e, 0x56, 0xde, 0x04, 0x4a, 0x6c,
 0x58, 0xad, 0xbc, 0x0a, 0xa9, 0xfc, 0xd6, 0x5f, 0x26, 0x87, 0x27, 0x63, 0x9d, 0xd9, 0x35, 0x57,
 0x61, 0xb4, 0x95, 0x56, 0xbf, 0x41, 0x7f, 0x11, 0xb7, 0x2a, 0xd1, 0xa7, 0x1d, 0xd2, 0x78, 0x48,
 0x95, 0x3d, 0xd5, 0x24, 0xa3, 0x15, 0x96, 0x61, 0x6d, 0xe0, 0x44, 0xa6, 0xc2, 0x9c, 0x47, 0x48,
 0x04, 0x6e, 0x19, 0x31, 0x2b, 0x23, 0x47, 0x71, 0xad, 0xed, 0xff, 0x00, 0x31, 0x0d, 0xb9, 0x6e,
 0xb6, 0x97, 0xc4, 0xb8, 0x4d, 0xc6, 0x43, 0xae, 0x10, 0xcf, 0xdf, 0xd7, 0x6d, 0x1f, 0x2f, 0x79,
 0x0d, 0x4a, 0x7a, 0xcd, 0xa4, 0xa5, 0xb5, 0x4f, 0xee, 0x74, 0x9e, 0x9d, 0x75, 0x18, 0xee, 0x70,
 0xfb, 0x17, 0x8a, 0x6f, 0x02, 0x25, 0x36, 0x2c, 0x09, 0x29, 0x5a, 0x09, 0x68, 0x52, 0x56, 0x95,
 0x15, 0x52, 0xa2, 0x3a, 0x91, 0x97, 0x32, 0x11, 0xa9, 0xb1, 0xd5, 0x8c, 0xf2, 0x6a, 0x29, 0x95,
 0xca, 0x6b, 0x02, 0x25, 0x36, 0x2c, 0x54, 0xde, 0x04, 0x4a, 0x6f, 0x02, 0x8a, 0x65, 0x14, 0xc4,
 0x9d, 0x51, 0x36, 0x71, 0xa7, 0xd5, 0x05, 0x08, 0xbd, 0x83, 0x4e, 0xe7, 0x16, 0x5c, 0x6b, 0xc8,
 0x82, 0xf3, 0x10, 0xf1, 0x31, 0x6b, 0x32, 0x65, 0xa7, 0x1d, 0x57, 0x13, 0xd9, 0x23, 0x31, 0x71,
 0x1d, 0xa7, 0x67, 0x6b, 0x88, 0x71, 0xe3, 0x86, 0x4b, 0x86, 0xb5, 0x9a, 0x8c, 0xd2, 0xe2, 0x4f,
 0x89, 0xfa, 0x43, 0x34, 0x8a, 0x00, 0xe0, 0xe5, 0x2c, 0xb4, 0xb6, 0xf6, 0x1d, 0x32, 0xda, 0x70,
 0xbb, 0xf6, 0x8f, 0x98, 0xf8, 0xe5, 0x67, 0x73, 0xa9, 0xdd, 0xc9, 0xdc, 0x66, 0x31, 0x5d, 0x39,
 0x78, 0x76, 0x5e, 0x07, 0xd0, 0xbb, 0x9a, 0x36, 0xb4, 0x57, 0x0f, 0x0d, 0x9c, 0xfd, 0xf6, 0x1f,
 0x86, 0x70, 0x92, 0xf3, 0x6b, 0x69, 0x7c, 0x48, 0x94, 0x54, 0x31, 0x77, 0x20, 0x99, 0x2d, 0xd7,
 0x0a, 0x12, 0x21, 0x5b, 0x46, 0x7e, 0xe1, 0x47, 0xc7, 0xd0, 0x62, 0xe3, 0x57, 0xb0, 0x85, 0x49,
 0x9c, 0x71, 0x64, 0x5b, 0x4d, 0xa9, 0x26, 0x93, 0xe4, 0x66, 0x74, 0x09, 0xf0, 0x06, 0x65, 0x1a,
 0xc1, 0xa6, 0xb5, 0xeb, 0x13, 0x4f, 0x58, 0x8c, 0xa3, 0x53, 0x47, 0xbe, 0x8c, 0x69, 0xcb, 0x29,
 0xe3, 0xe6, 0x9f, 0x83, 0x2d, 0x4e, 0x71, 0xbc, 0xa0, 0xdb, 0x5c, 0xc7, 0x33, 0x49, 0x90, 0xc0,
 0xdb, 0x5b, 0x5b, 0xcf, 0xd2, 0x22, 0x53, 0x78, 0x1f, 0xa1, 0xa9, 0x1c, 0x35, 0x22, 0x10, 0x0f,
 0xa3, 0x41, 0x90, 0xf9, 0x19, 0x64, 0xc8, 0xf5, 0x13, 0x11, 0xdc, 0x3b, 0x42, 0xc6, 0x1e, 0x3b,
 0x21, 0x29, 0x88, 0xdc, 0x8d, 0xe6, 0x23, 0x7f, 0x48, 0x7f, 0x35, 0x29, 0x98, 0x42, 0xb0, 0xf1,
 0x0d, 0x1f, 0xfa, 0x42, 0xd2, 0x12, 0x62, 0x75, 0x2e, 0xd7, 0x78, 0x43, 0x87, 0x8e, 0xe1, 0xbc,
 0x58, 0xc3, 0x47, 0x6f, 0x2d, 0xe3, 0x35, 0x33, 0x66, 0x15, 0xcf, 0x1e, 0xf4, 0xa6, 0xad, 0xbe,
 0x92, 0xf5, 0x32, 0xfe, 0x34, 0xda, 0x28, 0xff, 0x00, 0x7a, 0xa0, 0xe5, 0xd1, 0x5f, 0x4f, 0x1a,
 0xbf, 0xa3, 0xad, 0x31, 0xed, 0x7e, 0x49, 0x03, 0x27, 0x7e, 0x16, 0xe1, 0x71, 0x1b, 0x51, 0x4c,
 0xb8, 0xa5, 0xed, 0x2c, 0x92, 0x46, 0x55, 0x4a, 0xc8, 0xa9, 0xd9, 0x2e, 0xe0, 0x8f, 0xd2, 0x32,
 0xb6, 0xb5, 0xfe, 0xa0, 0x57, 0x39, 0x94, 0x41, 0xfe, 0xf1, 0x43, 0xa4, 0xf4, 0x39, 0xd1, 0x1c,
 0x87, 0x5a, 0xe9, 0x02, 0x9c, 0xcc, 0x66, 0xd3, 0x18, 0x57, 0xae, 0x9c, 0x67, 0xab, 0x61, 0x28,
 0x34, 0xd1, 0x24, 0x9a, 0x1f, 0x68, 0xab, 0x5d, 0xe3, 0xe9, 0x2a, 0x4e, 0x9c, 0x69, 0x27, 0x53,
 0xa1, 0xdf, 0x94, 0xe3, 0x08, 0x27, 0x21, 0x91, 0x8f, 0x2c, 0x2e, 0x93, 0x19, 0x2a, 0x26, 0x53,
 0xa6, 0x0c, 0xb9, 0x1c, 0x33, 0xc7, 0xff, 0x00, 0xca, 0x19, 0xfa, 0x32, 0xf2, 0xa4, 0xd7, 0x5a,
 0xbb, 0xa4, 0x7d, 0x3d, 0xa7, 0x26, 0x92, 0x6d, 0x32, 0xd4, 0x1c, 0xca, 0x62, 0xcc, 0x33, 0xee,
 0x31, 0x0c, 0xf1, 0x38, 0x94, 0x2d, 0x44, 0x46, 0x69, 0x33, 0x74, 0xc8, 0x8f, 0xd2, 0x46, 0x2b,
 0xd9, 0xf2, 0x6f, 0xd2, 0x2b, 0xe3, 0xa8, 0xe7, 0x65, 0xff, 0x00, 0x96, 0xd7, 0xd8, 0x18, 0xb4,
 0x47, 0x40, 0x3a, 0x5b, 0x4e, 0x6a, 0xa9, 0x5e, 0xa1, 0x85, 0xd4, 0x13, 0x87, 0x62, 0x25, 0xd1,
 0x48, 0x89, 0x6d, 0xb7, 0x10, 0xd1, 0x25, 0x4a, 0x41, 0xd4, 0x88, 0xe8, 0x55, 0xa0, 0xd6, 0xf5,
 0x8b, 0x64, 0xbd, 0x92, 0x6e, 0xbd, 0x29, 0xac, 0x1e, 0xa5, 0x89, 0x94, 0x32, 0xfa, 0x4d, 0x4c,
 0xa9, 0x2a, 0xf4, 0x0f, 0xcf, 0xdf, 0x2c, 0xf8, 0x73, 0x85, 0xe9, 0xe2, 0x64, 0xc9, 0xf7, 0x41,
 0xc2, 0x7f, 0x92, 0x91, 0xee, 0x68, 0x19, 0xca, 0x93, 0x4a, 0x2c, 0xc7, 0x86, 0xfc, 0xb5, 0x22,
 0x2e, 0xba, 0x7a, 0x98, 0xbc, 0x67, 0x5a, 0xc1, 0x41, 0xff, 0x00, 0x92, 0x91, 0x95, 0xa5, 0x77,
 0x37, 0xb5, 0x98, 0x51, 0xa1, 0x46, 0x35, 0x38, 0x90, 0x58, 0x67, 0x3f, 0xe8, 0xef, 0x4a, 0xea,
 0x1d, 0x7f, 0x3d, 0x85, 0xd2, 0xd2, 0x63, 0x25, 0xec, 0xf5, 0x8f, 0x99, 0xba, 0xb3, 0x26, 0xa1,
 0xd3, 0xd9, 0xdb, 0x71, 0x5c, 0xb8, 0x24, 0xb7, 0x15, 0x4c, 0xe8, 0x43, 0xb0, 0xc3, 0x79, 0x31,
 0xcf, 0x65, 0xfa, 0x82, 0x52, 0xeb, 0xd3, 0x89, 0x74, 0xc6, 0x5a, 0x51, 0x4d, 0x9c, 0x72, 0x50,
 0x95, 0xb6, 0xb4, 0xb6, 0x47, 0x55, 0x50, 0x95, 0xb9, 0x55, 0xa5, 0x38, 0xd7, 0x7f, 0x00, 0xd5,
 0xfe, 0x8f, 0x19, 0x2c, 0x3c, 0x62, 0xf5, 0x94, 0xc9, 0xdd, 0x8e, 0xb5, 0x08, 0x84, 0x86, 0x6c,
 0xcf, 0x89, 0x12, 0x8d, 0xc5, 0xa8, 0xbf, 0xc2, 0x9f, 0x50, 0xf5, 0x34, 0x7c, 0x8d, 0x49, 0xa9,
 0x92, 0x46, 0xdf, 0x1a, 0x0a, 0x5b, 0x59, 0xa7, 0xa8, 0xca, 0xf2, 0x2f, 0xfd, 0x3e, 0xe9, 0xe6,
 0xbf, 0x28, 0xc9, 0x36, 0xaf, 0x98, 0xe8, 0xf6, 0xe5, 0x3a, 0x4e, 0x52, 0xfc, 0x61, 0x45, 0x3c,
 0x77, 0xbd, 0x42, 0x92, 0x46, 0x96, 0x92, 0x55, 0x24, 0x11, 0x19, 0x91, 0x99, 0x28, 0xe9, 0xc3,
 0xb9, 0x34, 0xef, 0x1e, 0x7d, 0xd0, 0x5d, 0x13, 0x6a, 0x69, 0xfe, 0xa8, 0xf6, 0x2a, 0x6d, 0x2f,
 0x8f, 0x92, 0xc3, 0xb4, 0x83, 0x76, 0x21, 0xf8, 0x88, 0x65, 0x24, 0xc9, 0x24, 0x74, 0xa2, 0x2b,
 0x42, 0x52, 0x8c, 0xcf, 0x9f, 0x33, 0xee, 0x1e, 0xe8, 0xd6, 0x31, 0x52, 0x9d, 0x31, 0x25, 0x89,
 0x9c, 0xcf, 0xe3, 0x19, 0x80, 0x80, 0x87, 0x2a, 0xb8, 0xf3, 0xbc, 0x37, 0xf0, 0x22, 0x2e, 0x26,
 0xa3, 0xe0, 0x44, 0x5b, 0xcc, 0x79, 0xbb, 0x57, 0xf9, 0x4b, 0xcb, 0x1b, 0x79, 0x6c, 0x69, 0x9d,
 0x36, 0xf4, 0x5a, 0x08, 0xcc, 0x92, 0xfc, 0x7b, 0xdd, 0x5a, 0x4f, 0x24, 0xda, 0x6a, 0x7e, 0xb5,
 0x10, 0xd9, 0xdf, 0x19, 0xbd, 0xd2, 0x67, 0x03, 0x4f, 0x57, 0xf6, 0xd6, 0xf2, 0xb7, 0xb5, 0xa6,
 0xbc, 0x7d, 0xaf, 0x8b, 0xf1, 0xe7, 0xc9, 0x9a, 0xb3, 0x2f, 0x27, 0x99, 0x01, 0xc2, 0x29, 0x10,
 0x13, 0x99, 0x9b, 0x51, 0x5b, 0x34, 0x42, 0xde, 0xd8, 0x5a, 0x0d, 0x5d, 0xd5, 0x22, 0x22, 0x3a,
 0x7a, 0x0c, 0x79, 0xd2, 0x3a, 0x19, 0xd8, 0x38, 0xe7, 0xa1, 0x1e, 0x22, 0x4b, 0xac, 0xb8, 0xa6,
 0xd6, 0x45, 0xdc, 0xa4, 0x9d, 0x0f, 0xe7, 0x21, 0xd3, 0xa6, 0xfd, 0x35, 0xf4, 0x8b, 0x3f, 0x78,
 0xa1, 0x65, 0xce, 0xb3, 0x02, 0xa7, 0x0e, 0x89, 0x6a, 0x5d, 0x0b, 0x57, 0x0f, 0x04, 0x67, 0xb4,
 0xaa, 0xfa, 0x07, 0x31, 0x8d, 0x38, 0x93, 0x8d, 0x78, 0xe3, 0x3a, 0xdb, 0x9e, 0xb1, 0x5d, 0x6f,
 0x59, 0x5d, 0xbd, 0xba, 0xf6, 0xb6, 0xab, 0xbe, 0xb5, 0xad, 0x6a, 0x15, 0x25, 0x07, 0x8d, 0xab,
 0x07, 0x73, 0x46, 0xa1, 0xa8, 0xd1, 0x52, 0xf5, 0xda, 0x8a, 0x59, 0xc6, 0x3b, 0xaf, 0xa2, 0x3d,
 0x67, 0xa0, 0x5e, 0x76, 0x6b, 0xa1, 0x24, 0xb3, 0x07, 0xcc, 0xd6, 0xeb, 0xd0, 0x68, 0xeb, 0x14,
 0x7c, 0x54, 0xa2, 0xec, 0x99, 0xfc, 0xc3, 0x8a, 0xf9, 0x48, 0xb7, 0xd5, 0x6b, 0x58, 0x34, 0xff,
 0x00, 0xdd, 0xe8, 0x3f, 0xde, 0x2c, 0x77, 0x5e, 0x86, 0x21, 0xb6, 0xfa, 0x28, 0xd3, 0xab, 0xa7,
 0x18, 0x53, 0xff, 0x00, 0x31, 0x63, 0x8a, 0xf9, 0x52, 0xb7, 0xd5, 0x6b, 0xd8, 0x14, 0xd3, 0xfa,
 0x35, 0x07, 0xfb, 0xc7, 0x06, 0xfd, 0xc5, 0x5d, 0xd6, 0xe9, 0x79, 0x1f, 0x2f, 0xa1, 0xc9, 0x2d,
 0x66, 0xa4, 0x17, 0x45, 0xbb, 0xee, 0x20, 0x69, 0x19, 0x44, 0xd3, 0x52, 0xcc, 0x9a, 0x90, 0xc0,
 0x39, 0x44, 0x38, 0xa3, 0x79, 0x7b, 0x46, 0x7b, 0x08, 0x24, 0x96, 0xf5, 0x99, 0x60, 0x8e, 0x9f,
 0x2d, 0x3b, 0xc7, 0x43, 0x9c, 0xf4, 0x3c, 0xdc, 0x34, 0x9d, 0xe7, 0xa0, 0xa6, 0x8f, 0xbd, 0x18,
 0xd3, 0x66, 0xb2, 0x4a, 0xda, 0x22, 0x43, 0x86, 0x45, 0x53, 0x22, 0xa1, 0xd4, 0xbe, 0x71, 0xf5,
 0xe4, 0xc5, 0x0a, 0x97, 0xe7, 0x93, 0x97, 0x8d, 0x24, 0x6a, 0x6e, 0x0d, 0x09, 0x23, 0xe5, 0xb4,
 0xbd, 0xff, 0x00, 0x40, 0xed, 0xd1, 0x50, 0x75, 0x6d, 0x65, 0xb3, 0xc5, 0x26, 0x5f, 0x30, 0xca,
 0xce, 0xde, 0x94, 0xe9, 0xe6, 0x6b, 0x2d, 0x9b, 0xfa, 0xd6, 0xb7, 0x71, 0x6b, 0x7b, 0xc2, 0xa4,
 0xf0, 0x96, 0x33, 0xf1, 0xcf, 0x33, 0xc6, 0x4d, 0xad, 0x4d, 0xb8, 0x95, 0xa1, 0x46, 0x95, 0x24,
 0xc8, 0xd2, 0x64, 0x7b, 0xc8, 0xc3, 0xb6, 0x8e, 0xd1, 0x91, 0xba, 0xad, 0x2e, 0xce, 0x26, 0x31,
 0x8e, 0x34, 0xc2, 0xdc, 0x32, 0xeb, 0x29, 0xb4, 0xe3, 0xca, 0xef, 0x3d, 0xfd, 0xd9, 0x09, 0x2b,
 0x2a, 0x38, 0x65, 0x91, 0xe9, 0x4e, 0x8e, 0x60, 0x52, 0xde, 0x81, 0x92, 0xec, 0xa4, 0x88, 0x95,
 0x0a, 0x4b, 0x3f, 0x4a, 0x8c, 0xcc, 0xfe, 0x91, 0x1d, 0x3a, 0x8c, 0x2a, 0xd4, 0xc4, 0xfa, 0x23,
 0xb5, 0xae, 0x5f, 0x4e, 0xce, 0x82, 0x95, 0x3e, 0x4d, 0xbc, 0x67, 0xea, 0x71, 0x6e, 0x90, 0x34,
 0x79, 0xe9, 0xae, 0xa1, 0xf6, 0x22, 0x55, 0x11, 0x0a, 0xfa, 0x8d, 0x04, 0x6b, 0x4d, 0x14, 0x95,
 0x16, 0xfa, 0x1d, 0x37, 0x1e, 0xe1, 0xf3, 0xd1, 0x5c, 0x63, 0x90, 0xfa, 0xb5, 0x88, 0x74, 0xa8,
 0xfa, 0xb8, 0xa4, 0xa9, 0xb5, 0x97, 0x71, 0xee, 0x33, 0x2f, 0x9c, 0x87, 0x42, 0xe9, 0xea, 0x1c,
 0x9b, 0xd2, 0x70, 0xab, 0xa6, 0xf2, 0x8d, 0x49, 0x17, 0x81, 0x63, 0x9a, 0xf4, 0x68, 0x5b, 0x5a,
 0xe6, 0x54, 0x45, 0xde, 0xe9, 0xfd, 0x53, 0x15, 0xa9, 0x08, 0xd0, 0xbe, 0x8a, 0xa7, 0xc9, 0x65,
 0x18, 0x5a, 0xdc, 0x4a, 0xef, 0x4c, 0x94, 0xea, 0xf3, 0x78, 0x7f, 0x43, 0xb2, 0xc7, 0x2d, 0xb8,
 0x58, 0x57, 0x62, 0x5e, 0x3d, 0x96, 0x9a, 0x42, 0x96, 0xb3, 0xc1, 0x15, 0x4c, 0x70, 0x69, 0xec,
 0xce, 0x22, 0x6f, 0x33, 0x7a, 0x3a, 0x21, 0x5d, 0xa5, 0x9f, 0x65, 0x3d, 0xc8, 0x4f, 0x72, 0x4b,
 0x04, 0x3b, 0x4f, 0x49, 0x46, 0xa6, 0x34, 0x4c, 0xc9, 0x69, 0xdc, 0x66, 0xda, 0x51, 0xf2, 0x1a,
 0xd2, 0x46, 0x38, 0x5b, 0x2b, 0xea, 0xde, 0x43, 0x9b, 0x24, 0xad, 0x95, 0x12, 0xa8, 0x7c, 0x0e,
 0x9d, 0xc3, 0x6b, 0x5b, 0xae, 0xdc, 0xa3, 0x4f, 0x3c, 0xba, 0x90, 0xf4, 0x76, 0x92, 0x74, 0xe7,
 0x57, 0xc7, 0x38, 0x1f, 0xe4, 0x5d, 0x1e, 0xb6, 0xf4, 0x03, 0x71, 0x13, 0x58, 0x97, 0x9b, 0x75,
 0xc4, 0x92, 0x89, 0xa6, 0xa8, 0x5b, 0x04, 0x7c, 0x08, 0xcc, 0xeb, 0xbc, 0x2f, 0xeb, 0x3d, 0x30,
 0xec, 0x81, 0xd6, 0xdc, 0x43, 0xa6, 0xf4, 0x2b, 0xa6, 0x64, 0x85, 0x99, 0x51, 0x49, 0x51, 0x77,
 0x1f, 0xda, 0x2e, 0x55, 0xd2, 0x5c, 0xc4, 0xff, 0x00, 0xa3, 0x20, 0x8b, 0xff, 0x00, 0x12, 0xfe,
 0xd1, 0x55, 0xa9, 0xb5, 0x84, 0x4c, 0xf6, 0x5c, 0x50, 0x6f, 0xc1, 0x43, 0x34, 0x92, 0x70, 0x9c,
 0x25, 0x20, 0xd5, 0x52, 0x32, 0x23, 0x2e, 0xf3, 0xc8, 0x95, 0xc3, 0xd3, 0xdd, 0x0d, 0xb4, 0xfd,
 0xe5, 0xe3, 0xcc, 0xda, 0xb7, 0x5a, 0x8a, 0xaf, 0xba, 0xaf, 0xba, 0xfc, 0x39, 0x72, 0x2d, 0x7a,
 0x31, 0x9a, 0x2d, 0x6b, 0x72, 0x50, 0xf2, 0x8c, 0xd2, 0x49, 0x37, 0x18, 0xaf, 0x75, 0x3d, 0xd2,
 0x7d, 0x1d, 0xfe, 0xb0, 0xf0, 0xa6, 0xc7, 0x26, 0xd0, 0xae, 0x9b, 0x5a, 0xb6, 0x5c, 0x64, 0x7e,
 0xe9, 0xed, 0x83, 0xf4, 0x28, 0x8c, 0xbf, 0x88, 0xec, 0xaa, 0x6c, 0x76, 0x74, 0x3b, 0x89, 0x4e,
 0xdf, 0x6c, 0xbc, 0x1e, 0x3e, 0x47, 0x2f, 0x59, 0xa6, 0xa9, 0x5c, 0x65, 0x78, 0xac, 0x95, 0xcb,
 0x6c, 0x44, 0xb6, 0xf0, 0x2c, 0x56, 0xd8, 0x89, 0x6d, 0xe0, 0x77, 0x14, 0xce, 0x5a, 0x99, 0x5c,
 0xb6, 0xc4, 0x4b, 0x6c, 0x58, 0xad, 0xb0, 0x81, 0xac, 0xf5, 0x29, 0x3a, 0x6b, 0x97, 0x4b, 0x5c,
 0xfc, 0x1f, 0xb9, 0x75, 0xe4, 0x9f, 0xba, 0xc2, 0x71, 0x9e, 0xf1, 0xaf, 0x77, 0x7f, 0x4e, 0xd2,
 0x9e, 0xf9, 0xfc, 0x97, 0x73, 0x7a, 0xd2, 0x84, 0xee, 0x67, 0xb6, 0x3f, 0xf8, 0x68, 0xeb, 0x39,
 0xbb, 0x71, 0x4e, 0x94, 0x0c, 0x2a, 0xb6, 0x9a, 0x6d, 0x55, 0x5a, 0xcb, 0x82, 0x95, 0x8c, 0x10,
 0xd6, 0xd2, 0x10, 0x0a, 0x8b, 0x99, 0xa5, 0xe3, 0x4f, 0xe0, 0x98, 0xed, 0xa8, 0xf9, 0x9f, 0x71,
 0x7f, 0xfb, 0x90, 0xd3, 0x93, 0x4b, 0x22, 0xa6, 0xb1, 0x85, 0x0f, 0x0c, 0x8c, 0xad, 0x67, 0xee,
 0x50, 0x5c, 0xcc, 0x74, 0x99, 0x6c, 0xb1, 0x89, 0x74, 0x12, 0x21, 0x98, 0x4e, 0xe2, 0xde, 0xa5,
 0x1f, 0x15, 0x1f, 0x33, 0x1f, 0x3b, 0x61, 0x42, 0xae, 0xa3, 0x75, 0xeb, 0x55, 0xbd, 0xd4, 0xfe,
 0xdd, 0x12, 0xfe, 0x4e, 0xe5, 0xd5, 0x6a, 0x76, 0x74, 0x78, 0x30, 0xea, 0xff, 0x00, 0xee, 0x48,
 0x14, 0xd8, 0x89, 0x4d, 0xe0, 0x58, 0xa9, 0xb1, 0x12, 0x9b, 0x1f, 0x6c, 0xa6, 0x70, 0x94, 0xca,
 0xe5, 0x36, 0x22, 0x53, 0x78, 0x16, 0x2a, 0x6f, 0x02, 0x25, 0xb6, 0x28, 0xa6, 0x51, 0x4c, 0xe9,
 0x0c, 0xc6, 0x70, 0xde, 0x37, 0x98, 0x8c, 0xc8, 0x51, 0x66, 0x30, 0xbb, 0xd6, 0x5e, 0xb1, 0xb8,
 0xcc, 0x6a, 0x3c, 0xe2, 0x7c, 0x44, 0x3f, 0x9a, 0x94, 0x8d, 0x18, 0xd5, 0x1c, 0x18, 0x8c, 0xc8,
 0xdf, 0x87, 0x8d, 0xde, 0x5b, 0xc2, 0x6b, 0x11, 0xc9, 0xf3, 0x89, 0xf1, 0x10, 0xde, 0x62, 0x39,
 0x3b, 0xbf, 0x08, 0x9f, 0x11, 0x0c, 0xd4, 0x8b, 0xc6, 0xb1, 0xe7, 0xcd, 0x76, 0x7b, 0x5a, 0xd6,
 0x76, 0xae, 0x73, 0x07, 0xcf, 0xfc, 0x66, 0x3b, 0xff, 0x00, 0x93, 0x6c, 0x57, 0x53, 0xd1, 0xd1,
 0x22, 0xb4, 0xfe, 0x5c, 0xf1, 0xfc, 0xc8, 0x1e, 0x7c, 0xd6, 0x2a, 0xda, 0xd5, 0x73, 0x65, 0x16,
 0xfa, 0xc6, 0xba, 0x7f, 0xe3, 0x31, 0xda, 0x7a, 0x07, 0x8a, 0x4b, 0x3a, 0x18, 0x90, 0x6b, 0x22,
 0xfe, 0x58, 0xe9, 0xf1, 0xc2, 0x47, 0xd0, 0x5f, 0xbc, 0x5b, 0x2f, 0x91, 0xf4, 0xd7, 0xb2, 0xdb,
 0x6e, 0x9f, 0x91, 0xdc, 0x61, 0xe3, 0xf8, 0x76, 0x85, 0x94, 0x34, 0xc3, 0x87, 0x68, 0x22, 0xb1,
 0x1e, 0x9d, 0xdf, 0x84, 0x4f, 0xac, 0x58, 0x43, 0xcc, 0x13, 0xbb, 0xf0, 0x89, 0xf5, 0x8e, 0x2a,
 0x99, 0xc9, 0x85, 0x61, 0xf6, 0x16, 0x63, 0xc3, 0xb4, 0x3c, 0x83, 0xe5, 0x5c, 0xef, 0x5f, 0xd3,
 0x24, 0x73, 0x95, 0xad, 0x61, 0x21, 0x7f, 0xca, 0x48, 0xf4, 0x94, 0x3c, 0xc1, 0x3b, 0xbf, 0x08,
 0x5e, 0xb1, 0xe6, 0x0f, 0x29, 0x27, 0x3a, 0xee, 0x95, 0x23, 0x1c, 0x23, 0x23, 0xac, 0x34, 0x3f,
 0x7f, 0xf5, 0x64, 0x3a, 0x5a, 0x74, 0xb3, 0x55, 0xf9, 0x1d, 0x4b, 0x1a, 0xbb, 0xa7, 0x83, 0xb5,
 0x79, 0x06, 0x46, 0x5a, 0x48, 0x75, 0x4d, 0x0e, 0x86, 0xa8, 0xb8, 0x6f, 0x99, 0x0e, 0x0f, 0x56,
 0x40, 0x4f, 0x0e, 0x84, 0x95, 0x28, 0x94, 0x5c, 0x8c, 0x78, 0xdb, 0xc8, 0xda, 0x28, 0xa1, 0xe4,
 0x9a, 0x88, 0xb6, 0x88, 0xab, 0x15, 0x0f, 0xdf, 0xfa, 0x0b, 0x1e, 0x8a, 0x85, 0x99, 0x96, 0xee,
 0xd9, 0x7a, 0xc2, 0xea, 0x78, 0xac, 0xcb, 0xce, 0xbe, 0xda, 0x8d, 0x1c, 0x0f, 0xfd, 0x20, 0xda,
 0x9e, 0x26, 0x2f, 0x54, 0x69, 0xdd, 0x32, 0xca, 0x94, 0xdc, 0x03, 0x10, 0x27, 0x1e, 0xb4, 0x11,
 0xf6, 0x56, 0xf2, 0xd6, 0xa4, 0x11, 0x9f, 0xf6, 0x52, 0x8a, 0x17, 0x2d, 0xa3, 0xe6, 0x13, 0x7c,
 0x8e, 0xfa, 0x38, 0xd3, 0xbd, 0x21, 0x6b, 0x49, 0xa9, 0x6a, 0x26, 0xca, 0x2d, 0x99, 0x5c, 0x1a,
 0x62, 0x1a, 0x82, 0x35, 0x9a, 0x52, 0xf2, 0x94, 0xb2, 0x4d, 0x55, 0x4d, 0xe6, 0x94, 0xf2, 0xef,
 0x33, 0x2a, 0xee, 0xdc, 0x7d, 0x27, 0xca, 0xc3, 0x42, 0x47, 0xeb, 0x29, 0x4c, 0x06, 0xa4, 0x91,
 0x32, 0x71, 0x73, 0x19, 0x5b, 0x6a, 0x69, 0xf8, 0x66, 0xf7, 0xad, 0xd6, 0x0c, 0xf6, 0xaa, 0x92,
 0xef, 0x52, 0x4e, 0xbb, 0xb8, 0x99, 0x28, 0xe9, 0xc0, 0x79, 0x7f, 0x48, 0x6a, 0x6d, 0x45, 0xa2,
 0xb5, 0x1b, 0x53, 0xbd, 0x3b, 0x32, 0x88, 0x95, 0xcc, 0xe1, 0x8c, 0xd2, 0x4e, 0x23, 0x71, 0xd0,
 0xf7, 0x29, 0x2a, 0x49, 0xee, 0x51, 0x1f, 0x7a, 0x4c, 0x8c, 0x87, 0x46, 0xde, 0x6a, 0x74, 0x96,
 0xd7, 0xcc, 0xbc, 0x71, 0x52, 0x18, 0x5c, 0x8f, 0xd1, 0xb8, 0x7d, 0x2b, 0x23, 0xd2, 0xf0, 0x8a,
 0x5c, 0x04, 0xb2, 0x5d, 0x29, 0x83, 0x87, 0x49, 0xb8, 0xe2, 0x98, 0x61, 0x0c, 0xa5, 0x08, 0x4e,
 0xf5, 0x28, 0xcc, 0x88, 0xb7, 0x11, 0x11, 0x9d, 0x4c, 0x7e, 0x6d, 0x6a, 0x78, 0xb6, 0xa6, 0x1a,
 0x96, 0x67, 0x1e, 0xc9, 0x99, 0xb5, 0x13, 0x18, 0xeb, 0xc8, 0x33, 0xf8, 0xaa, 0x59, 0x99, 0x7c,
 0xc6, 0x3a, 0x7c, 0xd7, 0xa4, 0xbe, 0x9a, 0xba, 0x67, 0x71, 0xbd, 0x24, 0x98, 0xf8, 0xb9, 0x9b,
 0x6f, 0x99, 0x12, 0xe0, 0xa0, 0x21, 0x90, 0xc3, 0x6b, 0xcb, 0xa6, 0x82, 0x22, 0xd9, 0x2e, 0x3d,
 0xb3, 0xd9, 0x20, 0x89, 0xd2, 0x6e, 0x8d, 0x99, 0xe8, 0x1d, 0x67, 0x19, 0xa5, 0xe6, 0xce, 0x32,
 0xec, 0x54, 0x2a, 0x5b, 0x52, 0x9c, 0x64, 0xcc, 0xdb, 0x59, 0x2d, 0x09, 0x59, 0x1a, 0x4c, 0xe9,
 0x52, 0xed, 0x52, 0xb8, 0x31, 0x78, 0xc9, 0xf4, 0x93, 0xe6, 0x6b, 0x5a, 0x58, 0xc6, 0xda, 0x72,
 0x9a, 0x79, 0x6c, 0xf5, 0xf7, 0x40, 0xd0, 0x64, 0xef, 0x43, 0x1a, 0x61, 0xc2, 0x2a, 0xd6, 0x11,
 0x5f, 0xe6, 0xac, 0x70, 0x3f, 0x2b, 0xe6, 0x7a, 0x8e, 0x91, 0xe5, 0xe8, 0xa5, 0x2b, 0x2a, 0x6c,
 0xff, 0x00, 0x7a, 0xe0, 0xf4, 0x2f, 0x92, 0x0c, 0x5b, 0x33, 0xee, 0x83, 0xa0, 0x61, 0xda, 0x5a,
 0x57, 0x11, 0x2a, 0x89, 0x7a, 0x11, 0xf4, 0x57, 0x7a, 0x6a, 0xa3, 0x71, 0x07, 0xe8, 0x34, 0xaf,
 0xe6, 0x31, 0xc3, 0x3c, 0xb7, 0xe1, 0xce, 0x1f, 0xa5, 0x59, 0x6b, 0x66, 0x54, 0x3f, 0x61, 0x9a,
 0x3f, 0xde, 0xba, 0x2c, 0xea, 0xe6, 0x3b, 0x4e, 0x0d, 0x86, 0x9e, 0xe8, 0xea, 0xb3, 0xaa, 0xd7,
 0x5d, 0xdf, 0x56, 0x41, 0xe4, 0x92, 0xd7, 0x5b, 0x35, 0xd4, 0x25, 0x4a, 0xd2, 0x15, 0x9f, 0xae,
 0x63, 0xbd, 0xc4, 0xc2, 0x76, 0x15, 0xbb, 0xb8, 0xfe, 0x81, 0xc5, 0xbc, 0x8a, 0xd8, 0x27, 0xe7,
 0x3a, 0x98, 0x8e, 0x9b, 0xa0, 0xd8, 0x3f, 0xde, 0x18, 0xf4, 0x64, 0x64, 0x01, 0x12, 0x17, 0xc3,
 0xdc, 0x9f, 0xd0, 0x37, 0x2d, 0xeb, 0x6d, 0x8e, 0x0f, 0x9c, 0xf4, 0x9e, 0x8c, 0xff, 0x00, 0xc8,
 0xca, 0x71, 0xe9, 0xcb, 0xec, 0x8f, 0xcf, 0x17, 0x3f, 0x1a, 0xaf, 0xed, 0x18, 0xf5, 0x87, 0x46,
 0xd0, 0xdb, 0x5d, 0x1d, 0xc8, 0x15, 0x4e, 0x30, 0x0d, 0x98, 0xf2, 0x7b, 0x85, 0xf8, 0x65, 0x70,
 0xf7, 0x47, 0xf4, 0x8f, 0x64, 0xf4, 0x59, 0x0e, 0x4a, 0xe8, 0xc7, 0x4d, 0xab, 0x76, 0xf9, 0x73,
 0x67, 0xf4, 0x8f, 0x2c, 0x27, 0xb2, 0x6c, 0xfa, 0x0f, 0x4c, 0x27, 0xb2, 0xda, 0x9f, 0xfc, 0xbf,
 0x86, 0x73, 0x4f, 0x28, 0xe6, 0x3a, 0xbd, 0x15, 0x0a, 0xaa, 0x7f, 0x48, 0x20, 0xbf, 0xc0, 0xb1,
 0xc9, 0xfa, 0x27, 0x4e, 0xdf, 0x48, 0x72, 0x74, 0xf3, 0x78, 0xfe, 0xa2, 0x87, 0x6a, 0xf2, 0xa1,
 0x64, 0x9b, 0xd0, 0x50, 0x66, 0x54, 0xff, 0x00, 0x79, 0x20, 0xb8, 0xff, 0x00, 0x56, 0xe0, 0xe3,
 0x7d, 0x0d, 0x27, 0x6b, 0xa4, 0xd9, 0x1a, 0x4e, 0x9b, 0xdf, 0x3e, 0xff, 0x00, 0xd0, 0x50, 0xca,
 0xbc, 0xf3, 0x73, 0x17, 0xe4, 0x53, 0x45, 0x9e, 0xed, 0x1a, 0x6f, 0xe1, 0x23, 0xb3, 0xf4, 0x83,
 0x28, 0x5c, 0x7e, 0x8d, 0x9a, 0x43, 0x34, 0x83, 0x53, 0x87, 0x0e, 0x6b, 0x41, 0x17, 0x79, 0xa4,
 0xc9, 0x54, 0xf9, 0x87, 0x9b, 0xa1, 0x9c, 0x4b, 0x51, 0x0d, 0xb8, 0xa4, 0x12, 0xd2, 0x95, 0x92,
 0x8d, 0x27, 0xc0, 0xc8, 0x8f, 0x80, 0xf6, 0x4b, 0xb0, 0xc9, 0xa7, 0x14, 0x8f, 0x3d, 0xf4, 0xab,
 0xd1, 0xcc, 0x74, 0x9e, 0x60, 0xfc, 0xd6, 0x4f, 0x0c, 0xa8, 0x89, 0x5b, 0xaa, 0x35, 0x9a, 0x1a,
 0x2d, 0xa5, 0x43, 0x99, 0xf1, 0x23, 0x22, 0xdf, 0xb3, 0xc8, 0xfb, 0xb8, 0x18, 0xda, 0xd4, 0xa1,
 0x2a, 0x98, 0xa9, 0x1f, 0x03, 0x53, 0xd1, 0x9d, 0x4a, 0x94, 0x77, 0x5b, 0xd4, 0x78, 0xcf, 0x35,
 0xfd, 0x0f, 0x70, 0xb2, 0x5d, 0x3b, 0x1b, 0x06, 0xd4, 0x64, 0x34, 0xa6, 0x5a, 0xe3, 0x0f, 0xa0,
 0x96, 0xda, 0x93, 0x0e, 0x8a, 0x19, 0x1f, 0xc8, 0x29, 0xb5, 0x4a, 0xf4, 0x96, 0x9d, 0x4c, 0x39,
 0xc7, 0xc9, 0xa1, 0x14, 0x6f, 0xa8, 0xc9, 0x29, 0x6a, 0x15, 0x06, 0x64, 0x45, 0xc4, 0xe8, 0x74,
 0xdd, 0xdc, 0x39, 0x64, 0x93, 0x53, 0xcf, 0xa4, 0xac, 0xa9, 0x89, 0x6c, 0xc5, 0xd6, 0x5a, 0x33,
 0xa9, 0xb6, 0x74, 0x52, 0x6b, 0xce, 0x8a, 0x23, 0x22, 0x1a, 0xf1, 0x91, 0x53, 0x69, 0xfc, 0xc8,
 0x97, 0x10, 0xe4, 0x44, 0x74, 0x5b, 0x94, 0x4a, 0x48, 0x8b, 0x69, 0x5e, 0x82, 0x22, 0xe0, 0x5e,
 0x81, 0xec, 0xb5, 0x48, 0x3a, 0x78, 0x84, 0x3d, 0xaf, 0x25, 0x83, 0xa7, 0x4b, 0x46, 0xad, 0x1a,
 0xad, 0xd4, 0xaa, 0xf6, 0x79, 0xbc, 0x9d, 0x5a, 0x43, 0x30, 0xd1, 0x73, 0x28, 0xe6, 0x9a, 0x96,
 0x43, 0x42, 0x22, 0x2e, 0xbb, 0x4d, 0xa6, 0xcf, 0x61, 0x64, 0x64, 0x55, 0xa9, 0x1d, 0x29, 0xf3,
 0x86, 0x55, 0xb6, 0x17, 0x3a, 0x35, 0xd1, 0xce, 0x48, 0xa1, 0xd7, 0x30, 0x98, 0x92, 0x0a, 0x3d,
 0xf4, 0xec, 0x93, 0x7b, 0x44, 0x7d, 0x4a, 0x39, 0x7f, 0x68, 0xfb, 0xf9, 0x70, 0x0d, 0xcb, 0x4a,
 0x7e, 0x32, 0x7d, 0x63, 0xb9, 0x63, 0x3a, 0x8e, 0x96, 0x66, 0x92, 0x6f, 0xb7, 0x23, 0x81, 0x7f,
 0x3a, 0x4a, 0xb3, 0x8d, 0x29, 0x39, 0x25, 0xe2, 0xde, 0x7f, 0x6f, 0x81, 0x5e, 0xb6, 0xc4, 0x4b,
 0x6f, 0x02, 0xc1, 0x69, 0x4f, 0xc6, 0x4f, 0xac, 0x6a, 0xc7, 0xba, 0xd4, 0x2c, 0x23, 0xf1, 0x2b,
 0x52, 0x76, 0x59, 0x6d, 0x4e, 0x1e, 0xf2, 0xe0, 0x45, 0x5f, 0xe0, 0x37, 0xb8, 0x98, 0x59, 0x66,
 0xbc, 0x25, 0x97, 0x84, 0x73, 0xce, 0x92, 0x75, 0x01, 0xc3, 0x1a, 0xa4, 0xd0, 0x4b, 0xa3, 0x86,
 0x5f, 0xca, 0x16, 0x47, 0xbd, 0x24, 0x7e, 0xf0, 0xbd, 0x25, 0xc4, 0x24, 0x49, 0x25, 0xce, 0xcd,
 0x66, 0x2d, 0xc1, 0xb4, 0xb4, 0x23, 0x6b, 0x7a, 0x96, 0xb3, 0xa1, 0x21, 0x25, 0xc4, 0xc6, 0xbc,
 0x6c, 0x43, 0xb1, 0x71, 0x6e, 0xc5, 0x3c, 0xad, 0xa7, 0x1d, 0x59, 0xad, 0x47, 0x5e, 0xf3, 0x3a,
 0x88, 0xbd, 0x43, 0xe1, 0xee, 0xae, 0xdd, 0xcd, 0x7e, 0x24, 0xf9, 0xae, 0xdf, 0x03, 0xf4, 0x0b,
 0x5b, 0x55, 0x6f, 0x47, 0x87, 0x0e, 0xbd, 0xfe, 0x27, 0x62, 0x95, 0x40, 0x4b, 0xa5, 0x70, 0x49,
 0x85, 0x85, 0x71, 0xa2, 0x22, 0xde, 0xa5, 0x1a, 0xcb, 0x69, 0x67, 0xcc, 0xc4, 0xe6, 0xa6, 0x4c,
 0xe9, 0xd7, 0x35, 0xe3, 0x21, 0xc5, 0xbd, 0x43, 0x62, 0x59, 0xfe, 0xf1, 0x86, 0xe1, 0xf8, 0xe4,
 0x7d, 0x62, 0x1d, 0x8a, 0x3e, 0x90, 0x6c, 0x4a, 0x11, 0xa7, 0x85, 0xe7, 0xf8, 0x39, 0x93, 0xd1,
 0x9b, 0x6e, 0x72, 0xa9, 0x97, 0xe5, 0xf9, 0x3b, 0x02, 0xdb, 0x11, 0x29, 0xb1, 0x62, 0xea, 0x51,
 0xb4, 0x7d, 0xa4, 0x71, 0x3f, 0x7c, 0x42, 0x15, 0xa5, 0x1f, 0x1d, 0x3e, 0xb2, 0x1f, 0x58, 0xa4,
 0x7c, 0xf2, 0x99, 0x5e, 0xb6, 0xf0, 0x22, 0x53, 0x62, 0xc1, 0x69, 0x47, 0xc6, 0x47, 0xac, 0x84,
 0x4b, 0x4a, 0x3e, 0x3a, 0x7d, 0x64, 0x28, 0xa6, 0x51, 0x4c, 0xfd, 0x11, 0xf6, 0xa9, 0xa3, 0xff,
 0x00, 0x36, 0x24, 0x7f, 0xdd, 0xed, 0x7d, 0xd1, 0x9f, 0x6a, 0xda, 0x44, 0xb8, 0x69, 0x99, 0x27,
 0xec, 0x0d, 0x7d, 0xd1, 0xf1, 0x7b, 0x90, 0x5e, 0xe4, 0x7e, 0x4f, 0xc3, 0x8f, 0x63, 0xee, 0x38,
 0x70, 0xec, 0x89, 0x0b, 0x4c, 0x69, 0x2e, 0xed, 0x35, 0x25, 0xfd, 0x81, 0xaf, 0xba, 0x3e, 0x8b,
 0x4d, 0x69, 0x42, 0xe1, 0xa7, 0x24, 0xc5, 0xfa, 0x8b, 0x5f, 0x74, 0x43, 0x7b, 0x90, 0x5e, 0xe4,
 0x38, 0x71, 0xec, 0x38, 0x70, 0xec, 0x73, 0x19, 0xdc, 0xa2, 0x44, 0x89, 0xcc, 0x6a, 0x51, 0x27,
 0x96, 0x92, 0x4a, 0x21, 0x64, 0x44, 0x50, 0x8d, 0xf0, 0xda, 0x3c, 0x07, 0x5e, 0x8f, 0xe4, 0x7a,
 0x75, 0xc9, 0x06, 0xdb, 0x92, 0x39, 0x5a, 0xd5, 0xd7, 0xac, 0xaa, 0x70, 0x6d, 0xd7, 0xbb, 0x01,
 0x0a, 0x79, 0x15, 0x59, 0xd4, 0x76, 0xff, 0x00, 0xe7, 0x0b, 0xfa, 0xc6, 0x1d, 0x7a, 0x3f, 0x8c,
 0xd9, 0xd3, 0xf4, 0xaf, 0xc3, 0xaf, 0xf8, 0x0f, 0x76, 0xc7, 0xb1, 0xee, 0xc8, 0xf6, 0x1a, 0xca,
 0x43, 0xa6, 0xcb, 0x84, 0x86, 0x55, 0xfb, 0x1b, 0x7f, 0x60, 0xcf, 0xb0, 0x7a, 0x74, 0xb8, 0x49,
 0x25, 0x85, 0xfa, 0xa3, 0x7f, 0x60, 0xd4, 0xbd, 0xc8, 0x2f, 0x72, 0x1b, 0x23, 0xd8, 0x6c, 0x8f,
 0x63, 0x70, 0xa4, 0xda, 0x7c, 0xb8, 0x49, 0xa5, 0xbf, 0xb2, 0xa3, 0xec, 0x1c, 0xc7, 0xa4, 0x2d,
 0x3f, 0xa6, 0x5c, 0xd5, 0x0f, 0x2d, 0xcd, 0x3f, 0x27, 0x71, 0x5d, 0x5b, 0x7d, 0xa5, 0xc0, 0xb4,
 0xa3, 0xf7, 0x3c, 0xcd, 0x23, 0xa1, 0x5e, 0xe4, 0x73, 0xad, 0x77, 0x15, 0x5d, 0x48, 0xf1, 0xd7,
 0xe0, 0xdb, 0xfa, 0xa0, 0xa2, 0x97, 0x44, 0x7a, 0xa2, 0x97, 0x44, 0x30, 0x74, 0x55, 0x24, 0xd3,
 0xcc, 0x42, 0xcc, 0x09, 0x99, 0x24, 0xad, 0x92, 0x37, 0x51, 0x52, 0x6e, 0x0d, 0xb4, 0xd7, 0xb2,
 0x7c, 0x88, 0x3b, 0x14, 0xba, 0x4e, 0x5c, 0x25, 0x90, 0x45, 0xfa, 0xba, 0x3e, 0xc0, 0x83, 0xd1,
 0xb4, 0x5d, 0x21, 0x63, 0x8a, 0xbf, 0x08, 0x8f, 0xa0, 0xc3, 0x6d, 0xee, 0x41, 0xc5, 0x3f, 0x01,
 0xb5, 0x15, 0xfa, 0xda, 0x36, 0x5f, 0x2b, 0x87, 0x6e, 0x1e, 0x0e, 0x06, 0x0d, 0x11, 0x2f, 0x11,
 0x9e, 0xd9, 0x30, 0x9a, 0xa1, 0x25, 0xde, 0x5b, 0xb8, 0xd4, 0x73, 0x55, 0xe9, 0xe9, 0x1c, 0xce,
 0x3d, 0x4b, 0x73, 0x4f, 0x4b, 0x23, 0x62, 0xdf, 0x55, 0x54, 0xa5, 0xc0, 0xb4, 0xe3, 0x8e, 0x1f,
 0x33, 0x33, 0x4d, 0x4c, 0xf2, 0x61, 0x8b, 0xa4, 0x77, 0x57, 0xec, 0x84, 0x34, 0x46, 0xfe, 0xad,
 0x4d, 0x6c, 0x11, 0xe4, 0x8c, 0xce, 0x9f, 0x38, 0xd6, 0xd0, 0x73, 0x68, 0x38, 0x39, 0x9b, 0xd7,
 0x4e, 0x25, 0xb3, 0x71, 0xbd, 0x96, 0xd6, 0xa3, 0xa1, 0x11, 0xd7, 0x79, 0x57, 0xba, 0xbf, 0xc0,
 0x7a, 0x92, 0x5d, 0x02, 0x49, 0x04, 0xb6, 0x54, 0xf6, 0x91, 0xab, 0xb0, 0x52, 0x58, 0x79, 0x63,
 0x6e, 0x19, 0x1b, 0x84, 0xd4, 0x22, 0x10, 0xdb, 0x87, 0xdc, 0x4a, 0x24, 0x95, 0x0f, 0xe5, 0xde,
 0x34, 0x35, 0x34, 0x34, 0x8f, 0x50, 0x4d, 0xdc, 0x99, 0xcc, 0x24, 0x32, 0xa7, 0x9e, 0x5a, 0x52,
 0x82, 0x37, 0x61, 0x1b, 0x70, 0xc9, 0x29, 0x2a, 0x11, 0x55, 0x49, 0xad, 0x38, 0xfa, 0xc7, 0x4d,
 0x5c, 0x4b, 0x31, 0x2c, 0x29, 0xb5, 0xec, 0x3a, 0xcb, 0x85, 0xb2, 0xa2, 0xe2, 0x46, 0x46, 0x39,
 0x24, 0x4b, 0xc4, 0xd4, 0x4b, 0xad, 0x11, 0xee, 0x43, 0x8a, 0x49, 0x7c, 0x87, 0x40, 0xc2, 0xea,
 0x7a, 0x74, 0xfe, 0x8b, 0xe4, 0xb2, 0x69, 0x46, 0x9d, 0x37, 0x20, 0x25, 0x90, 0x30, 0x67, 0x18,
 0xe1, 0xb8, 0xe1, 0x43, 0xc3, 0xa1, 0xbd, 0xaa, 0x76, 0x53, 0x5d, 0x92, 0x2a, 0xd0, 0xab, 0xeb,
 0x0b, 0x5d, 0x2b, 0x4a, 0x24, 0x51, 0xda, 0x85, 0x87, 0x63, 0x64, 0xf2, 0xd8, 0xa7, 0x0a, 0x15,
 0x29, 0x25, 0xbf, 0x08, 0xdb, 0x8a, 0x22, 0xda, 0x56, 0xea, 0xa8, 0x8c, 0xe8, 0x2f, 0xf4, 0x8c,
 0x66, 0xce, 0x9b, 0x81, 0x2a, 0xfc, 0x19, 0xfd, 0x63, 0x0a, 0xfd, 0x22, 0x45, 0x56, 0x74, 0xce,
 0xff, 0x00, 0xe6, 0xe5, 0xf5, 0x94, 0x3d, 0x18, 0x2c, 0x7a, 0x26, 0x94, 0x48, 0xa0, 0xe3, 0xa6,
 0x0a, 0x84, 0x93, 0x4b, 0x61, 0x8d, 0x4d, 0x20, 0x94, 0x6c, 0xc2, 0x36, 0x8d, 0xa2, 0xda, 0x3e,
 0x3b, 0x24, 0x55, 0x1d, 0x01, 0x50, 0x92, 0xc3, 0x49, 0xd6, 0x06, 0x14, 0xf7, 0x79, 0x94, 0xfd,
 0x83, 0x9a, 0xf4, 0x6d, 0x17, 0xb3, 0x17, 0x1b, 0xbf, 0xe0, 0x91, 0xf5, 0x8c, 0x3a, 0x9c, 0x6f,
 0x64, 0xf7, 0xf7, 0x01, 0x83, 0xa7, 0x19, 0x3c, 0xb4, 0x71, 0xf3, 0xd3, 0x9a, 0x5b, 0x68, 0xff,
 0x00, 0xd9, 0xb9, 0x27, 0x1f, 0xf8, 0x7b, 0x3f, 0x74, 0x75, 0xed, 0x27, 0x2a, 0x92, 0x23, 0x4c,
 0xcb, 0x50, 0x89, 0x54, 0x02, 0x10, 0x98, 0x74, 0x92, 0x52, 0x98, 0x64, 0x11, 0x11, 0x72, 0x22,
 0xa6, 0xe1, 0xc8, 0x4e, 0x27, 0xb4, 0x7b, 0xfb, 0xc7, 0x51, 0xd3, 0x51, 0x94, 0xd3, 0xd0, 0x05,
 0x5f, 0x80, 0x48, 0x64, 0xf6, 0x50, 0x8c, 0xf9, 0x49, 0x64, 0xd4, 0xe9, 0x3e, 0x4d, 0xa7, 0xdf,
 0x90, 0xb2, 0x87, 0xa4, 0xb2, 0xc7, 0x53, 0x72, 0x93, 0xd9, 0x72, 0x11, 0xb5, 0x15, 0x76, 0x55,
 0xdc, 0x64, 0x13, 0xf4, 0x66, 0x9e, 0xd3, 0x2d, 0xea, 0x99, 0x7a, 0x9b, 0xd3, 0xd2, 0x74, 0x28,
 0x9d, 0x3a, 0x29, 0x30, 0x0d, 0x11, 0x97, 0x64, 0xfb, 0xc9, 0x21, 0x9b, 0xa4, 0x48, 0xbd, 0xa9,
 0x2b, 0x3b, 0xff, 0x00, 0x9c, 0x17, 0xd5, 0x50, 0x57, 0xd2, 0x31, 0x54, 0xd4, 0x90, 0x27, 0x5f,
 0x84, 0xff, 0x00, 0xda, 0x61, 0x90, 0xa1, 0x14, 0xb6, 0xa5, 0xc8, 0xeb, 0x5e, 0xc3, 0xc8, 0x4f,
 0xfa, 0x1e, 0x5d, 0xfb, 0x2a, 0x3e, 0xc0, 0x87, 0xaa, 0xe3, 0xe5, 0x0a, 0x8a, 0x5c, 0x1c, 0xb2,
 0x57, 0x2e, 0x69, 0xa6, 0xcc, 0xd2, 0xb7, 0x91, 0x0a, 0x8d, 0xa5, 0x9f, 0x7d, 0x0e, 0x9b, 0x8b,
 0xe9, 0x0c, 0x13, 0xf9, 0xaa, 0xa1, 0x24, 0xb1, 0x71, 0x08, 0x55, 0x16, 0x96, 0x8c, 0x92, 0x79,
 0x3d, 0xc5, 0xf4, 0x8e, 0x5c, 0xd3, 0xdb, 0x6e, 0x25, 0xb2, 0x55, 0x0d, 0x4a, 0x24, 0xd7, 0xd2,
 0x74, 0x19, 0x6e, 0x97, 0x73, 0x0e, 0x05, 0x3f, 0xd2, 0xbf, 0x63, 0x62, 0x1f, 0x48, 0x49, 0x66,
 0x0b, 0x5a, 0xd8, 0xd2, 0x72, 0xc8, 0xa5, 0x56, 0xab, 0x52, 0x65, 0xad, 0x2b, 0x7e, 0x4f, 0x67,
 0x88, 0xcc, 0x3c, 0x8e, 0x4f, 0x28, 0x8c, 0x35, 0x31, 0x20, 0x96, 0xc1, 0x44, 0x27, 0x72, 0xb6,
 0x60, 0x1a, 0x42, 0xbd, 0x07, 0xd9, 0xde, 0x43, 0xa7, 0x40, 0xc4, 0x42, 0x41, 0x42, 0x37, 0x0a,
 0xc3, 0x8d, 0x25, 0xb6, 0xca, 0x84, 0x44, 0xb2, 0xdf, 0x9f, 0x49, 0x8a, 0xfd, 0x43, 0x09, 0x03,
 0x39, 0x36, 0x54, 0xec, 0x5a, 0x59, 0x5b, 0x55, 0x2d, 0xb4, 0x9a, 0x4c, 0xcd, 0x27, 0xdd, 0xbc,
 0xf9, 0x8f, 0x33, 0x8e, 0x65, 0x1a, 0x4d, 0x61, 0x9f, 0x7a, 0x40, 0xb4, 0xd4, 0xdd, 0x85, 0x33,
 0x13, 0xa7, 0xe4, 0xe9, 0x8b, 0x68, 0xaa, 0xaa, 0x41, 0x37, 0x45, 0xa7, 0xe3, 0x16, 0xef, 0x59,
 0x0b, 0xef, 0x6b, 0xda, 0x5f, 0xf3, 0x7a, 0x51, 0xfb, 0x13, 0x7f, 0x74, 0x2d, 0xc9, 0xa5, 0x92,
 0xa9, 0x6c, 0x5a, 0x22, 0x21, 0xe2, 0x5c, 0x5b, 0xe4, 0x46, 0x44, 0x6a, 0x78, 0xb7, 0xd7, 0x8e,
 0xe2, 0x17, 0x97, 0xb9, 0x19, 0x71, 0x25, 0xdc, 0xc3, 0x85, 0x4f, 0xf4, 0xa2, 0x7f, 0x6b, 0x9a,
 0x5f, 0xf3, 0x76, 0x4f, 0xfb, 0x0b, 0x7f, 0x74, 0x43, 0x1b, 0xa5, 0x74, 0xac, 0x4c, 0x23, 0xd0,
 0xe7, 0xa7, 0x64, 0xf4, 0x75, 0xb5, 0x23, 0x7c, 0x0b, 0x5d, 0xe5, 0x4f, 0x8a, 0x31, 0x7b, 0x90,
 0x5e, 0xe4, 0x38, 0x92, 0xee, 0x7b, 0xc2, 0x87, 0x64, 0x71, 0xf7, 0x74, 0xc6, 0x99, 0x69, 0xd5,
 0xb4, 0xe6, 0x99, 0x92, 0x92, 0xd0, 0xa3, 0x4a, 0x8b, 0xd8, 0xe6, 0x77, 0x19, 0x6e, 0x3f, 0x7a,
 0x3e, 0x3d, 0xae, 0x69, 0x6f, 0xcd, 0xb9, 0x27, 0xf7, 0x7b, 0x3f, 0x74, 0x37, 0xeb, 0xa8, 0x03,
 0xeb, 0x55, 0x36, 0x86, 0x23, 0x34, 0xab, 0xf1, 0xe9, 0x2e, 0xe3, 0xf8, 0xdf, 0x68, 0x5b, 0x95,
 0x4c, 0xd1, 0x07, 0x1a, 0x87, 0xdd, 0x61, 0xa8, 0x86, 0xcb, 0x72, 0xdb, 0x71, 0x24, 0x64, 0xa2,
 0xf9, 0x78, 0x1e, 0x46, 0x06, 0x66, 0xa7, 0xb5, 0xcd, 0x2d, 0xf9, 0xb7, 0x24, 0xfe, 0xef, 0x67,
 0xee, 0x89, 0xe0, 0x34, 0xe6, 0x95, 0xbe, 0x87, 0xff, 0x00, 0x66, 0xe4, 0x9f, 0x8d, 0x47, 0xf4,
 0x7b, 0x3f, 0x18, 0xbf, 0x44, 0x74, 0x88, 0x05, 0x48, 0xe3, 0xa1, 0x51, 0x13, 0x0d, 0x05, 0x06,
 0xb6, 0xd5, 0xfd, 0x4a, 0x6a, 0x47, 0xc8, 0xca, 0x9b, 0x8c, 0x6c, 0x26, 0x1e, 0x58, 0x95, 0x12,
 0x93, 0x01, 0x08, 0x46, 0x47, 0x52, 0x32, 0x65, 0x3b, 0x8c, 0x01, 0x60, 0x7a, 0x5f, 0x49, 0x54,
 0xeb, 0xa6, 0xa4, 0xbc, 0x7f, 0x20, 0x6b, 0xee, 0x8c, 0x7b, 0x57, 0xd2, 0x3f, 0x9b, 0x32, 0x5f,
 0xd8, 0x1a, 0xfb, 0xa3, 0xe2, 0xf7, 0x20, 0xbd, 0xc8, 0xcf, 0x89, 0x3e, 0xec, 0xc3, 0x87, 0x0e,
 0xc7, 0xdf, 0xb5, 0x6d, 0x23, 0xf9, 0xb1, 0x24, 0xfd, 0x81, 0xaf, 0xba, 0x0f, 0x6a, 0xba, 0x43,
 0xf3, 0x62, 0x47, 0xfd, 0xde, 0xd7, 0xdd, 0x1f, 0x17, 0xb9, 0x05, 0xee, 0x43, 0x8b, 0x3e, 0xec,
 0x70, 0xe1, 0xd8, 0x5d, 0xbc, 0xc8, 0x2f, 0x32, 0x17, 0x2f, 0x32, 0x0b, 0xcc, 0x8c, 0x0c, 0xc6,
 0x3b, 0xcc, 0x82, 0xf3, 0xf4, 0x82, 0xe5, 0xe6, 0x41, 0x79, 0x90, 0x02, 0x9c, 0xe6, 0x2b, 0xfd,
 0x71, 0x18, 0x75, 0xf8, 0x75, 0xfd, 0x26, 0x2f, 0xb4, 0xc6, 0xa7, 0x81, 0x96, 0xca, 0xed, 0xa2,
 0x0d, 0xed, 0xbe, 0xb1, 0x4a, 0xec, 0xa2, 0xa5, 0x43, 0xa6, 0x42, 0x3c, 0xde, 0x2a, 0xb3, 0x58,
 0xbd, 0xff, 0x00, 0x0c, 0xbf, 0xa4, 0xc4, 0xb0, 0x10, 0x31, 0xd1, 0xac, 0x75, 0xf0, 0xe8, 0x42,
 0x91, 0xb4, 0x69, 0xa9, 0xac, 0x8b, 0x79, 0x00, 0x3a, 0x3f, 0xb7, 0x69, 0x57, 0x38, 0x9f, 0xf9,
 0x5f, 0xf5, 0x12, 0x42, 0xeb, 0x09, 0x6c, 0x4c, 0x4b, 0x70, 0xed, 0x9b, 0xfb, 0x6e, 0x28, 0x92,
 0x9a, 0xb7, 0x42, 0xa9, 0xfc, 0xa3, 0x9d, 0xfb, 0x0d, 0x35, 0xf3, 0x4d, 0xff, 0x00, 0xcd, 0x21,
 0xb3, 0x2b, 0x96, 0x4c, 0xa1, 0xe6, 0x50, 0xcf, 0xb8, 0xdb, 0x64, 0x86, 0xdc, 0x25, 0x28, 0xc9,
 0xc2, 0x3d, 0xc4, 0x00, 0xea, 0x97, 0x99, 0x1c, 0xff, 0x00, 0x5a, 0xc5, 0x57, 0x50, 0x3a, 0x75,
 0xf8, 0x34, 0x7d, 0x02, 0xf6, 0xf3, 0x21, 0x1b, 0x58, 0x45, 0x56, 0x7a, 0xe9, 0xd7, 0xde, 0x23,
 0xe8, 0x00, 0x37, 0xf4, 0x7b, 0x1c, 0x49, 0xbd, 0x6b, 0x6b, 0x79, 0xec, 0x2b, 0xe9, 0x20, 0xdb,
 0x79, 0x91, 0xc6, 0x25, 0x13, 0x87, 0xa5, 0xb1, 0x65, 0x12, 0xd1, 0x12, 0x88, 0xc8, 0xd2, 0xa4,
 0x9f, 0x05, 0x17, 0x21, 0x7e, 0x8d, 0x68, 0x4e, 0x44, 0xb2, 0x82, 0x86, 0xea, 0xdb, 0x52, 0xc8,
 0x9c, 0x52, 0x97, 0x53, 0x22, 0x3e, 0x40, 0x0e, 0x81, 0x30, 0x28, 0x78, 0xf8, 0x55, 0x43, 0xc5,
 0x27, 0x6d, 0x07, 0xbf, 0x8d, 0x0c, 0x8f, 0x99, 0x1f, 0x71, 0x85, 0x48, 0xdd, 0x34, 0xf2, 0x4c,
 0xce, 0x0e, 0x2d, 0xb7, 0x13, 0xdc, 0x97, 0x0b, 0x64, 0xfd, 0x65, 0xb8, 0x45, 0xa9, 0xa6, 0xb1,
 0xd0, 0x70, 0x49, 0x7e, 0x0d, 0x69, 0x22, 0x25, 0x51, 0xc3, 0x34, 0xd4, 0xc8, 0x8f, 0x81, 0xfa,
 0xfe, 0x90, 0xbf, 0x2b, 0xd5, 0x91, 0x8c, 0xc6, 0xf5, 0x91, 0xaf, 0x38, 0xfb, 0x2a, 0x2a, 0x29,
 0x3b, 0xbb, 0x39, 0x22, 0x00, 0x5a, 0x9c, 0x2c, 0xf6, 0x5c, 0xae, 0xb1, 0xa4, 0x44, 0x22, 0x9e,
 0xf9, 0x85, 0xd4, 0xbe, 0x61, 0x54, 0xe4, 0x5a, 0xd6, 0xe2, 0x96, 0xb5, 0x19, 0xa8, 0xcc, 0xcd,
 0x46, 0x7c, 0x6b, 0xde, 0x2e, 0xdc, 0xd6, 0x32, 0xd4, 0x36, 0x6a, 0x6c, 0xde, 0x71, 0x65, 0xc1,
 0x3b, 0x14, 0xdf, 0xe9, 0x30, 0x96, 0xec, 0x69, 0xb8, 0xea, 0xdd, 0x51, 0xef, 0x5a, 0x8d, 0x47,
 0xf2, 0x9d, 0x40, 0x1d, 0x7b, 0x4b, 0x45, 0xd3, 0x4f, 0x41, 0x15, 0x7e, 0x0f, 0xf8, 0x98, 0x5a,
 0xd7, 0xd1, 0x7b, 0x53, 0x86, 0x8e, 0xbf, 0x00, 0x5f, 0x58, 0xc6, 0xc4, 0x8d, 0xf5, 0x33, 0x27,
 0x84, 0x6d, 0x5b, 0x8c, 0x9a, 0x2a, 0x97, 0xa7, 0x7f, 0xf1, 0x0b, 0x5a, 0xe2, 0x2a, 0xb3, 0x56,
 0x8e, 0xbf, 0x00, 0x5f, 0x49, 0x80, 0x18, 0xba, 0x3d, 0x8c, 0x24, 0xc6, 0xc5, 0xa6, 0xbb, 0xcd,
 0xa4, 0x9f, 0xa9, 0x5f, 0xf5, 0x0e, 0x4a, 0x8c, 0xec, 0x9e, 0xfe, 0xe1, 0xc6, 0x65, 0x13, 0x77,
 0x65, 0xd1, 0x89, 0x8a, 0x6c, 0xb6, 0x93, 0xee, 0x54, 0x93, 0xe0, 0xa2, 0x3e, 0xea, 0x86, 0x38,
 0xbd, 0x67, 0x0a, 0x70, 0x8b, 0x26, 0x1b, 0x7b, 0xae, 0x52, 0x4c, 0x88, 0x94, 0x44, 0x44, 0x46,
 0x7d, 0xf5, 0xa8, 0x02, 0xa8, 0xe2, 0x7b, 0x47, 0xbf, 0xbc, 0x74, 0x8d, 0x35, 0x1c, 0x47, 0x21,
 0x82, 0xa2, 0xb8, 0x34, 0x45, 0xea, 0xdc, 0x38, 0xe9, 0x44, 0xf7, 0x11, 0xd4, 0x5f, 0xe9, 0xed,
 0x4f, 0xec, 0x73, 0x27, 0x07, 0x16, 0x85, 0x9b, 0x69, 0x51, 0x9a, 0x4d, 0x3e, 0xe9, 0x07, 0xde,
 0x46, 0x46, 0x00, 0x72, 0xd7, 0xd1, 0x95, 0x94, 0x34, 0x55, 0xf8, 0x72, 0xfa, 0xa6, 0x16, 0xb4,
 0xb4, 0x55, 0x35, 0x0c, 0x11, 0xd7, 0xe1, 0x3f, 0x81, 0x8a, 0xed, 0x4d, 0xa8, 0x9b, 0x99, 0x13,
 0x4c, 0xb0, 0x95, 0xa5, 0xa6, 0xcc, 0xd4, 0x66, 0xbd, 0xc6, 0xa3, 0xe1, 0xc0, 0x43, 0xa4, 0xdc,
 0x53, 0x93, 0xc6, 0x56, 0x5c, 0x1a, 0x23, 0x5a, 0x8f, 0x96, 0xea, 0x7d, 0x26, 0x00, 0xe9, 0x3a,
 0xb2, 0x28, 0xd7, 0xa7, 0xa2, 0xc8, 0x8f, 0x82, 0x52, 0x7e, 0xa5, 0x10, 0xe7, 0x89, 0x7c, 0xd4,
 0xb2, 0x49, 0x19, 0x54, 0xce, 0x9b, 0xc3, 0x8c, 0x4b, 0xc9, 0x88, 0x87, 0x71, 0x87, 0x0f, 0xb2,
 0xe2, 0x0d, 0x27, 0xf2, 0x90, 0xe7, 0x11, 0x66, 0xec, 0x2c, 0x4a, 0xe1, 0xdd, 0xa9, 0x2d, 0x07,
 0x43, 0xce, 0x40, 0x0e, 0x3e, 0xd7, 0x66, 0x9f, 0xf6, 0x5f, 0xf9, 0x9f, 0xf4, 0x1a, 0xb3, 0x39,
 0x5c, 0x64, 0xba, 0x1a, 0xe2, 0x23, 0xa8, 0xd8, 0xda, 0x24, 0xf6, 0x57, 0x53, 0xa9, 0xfc, 0x83,
 0xea, 0x59, 0xac, 0x61, 0xce, 0x19, 0x28, 0x8d, 0xdb, 0x43, 0xa9, 0x2a, 0x1a, 0x92, 0x9d, 0xa2,
 0x56, 0x70, 0x62, 0xab, 0x52, 0xea, 0x22, 0x99, 0x1a, 0x19, 0x65, 0x2a, 0x4b, 0x0d, 0x9e, 0xd7,
 0x6b, 0x8a, 0x8f, 0x9e, 0x00, 0x16, 0x1a, 0x69, 0xed, 0xb9, 0xf4, 0x11, 0x11, 0x16, 0xe7, 0x49,
 0x5e, 0xad, 0xe3, 0xa4, 0xde, 0x64, 0x73, 0x0d, 0x12, 0x85, 0x1c, 0x42, 0xe3, 0xd6, 0x54, 0x42,
 0x08, 0xd0, 0xd9, 0xf3, 0x33, 0xe2, 0x7f, 0x21, 0x7d, 0x21, 0xb6, 0xf3, 0x20, 0x06, 0x3b, 0xcc,
 0x82, 0xf3, 0x21, 0x72, 0xf3, 0x23, 0x17, 0x99, 0x00, 0x31, 0xaa, 0x2c, 0x94, 0x46, 0x47, 0x43,
 0x23, 0x2a, 0x19, 0x1f, 0x78, 0x47, 0xd5, 0x12, 0xa3, 0x83, 0x52, 0xa2, 0xe0, 0xc8, 0xce, 0x18,
 0xce, 0xaa, 0x41, 0x71, 0x6f, 0xff, 0x00, 0xaf, 0xd0, 0x2d, 0xaf, 0x32, 0x30, 0x71, 0x64, 0x64,
 0x64, 0x66, 0x46, 0x47, 0xb8, 0xc8, 0xc0, 0x0b, 0x32, 0x49, 0xf4, 0x4c, 0xaa, 0x2b, 0xad, 0x69,
 0x5b, 0x4d, 0xab, 0xf1, 0x8d, 0x99, 0xee, 0x51, 0x7f, 0x03, 0xc8, 0xe8, 0x70, 0x13, 0x76, 0x63,
 0x61, 0x51, 0x13, 0x0e, 0xbd, 0xa4, 0x2c, 0xbe, 0x52, 0x3e, 0xf2, 0x3c, 0x8e, 0x5b, 0xaa, 0x20,
 0xd3, 0x02, 0xf1, 0x44, 0x43, 0xee, 0x87, 0x70, 0xe9, 0xb3, 0xf1, 0x15, 0xcb, 0xd1, 0xc8, 0x67,
 0x48, 0x4e, 0x55, 0x0b, 0x30, 0x28, 0x65, 0x2f, 0xf0, 0x51, 0x07, 0x4a, 0x72, 0x57, 0x71, 0xff,
 0x00, 0x00, 0x07, 0x58, 0xbc, 0xc8, 0x2f, 0x32, 0x17, 0x2f, 0x32, 0x0b, 0xcc, 0x80, 0x18, 0xef,
 0x32, 0x0b, 0xcc, 0x85, 0xcb, 0xcc, 0x82, 0xf3, 0x20, 0x05, 0xcb, 0xdc, 0x82, 0xf7, 0x21, 0x76,
 0xf3, 0x23, 0x17, 0xb9, 0x00, 0x31, 0xde, 0xe4, 0x17, 0x99, 0x0b, 0x97, 0xb9, 0x05, 0xee, 0x40,
 0x14, 0x93, 0x48, 0x9f, 0xf5, 0x9c, 0x51, 0xd7, 0xe1, 0x95, 0xf4, 0x98, 0x66, 0xd2, 0x31, 0x94,
 0x94, 0x52, 0xbf, 0x0a, 0xaf, 0xe0, 0x39, 0xf4, 0xca, 0x26, 0xb3, 0x08, 0x83, 0xaf, 0xc2, 0xab,
 0xe9, 0x03, 0x13, 0x58, 0xb6, 0x1b, 0xea, 0xd9, 0x89, 0x71, 0xb4, 0x56, 0xb4, 0x49, 0xd0, 0xaa,
 0x00, 0xeb, 0x37, 0xa5, 0xcc, 0x17, 0xa5, 0xcc, 0x72, 0xaf, 0x67, 0x26, 0x3f, 0x96, 0xbf, 0xe2,
 0x07, 0xb3, 0x93, 0x1f, 0xcb, 0x5f, 0xf1, 0x00, 0x3a, 0xad, 0xee, 0x45, 0x2c, 0xda, 0x5c, 0x51,
 0xf1, 0xaa, 0x89, 0xbb, 0xea, 0xf6, 0x92, 0x45, 0xb3, 0xb1, 0x5e, 0x05, 0xe9, 0x15, 0x52, 0x49,
 0x83, 0x8e, 0xcb, 0x19, 0x5b, 0xae, 0xa9, 0x6b, 0x3a, 0xd5, 0x4a, 0x3d, 0xe7, 0xbc, 0xc6, 0xed,
 0xe6, 0x40, 0x1b, 0x0d, 0xca, 0xd8, 0xf6, 0x35, 0x50, 0x8e, 0xbe, 0x6a, 0x57, 0x58, 0x6b, 0x43,
 0x84, 0x9a, 0x1a, 0x4c, 0xc8, 0x8a, 0x94, 0xe5, 0xb8, 0x68, 0xa6, 0x46, 0xee, 0xdd, 0x17, 0x18,
 0xd9, 0x23, 0x9a, 0x50, 0x75, 0x12, 0xde, 0x64, 0x17, 0xb9, 0x00, 0x5f, 0xf5, 0xe9, 0x38, 0x72,
 0x65, 0xc3, 0xeb, 0x13, 0xb1, 0xb2, 0xad, 0xaf, 0x7c, 0x54, 0xa6, 0xf1, 0x41, 0x19, 0x24, 0x49,
 0xac, 0xd5, 0x09, 0x12, 0x48, 0x23, 0xf7, 0x8e, 0x15, 0x69, 0xf2, 0x90, 0x2f, 0x72, 0x33, 0x79,
 0x90, 0x06, 0xa1, 0x49, 0x63, 0x2b, 0xbd, 0xf8, 0x7a, 0x7a, 0x4f, 0xec, 0x1b, 0xf2, 0xe9, 0x43,
 0x0c, 0xba, 0x97, 0x62, 0x9e, 0xeb, 0xcd, 0x3b, 0xc9, 0x04, 0x54, 0x4f, 0xcb, 0xcc, 0x45, 0x79,
 0x90, 0x5e, 0x64, 0x00, 0xc7, 0x7b, 0x91, 0x51, 0x39, 0x82, 0x29, 0x8c, 0x52, 0x5f, 0xb9, 0xea,
 0xb6, 0x50, 0x49, 0xa6, 0xc5, 0x7b, 0xcc, 0xf9, 0xe4, 0x6a, 0x5e, 0x64, 0x62, 0xf7, 0x20, 0x0d,
 0xc8, 0x09, 0x7b, 0x0c, 0x42, 0x3f, 0x0d, 0x10, 0xe7, 0x5e, 0x87, 0x54, 0x4a, 0xf7, 0x3b, 0x26,
 0x93, 0x22, 0xe2, 0x43, 0x41, 0xf9, 0x1a, 0xb6, 0xcf, 0xa8, 0x8c, 0x4e, 0xc7, 0x71, 0x2d, 0x3b,
 0xcb, 0xd4, 0x24, 0xbc, 0xc8, 0xc5, 0xe6, 0x40, 0x1b, 0x12, 0xb9, 0x5b, 0x10, 0xaf, 0x25, 0xf7,
 0xdd, 0xeb, 0xdc, 0x49, 0xd5, 0x24, 0x45, 0x44, 0x91, 0xf3, 0xc8, 0x9a, 0x6d, 0x01, 0x0d, 0x1e,
 0xb3, 0x79, 0x2b, 0x36, 0x5e, 0x3e, 0x2a, 0x22, 0xa9, 0x2b, 0xd2, 0x5f, 0xc4, 0x69, 0x5e, 0xe4,
 0x17, 0x99, 0x00, 0x42, 0x99, 0x1b, 0xdb, 0x5d, 0xa8, 0xc6, 0x89, 0x38, 0x49, 0xd4, 0x5e, 0x4a,
 0xda, 0x87, 0x97, 0x32, 0x68, 0x66, 0xa6, 0xa5, 0x7b, 0xb5, 0xab, 0x8a, 0x85, 0x4d, 0xee, 0xee,
 0x23, 0x17, 0xb9, 0x00, 0x31, 0xde, 0xe4, 0x68, 0xcd, 0x58, 0x86, 0x98, 0xa0, 0xba, 0xda, 0xa5,
 0xc4, 0x95, 0x12, 0xe2, 0x78, 0x96, 0x32, 0x42, 0xac, 0xa3, 0x32, 0x31, 0x7b, 0x90, 0x06, 0xbb,
 0x92, 0x48, 0xa2, 0x57, 0xe0, 0xe2, 0x58, 0x52, 0x79, 0x9d, 0x48, 0xc6, 0xc4, 0x1c, 0x91, 0x29,
 0x59, 0x2a, 0x2e, 0x24, 0x96, 0x45, 0xef, 0x1b, 0x2a, 0x57, 0xe5, 0x05, 0xee, 0x46, 0x6f, 0x32,
 0x00, 0x60, 0x6a, 0x21, 0xb6, 0x9b, 0x4b, 0x6d, 0x24, 0x90, 0x84, 0x95, 0x12, 0x92, 0xe0, 0x44,
 0x3e, 0xaf, 0x72, 0x17, 0x2f, 0x72, 0x0b, 0xdc, 0x80, 0x18, 0xef, 0x72, 0x0b, 0xca, 0x9f, 0x10,
 0xbb, 0x79, 0x91, 0x82, 0x8c, 0xc8, 0x03, 0x5e, 0x23, 0x55, 0xcc, 0x92, 0xea, 0xdb, 0x22, 0x61,
 0x06, 0x95, 0x1a, 0x4f, 0xb0, 0x67, 0xc3, 0xd2, 0x61, 0x82, 0x51, 0x35, 0x54, 0x5c, 0xb9, 0x97,
 0xd6, 0xb2, 0x52, 0xcc, 0xa8, 0xba, 0x6e, 0xed, 0x17, 0x10, 0x89, 0xa8, 0x58, 0x59, 0x3e, 0xb8,
 0xb6, 0x08, 0xd4, 0x85, 0xef, 0x59, 0x17, 0x14, 0x9f, 0x3f, 0x40, 0xac, 0x84, 0x9a, 0xc5, 0x42,
 0x56, 0xdd, 0xf5, 0x20, 0x8f, 0x89, 0x16, 0xf2, 0x3f, 0x90, 0x01, 0xd1, 0x35, 0x54, 0x6a, 0x3d,
 0x86, 0x71, 0x2a, 0x51, 0x55, 0x4b, 0x49, 0x27, 0xd3, 0x5f, 0xb2, 0xa1, 0x4e, 0x06, 0x29, 0x57,
 0xac, 0x6c, 0x9f, 0x6b, 0xad, 0x4d, 0x3d, 0x64, 0x29, 0xa2, 0xe6, 0x91, 0x11, 0x4a, 0x25, 0x44,
 0xbc, 0xa7, 0x29, 0xc2, 0xbc, 0x0b, 0xe4, 0x16, 0x9a, 0x75, 0x85, 0xf5, 0xe9, 0x8c, 0x7c, 0x8d,
 0x28, 0x46, 0xf6, 0xc8, 0xf8, 0xa8, 0xf9, 0xfa, 0x00, 0x1d, 0x18, 0xe3, 0x77, 0x9e, 0xfe, 0xf0,
 0x5e, 0x64, 0x2e, 0xde, 0xe4, 0x62, 0xf7, 0x20, 0x06, 0x3b, 0xdc, 0x82, 0xf7, 0x21, 0x72, 0xf7,
 0x20, 0xbd, 0xc8, 0x01, 0x76, 0xf3, 0x23, 0x17, 0x99, 0x0b, 0xb7, 0xb9, 0x05, 0xe6, 0x40, 0x0c,
 0x57, 0x99, 0x05, 0xe6, 0x42, 0xed, 0xe6, 0x41, 0x79, 0x90, 0x05, 0xc2, 0xda, 0x82, 0x5a, 0xd4,
 0xb5, 0xc3, 0xa0, 0xd4, 0xa3, 0xa9, 0x9d, 0x4f, 0x79, 0x8c, 0x75, 0x10, 0x1f, 0x93, 0x37, 0xeb,
 0x31, 0x51, 0x79, 0x90, 0x5e, 0x64, 0x01, 0x6f, 0xd4, 0x40, 0x7e, 0x4c, 0x8f, 0x59, 0x83, 0xa8,
 0x80, 0xfc, 0x99, 0xbf, 0x59, 0x8a, 0x8b, 0xcc, 0x82, 0xf3, 0x20, 0x06, 0x06, 0x5f, 0x6d, 0x96,
 0xc9, 0xb6, 0x88, 0x90, 0x84, 0xf0, 0x22, 0xee, 0x1f, 0x57, 0x99, 0x0b, 0xb7, 0x99, 0x05, 0xe6,
 0x40, 0x0c, 0x77, 0x87, 0xcc, 0x17, 0x87, 0xcf, 0xe7, 0x0b, 0x97, 0xb9, 0x05, 0xee, 0x40, 0x0c,
 0x77, 0x99, 0x18, 0xbc, 0xc8, 0x5d, 0xbc, 0xc8, 0x2f, 0x32, 0x00, 0x62, 0xbc, 0xc8, 0xcd, 0xe6,
 0x42, 0xe5, 0xe6, 0x41, 0x79, 0x90, 0x03, 0x1d, 0xe6, 0x41, 0x79, 0x90, 0xb9, 0x79, 0x90, 0x5e,
 0x64, 0x00, 0xc7, 0x78, 0x7c, 0xc1, 0x79, 0x90, 0xb9, 0x79, 0x90, 0x5e, 0x64, 0x00, 0xc7, 0x79,
 0x90, 0x5e, 0x1f, 0x30, 0xb9, 0x79, 0x90, 0x5e, 0x64, 0x00, 0xc7, 0x79, 0x90, 0x5e, 0x64, 0x2e,
 0x5e, 0x64, 0x17, 0x99, 0x00, 0x31, 0xde, 0x64, 0x62, 0xf3, 0x21, 0x76, 0xf3, 0x20, 0xbc, 0xc8,
 0x01, 0x8e, 0xf3, 0x20, 0xbc, 0xc8, 0x5c, 0xbc, 0xc8, 0x2f, 0x32, 0x00, 0x63, 0xbc, 0x3e, 0x63,
 0x17, 0x99, 0x0b, 0xb7, 0x99, 0x05, 0xe6, 0x40, 0x0c, 0x77, 0x99, 0x18, 0xbc, 0xc8, 0x5d, 0xbc,
 0xc8, 0x2f, 0x32, 0x00, 0x63, 0xbc, 0x3e, 0x63, 0x5d, 0xe4, 0xc2, 0x3a, 0xad, 0xa7, 0x21, 0xda,
 0x51, 0xf3, 0xa5, 0x0f, 0xe6, 0x14, 0x97, 0xb9, 0x05, 0xe6, 0x40, 0x17, 0x4d, 0x26, 0x11, 0xa5,
 0x6d, 0x37, 0x0e, 0xd1, 0x1f, 0x3a, 0x57, 0xe9, 0x1b, 0x37, 0x99, 0x0b, 0x97, 0x99, 0x05, 0xe6,
 0x40, 0x0c, 0x57, 0x99, 0x05, 0xe6, 0x42, 0xed, 0xe6, 0x41, 0x79, 0x90, 0x03, 0x1d, 0xe1, 0xf3,
 0x18, 0xbc, 0xc8, 0x5d, 0xbd, 0xc8, 0x2f, 0x32, 0x00, 0x5c, 0xbd, 0xc8, 0x2f, 0x32, 0x17, 0x6f,
 0x0f, 0x98, 0x2f, 0x32, 0x00, 0x62, 0xbd, 0xc8, 0x2f, 0x32, 0x17, 0x2f, 0x32, 0x0b, 0xcc, 0x80,
 0x18, 0xef, 0x72, 0x0b, 0xdc, 0x85, 0xdb, 0xc3, 0xe6, 0x31, 0x78, 0x7c, 0xc0, 0x0c, 0x77, 0xb9,
 0x05, 0xe6, 0x42, 0xed, 0xe6, 0x46, 0x2f, 0x32, 0x00, 0x63, 0xbd, 0xc8, 0x2f, 0x32, 0x17, 0x2f,
 0x32, 0x33, 0x79, 0x90, 0x03, 0x15, 0xee, 0x4c, 0x17, 0x99, 0x0b, 0x97, 0x99, 0x05, 0xe6, 0x40,
 0x0c, 0x77, 0x99, 0x05, 0xee, 0x42, 0xed, 0xe1, 0xf3, 0x05, 0xe6, 0x40, 0x0c, 0x57, 0xb9, 0x05,
 0xe6, 0x42, 0xed, 0xe1, 0xf3, 0x05, 0xe6, 0x7e, 0x70, 0x03, 0x15, 0xee, 0x41, 0x79, 0x90, 0xb9,
 0x79, 0x91, 0x9b, 0xcc, 0x80, 0x18, 0xaf, 0x72, 0x0b, 0xdc, 0x85, 0xdb, 0xc3, 0xe7, 0xf3, 0x82,
 0xf0, 0xf9, 0xfc, 0xe0, 0x06, 0x2b, 0xdc, 0x82, 0xf7, 0x21, 0x76, 0xf0, 0xf9, 0xfc, 0xe3, 0x17,
 0x99, 0x00, 0x31, 0xde, 0xe4, 0x17, 0x99, 0x0b, 0x97, 0x99, 0x19, 0xbc, 0xc8, 0x01, 0x8a, 0xf3,
 0x20, 0xbc, 0xc8, 0x5c, 0xbc, 0xc8, 0xcd, 0xe6, 0x40, 0x0c, 0x57, 0xb9, 0x05, 0xe6, 0x42, 0xe5,
 0xee, 0x41, 0x79, 0x90, 0x03, 0x1d, 0xee, 0x41, 0x7b, 0x90, 0xb9, 0x7b, 0x91, 0x9b, 0xc3, 0xe7,
 0xf3, 0x80, 0x18, 0xaf, 0x72, 0x0b, 0xcc, 0x85, 0xcb, 0xcc, 0x82, 0xf3, 0x20, 0x06, 0x3b, 0xdc,
 0x82, 0xf7, 0x21, 0x72, 0xf3, 0x20, 0xbc, 0xc8, 0x01, 0x8e, 0xf3, 0x20, 0xbd, 0xc8, 0x5d, 0xbc,
 0x3e, 0x60, 0xbc, 0xc8, 0x01, 0x8a, 0xf7, 0x20, 0xbc, 0xc8, 0x5c, 0xbc, 0xc8, 0x2f, 0x32, 0x00,
 0x63, 0xbc, 0xc8, 0x2f, 0x32, 0x17, 0x2f, 0x32, 0x0b, 0xcc, 0x80, 0x17, 0x6f, 0x32, 0x0b, 0xcc,
 0x85, 0xcb, 0xcc, 0x82, 0xf3, 0x20, 0x06, 0x3b, 0xcc, 0x82, 0xf3, 0x21, 0x72, 0xf3, 0x20, 0xbc,
 0xc8, 0x01, 0x8e, 0xf3, 0x20, 0xbc, 0xc8, 0x5c, 0xbd, 0xc8, 0x2f, 0x0b, 0x98, 0x01, 0x8e, 0xf7,
 0x20, 0xbc, 0xc8, 0x5c, 0xbc, 0xc8, 0x2f, 0x32, 0x00, 0x63, 0xbc, 0xc8, 0x2f, 0x32, 0x17, 0x2f,
 0x72, 0x0b, 0xdc, 0x80, 0x18, 0xef, 0x32, 0x0b, 0xcc, 0x85, 0xcb, 0xcc, 0x82, 0xf7, 0x20, 0x06,
 0x3b, 0xcc, 0x82, 0xf3, 0x21, 0x72, 0xf3, 0x20, 0xbc, 0xc8, 0x01, 0x8e, 0xf3, 0x20, 0xbc, 0xc8,
 0x5c, 0xbc, 0xc8, 0x2f, 0x32, 0x60, 0x06, 0x3b, 0xcc, 0x82, 0xf3, 0x21, 0x72, 0xf7, 0x20, 0xbd,
 0xc9, 0x80, 0x18, 0xef, 0x32, 0x0b, 0xcc, 0x85, 0xcb, 0xcc, 0x98, 0x2f, 0x32, 0x00, 0x63, 0xbc,
 0xc8, 0x2f, 0x32, 0x17, 0x2f, 0x32, 0x0b, 0xcc, 0x80, 0x18, 0xef, 0x32, 0x0b, 0xcc, 0x85, 0xcb,
 0xcc, 0x82, 0xf3, 0x20, 0x06, 0x2b, 0xcc, 0x8c, 0xde, 0x64, 0x2e, 0x5e, 0x7e, 0x90, 0x2f, 0x32,
 0x00, 0x62, 0xbc, 0xc8, 0xcd, 0xe6, 0x42, 0xe5, 0xe6, 0x4c, 0x17, 0x99, 0x00, 0x31, 0xde, 0x64,
 0x17, 0x99, 0x0b, 0x97, 0xb9, 0x05, 0xee, 0x40, 0x0c, 0x77, 0x99, 0x05, 0xe6, 0x42, 0xe5, 0xee,
 0x41, 0x79, 0x90, 0x03, 0x15, 0xe6, 0x46, 0x6f, 0x32, 0x17, 0x2f, 0x32, 0x0b, 0xcc, 0x80, 0x18,
 0xef, 0x32, 0x0b, 0xcc, 0x85, 0xcb, 0xcc, 0x82, 0xf7, 0x20, 0x06, 0x3b, 0xcc, 0x8c, 0x5e, 0x64,
 0x2e, 0xde, 0x64, 0x17, 0x99, 0x00, 0x31, 0x5e, 0x64, 0x66, 0xf3, 0x21, 0x72, 0xf7, 0x20, 0xbc,
 0xfd, 0x23, 0x00, 0x53, 0xd4, 0xf9, 0x98, 0x2a, 0x7c, 0xc6, 0x00, 0x00, 0xcd, 0x4f, 0x99, 0x82,
 0xa7, 0xcc, 0x60, 0x00, 0x0c, 0xd4, 0xf9, 0x98, 0x2a, 0x7c, 0xcc, 0x60, 0x00, 0x0c, 0xd4, 0xf9,
 0x98, 0x2a, 0x7c, 0xc6, 0x00, 0x00, 0xcd, 0x4f, 0x99, 0x82, 0xa7, 0xcc, 0xc6, 0x00, 0x00, 0xcd,
 0x4f, 0x99, 0x82, 0xa7, 0xcc, 0xc6, 0x00, 0x00, 0xcd, 0x4f, 0x99, 0x82, 0xa7, 0xcc, 0xc6, 0x00,
 0x00, 0xcd, 0x4f, 0x98, 0x2a, 0x7c, 0xcc, 0x60, 0x00, 0x0c, 0xd4, 0xf9, 0x82, 0xa7, 0xcc, 0xc6,
 0x00, 0x00, 0xcd, 0x4f, 0x99, 0x82, 0xa7, 0xcc, 0xc6, 0x00, 0x00, 0xcd, 0x4f, 0x99, 0x82, 0xa7,
 0xcc, 0xc6, 0x00, 0x00, 0xcd, 0x4f, 0x98, 0x2a, 0x7c, 0xcc, 0x60, 0x00, 0x0c, 0xd4, 0xf9, 0x98,
 0x2a, 0x7c, 0xcc, 0x60, 0x00, 0x0c, 0xd4, 0xf9, 0x98, 0x2a, 0x7c, 0xcc, 0x60, 0x00, 0x0c, 0xd4,
 0xf9, 0x98, 0x2a, 0x7c, 0xcc, 0x60, 0x00, 0x0c, 0xd4, 0xf9, 0x98, 0x2a, 0x7c, 0xcc, 0x60, 0x00,
 0x0c, 0xd4, 0xf9, 0x82, 0xa7, 0xcc, 0xc6, 0x00, 0x00, 0xcd, 0x4f, 0x99, 0x82, 0xa7, 0xcc, 0xc6,
 0x00, 0x00, 0xcd, 0x4f, 0x98, 0x2a, 0x7c, 0xc6, 0x00, 0x00, 0xcd, 0x4f, 0x99, 0x82, 0xa7, 0xcc,
 0xc6, 0x00, 0x00, 0x00, 0x25, 0xb7, 0x7f, 0xcc, 0xb9, 0xe0, 0x30, 0x5b, 0xbf, 0xe6, 0x5c, 0xf0,
 0x18, 0xf3, 0x28, 0xf3, 0x72, 0x22, 0x00, 0x96, 0xdd, 0xff, 0x00, 0x32, 0xe7, 0x80, 0xc1, 0x6e,
 0xff, 0x00, 0x99, 0x73, 0xc0, 0x61, 0x94, 0x37, 0x22, 0x20, 0x09, 0x6d, 0xdf, 0xf3, 0x2e, 0x78,
 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3c, 0x06, 0x19, 0x43, 0x72, 0x22, 0x00, 0x96, 0xdd, 0xff, 0x00,
 0x32, 0xe7, 0x80, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xc0, 0x61, 0x94, 0x37, 0x22, 0x20, 0x09,
 0x6d, 0xdf, 0xf3, 0x2e, 0x78, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3c, 0x06, 0x19, 0x43, 0x72, 0x22,
 0x00, 0x96, 0xdd, 0xff, 0x00, 0x32, 0xe7, 0x80, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xc0, 0x61,
 0x94, 0x37, 0x22, 0x20, 0x09, 0x6d, 0xdf, 0xf3, 0x2e, 0x78, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3c,
 0x06, 0x19, 0x43, 0x72, 0x22, 0x00, 0x96, 0xdd, 0xff, 0x00, 0x32, 0xe7, 0x80, 0xc1, 0x6e, 0xff,
 0x00, 0x99, 0x73, 0xc0, 0x61, 0x94, 0x37, 0x22, 0x20, 0x09, 0x6d, 0xdf, 0xf3, 0x2e, 0x78, 0x0c,
 0x16, 0xef, 0xf9, 0x97, 0x3c, 0x06, 0x19, 0x43, 0x72, 0x22, 0x00, 0x96, 0xdd, 0xff, 0x00, 0x32,
 0xe7, 0x80, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xc0, 0x61, 0x94, 0x37, 0x22, 0x20, 0x09, 0x6d,
 0xdf, 0xf3, 0x2e, 0x78, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3c, 0x06, 0x19, 0x43, 0x72, 0x22, 0x00,
 0x96, 0xdd, 0xff, 0x00, 0x32, 0xe7, 0x80, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xc0, 0x61, 0x94,
 0x37, 0x22, 0x20, 0x09, 0x6d, 0xdf, 0xf3, 0x2e, 0x78, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3c, 0x06,
 0x19, 0x43, 0x72, 0x22, 0x00, 0x96, 0xdd, 0xff, 0x00, 0x32, 0xe7, 0x80, 0xc1, 0x6e, 0xff, 0x00,
 0x99, 0x73, 0xc0, 0x61, 0x94, 0x37, 0x22, 0x20, 0x09, 0x6d, 0xdf, 0xf3, 0x2e, 0x78, 0x0c, 0x16,
 0xef, 0xf9, 0x97, 0x3c, 0x06, 0x19, 0x43, 0x72, 0x22, 0x00, 0x96, 0xdd, 0xff, 0x00, 0x32, 0xe7,
 0x80, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xc0, 0x61, 0x94, 0x37, 0x22, 0x20, 0x09, 0x6d, 0xdf,
 0xf3, 0x2e, 0x78, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3c, 0x06, 0x19, 0x43, 0x72, 0x22, 0x00, 0x96,
 0xdd, 0xff, 0x00, 0x32, 0xe7, 0x80, 0xc1, 0x6e, 0xff, 0x00, 0x99, 0x73, 0xc0, 0x61, 0x94, 0x37,
 0x22, 0x20, 0x09, 0x6d, 0xdf, 0xf3, 0x2e, 0x78, 0x0c, 0x16, 0xef, 0xf9, 0x97, 0x3c, 0x06, 0x19,
 0x43, 0x72, 0x22, 0x00, 0x96, 0xdd, 0xff, 0x00, 0x32, 0xe7, 0x80, 0xc1, 0x6d, 0x11, 0xe6, 0x1d,
 0xf0, 0x18, 0x65, 0x0d, 0xc8, 0xff, 0xd9};
static const unsigned char PIC_640x480_2[] = { 
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x17, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
 0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65, 0x20, 0x47, 0x49, 0x4d, 0x50, 0xff, 0xe1, 0x00,
 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x05, 0x03, 0x04, 0x04, 0x04, 0x03,
 0x05, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0c, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0f,
 0x0b, 0x0b, 0x09, 0x0c, 0x11, 0x0f, 0x12, 0x12, 0x11, 0x0f, 0x11, 0x11, 0x13, 0x16, 0x1c, 0x17,
 0x13, 0x14, 0x1a, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1a, 0x1d, 0x1d, 0x1f, 0x1f, 0x1f, 0x13,
 0x17, 0x22, 0x24, 0x22, 0x1e, 0x24, 0x1c, 0x1e, 0x1f, 0x1e, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x05,
 0x05, 0x05, 0x07, 0x06, 0x07, 0x0e, 0x08, 0x08, 0x0e, 0x1e, 0x14, 0x11, 0x14, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0xff,
 0xc0, 0x00, 0x11, 0x08, 0x01, 0xe0, 0x02, 0x80, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03,
 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1d, 0x00, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x02, 0x04, 0x03, 0x06, 0x07, 0x01, 0x08,
 0x09, 0xff, 0xc4, 0x00, 0x5d, 0x10, 0x00, 0x01, 0x02, 0x04, 0x03, 0x05, 0x02, 0x06, 0x0c, 0x08,
 0x06, 0x10, 0x06, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x13, 0x61, 0x05, 0x06, 0x11,
 0x07, 0x12, 0x21, 0x31, 0x51, 0x41, 0x93, 0x08, 0x15, 0x22, 0x54, 0x71, 0xd1, 0x14, 0x16, 0x17,
 0x52, 0x56, 0x81, 0x91, 0xa1, 0xb1, 0xb2, 0xb3, 0xe1, 0x25, 0x32, 0x42, 0x43, 0x72, 0x92, 0x94,
 0xc1, 0x26, 0x33, 0x46, 0x62, 0x64, 0xc2, 0x23, 0x24, 0x44, 0x45, 0x53, 0x55, 0x73, 0x74, 0x82,
 0x84, 0xa2, 0xa3, 0xb4, 0xd2, 0xd3, 0xf0, 0x09, 0x34, 0x63, 0x65, 0x83, 0xf1, 0x75, 0x85, 0x95,
 0xff, 0xc4, 0x00, 0x1c, 0x01, 0x01, 0x01, 0x00, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0xff, 0xc4,
 0x00, 0x39, 0x11, 0x01, 0x00, 0x02, 0x01, 0x03, 0x02, 0x03, 0x06, 0x03, 0x06, 0x05, 0x05, 0x01,
 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x11, 0x12, 0x05, 0x51, 0x21, 0x31, 0x91, 0x06,
 0x13, 0x14, 0x41, 0x52, 0x71, 0x61, 0x81, 0xb1, 0x22, 0x23, 0x33, 0xa1, 0xc1, 0xd1, 0x32, 0x42,
 0x72, 0xe1, 0xf0, 0x15, 0x16, 0x53, 0x62, 0xf1, 0x43, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00,
 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xe7, 0xca, 0xd3, 0x1a, 0xb4, 0xb4, 0xad, 0xb1, 0x07,
 0x34, 0xfa, 0x27, 0x27, 0xcc, 0xe2, 0xca, 0xea, 0xc2, 0x0a, 0xd2, 0xca, 0xb4, 0x82, 0xb4, 0xad,
 0xd5, 0x16, 0x56, 0x56, 0x91, 0x56, 0x96, 0x55, 0x84, 0x1c, 0xde, 0xa5, 0xc5, 0x95, 0xba, 0xb2,
 0xb0, 0x8b, 0x9a, 0x58, 0x56, 0x91, 0x56, 0xd8, 0xce, 0xec, 0xc4, 0xab, 0xab, 0x4c, 0x6a, 0xd2,
 0xd2, 0xb3, 0x89, 0x07, 0x34, 0xb8, 0xb2, 0xe2, 0x55, 0x95, 0xa4, 0x5c, 0xd2, 0xc2, 0xb7, 0x89,
 0x15, 0x69, 0x9d, 0xd5, 0x12, 0xac, 0xad, 0xe2, 0x45, 0x5a, 0x58, 0x56, 0xa1, 0x05, 0x61, 0x71,
 0x2a, 0xe4, 0xae, 0xac, 0x42, 0x2e, 0x69, 0x61, 0x5b, 0xc4, 0x82, 0xb4, 0xce, 0xea, 0x89, 0x57,
 0x56, 0xf1, 0x22, 0xad, 0x2c, 0x2b, 0x48, 0x2b, 0x4b, 0x8b, 0x2e, 0x2c, 0xae, 0xad, 0x20, 0xad,
 0x2c, 0xab, 0x78, 0x91, 0x73, 0x4c, 0xee, 0xa8, 0xb2, 0xb2, 0xb4, 0x8a, 0xb4, 0xb0, 0xad, 0xe2,
 0x45, 0xcd, 0x2a, 0x25, 0x5b, 0xab, 0x2b, 0x48, 0x2b, 0x4b, 0x2e, 0x69, 0x05, 0x6f, 0x0e, 0x45,
 0x6e, 0xa8, 0xb2, 0xba, 0xb4, 0x8a, 0xb7, 0x52, 0xc2, 0xb7, 0x89, 0x15, 0x69, 0x71, 0x65, 0x44,
 0xab, 0x2b, 0x48, 0xb9, 0xa5, 0x8d, 0xd2, 0x2a, 0xd5, 0x33, 0xba, 0xa2, 0xca, 0xca, 0xd2, 0x0a,
 0xd2, 0xca, 0xb7, 0x89, 0x17, 0x34, 0xbd, 0xd5, 0x12, 0xac, 0xad, 0x22, 0xad, 0x2c, 0x2b, 0x78,
 0x90, 0x56, 0x19, 0xdd, 0x5b, 0xb0, 0x2b, 0x48, 0xaa, 0x68, 0x67, 0x56, 0xd8, 0x8a, 0xb4, 0xa8,
 0x95, 0x44, 0xb1, 0x01, 0x25, 0x69, 0xe6, 0x8a, 0x56, 0xec, 0xbc, 0x00, 0x01, 0xb8, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x0e, 0xbc, 0xe6, 0x90, 0x56, 0x96, 0x9c, 0xce, 0x26, 0x37, 0x30, 0xf3, 0x31, 0x67,
 0x97, 0x8b, 0x2b, 0xab, 0x48, 0x2b, 0x4b, 0x2a, 0xd2, 0x0a, 0xd3, 0x3b, 0xaa, 0x25, 0x59, 0x58,
 0x45, 0x5a, 0x59, 0x56, 0x90, 0x73, 0x4a, 0x89, 0x54, 0x59, 0x59, 0x5a, 0x45, 0xcd, 0x2c, 0x2b,
 0x08, 0xab, 0x4a, 0xdd, 0x7b, 0xab, 0x2b, 0x54, 0x8b, 0x9a, 0x59, 0x56, 0x90, 0x56, 0x97, 0x12,
 0xa8, 0x95, 0x75, 0x61, 0x07, 0x34, 0xb0, 0xad, 0x22, 0xad, 0x33, 0xba, 0xa2, 0x55, 0x95, 0xa4,
 0x55, 0xa5, 0x95, 0x69, 0x07, 0x34, 0xa8, 0x95, 0x6e, 0xae, 0xad, 0x20, 0xe6, 0x96, 0x15, 0xa4,
 0x55, 0x85, 0x45, 0x95, 0x16, 0x56, 0x56, 0x90, 0x56, 0x96, 0x55, 0xa4, 0x55, 0xa5, 0x44, 0xaa,
 0x25, 0x59, 0x5a, 0x45, 0xcd, 0x2c, 0x2b, 0x48, 0x39, 0xa5, 0xee, 0xa8, 0x95, 0x75, 0x61, 0x15,
 0x69, 0x61, 0x5a, 0x45, 0x5a, 0x66, 0x25, 0x71, 0x65, 0x65, 0x69, 0x17, 0x34, 0xb0, 0xad, 0xe2,
 0x45, 0x5a, 0x56, 0xea, 0xdd, 0x59, 0x59, 0xa1, 0x05, 0x69, 0x65, 0x53, 0x89, 0x15, 0x6d, 0x8a,
 0x89, 0x57, 0x25, 0x65, 0x69, 0x15, 0x69, 0x61, 0x5b, 0xc4, 0x8a, 0xb4, 0xad, 0xd5, 0xc9, 0x59,
 0x5a, 0x41, 0x5a, 0x59, 0x56, 0x91, 0x56, 0x97, 0x16, 0x54, 0x4a, 0xb2, 0xb4, 0x82, 0xb4, 0xb2,
 0xad, 0x22, 0xe6, 0x99, 0xdd, 0x51, 0x2a, 0xca, 0xc2, 0x0a, 0xc2, 0xca, 0xb4, 0x8a, 0xb4, 0xb8,
 0x95, 0x44, 0xab, 0x2b, 0x48, 0xab, 0x4b, 0x0e, 0x69, 0x05, 0x69, 0x9d, 0xd5, 0x12, 0xae, 0xad,
 0x3c, 0x56, 0x99, 0xd5, 0xba, 0x11, 0x56, 0x97, 0x12, 0xae, 0x4c, 0x0a, 0x9a, 0x01, 0x91, 0xcd,
 0xb1, 0x15, 0x69, 0x9d, 0xd5, 0x12, 0x88, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xdc, 0xdf, 0x04, 0xc0, 0xf8, 0x49, 0xd0,
 0x6c, 0xf8, 0x46, 0x08, 0x90, 0xac, 0x78, 0xfa, 0xdd, 0xe3, 0x6b, 0x72, 0xa7, 0x43, 0xb1, 0x8d,
 0xcc, 0xd0, 0x66, 0xf8, 0x36, 0x30, 0xbe, 0x11, 0xb6, 0x2e, 0xdb, 0x17, 0x50, 0x56, 0x98, 0xd5,
 0xa5, 0xd7, 0xc2, 0x31, 0x3a, 0x1a, 0x97, 0x16, 0x6c, 0x8b, 0x2b, 0x2b, 0x48, 0x2b, 0x4b, 0x2a,
 0xd2, 0x0a, 0xd2, 0xe2, 0x55, 0x16, 0x57, 0x56, 0x90, 0x56, 0x96, 0x55, 0xa4, 0x15, 0xa5, 0x6e,
 0xb8, 0x95, 0x75, 0x69, 0x05, 0x69, 0x65, 0xcd, 0xb1, 0x05, 0x69, 0x51, 0x2a, 0xe4, 0xac, 0xad,
 0x22, 0xad, 0x2c, 0xab, 0x48, 0x2b, 0x4a, 0xdd, 0x51, 0x2a, 0xea, 0xd2, 0x0a, 0xd2, 0xca, 0xb4,
 0x82, 0xb4, 0xa8, 0x95, 0x45, 0x95, 0xdc, 0xdb, 0x10, 0x56, 0x96, 0x55, 0xa4, 0x1c, 0xd2, 0xb7,
 0x54, 0x4a, 0xb2, 0xb7, 0x89, 0x17, 0x34, 0xb0, 0xac, 0x22, 0xad, 0x33, 0x16, 0x57, 0x25, 0x65,
 0x69, 0x05, 0x69, 0x65, 0x5a, 0xa4, 0x55, 0xb6, 0x2f, 0x92, 0xe2, 0xca, 0xca, 0xd2, 0x2a, 0xd2,
 0xc2, 0xb4, 0x8b, 0x9a, 0x54, 0x4a, 0xa2, 0x55, 0x95, 0x84, 0x5c, 0xd2, 0xc2, 0xb7, 0x89, 0x15,
 0x69, 0x5b, 0xab, 0x75, 0x65, 0x69, 0x15, 0x69, 0x61, 0xcd, 0x20, 0xac, 0x2a, 0x25, 0x51, 0x65,
 0x75, 0x61, 0x17, 0x34, 0xb0, 0xad, 0xe2, 0x45, 0xcd, 0x33, 0x12, 0xa8, 0xb2, 0xb2, 0xb4, 0x8a,
 0xb4, 0xb0, 0xad, 0xe2, 0x45, 0xcd, 0x2e, 0x2c, 0xad, 0xd5, 0x95, 0xbc, 0x48, 0xab, 0x7a, 0x16,
 0x15, 0xba, 0x10, 0x56, 0x95, 0xba, 0xa2, 0x55, 0xf7, 0x78, 0x91, 0x56, 0xd8, 0xb1, 0xba, 0x45,
 0x5a, 0x54, 0x4a, 0xa2, 0x55, 0x95, 0xbc, 0x48, 0x39, 0xa5, 0x95, 0x6a, 0x91, 0x56, 0x95, 0xba,
 0xe2, 0xca, 0xca, 0xd2, 0x2a, 0xd2, 0xc2, 0xb4, 0x8a, 0xb6, 0xc5, 0x44, 0xb3, 0xba, 0xb2, 0xb7,
 0x89, 0x17, 0x34, 0xb0, 0xad, 0x22, 0xad, 0xb1, 0x5b, 0xaf, 0x75, 0x75, 0x43, 0xc3, 0x32, 0xb4,
 0x8a, 0xb4, 0xcc, 0x4b, 0x3b, 0xb1, 0x81, 0xea, 0xb4, 0xf1, 0x51, 0x4a, 0xdd, 0x90, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x20, 0xf8, 0x49, 0xd0, 0xc2, 0xf8, 0x23,
 0x68, 0x90, 0x97, 0xa1, 0x81, 0xf0, 0x8f, 0x07, 0x17, 0x78, 0x18, 0xc8, 0x54, 0xf8, 0x56, 0x30,
 0xbe, 0x15, 0x86, 0xaf, 0x85, 0x63, 0x03, 0xe0, 0x9b, 0x6b, 0x91, 0xb6, 0xb7, 0x2a, 0x7c, 0x24,
 0xe8, 0x62, 0x7c, 0x2b, 0x0d, 0x1f, 0x06, 0xc6, 0x17, 0xc2, 0xb1, 0xb6, 0x2e, 0xdb, 0x17, 0x2a,
 0x74, 0x2e, 0x3c, 0x8c, 0x4f, 0x87, 0xa7, 0x60, 0xd1, 0xf0, 0xac, 0x61, 0x7c, 0x2b, 0x1b, 0x62,
 0xed, 0xb5, 0xb9, 0x6b, 0x99, 0xd5, 0x08, 0x39, 0xa5, 0xf7, 0xc2, 0xb1, 0x81, 0xf0, 0x94, 0xd9,
 0x16, 0x6d, 0x8b, 0xaa, 0xab, 0x6c, 0x41, 0x5a, 0x59, 0x73, 0x15, 0x08, 0x2b, 0x0b, 0x8b, 0x2a,
 0x25, 0x5d, 0x5a, 0x41, 0x5a, 0x59, 0x56, 0xd8, 0x82, 0xb4, 0xad, 0xd7, 0x12, 0xae, 0xe6, 0x98,
 0xd5, 0xa5, 0xa5, 0x69, 0x05, 0x69, 0x51, 0x65, 0x45, 0x95, 0xd5, 0xa4, 0x1c, 0xd2, 0xcb, 0x9a,
 0x41, 0x5a, 0x56, 0xea, 0xdd, 0x59, 0x5a, 0xa4, 0x55, 0xa5, 0x95, 0x69, 0x07, 0x36, 0xc5, 0x6e,
 0xa8, 0x95, 0x75, 0x69, 0x05, 0x69, 0x61, 0x5a, 0x45, 0x5a, 0x56, 0xea, 0xdd, 0x59, 0x5a, 0x41,
 0xcd, 0x2d, 0x2b, 0x6c, 0x41, 0x5a, 0x67, 0x75, 0x45, 0x95, 0x95, 0xa9, 0xd0, 0x8a, 0xb4, 0xb0,
 0xad, 0x22, 0xe6, 0x95, 0x16, 0x5f, 0x25, 0x65, 0x6a, 0x90, 0x56, 0xf1, 0xe4, 0x59, 0x56, 0x91,
 0x56, 0x97, 0xbb, 0x31, 0x2a, 0xca, 0xd2, 0x2a, 0xd2, 0xc2, 0xb6, 0xc4, 0x1c, 0xd2, 0xb7, 0x5c,
 0x4a, 0xba, 0xb4, 0x8a, 0xb4, 0xb0, 0xad, 0x22, 0xe6, 0x99, 0xdd, 0x51, 0x65, 0x65, 0x69, 0x17,
 0x30, 0xb0, 0xad, 0x52, 0x0a, 0xd2, 0xf7, 0x54, 0x59, 0x5d, 0x5a, 0xa4, 0x55, 0xa5, 0x85, 0x42,
 0x2e, 0x69, 0x51, 0x2a, 0x89, 0x56, 0x56, 0xf1, 0x22, 0xac, 0x2c, 0x2b, 0x14, 0x8a, 0xb4, 0xad,
 0xd5, 0x12, 0xac, 0xad, 0x20, 0xad, 0xea, 0x59, 0x56, 0xf1, 0x22, 0xad, 0x2a, 0x2c, 0xbd, 0xd5,
 0x95, 0xbc, 0x48, 0xab, 0x0b, 0x0a, 0xce, 0x84, 0x5c, 0xdb, 0x15, 0x12, 0xa8, 0xb2, 0xb2, 0xb4,
 0x8a, 0xb4, 0xb0, 0xad, 0xb1, 0x15, 0x6f, 0xa0, 0xa8, 0x96, 0x77, 0x56, 0x56, 0x91, 0x56, 0x96,
 0x15, 0xb6, 0x20, 0xad, 0xe8, 0x54, 0x4a, 0xa2, 0xca, 0xea, 0xd3, 0xcd, 0x14, 0xce, 0xad, 0x22,
 0xad, 0xb1, 0x51, 0x65, 0xee, 0xc2, 0x04, 0xd5, 0xa4, 0x55, 0xba, 0x19, 0xdd, 0x9d, 0xde, 0x00,
 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x01, 0xf5, 0x73, 0xe1, 0x18, 0x5f, 0x04, 0x6a, 0xf8, 0x36, 0x30, 0xbe,
 0x09, 0xf3, 0x68, 0xbb, 0xe6, 0x95, 0xb9, 0x53, 0xe1, 0x18, 0x1f, 0x0a, 0xc3, 0x67, 0xc1, 0xb1,
 0x85, 0xf0, 0x8d, 0xd5, 0xbb, 0x6c, 0x64, 0x29, 0x7c, 0x23, 0x03, 0xe1, 0x58, 0x6c, 0xf8, 0x4b,
 0xd0, 0xc2, 0xf8, 0x46, 0xda, 0xdd, 0xba, 0xb9, 0x0a, 0x9f, 0x06, 0xc6, 0x07, 0xc2, 0xb0, 0xd9,
 0xd0, 0xac, 0x61, 0x7c, 0x2b, 0x1b, 0x62, 0xed, 0xb5, 0xc8, 0x54, 0xf8, 0x56, 0x30, 0x3e, 0x0d,
 0x86, 0xaf, 0x85, 0x63, 0x0b, 0xe1, 0x58, 0xdb, 0x17, 0x6d, 0xae, 0x42, 0x97, 0xc2, 0xb1, 0x89,
 0xf0, 0x86, 0xaf, 0x84, 0xa6, 0x17, 0xc2, 0xb1, 0xb6, 0xb7, 0x6d, 0x8b, 0x95, 0xba, 0x1a, 0xa7,
 0x61, 0x89, 0xcd, 0xb0, 0xcd, 0xf0, 0xac, 0x61, 0x7c, 0x2b, 0x1b, 0x62, 0xed, 0x91, 0x75, 0x05,
 0x69, 0x17, 0x34, 0xb6, 0xe8, 0x6a, 0x86, 0x37, 0x30, 0xb8, 0xb3, 0x64, 0x59, 0x59, 0x5a, 0x41,
 0xcd, 0x2c, 0xb9, 0x84, 0x15, 0xa5, 0xc4, 0xaf, 0x92, 0xbb, 0x9a, 0x41, 0x5a, 0x59, 0x56, 0x90,
 0x73, 0x4c, 0xee, 0xad, 0xd5, 0xdc, 0xd2, 0x0a, 0xd2, 0xca, 0xb4, 0x83, 0x9a, 0x54, 0x4a, 0xa2,
 0xca, 0xca, 0xc2, 0x2a, 0xd2, 0xc2, 0xb4, 0x8a, 0xb4, 0xa8, 0x95, 0x44, 0xab, 0xab, 0x48, 0x39,
 0xa5, 0x95, 0x69, 0x05, 0x69, 0x51, 0x2a, 0x8b, 0x2b, 0x2b, 0x08, 0xab, 0x4b, 0x0a, 0xd2, 0x2e,
 0x69, 0x51, 0x2a, 0x89, 0x56, 0x56, 0x91, 0x56, 0x16, 0x55, 0x8a, 0x41, 0xcd, 0x2a, 0x2c, 0xa8,
 0xb2, 0xb2, 0xb0, 0x83, 0x9a, 0x5a, 0x56, 0x90, 0x56, 0xd8, 0xa8, 0x95, 0xc5, 0x95, 0x95, 0xaa,
 0x45, 0xcd, 0x2c, 0xab, 0x4c, 0x6a, 0xd2, 0xa2, 0x55, 0x12, 0xae, 0xac, 0x20, 0xad, 0x2c, 0xab,
 0x48, 0xab, 0x4a, 0xdd, 0x51, 0x2a, 0xca, 0xde, 0x24, 0x55, 0xa5, 0x85, 0x69, 0x15, 0x6a, 0x95,
 0x12, 0xb8, 0x95, 0x65, 0x61, 0x05, 0x69, 0x65, 0x5b, 0xc4, 0x8a, 0xb4, 0xa8, 0x96, 0x77, 0x56,
 0x56, 0x91, 0x56, 0x96, 0x15, 0xa8, 0x45, 0x58, 0x54, 0x59, 0x5c, 0x95, 0x95, 0x88, 0x45, 0x5a,
 0x58, 0x56, 0x91, 0x73, 0x4a, 0xdd, 0x51, 0x65, 0x65, 0x6f, 0x12, 0x2a, 0xd2, 0xc2, 0xb4, 0x8a,
 0xb4, 0xa8, 0x95, 0xee, 0xac, 0xe6, 0x90, 0x56, 0x96, 0x55, 0xbc, 0x48, 0xb9, 0xa5, 0x6e, 0xae,
 0x4a, 0xaa, 0xd3, 0xc5, 0x69, 0x61, 0x5b, 0x62, 0x2a, 0xd2, 0xa2, 0x55, 0x12, 0xac, 0xad, 0xd0,
 0x8a, 0xb4, 0xb0, 0xad, 0x22, 0xad, 0xb1, 0x5b, 0xaa, 0x2c, 0xaf, 0xa0, 0x19, 0x55, 0xa4, 0x55,
 0xa6, 0x62, 0x55, 0xba, 0x00, 0x7a, 0xa8, 0x79, 0xc4, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf6, 0x74, 0x59, 0x75, 0xe8, 0x57, 0x7c, 0x1b,
 0x0f, 0xe2, 0x4b, 0xd8, 0xad, 0x16, 0x5e, 0xc7, 0xca, 0xab, 0x91, 0xf3, 0xab, 0xe9, 0x66, 0x3c,
 0x88, 0xdf, 0x0a, 0xc6, 0x07, 0xc2, 0xb0, 0xe6, 0x24, 0xbd, 0x8a, 0xf1, 0x20, 0xaf, 0x43, 0x75,
 0x72, 0x38, 0xf3, 0x5b, 0x57, 0xcc, 0xa1, 0xf0, 0x6c, 0x61, 0x7c, 0x21, 0xab, 0xe0, 0xd8, 0xc2,
 0xf8, 0x56, 0x36, 0xd6, 0xe5, 0x6e, 0x54, 0xf8, 0x36, 0x30, 0xbe, 0x10, 0xd5, 0xf0, 0x8c, 0x2f,
 0x82, 0x6d, 0x8c, 0x8d, 0xb1, 0x72, 0x97, 0xc2, 0x4e, 0x86, 0x17, 0xc2, 0xb0, 0xda, 0x24, 0x23,
 0x03, 0xe0, 0xd8, 0xdb, 0x5b, 0xb6, 0xd7, 0x21, 0x4b, 0xe1, 0x58, 0xc2, 0xf8, 0x56, 0x1b, 0x3e,
 0x11, 0x85, 0xf0, 0x97, 0xa1, 0xb6, 0x2e, 0xdd, 0x19, 0x0a, 0x5f, 0x0a, 0xc6, 0x17, 0xc2, 0xb0,
 0xd5, 0xf0, 0xb5, 0xec, 0x30, 0xbe, 0x0a, 0x9b, 0x62, 0xed, 0xb1, 0x72, 0x97, 0x42, 0x31, 0x3e,
 0x15, 0x86, 0xaf, 0x85, 0x63, 0x0b, 0xe1, 0x58, 0xdb, 0x5b, 0xb6, 0xc5, 0xca, 0x9f, 0x0a, 0xc6,
 0x27, 0x43, 0x5e, 0x83, 0x47, 0xc1, 0xb1, 0x81, 0xf0, 0x97, 0xa1, 0xb6, 0x2e, 0xdb, 0x17, 0x2f,
 0x56, 0x58, 0x82, 0xb2, 0xc5, 0xd7, 0xc2, 0x31, 0x3a, 0x1a, 0xa1, 0xb2, 0x2c, 0xd9, 0x16, 0x55,
 0x56, 0x90, 0x56, 0x96, 0x5c, 0xde, 0xa4, 0x15, 0xa5, 0x44, 0xae, 0x25, 0x5d, 0xcd, 0x20, 0xe6,
 0x96, 0x55, 0xa4, 0x1c, 0xd2, 0xa2, 0x55, 0x12, 0xac, 0xad, 0xb1, 0x15, 0x69, 0x65, 0xcd, 0x52,
 0x0a, 0xc2, 0xb7, 0x54, 0x4a, 0xb2, 0xb4, 0x82, 0xb4, 0xb4, 0xe6, 0x90, 0x56, 0x95, 0x12, 0xad,
 0xd5, 0xd5, 0xa4, 0x1c, 0xd2, 0xca, 0xb4, 0x82, 0xb4, 0xad, 0xd5, 0x12, 0xac, 0xac, 0x22, 0xe6,
 0xd8, 0xb2, 0xe6, 0x90, 0x56, 0x95, 0x12, 0xb8, 0x95, 0x65, 0x69, 0x05, 0x69, 0x65, 0x58, 0x45,
 0xcd, 0x2b, 0x92, 0xa2, 0xca, 0xca, 0xc2, 0x0e, 0x69, 0x65, 0x58, 0xa4, 0x55, 0xa5, 0x72, 0x54,
 0x59, 0x59, 0x5b, 0xc4, 0x83, 0x9b, 0x62, 0xd2, 0xb4, 0xc6, 0xac, 0x2a, 0x25, 0x51, 0x2a, 0xea,
 0xd2, 0x2a, 0xd2, 0xc2, 0xb0, 0x83, 0x9a, 0x85, 0x44, 0xaa, 0x25, 0x5d, 0x5b, 0xc4, 0x8a, 0xb4,
 0xb0, 0xad, 0xb1, 0x05, 0x69, 0x51, 0x65, 0x44, 0xab, 0xab, 0x78, 0x91, 0x56, 0x21, 0x61, 0x5b,
 0xc4, 0x8b, 0x9a, 0x54, 0x4a, 0xa2, 0xca, 0xca, 0xdd, 0x3b, 0x08, 0x2b, 0x4b, 0x4a, 0xdd, 0x7b,
 0x0c, 0x6a, 0xd2, 0xa2, 0x57, 0xba, 0xba, 0xb7, 0x89, 0x17, 0x35, 0x0b, 0x0a, 0xc2, 0x2a, 0xd2,
 0xa2, 0x59, 0xdd, 0x59, 0x5b, 0xc7, 0x91, 0x15, 0x69, 0x61, 0x5a, 0x9a, 0x91, 0x73, 0x75, 0x2a,
 0x2c, 0xbd, 0xd5, 0x95, 0xa4, 0x1c, 0xd2, 0xca, 0xb5, 0x48, 0xab, 0x78, 0x71, 0x2a, 0x25, 0x51,
 0x65, 0x65, 0x61, 0x05, 0x69, 0x65, 0x5b, 0xc4, 0x8b, 0x9a, 0x54, 0x4a, 0xb7, 0x56, 0x56, 0x91,
 0x56, 0x96, 0x15, 0x84, 0x55, 0xa5, 0x44, 0xaa, 0x2c, 0xae, 0xad, 0x22, 0xa9, 0xa1, 0x9d, 0x5a,
 0x45, 0x5a, 0x57, 0x25, 0x6e, 0xc4, 0x04, 0x95, 0xa4, 0x74, 0x53, 0x3b, 0xb2, 0x00, 0x00, 0xc8,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xbf, 0x22, 0xcb, 0x58, 0xad, 0x16, 0x59, 0x3a, 0x1b,
 0x3c, 0xc4, 0x82, 0xa2, 0xf2, 0x28, 0x46, 0x95, 0x54, 0xec, 0x3e, 0x35, 0x5c, 0xce, 0x97, 0x3e,
 0x82, 0x63, 0xce, 0x1a, 0xec, 0x59, 0x7b, 0x15, 0xa2, 0x4b, 0xd8, 0xd8, 0x22, 0x4b, 0xd8, 0xab,
 0x16, 0x5e, 0xc6, 0xfa, 0xe4, 0x75, 0x79, 0x74, 0x6d, 0x7e, 0x2c, 0xbd, 0x8a, 0xb1, 0x25, 0xec,
 0x6c, 0x31, 0x25, 0xd3, 0xa1, 0x56, 0x24, 0xbd, 0x94, 0xdd, 0x5c, 0x8e, 0xbb, 0x26, 0x8f, 0x62,
 0x17, 0xc1, 0xb1, 0x81, 0xf0, 0x6c, 0x3c, 0x89, 0x2f, 0x62, 0xac, 0x49, 0x7b, 0x1b, 0xab, 0x91,
 0xc3, 0xb6, 0x2b, 0x54, 0x9d, 0xf0, 0xac, 0x61, 0x7c, 0x21, 0xb4, 0x48, 0x3a, 0x76, 0x18, 0x1f,
 0x06, 0xc6, 0xea, 0xdd, 0x11, 0x69, 0x8f, 0x32, 0xa7, 0xc1, 0x30, 0x3e, 0x10, 0xd9, 0xf0, 0xac,
 0x61, 0x7c, 0x25, 0xe8, 0x6d, 0x8b, 0xb6, 0x57, 0x21, 0x4b, 0xe0, 0x98, 0x5f, 0x09, 0x06, 0xaf,
 0x82, 0x61, 0x7c, 0x13, 0x6d, 0x6e, 0xdb, 0x5c, 0x85, 0x2f, 0x85, 0x63, 0x0b, 0xe1, 0x58, 0x6c,
 0xf8, 0x56, 0x30, 0xbe, 0x15, 0x8d, 0xb1, 0x76, 0xd8, 0xb9, 0x53, 0xe1, 0x69, 0xcd, 0x0c, 0x0f,
 0x84, 0x83, 0x67, 0xc1, 0xb1, 0x82, 0x24, 0x2b, 0x1b, 0x62, 0xed, 0xd1, 0x72, 0xa7, 0xc1, 0xb1,
 0x85, 0xf0, 0xac, 0x35, 0x7c, 0x2b, 0x18, 0x1f, 0x0a, 0xc6, 0xda, 0xdd, 0xb6, 0xb7, 0x2b, 0x7c,
 0x2b, 0x18, 0x5f, 0x0a, 0xc3, 0x57, 0xc2, 0xb1, 0x81, 0xf0, 0x6c, 0x6d, 0x8b, 0xb6, 0xd6, 0xe5,
 0x8e, 0x66, 0x9d, 0x84, 0x15, 0xa3, 0x07, 0xc2, 0xb1, 0x85, 0xf0, 0x97, 0xb0, 0xd9, 0x16, 0x6d,
 0x8b, 0xa9, 0xb9, 0xa4, 0x15, 0xa5, 0xa7, 0x43, 0x5d, 0x4c, 0x6e, 0x61, 0x71, 0x65, 0xc5, 0x95,
 0xdc, 0xd2, 0x0a, 0xd2, 0xca, 0xb0, 0x82, 0xb4, 0xbd, 0xd5, 0x12, 0xae, 0xad, 0x20, 0xad, 0x2c,
 0xab, 0x48, 0x39, 0xaa, 0x56, 0xeb, 0xdd, 0x59, 0x5b, 0xc4, 0x8b, 0x9b, 0x62, 0xca, 0xb0, 0x83,
 0x9a, 0x66, 0x2c, 0xcc, 0x59, 0x5d, 0x5a, 0x41, 0xcd, 0x2c, 0xab, 0x48, 0x2b, 0x4b, 0xdd, 0x7b,
 0xab, 0xab, 0x48, 0x2b, 0x4b, 0x2a, 0xd2, 0x0e, 0x69, 0x9d, 0xd5, 0x12, 0xac, 0xac, 0xe2, 0x41,
 0x5a, 0x5a, 0x73, 0x48, 0x39, 0xa5, 0x44, 0xaa, 0x25, 0x59, 0x5a, 0x45, 0x5a, 0x59, 0x56, 0x10,
 0x56, 0x95, 0x16, 0x54, 0x59, 0x59, 0x5a, 0x41, 0xcd, 0x2c, 0xaa, 0x11, 0x56, 0x97, 0x16, 0x5c,
 0x59, 0x59, 0x5a, 0x45, 0xcd, 0x2c, 0x2b, 0x48, 0x39, 0xa6, 0x62, 0x59, 0xdd, 0x5d, 0x58, 0x45,
 0x5a, 0x58, 0x56, 0x91, 0x73, 0x4b, 0xdd, 0x5c, 0x95, 0xd5, 0xa4, 0x15, 0xa5, 0x95, 0x61, 0x05,
 0x69, 0x98, 0x95, 0xc4, 0xab, 0x2b, 0x08, 0x2b, 0x54, 0xb2, 0xad, 0x22, 0xad, 0x2f, 0x75, 0x44,
 0xab, 0x2b, 0x48, 0xab, 0x6c, 0x58, 0x56, 0x11, 0x56, 0xd8, 0xcc, 0x59, 0x51, 0x2a, 0xca, 0xc2,
 0x0a, 0xd2, 0xca, 0xb4, 0x8a, 0xb4, 0xbd, 0xd5, 0x12, 0xac, 0xad, 0x22, 0xad, 0x2c, 0x2b, 0x48,
 0xb9, 0xa5, 0x44, 0xaa, 0x2c, 0xac, 0xac, 0x20, 0xad, 0x2c, 0xab, 0x48, 0xab, 0x4a, 0xdd, 0x51,
 0x2a, 0xca, 0xd2, 0x2a, 0xd2, 0xc2, 0xb4, 0x8a, 0xb0, 0xcc, 0x4a, 0xb7, 0x56, 0x56, 0xf1, 0x22,
 0xad, 0x52, 0xc2, 0xb4, 0x8a, 0xb4, 0xbd, 0xd5, 0xc9, 0x83, 0x40, 0x32, 0x2b, 0x48, 0xab, 0x4c,
 0xc4, 0xab, 0x74, 0x40, 0x15, 0x14, 0x0c, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x42, 0x89, 0x29, 0x0e, 0x2a, 0x6a,
 0xc5, 0x45, 0x28, 0x4c, 0xe1, 0xfc, 0x3f, 0x14, 0xad, 0x2d, 0x3e, 0xa9, 0xc9, 0xc3, 0x38, 0x18,
 0x83, 0x5e, 0x9b, 0xaf, 0x44, 0x54, 0x3e, 0x03, 0x4c, 0xd3, 0x0f, 0x41, 0x7d, 0x3e, 0x2c, 0xa4,
 0x53, 0x18, 0x7e, 0x8a, 0xbe, 0x48, 0xbe, 0x34, 0x9b, 0x93, 0xb0, 0xdd, 0x37, 0x25, 0xe3, 0xa7,
 0x92, 0xa8, 0x8b, 0xd1, 0x4a, 0xb3, 0x12, 0x1c, 0x3f, 0x14, 0xe5, 0xe3, 0xd4, 0x3a, 0xbd, 0x47,
 0x4a, 0xdf, 0xc9, 0xa4, 0xc5, 0x96, 0x5e, 0x85, 0x68, 0x92, 0xf6, 0x36, 0xd9, 0x9c, 0x3f, 0xf9,
 0xa2, 0xd8, 0xf2, 0x2a, 0x9a, 0xf0, 0x39, 0x54, 0xcd, 0x12, 0xe8, 0xf3, 0xf4, 0xeb, 0x57, 0xe4,
 0xd6, 0xa2, 0x4b, 0x58, 0xab, 0x12, 0x5e, 0xc6, 0xc5, 0x1a, 0x55, 0x53, 0x9a, 0x15, 0x22, 0xcb,
 0xd8, 0xe4, 0x57, 0x23, 0xa9, 0xcb, 0xa3, 0x6b, 0xf1, 0x65, 0xd7, 0xa1, 0x5a, 0x24, 0xbd, 0x84,
 0xd9, 0xb7, 0x6a, 0x5b, 0x3e, 0xcb, 0x18, 0xec, 0xc6, 0x07, 0x8e, 0x63, 0xe9, 0x29, 0x88, 0x4b,
 0xee, 0xd5, 0x83, 0xec, 0x58, 0xcf, 0xdd, 0xde, 0x6a, 0x39, 0x38, 0xb5, 0x8a, 0x8b, 0xc1, 0x51,
 0x79, 0xf6, 0x89, 0x1f, 0xb6, 0xdd, 0x95, 0x2f, 0x2c, 0xd2, 0xdf, 0xd8, 0xa6, 0x3f, 0xe4, 0x36,
 0xd7, 0x34, 0x38, 0xd7, 0xe8, 0xba, 0x9b, 0xc6, 0xf5, 0xc7, 0x33, 0xf9, 0x36, 0xa8, 0x90, 0x34,
 0xec, 0x30, 0x3e, 0x0d, 0x8d, 0x56, 0x26, 0xda, 0x76, 0x5a, 0xbc, 0xb3, 0x3b, 0x57, 0xfd, 0x4e,
 0x3f, 0xfc, 0x86, 0x07, 0xed, 0x97, 0x66, 0x0b, 0xcb, 0x33, 0x37, 0xf6, 0x38, 0xff, 0x00, 0xf2,
 0x1b, 0xab, 0x9e, 0xbd, 0xdc, 0x4b, 0x74, 0x3d, 0x6c, 0x79, 0x62, 0xb7, 0xa4, 0xb6, 0xa7, 0xc1,
 0xb1, 0x85, 0xf0, 0xac, 0x6a, 0xae, 0xdb, 0x16, 0xcc, 0xd7, 0x96, 0x65, 0x6f, 0xec, 0x71, 0xff,
 0x00, 0xe4, 0x30, 0xbf, 0x6c, 0x1b, 0x36, 0x5e, 0x59, 0x91, 0xbf, 0xb2, 0x46, 0xff, 0x00, 0x90,
 0xdb, 0x19, 0xe9, 0xdd, 0xaf, 0xfe, 0x93, 0xd4, 0x23, 0xff, 0x00, 0xc6, 0xde, 0x92, 0xda, 0x9f,
 0x0a, 0xc6, 0x07, 0xc2, 0xb1, 0xab, 0xbb, 0x6b, 0xbb, 0x38, 0x5f, 0xe5, 0x1b, 0x7f, 0x64, 0x8d,
 0xff, 0x00, 0x21, 0x8d, 0xdb, 0x5b, 0xd9, 0xd2, 0xff, 0x00, 0x28, 0xdb, 0xfb, 0x2c, 0x6f, 0xf9,
 0x0d, 0x91, 0xa9, 0xa7, 0x75, 0xc7, 0x4b, 0xd7, 0xff, 0x00, 0xe1, 0xb7, 0xa4, 0xb6, 0x67, 0xc2,
 0x30, 0xbe, 0x0d, 0x8c, 0x19, 0x5b, 0x34, 0x65, 0xec, 0xd4, 0xd9, 0x97, 0x60, 0x18, 0x82, 0x4e,
 0x24, 0xb6, 0xea, 0x46, 0x54, 0x84, 0xf6, 0x6e, 0xef, 0x6b, 0xa7, 0xe3, 0x22, 0x74, 0x5f, 0x90,
 0x6c, 0xf8, 0x3a, 0x9c, 0x8a, 0x65, 0x8b, 0x46, 0xf0, 0xd1, 0x92, 0xb9, 0x30, 0xde, 0x69, 0x92,
 0x26, 0x26, 0x3e, 0x52, 0x52, 0xf8, 0x46, 0x27, 0xc2, 0xb0, 0xd5, 0xf0, 0x8c, 0x2f, 0x84, 0x6e,
 0x8b, 0xb3, 0x19, 0x0a, 0x5f, 0x0a, 0xc6, 0x17, 0xc2, 0xb0, 0xda, 0x24, 0x23, 0x03, 0xe0, 0xaf,
 0x43, 0x6c, 0x5d, 0xb6, 0x32, 0x15, 0x3e, 0x0d, 0x8c, 0x2f, 0x82, 0x9d, 0x06, 0xaf, 0x85, 0x63,
 0x0b, 0xe1, 0x1b, 0x6b, 0x76, 0xda, 0xdc, 0xa9, 0xf0, 0xac, 0x61, 0x7c, 0x24, 0xe8, 0x35, 0x7c,
 0x2b, 0x18, 0x5f, 0x0a, 0xc6, 0xda, 0xdd, 0xb6, 0xb7, 0x2a, 0x74, 0x3b, 0x18, 0x9c, 0xcb, 0x0c,
 0xdf, 0x04, 0xc2, 0xf8, 0x36, 0x36, 0xc5, 0xf7, 0x6d, 0x8b, 0xa8, 0x2b, 0x48, 0x39, 0xa5, 0xc7,
 0x41, 0x53, 0x13, 0xa1, 0xaf, 0x42, 0xe2, 0xcd, 0x91, 0x65, 0x65, 0x69, 0x05, 0x61, 0x65, 0x5a,
 0x41, 0x5a, 0x5e, 0xea, 0x89, 0x57, 0x56, 0x18, 0xdc, 0xdb, 0x16, 0x95, 0xa4, 0x15, 0xa5, 0x6e,
 0xb8, 0xb2, 0xba, 0xb4, 0x83, 0x9a, 0x59, 0x73, 0x48, 0x2b, 0x4c, 0xee, 0xa8, 0xb2, 0xb2, 0xb1,
 0x08, 0xab, 0x4b, 0x2a, 0xd2, 0x0a, 0xd2, 0xe2, 0x55, 0xba, 0xba, 0xb4, 0x82, 0xb5, 0x0b, 0x2e,
 0x69, 0x05, 0x69, 0x5b, 0xaa, 0x25, 0x59, 0x5a, 0xa4, 0x5c, 0xd2, 0xca, 0xb4, 0x83, 0x9a, 0x66,
 0x25, 0x51, 0x65, 0x65, 0x69, 0x17, 0x36, 0xc5, 0x85, 0x61, 0x05, 0x61, 0x5b, 0xaa, 0x25, 0x5d,
 0x58, 0x45, 0xcd, 0x2c, 0x2b, 0x48, 0xab, 0x4b, 0x8b, 0x2b, 0x92, 0xb2, 0xb4, 0x8b, 0x9a, 0x58,
 0x73, 0x48, 0xb9, 0xa5, 0x44, 0xaf, 0x75, 0x65, 0x61, 0x17, 0x34, 0xb0, 0xad, 0x22, 0xad, 0x2a,
 0x25, 0x51, 0x65, 0x65, 0x6f, 0x12, 0x2a, 0xd2, 0xcb, 0x9a, 0x41, 0x58, 0x66, 0x25, 0x51, 0x65,
 0x75, 0x69, 0x05, 0x69, 0x61, 0x5b, 0xc4, 0x8a, 0xb4, 0xb8, 0xb2, 0xa2, 0x55, 0x95, 0xbc, 0x48,
 0x2b, 0x4b, 0x2a, 0xd2, 0x2a, 0xce, 0x86, 0x77, 0x54, 0x4a, 0xb2, 0xb7, 0x89, 0x15, 0x69, 0x61,
 0x58, 0x45, 0x5a, 0x54, 0x59, 0x51, 0x2a, 0xca, 0xd5, 0x22, 0xad, 0x2c, 0x2a, 0x58, 0x8b, 0x9a,
 0x5e, 0xea, 0x8b, 0x2b, 0x2b, 0x78, 0x91, 0x73, 0x4b, 0x0a, 0xd2, 0x2a, 0xd2, 0xa2, 0x55, 0x12,
 0xac, 0xad, 0x21, 0xbb, 0xc0, 0xb2, 0xad, 0x22, 0xad, 0x33, 0xba, 0xb9, 0x2b, 0x2b, 0x48, 0xb9,
 0xa5, 0x85, 0x67, 0x12, 0x2a, 0xd2, 0xa2, 0xca, 0x89, 0x57, 0xd1, 0x4f, 0x38, 0xf4, 0x27, 0x19,
 0xf0, 0xa1, 0x26, 0xf4, 0x58, 0x8d, 0x62, 0x75, 0x72, 0xa2, 0x14, 0xe2, 0x62, 0x78, 0x7b, 0x1d,
 0xa7, 0xb2, 0x9a, 0xbe, 0x84, 0x55, 0x35, 0xe4, 0xd5, 0xe1, 0xc5, 0x3b, 0x5e, 0xf1, 0x1f, 0x79,
 0x6e, 0xad, 0x2f, 0x7f, 0x28, 0xdd, 0x67, 0xe2, 0x02, 0x9b, 0x71, 0x3c, 0x3d, 0xdc, 0x12, 0x69,
 0xa9, 0xe9, 0x45, 0x42, 0xc4, 0x38, 0xb0, 0xa2, 0xa6, 0xb0, 0xa2, 0xb5, 0xe9, 0xfc, 0xd5, 0xd4,
 0x63, 0xd5, 0xe0, 0xcb, 0x3b, 0x52, 0xf1, 0x3f, 0x9b, 0x36, 0xc5, 0x7a, 0xf9, 0xc3, 0x20, 0x00,
 0x1c, 0x84, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf4, 0x1a, 0x0c,
 0xdd, 0xcb, 0xb0, 0x67, 0x15, 0x17, 0x99, 0xab, 0x42, 0x99, 0xb9, 0x72, 0x0c, 0xcd, 0xcf, 0xce,
 0xbc, 0x9d, 0xd5, 0x72, 0x36, 0xd9, 0x79, 0xe5, 0x45, 0x4f, 0x28, 0x67, 0x2d, 0x89, 0x39, 0x13,
 0x45, 0x76, 0xa9, 0xd0, 0xd2, 0xa0, 0xcd, 0x2f, 0x0e, 0x25, 0xe8, 0x33, 0x8b, 0xc3, 0xca, 0x2e,
 0x2c, 0xdf, 0x5c, 0xad, 0xd1, 0x91, 0xe5, 0xe3, 0xa6, 0x8a, 0x88, 0x8a, 0x42, 0x34, 0x93, 0x5e,
 0x9a, 0xb7, 0x47, 0x7a, 0x0d, 0x6e, 0x04, 0xee, 0x9f, 0x94, 0x32, 0x95, 0xc4, 0x15, 0x34, 0xf2,
 0xf4, 0xf8, 0xcd, 0xb5, 0xcb, 0x30, 0xb9, 0x8a, 0x64, 0xff, 0x00, 0x14, 0x3d, 0x98, 0xc3, 0xf9,
 0xf9, 0x22, 0xd9, 0x89, 0x0d, 0x35, 0xd1, 0x0d, 0x8e, 0x0c, 0xf4, 0x38, 0x88, 0x89, 0x11, 0x11,
 0x6e, 0x84, 0xdf, 0x02, 0x0c, 0x64, 0xd5, 0x8a, 0x9e, 0x85, 0x39, 0x54, 0xd4, 0x38, 0x19, 0xfa,
 0x6d, 0x2f, 0xe3, 0x0f, 0xcd, 0x8f, 0x0b, 0x36, 0xd3, 0xdb, 0xe6, 0x63, 0x67, 0x4f, 0x63, 0x7f,
 0xc3, 0x42, 0x39, 0x49, 0xd7, 0xfc, 0x32, 0x61, 0xd2, 0xf0, 0x8e, 0xcd, 0x2c, 0xe9, 0xec, 0x5f,
 0xf8, 0x58, 0x47, 0x20, 0x3b, 0x1a, 0xce, 0xf1, 0xbb, 0xb1, 0xc5, 0x5e, 0x14, 0xad, 0x7b, 0x40,
 0x01, 0xae, 0x57, 0xcb, 0x98, 0xee, 0x68, 0xc4, 0xfc, 0x5b, 0x97, 0xb0, 0xa9, 0xbc, 0x52, 0x71,
 0x21, 0xba, 0x2d, 0x19, 0x68, 0x6a, 0xf7, 0xee, 0x26, 0x9a, 0xbb, 0x44, 0xec, 0x4d, 0x50, 0xd9,
 0xd7, 0x63, 0xbb, 0x50, 0x4e, 0x79, 0x0b, 0x30, 0x27, 0xfa, 0x9b, 0x8c, 0xb3, 0x6c, 0x94, 0xaf,
 0xf8, 0xa7, 0x66, 0x86, 0x06, 0xf4, 0xbb, 0x20, 0xda, 0x7a, 0x7f, 0x21, 0x71, 0xff, 0x00, 0xd8,
 0xdc, 0x45, 0x76, 0x47, 0xb4, 0xc4, 0xe7, 0x91, 0xf1, 0xef, 0xd9, 0x1c, 0x11, 0xf1, 0x18, 0xbe,
 0xa8, 0xf5, 0x86, 0x8e, 0x06, 0xee, 0xbb, 0x25, 0xda, 0x52, 0x73, 0xc9, 0x18, 0xef, 0xec, 0x8e,
 0x22, 0xbb, 0x28, 0xda, 0x3a, 0x73, 0xc9, 0x58, 0xe7, 0xec, 0xaa, 0x67, 0x66, 0x3e, 0x2b, 0x07,
 0xd7, 0x1e, 0xb0, 0xe9, 0x9e, 0x08, 0xac, 0xdf, 0x97, 0xcc, 0xbf, 0xa5, 0x2d, 0xf4, 0x44, 0x3b,
 0xab, 0xe1, 0x58, 0xe5, 0xbe, 0x0b, 0xb9, 0x4b, 0x31, 0x65, 0xd8, 0x39, 0x85, 0xb8, 0xfe, 0x0b,
 0x3b, 0x86, 0xac, 0x77, 0x4b, 0xac, 0x1f, 0x64, 0xc2, 0x56, 0x6f, 0xe8, 0x91, 0x35, 0xd3, 0xae,
 0x9a, 0xa7, 0xca, 0x76, 0x38, 0x92, 0xfa, 0x76, 0x1d, 0x86, 0x0b, 0xed, 0x48, 0x87, 0xca, 0xbd,
 0xa4, 0x9e, 0x7d, 0x47, 0x25, 0xab, 0x3b, 0xc7, 0x87, 0xe9, 0x05, 0x0e, 0x85, 0x63, 0x0b, 0xe0,
 0xd8, 0x6b, 0x12, 0x0a, 0x98, 0x5f, 0x04, 0xe5, 0x56, 0xee, 0x8e, 0x2e, 0x52, 0xf8, 0x46, 0x17,
 0xc2, 0x1a, 0xbe, 0x15, 0x8c, 0x2f, 0x83, 0xc0, 0xdb, 0x5b, 0xb6, 0xd6, 0xe5, 0x2f, 0x85, 0x63,
 0x0b, 0xe0, 0xd8, 0x6c, 0xf8, 0x2a, 0x60, 0x7c, 0x23, 0x6d, 0x6e, 0xdb, 0x5b, 0x95, 0x3e, 0x12,
 0x74, 0x30, 0xbe, 0x15, 0x86, 0xcf, 0x83, 0x63, 0x03, 0xe0, 0x9b, 0x62, 0xed, 0xd5, 0xc8, 0x52,
 0xf8, 0x49, 0xd0, 0xc2, 0xf8, 0x56, 0x1b, 0x3e, 0x15, 0x8c, 0x2f, 0x84, 0x6d, 0xad, 0xdb, 0x63,
 0x21, 0x4b, 0xe1, 0x58, 0xc2, 0xf8, 0x56, 0x1b, 0x3e, 0x12, 0xf4, 0x30, 0xbe, 0x15, 0x8d, 0xb1,
 0x76, 0xda, 0xe4, 0x29, 0x74, 0x2e, 0x26, 0x27, 0x43, 0xd0, 0x68, 0xf8, 0x36, 0x30, 0xbe, 0x15,
 0x8d, 0xb5, 0xbb, 0x6c, 0x64, 0x2d, 0x73, 0x7a, 0x90, 0x73, 0x74, 0x2f, 0xbe, 0x09, 0x85, 0xd0,
 0x94, 0xd9, 0x16, 0x6c, 0x8b, 0xaa, 0x2b, 0x48, 0x2b, 0x4b, 0x4e, 0x62, 0x98, 0xdc, 0xd2, 0xe2,
 0xcd, 0x91, 0x65, 0x75, 0x69, 0x05, 0x6f, 0x42, 0xca, 0xb4, 0x82, 0xb4, 0xa8, 0x95, 0x6e, 0xae,
 0xe6, 0x90, 0x56, 0x96, 0x55, 0xa4, 0x1c, 0xd2, 0xb7, 0x54, 0x4a, 0xba, 0xb6, 0xc4, 0x1c, 0xd2,
 0xca, 0xb4, 0x82, 0xb4, 0xa8, 0xb2, 0xa2, 0x55, 0x95, 0x84, 0x55, 0xa5, 0x95, 0x69, 0x07, 0x34,
 0xa8, 0x95, 0x44, 0xab, 0xab, 0x10, 0x83, 0x9a, 0x59, 0x56, 0x90, 0x56, 0x95, 0xba, 0xe2, 0x55,
 0x95, 0x84, 0x1c, 0xd2, 0xd2, 0xb6, 0xc4, 0x15, 0xa5, 0x44, 0xb3, 0xba, 0xb2, 0xb5, 0x08, 0x2b,
 0x4b, 0x2a, 0xc2, 0x0a, 0xd2, 0xb9, 0x2e, 0x2c, 0xae, 0xac, 0x20, 0xe6, 0x96, 0x55, 0xa4, 0x15,
 0xa5, 0x44, 0xaa, 0x2c, 0xc0, 0xad, 0x20, 0xe6, 0x16, 0x5c, 0xd3, 0x1a, 0xb4, 0xa8, 0x95, 0x44,
 0xab, 0xab, 0x08, 0xab, 0x4b, 0x0a, 0xd2, 0x2e, 0x69, 0x51, 0x2a, 0xdd, 0x59, 0x5b, 0xc4, 0x8b,
 0x9a, 0x59, 0x56, 0x10, 0x56, 0x95, 0x12, 0xad, 0xd5, 0x95, 0xb6, 0x22, 0xe6, 0x96, 0x15, 0xbc,
 0x48, 0xb9, 0xa5, 0x44, 0xab, 0x92, 0xb2, 0xb7, 0x89, 0x15, 0x69, 0x61, 0x58, 0x45, 0x5a, 0x54,
 0x4a, 0xe2, 0x55, 0x95, 0xa4, 0x5c, 0xdb, 0x16, 0x15, 0xbc, 0x48, 0xab, 0x4a, 0x8b, 0x2a, 0x2c,
 0xac, 0xe4, 0x44, 0x45, 0x57, 0x2a, 0x22, 0x22, 0x6a, 0xba, 0x9a, 0xc6, 0x31, 0x98, 0x1d, 0xbe,
 0xe8, 0x32, 0x3c, 0x1a, 0x9c, 0x16, 0x2a, 0xa7, 0x15, 0xf4, 0x74, 0x2d, 0x67, 0x39, 0xe5, 0x83,
 0x09, 0x92, 0x30, 0x97, 0x47, 0x44, 0x4d, 0xe8, 0x9f, 0xa3, 0xd8, 0x9f, 0x19, 0xa9, 0x2f, 0x33,
 0xc9, 0x75, 0xce, 0xb3, 0x92, 0x97, 0x9d, 0x3e, 0x19, 0xdb, 0x6f, 0x39, 0xfe, 0x8e, 0xef, 0xa7,
 0xe8, 0xeb, 0x35, 0xf7, 0x97, 0xf9, 0xf9, 0x25, 0x16, 0x23, 0xe2, 0xb9, 0x5f, 0x11, 0xee, 0x7b,
 0x97, 0xb5, 0x57, 0x52, 0x07, 0xad, 0x45, 0x55, 0xd1, 0x13, 0x98, 0xd2, 0x5b, 0x00, 0xc4, 0x63,
 0x31, 0x1d, 0x45, 0x21, 0xa2, 0xf2, 0xa8, 0xed, 0x3e, 0x63, 0xcc, 0x62, 0xc1, 0x9b, 0x51, 0x6f,
 0xd8, 0xac, 0xda, 0x7d, 0x5d, 0xad, 0xaf, 0x4c, 0x71, 0xfb, 0x53, 0xb1, 0x51, 0x38, 0x6f, 0x7c,
 0x37, 0x23, 0x98, 0xe7, 0x35, 0x53, 0xb5, 0x17, 0x42, 0xfc, 0xde, 0x0b, 0x3f, 0x2c, 0xc5, 0x88,
 0xf8, 0x3b, 0xcc, 0x4e, 0x2a, 0xac, 0x5d, 0x74, 0x17, 0x2f, 0x0e, 0x46, 0x32, 0x61, 0xcb, 0xa7,
 0xb6, 0xd7, 0x89, 0xac, 0x95, 0xbd, 0x6f, 0x1b, 0xd6, 0x77, 0x3c, 0xc2, 0xf1, 0x95, 0x57, 0x24,
 0x19, 0xb5, 0xd5, 0x17, 0x82, 0x44, 0xe9, 0xe9, 0x1e, 0xe9, 0xc3, 0x54, 0xd0, 0xd1, 0x90, 0xd9,
 0x72, 0xcc, 0xda, 0xc6, 0x84, 0xe9, 0x58, 0x8b, 0xab, 0x98, 0x9a, 0xb3, 0xae, 0x9d, 0x0f, 0x59,
 0xd0, 0x3a, 0xd6, 0x4b, 0xde, 0x34, 0xf9, 0xe7, 0x7d, 0xfc, 0xa7, 0xfa, 0x3a, 0xed, 0x6e, 0x96,
 0x22, 0xbe, 0xf2, 0x9f, 0x99, 0xa0, 0x13, 0x73, 0x48, 0xe8, 0x7b, 0x3d, 0xdd, 0x4b, 0xc0, 0x05,
 0x45, 0x3c, 0xe2, 0x19, 0x7a, 0x00, 0x01, 0x80, 0x00, 0x00, 0x7d, 0xa5, 0x0a, 0x62, 0xe5, 0xa8,
 0x53, 0x17, 0x35, 0xf8, 0x73, 0x17, 0x2c, 0xc3, 0x98, 0xb9, 0xf9, 0xbe, 0x25, 0xcc, 0xad, 0xdb,
 0x14, 0x29, 0x9b, 0x96, 0xa1, 0x4c, 0xf1, 0xe6, 0x6b, 0x90, 0xa6, 0x2e, 0x5a, 0x85, 0x33, 0x72,
 0xe2, 0xcd, 0xb5, 0xc8, 0xd9, 0x20, 0xcd, 0x5c, 0xbb, 0x06, 0x6e, 0xe6, 0xb1, 0x0a, 0x66, 0xe5,
 0xb8, 0x53, 0x37, 0x2a, 0x2c, 0xdd, 0x5c, 0x8d, 0xa6, 0x04, 0xe2, 0xa7, 0x68, 0xc2, 0x5e, 0x7d,
 0x53, 0x8e, 0xf1, 0xa8, 0xc2, 0x9a, 0x5e, 0xa5, 0xc8, 0x33, 0x6a, 0x9d, 0xa5, 0xf2, 0x6f, 0xae,
 0x57, 0xc3, 0xde, 0x18, 0x71, 0x56, 0x37, 0x84, 0x4e, 0x67, 0x88, 0xab, 0xae, 0xbe, 0xc5, 0xff,
 0x00, 0x85, 0x84, 0x72, 0x23, 0xa9, 0xf8, 0x57, 0x3f, 0x7f, 0x6f, 0x79, 0x8d, 0xdd, 0x7d, 0x8d,
 0xff, 0x00, 0x0d, 0x08, 0xe5, 0x87, 0x7f, 0x8b, 0xfc, 0x11, 0xf6, 0x72, 0xeb, 0x3b, 0xc6, 0xee,
 0xfd, 0xe0, 0x1d, 0x09, 0x23, 0x6d, 0xc1, 0xec, 0x54, 0xd7, 0xf0, 0x3c, 0xd7, 0xf5, 0x0f, 0xb9,
 0xe6, 0x70, 0xe6, 0xfb, 0xc4, 0xf9, 0x0f, 0x86, 0x7c, 0x03, 0x23, 0x50, 0xdb, 0x93, 0x9f, 0xff,
 0x00, 0xb3, 0xcd, 0x7f, 0x50, 0xfb, 0xf2, 0x1c, 0xdc, 0x08, 0xc9, 0xe5, 0xa2, 0x25, 0xd0, 0xe2,
 0x67, 0xcb, 0xc3, 0x26, 0xce, 0x36, 0x7d, 0x2d, 0x33, 0x79, 0xf9, 0xb5, 0x79, 0x8c, 0x3d, 0x13,
 0x93, 0x7e, 0x62, 0x84, 0x69, 0x4d, 0x3f, 0x21, 0x3e, 0x43, 0x78, 0x89, 0x2b, 0x0e, 0x2b, 0x75,
 0x62, 0xa2, 0x94, 0x26, 0x70, 0xfe, 0x7e, 0x49, 0x78, 0xf5, 0x0e, 0x97, 0x51, 0xd2, 0x67, 0xe4,
 0xd3, 0x22, 0xcb, 0x27, 0xbd, 0x4f, 0x90, 0xab, 0x12, 0x59, 0x3d, 0xea, 0x1b, 0x5c, 0xce, 0x1f,
 0xa7, 0xe4, 0x8b, 0xa3, 0xc9, 0xaa, 0x76, 0x1c, 0xaa, 0x66, 0x89, 0x74, 0x99, 0xfa, 0x7c, 0xd7,
 0xe4, 0xd7, 0x22, 0x4b, 0x27, 0x62, 0x27, 0xc8, 0x56, 0x8b, 0x2f, 0x63, 0x61, 0x8b, 0x2d, 0xa2,
 0xf2, 0x2a, 0xc4, 0x96, 0x4e, 0x86, 0xfa, 0xe4, 0x75, 0x59, 0x74, 0x6d, 0x7a, 0x2c, 0x0d, 0x39,
 0xa1, 0x56, 0x24, 0x04, 0xff, 0x00, 0xb5, 0x39, 0xef, 0x85, 0x9e, 0x3d, 0x8e, 0xe5, 0x7c, 0x9d,
 0x84, 0x4d, 0xe0, 0x38, 0xac, 0xde, 0x1b, 0x1e, 0x36, 0x22, 0xe8, 0x71, 0x1f, 0x2f, 0x11, 0x58,
 0xae, 0x6a, 0x42, 0x55, 0xd1, 0x55, 0x3b, 0x35, 0xe2, 0x7c, 0xd5, 0xee, 0xa7, 0xb4, 0x55, 0xe7,
 0x9c, 0xf1, 0xaf, 0xda, 0x94, 0xd9, 0xef, 0xf6, 0x72, 0xb4, 0xde, 0xcb, 0xe4, 0xd6, 0x62, 0x8c,
 0xb5, 0xbc, 0x44, 0x4b, 0xec, 0xf8, 0x90, 0x4c, 0x0f, 0x85, 0x63, 0xe7, 0x1d, 0x82, 0xe7, 0xac,
 0xe5, 0x8e, 0xed, 0x57, 0x08, 0xc2, 0xb1, 0x5c, 0xc9, 0x89, 0xcf, 0x49, 0xc6, 0x48, 0xd5, 0x20,
 0x46, 0x8e, 0xae, 0x6b, 0xf4, 0x82, 0xf5, 0x4d, 0x53, 0xd2, 0x88, 0xa3, 0xed, 0xba, 0x6d, 0x8a,
 0x62, 0x4f, 0x13, 0x8f, 0x96, 0xb2, 0x7c, 0xd3, 0x61, 0x3a, 0x02, 0xac, 0x39, 0xbc, 0x41, 0x9a,
 0x2a, 0xef, 0xa7, 0x05, 0x64, 0x35, 0xec, 0xd3, 0xb5, 0xdc, 0xf5, 0xe5, 0xcb, 0x55, 0xdb, 0x5d,
 0x4c, 0x6d, 0xbc, 0xb8, 0xb9, 0x3d, 0x96, 0xd5, 0x57, 0x55, 0x1a, 0x7a, 0x4c, 0x4e, 0xf1, 0xbe,
 0xff, 0x00, 0x28, 0xfb, 0xbb, 0x54, 0x48, 0x5a, 0x2e, 0x8a, 0x9a, 0x59, 0x4c, 0x2f, 0x83, 0xc3,
 0x5d, 0x17, 0x4e, 0xc5, 0x3e, 0x1d, 0x9e, 0xc4, 0xf1, 0x09, 0xf8, 0xee, 0x8f, 0x3b, 0x3d, 0x35,
 0x33, 0x15, 0x79, 0xbe, 0x2c, 0x67, 0x39, 0x7e, 0x55, 0x51, 0x96, 0x01, 0x9c, 0x73, 0x46, 0x05,
 0x15, 0xb1, 0x30, 0xac, 0x72, 0x7a, 0x5d, 0x13, 0xf2, 0x2a, 0xab, 0x98, 0xbe, 0x96, 0xae, 0xa8,
 0xbf, 0x20, 0x8d, 0x6f, 0x78, 0x76, 0xb3, 0xec, 0x5e, 0x48, 0xaf, 0xec, 0xe6, 0x8d, 0xfe, 0xde,
 0x1f, 0xaf, 0xf4, 0x7d, 0x93, 0x12, 0x15, 0x8c, 0x0f, 0x84, 0x63, 0xc9, 0x11, 0xb1, 0x5c, 0x43,
 0x27, 0xe1, 0x53, 0xf8, 0xd3, 0x21, 0x37, 0x10, 0x99, 0x96, 0x6c, 0x58, 0xcd, 0x86, 0xcd, 0xd4,
 0x4d, 0xee, 0x29, 0xc3, 0xb1, 0x74, 0xd3, 0x5b, 0x96, 0xb1, 0x89, 0xa9, 0x3c, 0x2b, 0x0d, 0x8f,
 0x88, 0xe2, 0x33, 0x0c, 0x96, 0x95, 0x80, 0xc5, 0x7c, 0x58, 0x8f, 0x5e, 0x0d, 0x4f, 0xfb, 0xe1,
 0xa7, 0x53, 0x9d, 0x5c, 0xb1, 0xb6, 0xef, 0x1f, 0x34, 0xb5, 0x72, 0xce, 0x28, 0xf1, 0x98, 0x9d,
 0xbc, 0x3e, 0x73, 0xe5, 0xe0, 0xa8, 0xf8, 0x25, 0x78, 0xed, 0x64, 0x26, 0x2b, 0xe2, 0xb9, 0xb0,
 0xda, 0x9c, 0xd5, 0xca, 0x88, 0x9f, 0x2a, 0x9c, 0x23, 0x3f, 0x6d, 0xa3, 0x17, 0xc4, 0x63, 0xc4,
 0x95, 0xcb, 0x28, 0xb8, 0x5c, 0x92, 0x2a, 0xa2, 0x47, 0x56, 0xa2, 0xc7, 0x88, 0x9d, 0x75, 0x5e,
 0x0c, 0xf4, 0x27, 0x1b, 0x9c, 0xbb, 0x11, 0xc4, 0xf1, 0x1c, 0x46, 0x2a, 0xc5, 0x9f, 0x9e, 0x99,
 0x9a, 0x88, 0xab, 0xaa, 0xba, 0x34, 0x57, 0x3d, 0x7e, 0x75, 0x34, 0x5b, 0xa8, 0x45, 0x67, 0x6a,
 0xc6, 0xef, 0x5d, 0xa3, 0xf6, 0x53, 0x51, 0x92, 0xb1, 0x6c, 0xd6, 0x8a, 0xfe, 0x1e, 0x72, 0xfa,
 0xda, 0x2e, 0x27, 0x84, 0x35, 0x74, 0x76, 0x2b, 0x87, 0xb5, 0x7a, 0x2c, 0xdc, 0x34, 0xfd, 0xe4,
 0x19, 0x39, 0x87, 0x46, 0x5d, 0xd8, 0x38, 0x84, 0x9c, 0x55, 0xe8, 0xc9, 0x86, 0x3b, 0xe8, 0x53,
 0xe4, 0x1d, 0x4f, 0x51, 0x74, 0xe2, 0x9c, 0x16, 0xc4, 0xc7, 0x53, 0xb4, 0x7f, 0x95, 0xd9, 0x7f,
 0xda, 0x58, 0xf6, 0xf0, 0xcb, 0x3e, 0x9f, 0xee, 0xfb, 0x05, 0xf0, 0x57, 0x4d, 0x74, 0xe1, 0xd4,
 0xc2, 0xf8, 0x56, 0x3e, 0x5b, 0xc1, 0x73, 0x36, 0x3f, 0x83, 0xc5, 0x47, 0xe1, 0xd8, 0xb4, 0xdc,
 0x0d, 0xdf, 0xc8, 0x48, 0x8a, 0xac, 0x5f, 0x4b, 0x57, 0x82, 0xfc, 0x87, 0x62, 0xd9, 0xc6, 0xd3,
 0xe0, 0xe3, 0x53, 0x30, 0xb0, 0x9c, 0x7d, 0x90, 0xe5, 0x67, 0x62, 0x2a, 0x36, 0x14, 0xc3, 0x38,
 0x43, 0x8a, 0xee, 0xc4, 0x54, 0xfc, 0x97, 0x2f, 0xc8, 0xb6, 0x39, 0x78, 0x3a, 0x95, 0x2f, 0x3b,
 0x5b, 0xc1, 0xd6, 0x6b, 0xbd, 0x9e, 0xd4, 0xe9, 0x6b, 0x39, 0x29, 0x3c, 0xe2, 0x3b, 0x79, 0xfa,
 0x37, 0xc7, 0xc2, 0xb1, 0x81, 0xf0, 0x86, 0xcf, 0x84, 0x61, 0x7c, 0x2b, 0x1d, 0x9c, 0x5d, 0xd0,
 0xc5, 0xca, 0x1f, 0x0b, 0xa9, 0x89, 0xf0, 0x8a, 0x1b, 0x4f, 0x98, 0x9b, 0xc3, 0xb2, 0x46, 0x23,
 0x3b, 0x25, 0x31, 0x12, 0x5e, 0x62, 0x12, 0x43, 0x56, 0x44, 0x86, 0xba, 0x39, 0xba, 0xc4, 0x6a,
 0x2e, 0x8b, 0xe8, 0x53, 0x85, 0x2e, 0x73, 0xcd, 0x5f, 0xe3, 0xfc, 0x43, 0xbe, 0x53, 0x8d, 0x9f,
 0xa9, 0x57, 0x4f, 0x6e, 0x33, 0x1b, 0xbb, 0xee, 0x9b, 0xd2, 0x32, 0xeb, 0xb1, 0x7b, 0xca, 0x5a,
 0x22, 0x37, 0xd9, 0xdf, 0x9c, 0xcd, 0x08, 0x39, 0x87, 0x0f, 0xc0, 0xf3, 0x6e, 0x65, 0x8f, 0x8d,
 0x48, 0xc1, 0x8b, 0x8d, 0xcf, 0x3e, 0x1c, 0x49, 0x98, 0x6d, 0x73, 0x56, 0x2a, 0xe8, 0xa8, 0xae,
 0x44, 0x54, 0x3a, 0xd6, 0x78, 0xcd, 0x18, 0x6e, 0x59, 0x84, 0xa9, 0x1b, 0xfb, 0x3c, 0xe3, 0xf8,
 0xc2, 0x96, 0x62, 0xe8, 0xaa, 0x9d, 0x55, 0x7b, 0x1a, 0x6c, 0xd3, 0xf5, 0x2c, 0x79, 0x69, 0x36,
 0x9f, 0x08, 0x85, 0xea, 0x7a, 0x4e, 0x7c, 0x19, 0x29, 0x8e, 0x3f, 0x6a, 0x6d, 0xd8, 0xd1, 0x5b,
 0xaa, 0xe8, 0x89, 0xaa, 0xd8, 0x83, 0x93, 0x4e, 0x07, 0x0e, 0xc7, 0x73, 0xae, 0x3f, 0x8a, 0xc4,
 0x76, 0xf4, 0xeb, 0xa5, 0xa0, 0xaf, 0x28, 0x32, 0xeb, 0xb8, 0xd4, 0xf8, 0xd3, 0x8a, 0xfc, 0x6a,
 0x6b, 0xef, 0x8f, 0x19, 0xee, 0xde, 0x74, 0x58, 0x8e, 0x72, 0xf6, 0xab, 0x97, 0x53, 0x8d, 0x7e,
 0xb9, 0x48, 0x9f, 0xd9, 0xae, 0xee, 0xcb, 0x17, 0xb3, 0x99, 0x26, 0xbb, 0xe4, 0xbc, 0x44, 0xfe,
 0x1e, 0x2f, 0xa3, 0xd5, 0xbd, 0xba, 0x29, 0x07, 0x30, 0xe0, 0xb8, 0x4e, 0x63, 0xc6, 0xb0, 0xc8,
 0x88, 0xe9, 0x4c, 0x46, 0x61, 0xa8, 0x9f, 0x90, 0xe7, 0x6f, 0x31, 0x7d, 0x2d, 0x5e, 0x07, 0x53,
 0xc8, 0xf9, 0xc2, 0x5f, 0x30, 0x27, 0xb1, 0x26, 0x58, 0xd9, 0x7c, 0x41, 0xa9, 0xae, 0xe2, 0x2f,
 0x93, 0x11, 0x13, 0x9a, 0xb7, 0xa2, 0xd8, 0xe5, 0x69, 0x7a, 0xae, 0x2c, 0xf3, 0xc6, 0x7c, 0x25,
 0xc5, 0xd6, 0x74, 0x6c, 0xda, 0x6a, 0xf3, 0x89, 0xe5, 0x1f, 0xa3, 0x65, 0x56, 0x98, 0xd5, 0xbd,
 0x85, 0x4c, 0xcb, 0x8d, 0xc8, 0x60, 0x32, 0x5e, 0xc9, 0x9d, 0x7a, 0xea, 0xee, 0x10, 0xe1, 0xb7,
 0xf1, 0xe2, 0x2d, 0xbd, 0x67, 0x29, 0xc7, 0xf3, 0xbe, 0x37, 0x89, 0x44, 0x73, 0x60, 0xc6, 0x59,
 0x19, 0x75, 0xe5, 0x0e, 0x0a, 0xe8, 0xba, 0x5d, 0xdc, 0xd4, 0xdd, 0xaa, 0xea, 0x58, 0xb4, 0xde,
 0x16, 0xf1, 0x9e, 0xd0, 0xd5, 0xa1, 0xe9, 0x99, 0xf5, 0x71, 0xca, 0xbe, 0x15, 0xef, 0x2e, 0xc0,
 0xe6, 0xe8, 0xbc, 0x78, 0x10, 0x56, 0xf0, 0xd7, 0x4e, 0x07, 0xcf, 0xb1, 0x63, 0xc7, 0x8a, 0xfd,
 0xf8, 0x91, 0xa2, 0x3d, 0xdd, 0x5c, 0xf5, 0x55, 0x2d, 0x48, 0xe2, 0xd8, 0x9c, 0x8b, 0xd1, 0xf2,
 0xb3, 0xf3, 0x10, 0xb4, 0x5e, 0x4d, 0x7a, 0xe9, 0xf2, 0x72, 0x38, 0x35, 0xeb, 0xf5, 0xdf, 0xc6,
 0x9f, 0xcd, 0xda, 0xcf, 0xb3, 0xd6, 0xdb, 0xc3, 0x27, 0x8f, 0xdb, 0xfd, 0xdd, 0xd9, 0x5a, 0x41,
 0x5a, 0x69, 0x39, 0x47, 0x3d, 0xfb, 0x26, 0x3b, 0x24, 0x71, 0xad, 0xc6, 0x3d, 0xeb, 0xa3, 0x26,
 0x1a, 0x9a, 0x22, 0xaf, 0xf3, 0x93, 0xb3, 0xd2, 0x86, 0xf8, 0xe6, 0x9d, 0xce, 0x9b, 0x57, 0x8f,
 0x53, 0x5e, 0x54, 0x97, 0x4d, 0xa9, 0xd2, 0xe5, 0xd2, 0xdb, 0x8e, 0x48, 0xfe, 0xca, 0xea, 0xd2,
 0x0a, 0xd4, 0x2c, 0xab, 0x08, 0x2b, 0x0e, 0x56, 0xee, 0x3c, 0x4a, 0xbb, 0x9a, 0x41, 0xcd, 0x33,
 0xc7, 0x74, 0x38, 0x50, 0x9d, 0x16, 0x23, 0xd1, 0x8c, 0x62, 0x6a, 0xe7, 0x39, 0x74, 0x44, 0x4e,
 0xaa, 0x73, 0xdc, 0xc9, 0x9e, 0x9e, 0xb1, 0x1d, 0x2f, 0x83, 0x35, 0x1a, 0xc4, 0xe0, 0xb3, 0x0e,
 0x4e, 0x2e, 0xfd, 0x14, 0x5e, 0x5e, 0x95, 0x38, 0xda, 0x9d, 0x76, 0x2d, 0x2d, 0x77, 0xc9, 0x3f,
 0xdd, 0xcd, 0xd2, 0x69, 0x32, 0xea, 0xad, 0xb5, 0x23, 0xf3, 0x6e, 0xef, 0xdd, 0x6a, 0x6f, 0x39,
 0x51, 0xa9, 0xd5, 0x57, 0x42, 0xb2, 0xcd, 0x49, 0xaa, 0xe9, 0xec, 0xb9, 0x6d, 0x7f, 0xcb, 0x37,
 0xd6, 0x71, 0xd9, 0xc9, 0xd9, 0xc9, 0xc8, 0x8a, 0xf9, 0xa9, 0x98, 0xb1, 0xdc, 0xbd, 0xaf, 0x7a,
 0xa9, 0x5c, 0xe9, 0xad, 0xed, 0x14, 0xef, 0xfb, 0x34, 0xfe, 0x6e, 0xee, 0x9d, 0x0a, 0x36, 0xfd,
 0xab, 0xff, 0x00, 0x27, 0x6e, 0x6e, 0xec, 0x46, 0xef, 0x43, 0x72, 0x3d, 0x3a, 0xb5, 0x75, 0x3c,
 0x56, 0x9c, 0x5e, 0x5a, 0x66, 0x62, 0x59, 0xe9, 0x12, 0x5e, 0x3c, 0x58, 0x4e, 0x4e, 0xd6, 0x39,
 0x50, 0xda, 0x30, 0x3c, 0xeb, 0x39, 0x01, 0xcd, 0x85, 0x89, 0x27, 0xb2, 0xa0, 0xfb, 0xf4, 0x44,
 0x47, 0xb7, 0xd6, 0x72, 0x74, 0xde, 0xd0, 0x62, 0xbc, 0xed, 0x92, 0x38, 0xff, 0x00, 0x36, 0x9c,
 0xfd, 0x17, 0x2d, 0x23, 0x7c, 0x73, 0xbf, 0xf2, 0x6f, 0xaa, 0xd2, 0x2e, 0x69, 0x29, 0x38, 0xf2,
 0xf3, 0xb2, 0xcc, 0x99, 0x95, 0x8a, 0xd8, 0x90, 0x9e, 0x9c, 0x1c, 0x9f, 0x45, 0x94, 0xc8, 0xe6,
 0x9d, 0xfd, 0x2f, 0x16, 0x8d, 0xe3, 0xc9, 0xd3, 0xce, 0xf5, 0x9d, 0xa5, 0x59, 0x58, 0x45, 0xcd,
 0x2c, 0x2b, 0x48, 0xab, 0x50, 0xd9, 0x16, 0x66, 0x2c, 0xac, 0xad, 0xe2, 0x45, 0xcd, 0x2c, 0x2b,
 0x08, 0xb9, 0x85, 0x6e, 0xa8, 0xb2, 0xb2, 0xb0, 0x8a, 0xb4, 0xb0, 0xad, 0x22, 0xe6, 0x95, 0xc9,
 0x71, 0x2e, 0x5f, 0x98, 0x26, 0x3d, 0x93, 0x8b, 0xcc, 0xc5, 0x55, 0x5d, 0x37, 0xd5, 0xad, 0xf4,
 0x27, 0x04, 0xfa, 0x0a, 0x26, 0xf1, 0x1f, 0x27, 0xc9, 0xbd, 0xca, 0xf6, 0xcd, 0x4c, 0x22, 0xaa,
 0xeb, 0xc5, 0x11, 0x4a, 0x71, 0x72, 0x63, 0xbf, 0x37, 0x3e, 0x8b, 0xfa, 0x50, 0xf4, 0xfa, 0x14,
 0xf0, 0x9a, 0x8e, 0x8d, 0xae, 0xbe, 0x4b, 0x5e, 0x6b, 0xbe, 0xf3, 0xbf, 0x9c, 0x3d, 0x3e, 0x3e,
 0xa1, 0xa6, 0x8a, 0xc5, 0x62, 0xdb, 0x2b, 0xe4, 0xa9, 0x16, 0x45, 0x7c, 0x49, 0xc8, 0x8d, 0xde,
 0xa6, 0xbb, 0xac, 0xd5, 0x3b, 0x7b, 0x54, 0xda, 0x95, 0xa5, 0x7c, 0x03, 0x0d, 0x7e, 0x19, 0x22,
 0xb2, 0xf1, 0x1e, 0xc8, 0x8e, 0x57, 0xab, 0xb5, 0x6a, 0x70, 0xe3, 0xa1, 0x79, 0xcd, 0x3d, 0x77,
 0x49, 0xd3, 0xfc, 0x36, 0x96, 0xb5, 0x98, 0xda, 0x7e, 0x6e, 0x9b, 0x59, 0x9e, 0x32, 0xe6, 0x99,
 0x89, 0xde, 0x3e, 0x4a, 0xca, 0xd3, 0x4b, 0xcd, 0x72, 0x4c, 0x95, 0xc4, 0x11, 0xf0, 0x9b, 0xba,
 0xc8, 0xad, 0xde, 0xd1, 0x3b, 0x17, 0xb4, 0xde, 0x95, 0xa6, 0xa7, 0x9e, 0x95, 0xa9, 0x16, 0x55,
 0x9d, 0xa8, 0xd7, 0x39, 0x7d, 0x1a, 0xa7, 0xa8, 0xe2, 0xfb, 0x43, 0x8e, 0x96, 0xd1, 0xcd, 0xa7,
 0xce, 0x26, 0x36, 0x6f, 0xe9, 0x97, 0xb4, 0x67, 0xda, 0x3e, 0x6d, 0x64, 0xbf, 0x80, 0xc4, 0x58,
 0x78, 0xb4, 0xba, 0xa2, 0xfe, 0x33, 0xb7, 0x57, 0xe3, 0xe0, 0x50, 0xed, 0x2e, 0xe0, 0x8d, 0xdf,
 0xc5, 0xa5, 0x5a, 0x9f, 0xe1, 0x50, 0xf1, 0x1a, 0x39, 0x9a, 0xea, 0x29, 0x31, 0xde, 0x3f, 0x57,
 0x7f, 0x9b, 0x6f, 0x77, 0x6d, 0xfb, 0x37, 0x55, 0x69, 0x15, 0x69, 0x63, 0x77, 0x89, 0x17, 0x36,
 0xc7, 0xd6, 0x37, 0x79, 0x58, 0x95, 0x75, 0x69, 0x05, 0x69, 0x61, 0x58, 0x45, 0x5a, 0x54, 0x59,
 0x51, 0x65, 0x7d, 0x00, 0xca, 0xad, 0x22, 0xad, 0x2b, 0x75, 0x6e, 0x80, 0x1e, 0xaa, 0x1e, 0x19,
 0x1f, 0x54, 0x43, 0x8f, 0x72, 0xc4, 0x38, 0xf7, 0x12, 0x32, 0x3f, 0x45, 0x33, 0xb2, 0x3d, 0xcf,
 0xcd, 0x71, 0x24, 0x5c, 0xf6, 0x1c, 0x7b, 0x96, 0x21, 0xc7, 0xb8, 0x8e, 0x1c, 0x7b, 0x96, 0x21,
 0xc7, 0xb9, 0x5b, 0xb6, 0xc5, 0xcf, 0x61, 0x4c, 0x5c, 0xb5, 0x0e, 0x63, 0x8f, 0x31, 0x04, 0x39,
 0x8b, 0x96, 0x61, 0xc7, 0xb9, 0x51, 0x66, 0xd8, 0xbb, 0x60, 0x85, 0x33, 0xc3, 0x99, 0x6a, 0x14,
 0xcd, 0xcd, 0x7a, 0x14, 0xc5, 0xcb, 0x30, 0xe6, 0x2e, 0x54, 0x4b, 0x6d, 0x72, 0x3e, 0x41, 0xf0,
 0x9f, 0x76, 0xfe, 0xdb, 0xf1, 0xf7, 0x75, 0xf6, 0x3f, 0xfc, 0x3c, 0x33, 0x99, 0x9d, 0x1b, 0xc2,
 0x49, 0xdb, 0xfb, 0x66, 0xc7, 0x1d, 0xfe, 0x6f, 0xf6, 0x10, 0xce, 0x72, 0x7a, 0x4c, 0x3f, 0xc3,
 0xaf, 0xd9, 0xdc, 0x63, 0x9d, 0xe9, 0x0e, 0xad, 0xe0, 0xb5, 0x9b, 0xf0, 0x0c, 0x93, 0xb4, 0xe7,
 0x63, 0x39, 0x8e, 0x7f, 0xd8, 0x32, 0x4b, 0x87, 0x47, 0x83, 0x56, 0x93, 0xe2, 0x79, 0x6e, 0xdd,
 0xd1, 0x34, 0x62, 0x2a, 0xf6, 0x2f, 0x61, 0xf5, 0x6c, 0x1f, 0x08, 0xed, 0x91, 0xb7, 0x9e, 0x6d,
 0x5f, 0xff, 0x00, 0x9f, 0x33, 0xff, 0x00, 0x4c, 0xfc, 0xfc, 0x3d, 0x35, 0xe5, 0xd3, 0x53, 0x25,
 0xb9, 0x4b, 0x33, 0x5d, 0xe7, 0x77, 0xe8, 0x7c, 0x0f, 0x09, 0x6d, 0x90, 0x33, 0x9e, 0x6f, 0x54,
 0xff, 0x00, 0xf5, 0xf3, 0x3f, 0xf4, 0xcb, 0xd0, 0xbc, 0x27, 0xb6, 0x32, 0xa9, 0xa4, 0x5c, 0xdf,
 0xaf, 0xa7, 0x0d, 0x9a, 0xff, 0x00, 0xa6, 0x7e, 0x70, 0x9e, 0xea, 0x4c, 0x69, 0x29, 0x1d, 0xd4,
 0xfd, 0x1f, 0x89, 0xe1, 0x27, 0xb0, 0xc8, 0x89, 0xaf, 0xb7, 0x4d, 0xd5, 0xe8, 0xb8, 0x64, 0xd7,
 0xfd, 0x21, 0x8e, 0x4b, 0xda, 0xde, 0xcc, 0xb3, 0xd6, 0x3e, 0xcc, 0x07, 0x2a, 0xe6, 0x3f, 0x18,
 0x62, 0x2f, 0x86, 0xf8, 0xad, 0x83, 0xec, 0x28, 0xf0, 0xf5, 0x6b, 0x13, 0x57, 0x2e, 0xf3, 0xd8,
 0x89, 0xc1, 0x2e, 0x7e, 0x67, 0x1d, 0xd7, 0xc0, 0x66, 0x2d, 0x1d, 0xbe, 0x49, 0xbd, 0x7b, 0x30,
 0xf9, 0xae, 0x7f, 0xa0, 0x66, 0xd8, 0x62, 0x95, 0x99, 0x89, 0x69, 0xbe, 0x0a, 0x5f, 0xce, 0x1f,
 0x76, 0xcc, 0xe1, 0xfc, 0x7f, 0x14, 0x5b, 0x1e, 0x45, 0x53, 0x92, 0x1b, 0x6b, 0x23, 0xcb, 0xc6,
 0x4d, 0x1d, 0xa3, 0x57, 0xaa, 0x10, 0x8d, 0x24, 0xd7, 0xa2, 0xab, 0x34, 0x54, 0xb1, 0xa3, 0x1e,
 0xa1, 0xd6, 0x67, 0xe9, 0x75, 0xb7, 0x8c, 0x3e, 0x47, 0xf0, 0xe9, 0x82, 0xb0, 0xb6, 0x7f, 0x80,
 0xaa, 0xa6, 0x9a, 0xe2, 0xce, 0xfb, 0x17, 0x1f, 0x1e, 0x9f, 0x6c, 0xff, 0x00, 0xe2, 0x0d, 0x2d,
 0x43, 0x67, 0x39, 0x75, 0x74, 0xd3, 0x5c, 0x61, 0xff, 0x00, 0x60, 0xe3, 0xe2, 0x63, 0x9d, 0x4b,
 0x72, 0x8d, 0xdc, 0xdd, 0x0e, 0x1f, 0x73, 0x86, 0x28, 0x69, 0x96, 0x71, 0xbc, 0x43, 0x2f, 0x62,
 0xcd, 0xc5, 0x30, 0xb8, 0xb4, 0x66, 0xdb, 0x06, 0x2c, 0x26, 0x44, 0xed, 0x65, 0x48, 0x6e, 0x62,
 0xb9, 0x2e, 0x88, 0xe5, 0xd1, 0x7a, 0x8b, 0x9d, 0xab, 0x95, 0x5d, 0xcc, 0x8a, 0x73, 0xd0, 0xfa,
 0x33, 0xc1, 0x87, 0x62, 0xf8, 0x6e, 0x65, 0xc2, 0x3d, 0xb8, 0xe6, 0xc9, 0x67, 0x4c, 0xc8, 0xba,
 0x2a, 0xc3, 0x90, 0x93, 0x55, 0x56, 0xb2, 0x36, 0xea, 0xe8, 0xe8, 0x8f, 0xd3, 0x8a, 0xb7, 0x5e,
 0x08, 0x9d, 0xba, 0x2e, 0xbc, 0x0a, 0x6c, 0xd4, 0x67, 0xc7, 0xa7, 0xa4, 0xe5, 0xbb, 0xe7, 0x44,
 0x45, 0xd7, 0x82, 0x9b, 0x26, 0xcc, 0xf2, 0xf3, 0xb3, 0x46, 0x7b, 0xc2, 0x30, 0x34, 0x6a, 0xac,
 0x39, 0x89, 0x84, 0xad, 0x68, 0x4d, 0xf2, 0x9e, 0xbf, 0xaa, 0x8a, 0x7d, 0xdb, 0x33, 0x90, 0x32,
 0x6c, 0x49, 0x2f, 0x61, 0x3f, 0x29, 0xe0, 0x6b, 0x2f, 0xa6, 0x9b, 0x9e, 0xc1, 0x86, 0x9c, 0x3d,
 0x3a, 0x6b, 0xf3, 0x9a, 0xd6, 0x53, 0xd9, 0x16, 0x54, 0xca, 0x79, 0xc6, 0x63, 0x32, 0x60, 0x50,
 0x23, 0xcb, 0xbe, 0x34, 0xb3, 0xa0, 0x24, 0xb3, 0x9f, 0xbf, 0x0a, 0x12, 0xb9, 0xc8, 0xaa, 0xe6,
 0x6b, 0xc5, 0x35, 0x44, 0xd3, 0x45, 0x55, 0x2e, 0x2b, 0xe2, 0xe8, 0xf3, 0x7b, 0x41, 0x49, 0xc5,
 0x78, 0x8a, 0xcc, 0x5b, 0x6f, 0x0f, 0xb9, 0xd3, 0xa5, 0x9a, 0xc6, 0xa3, 0x58, 0xcd, 0xd6, 0xb5,
 0x34, 0x6b, 0x53, 0xb1, 0x3b, 0x10, 0xf9, 0x83, 0xc2, 0x7b, 0x39, 0x44, 0x9e, 0xcc, 0x9e, 0xd4,
 0xe4, 0xe2, 0xaa, 0x49, 0xe1, 0xea, 0x8b, 0x33, 0xba, 0xbf, 0xc6, 0x47, 0x54, 0xe4, 0xb6, 0x6a,
 0x2e, 0x9e, 0x95, 0x53, 0xeb, 0x68, 0x92, 0xfa, 0x71, 0x44, 0xe5, 0x63, 0xe6, 0x5c, 0xdf, 0xe0,
 0xe7, 0x99, 0xa7, 0x31, 0x29, 0xcc, 0x4a, 0x4f, 0x32, 0x61, 0xd3, 0xd1, 0xa6, 0x63, 0x3e, 0x33,
 0x92, 0x62, 0x1b, 0xe0, 0xb9, 0xce, 0x72, 0xaa, 0xaf, 0x1f, 0x29, 0x39, 0xaf, 0x53, 0x7e, 0x4b,
 0xcd, 0xab, 0xb4, 0x3c, 0xbf, 0xb3, 0xd8, 0xf4, 0xba, 0x7d, 0x54, 0xe6, 0xd4, 0xdb, 0x69, 0x88,
 0xf0, 0xdf, 0xbc, 0xfc, 0xdf, 0x3d, 0x96, 0xb0, 0xe9, 0x09, 0xdc, 0x4a, 0x72, 0x1c, 0x9c, 0x84,
 0xac, 0x69, 0xa9, 0x88, 0x8b, 0xa3, 0x21, 0x41, 0x62, 0xb9, 0xce, 0xf8, 0x90, 0xdf, 0x71, 0x8d,
 0x89, 0x6d, 0x1f, 0x0d, 0x73, 0x97, 0xc4, 0x0b, 0x3b, 0x0d, 0x3f, 0x2a, 0x52, 0x3b, 0x22, 0xeb,
 0xe8, 0x4d, 0x77, 0xbe, 0x63, 0xbb, 0xec, 0x27, 0x21, 0x37, 0x29, 0xe5, 0x08, 0x53, 0x53, 0x92,
 0x8b, 0x0b, 0x19, 0x9f, 0x6d, 0x49, 0xa5, 0x7b, 0x7c, 0xb8, 0x4d, 0xd7, 0xc9, 0x85, 0x6d, 0x13,
 0x8a, 0xa7, 0x55, 0xb1, 0xa7, 0x1e, 0x39, 0xb5, 0xb6, 0x7b, 0x0e, 0xa5, 0xd7, 0xb4, 0xfa, 0x4d,
 0x3f, 0xbd, 0xc7, 0x31, 0x79, 0xf2, 0x88, 0x89, 0xf9, 0xbe, 0x7b, 0x83, 0xb2, 0x3d, 0xa1, 0x44,
 0x85, 0x51, 0x32, 0xe4, 0x56, 0x26, 0x9a, 0xe9, 0x12, 0x3c, 0x36, 0x3b, 0xe4, 0x57, 0x6a, 0x24,
 0xcc, 0x39, 0x37, 0x33, 0xe5, 0xf8, 0x35, 0x71, 0x8c, 0x12, 0x72, 0x52, 0x0e, 0xba, 0x55, 0x73,
 0x35, 0x66, 0xbf, 0xa4, 0x9a, 0xa1, 0xf6, 0xe3, 0xe0, 0xe9, 0xd8, 0x54, 0x9d, 0x92, 0x97, 0x9a,
 0x95, 0x8b, 0x2b, 0x35, 0x05, 0x91, 0xa5, 0xe3, 0x35, 0x59, 0x16, 0x1b, 0xd3, 0x56, 0xbd, 0xab,
 0xcd, 0x15, 0x0e, 0x57, 0xc2, 0x56, 0x63, 0xc2, 0x5e, 0x5b, 0x17, 0xb6, 0xb9, 0xf9, 0xc7, 0xbc,
 0xc7, 0x1b, 0x7e, 0x1b, 0xee, 0xf8, 0x3d, 0xc9, 0xa0, 0x22, 0xaa, 0x2e, 0xa8, 0xba, 0x2f, 0x51,
 0xc6, 0x75, 0xc2, 0xdb, 0x82, 0x66, 0xcc, 0x57, 0x08, 0x67, 0x16, 0x4a, 0x4d, 0xc4, 0x84, 0xcd,
 0x79, 0xee, 0xa3, 0x97, 0x4f, 0x9b, 0x41, 0x31, 0xc1, 0x98, 0xda, 0x5f, 0x43, 0xa5, 0xe3, 0x25,
 0x62, 0xd5, 0xf2, 0x97, 0xd5, 0xbb, 0x2e, 0xc5, 0xa2, 0x66, 0x0c, 0x89, 0x87, 0x62, 0x11, 0xdc,
 0xae, 0x98, 0x46, 0x2c, 0x18, 0xce, 0x5e, 0x6e, 0x7b, 0x17, 0x4d, 0x57, 0xd2, 0x9a, 0x2f, 0xc6,
 0x6c, 0x2f, 0x85, 0x63, 0x9f, 0xf8, 0x33, 0x3d, 0xd1, 0xb2, 0x2c, 0xec, 0x25, 0xe2, 0x90, 0xb1,
 0x07, 0x69, 0x6d, 0x58, 0xd5, 0x3a, 0x7b, 0xe1, 0x1e, 0x87, 0x4f, 0x96, 0x6d, 0x8e, 0xb3, 0x2f,
 0x93, 0x75, 0x5a, 0x46, 0x0d, 0x6e, 0x4c, 0x75, 0xf2, 0x89, 0xfd, 0x7c, 0x5c, 0xeb, 0x6d, 0x10,
 0xf7, 0x76, 0x6f, 0x8b, 0x2e, 0x9d, 0x90, 0xbe, 0xd5, 0x87, 0xcd, 0x07, 0xd4, 0x7b, 0x70, 0x87,
 0xbb, 0xb3, 0x0c, 0x61, 0x6d, 0x0b, 0xed, 0x58, 0x7c, 0xb8, 0x75, 0xbd, 0x46, 0x77, 0xcb, 0x1f,
 0x67, 0xb5, 0xf6, 0x52, 0x77, 0xd1, 0xcf, 0xfa, 0xa7, 0xf4, 0x85, 0x8c, 0x3e, 0x69, 0xd2, 0x73,
 0xd0, 0x26, 0xe1, 0xa2, 0x2b, 0xe0, 0xc4, 0x6c, 0x46, 0xa3, 0xb9, 0x2a, 0xb5, 0x75, 0xe3, 0xf2,
 0x13, 0xc5, 0x67, 0xe6, 0xb1, 0x4c, 0x42, 0x34, 0xfc, 0xec, 0x67, 0x46, 0x8f, 0x1d, 0xea, 0xe7,
 0xb9, 0xdd, 0x7d, 0x45, 0x44, 0x3a, 0xc6, 0xc4, 0x32, 0x4c, 0xb6, 0x25, 0x05, 0xf9, 0x8b, 0x14,
 0x80, 0xd8, 0xd0, 0x61, 0xc4, 0x56, 0x4a, 0xc2, 0x7a, 0x6a, 0xd7, 0x39, 0x39, 0xbd, 0x53, 0xb5,
 0x13, 0x92, 0x27, 0x53, 0x8d, 0x87, 0x1d, 0xb2, 0xdb, 0x85, 0x5d, 0xd6, 0xb7, 0x55, 0x8b, 0x47,
 0x8a, 0x73, 0xe4, 0xf9, 0x7f, 0xcd, 0x9c, 0xf7, 0x0e, 0xcb, 0x98, 0xf6, 0x21, 0x06, 0xb4, 0x96,
 0x0f, 0x3b, 0x31, 0x0d, 0x78, 0xa3, 0xd9, 0x05, 0x55, 0x17, 0xd0, 0xa5, 0x3c, 0x43, 0x0f, 0x9d,
 0xc3, 0xe3, 0xd1, 0x9e, 0x94, 0x8d, 0x2d, 0x13, 0xde, 0x45, 0x62, 0xb5, 0x7e, 0x73, 0xeb, 0x27,
 0x41, 0xd1, 0x11, 0x11, 0x38, 0x27, 0x24, 0xe8, 0x6b, 0x5b, 0x44, 0xc0, 0x20, 0x63, 0x79, 0x5a,
 0x76, 0x0c, 0x48, 0x68, 0xe8, 0xf0, 0x61, 0x3a, 0x2c, 0xbb, 0xd7, 0x9b, 0x1e, 0xd4, 0xd7, 0x85,
 0x97, 0x4d, 0x0e, 0xca, 0xfd, 0x2e, 0x22, 0x93, 0x35, 0xb7, 0x8b, 0xce, 0xe9, 0xfd, 0xa7, 0xf7,
 0x99, 0xa2, 0xb7, 0xa6, 0xd5, 0x9f, 0xc7, 0xc5, 0xf3, 0x39, 0x62, 0x46, 0x6a, 0x34, 0x94, 0xd4,
 0x29, 0xa9, 0x78, 0x8e, 0x87, 0x16, 0x13, 0xd1, 0xec, 0x72, 0x76, 0x2a, 0x15, 0xcf, 0x50, 0xea,
 0x22, 0x76, 0x9d, 0xe1, 0xeb, 0xa6, 0x22, 0x63, 0x69, 0x32, 0xcc, 0x18, 0xc4, 0xe6, 0x39, 0x88,
 0xbe, 0x76, 0x75, 0xc8, 0xb1, 0x1d, 0xc1, 0xad, 0x6a, 0x68, 0xd6, 0x37, 0xb1, 0x11, 0x3b, 0x10,
 0xc3, 0x86, 0xe1, 0x98, 0x8e, 0x22, 0xe5, 0x6c, 0x8c, 0x94, 0xc4, 0xca, 0xa7, 0x3a, 0x6c, 0x55,
 0xd0, 0x75, 0xb3, 0xbc, 0xb9, 0xed, 0x8f, 0x1d, 0x6c, 0x08, 0xbb, 0xc9, 0x2b, 0x05, 0xb5, 0x23,
 0xb9, 0x38, 0x2e, 0x9a, 0xe8, 0x8d, 0x4b, 0xaa, 0xfe, 0xf3, 0xb9, 0xca, 0xc9, 0x4b, 0xc9, 0x4b,
 0x32, 0x5a, 0x52, 0x03, 0x20, 0x41, 0x62, 0x68, 0xd6, 0x31, 0x34, 0x44, 0x3b, 0x3d, 0x1e, 0x86,
 0xda, 0xb9, 0x9b, 0xde, 0xdb, 0x43, 0xa4, 0xea, 0x1d, 0x5b, 0x1e, 0x82, 0x63, 0x0e, 0x3a, 0xef,
 0x3d, 0xbe, 0x50, 0xf9, 0xcf, 0x12, 0xc2, 0x71, 0x2c, 0x39, 0x53, 0xd9, 0xd2, 0x13, 0x12, 0xda,
 0xf2, 0x58, 0x90, 0xd5, 0x11, 0x7e, 0x32, 0x92, 0xa6, 0x8a, 0x7d, 0x29, 0x3f, 0x27, 0x2f, 0x3b,
 0x29, 0x12, 0x52, 0x6e, 0x13, 0x62, 0xc0, 0x88, 0x9a, 0x3d, 0xae, 0x4f, 0xfb, 0xe3, 0x73, 0xe7,
 0x9c, 0xc1, 0x22, 0xb8, 0x6e, 0x37, 0x39, 0x20, 0xab, 0xad, 0x08, 0xce, 0x62, 0x2f, 0x54, 0x45,
 0xe1, 0xf3, 0x11, 0xaf, 0xd0, 0x7c, 0x2e, 0xd3, 0x13, 0xbc, 0x4b, 0x6f, 0x4b, 0xea, 0x91, 0xad,
 0x89, 0x89, 0x8d, 0xa6, 0x14, 0x53, 0x99, 0xd9, 0x76, 0x6d, 0x8a, 0xbf, 0x14, 0xcb, 0xad, 0x64,
 0x67, 0x6f, 0x47, 0x94, 0x75, 0x17, 0x2a, 0xf3, 0x72, 0x69, 0xe4, 0xaf, 0xc9, 0xc3, 0xe2, 0x38,
 0xca, 0x1d, 0x17, 0x62, 0x71, 0x15, 0x66, 0xf1, 0x38, 0x1d, 0x8b, 0x0d, 0x8f, 0xd3, 0xd0, 0xaa,
 0x9f, 0xbc, 0xbe, 0x91, 0x96, 0x71, 0xea, 0x62, 0x23, 0xe7, 0xe0, 0x75, 0xac, 0x51, 0x7d, 0x25,
 0xad, 0x3e, 0x71, 0xe2, 0xe8, 0xea, 0xd3, 0x1a, 0xb6, 0xc5, 0xa5, 0x68, 0xa3, 0x36, 0x4f, 0xf8,
 0xa7, 0x2f, 0xce, 0x4f, 0x35, 0x51, 0x22, 0x32, 0x1e, 0xec, 0x3f, 0xd3, 0x5e, 0x09, 0xf3, 0xae,
 0xbf, 0x11, 0xeb, 0xaf, 0x96, 0x29, 0x59, 0xb4, 0xfc, 0x9e, 0x33, 0x15, 0x67, 0x25, 0xe2, 0x95,
 0xf3, 0x97, 0x3b, 0xda, 0x5e, 0x62, 0x74, 0xdc, 0xe3, 0xf0, 0x99, 0x48, 0x8b, 0xec, 0x68, 0x2e,
 0xd2, 0x2a, 0xa2, 0xff, 0x00, 0x18, 0xf4, 0xec, 0xf4, 0x21, 0xa4, 0xf6, 0x9e, 0xbd, 0xca, 0xe5,
 0x57, 0x39, 0x55, 0x55, 0x57, 0x8a, 0xa9, 0xe1, 0xe1, 0x35, 0x3a, 0x8b, 0x6a, 0x32, 0x4d, 0xed,
 0xf3, 0x7d, 0x0b, 0x4d, 0xa7, 0xa6, 0x9f, 0x1c, 0x63, 0xa7, 0xc9, 0x38, 0x50, 0xe2, 0x45, 0x8a,
 0xd8, 0x70, 0x61, 0xba, 0x23, 0xdc, 0xba, 0x35, 0xad, 0x4d, 0x55, 0x7e, 0x21, 0xd4, 0x3c, 0xa1,
 0x98, 0xe2, 0x43, 0xa8, 0x98, 0x64, 0x46, 0xa7, 0x47, 0x3d, 0xad, 0x5f, 0x91, 0x57, 0x53, 0xa2,
 0xe4, 0x5c, 0xbb, 0x0b, 0x08, 0xc3, 0x21, 0xcc, 0x45, 0x86, 0x8b, 0x3d, 0x1d, 0xa8, 0xf7, 0xb9,
 0x53, 0x8b, 0x11, 0x78, 0xa3, 0x53, 0xa5, 0xcd, 0x89, 0x5a, 0x77, 0x9a, 0x4e, 0x89, 0x5b, 0xd2,
 0x2d, 0x96, 0xdb, 0x4c, 0xfc, 0xa1, 0xd1, 0xea, 0xba, 0xec, 0xd3, 0x24, 0xd7, 0x15, 0x77, 0xdb,
 0xe7, 0x2e, 0x09, 0x3f, 0x21, 0x39, 0x23, 0x19, 0x61, 0x4e, 0x4b, 0x45, 0x80, 0xfe, 0x8f, 0x6e,
 0x9a, 0xfa, 0x3a, 0x95, 0x8e, 0xeb, 0x8d, 0x61, 0x52, 0x98, 0xac, 0x8b, 0xe5, 0x26, 0xe1, 0xa3,
 0x9a, 0xbf, 0x8a, 0xee, 0xd6, 0x2f, 0x54, 0x38, 0xa6, 0x2b, 0x27, 0x17, 0x0f, 0xc4, 0x66, 0x24,
 0xa3, 0x27, 0xf6, 0x48, 0x2f, 0x56, 0xad, 0xf4, 0xed, 0x3a, 0xee, 0xa1, 0xd3, 0xe7, 0x49, 0x31,
 0x31, 0x3b, 0xc4, 0xbb, 0x2e, 0x9f, 0xd4, 0x6b, 0xac, 0x89, 0x8d, 0xb6, 0x98, 0x34, 0xc9, 0xd8,
 0xe3, 0xf0, 0x89, 0xf4, 0x6c, 0x47, 0x2a, 0xca, 0x46, 0x72, 0x24, 0x56, 0xf4, 0xfe, 0x72, 0x5d,
 0x3e, 0x83, 0xaa, 0xe8, 0x8e, 0x44, 0x56, 0xaa, 0x2a, 0x2f, 0x14, 0x5e, 0xa8, 0x70, 0xc4, 0x5e,
 0x3c, 0x8e, 0xb1, 0xb3, 0xf9, 0xe5, 0x9f, 0xcb, 0x90, 0xdb, 0x11, 0xda, 0xc4, 0x97, 0x72, 0xc1,
 0x77, 0xa1, 0x38, 0xb7, 0xe6, 0x5f, 0x98, 0xec, 0xfa, 0x0e, 0xb2, 0x77, 0x9c, 0x16, 0xf2, 0xf3,
 0x8f, 0xea, 0xe0, 0x75, 0xad, 0x34, 0x44, 0x46, 0x6a, 0xfe, 0x67, 0x2a, 0xd2, 0x2a, 0xd2, 0xc2,
 0xb4, 0x8a, 0xb4, 0xf5, 0x5b, 0xbc, 0xec, 0x59, 0x5d, 0x5a, 0x41, 0x5a, 0x59, 0x56, 0x98, 0xd5,
 0xa5, 0x44, 0xaa, 0x25, 0x5d, 0x5a, 0x84, 0x5c, 0xd2, 0xc2, 0xb4, 0x82, 0xb4, 0xce, 0xea, 0x89,
 0x57, 0x56, 0x91, 0x56, 0x96, 0x5c, 0xd2, 0x0a, 0xd2, 0xa2, 0x57, 0x16, 0x57, 0x56, 0xf0, 0x20,
 0xe6, 0x96, 0x15, 0xa4, 0x1c, 0xd4, 0x4d, 0x55, 0x78, 0x21, 0x5c, 0x95, 0x16, 0x56, 0x89, 0xba,
 0xc6, 0xb9, 0xef, 0x54, 0x6b, 0x5a, 0x9a, 0xaa, 0xaf, 0x62, 0x1c, 0xdf, 0x30, 0x4f, 0x7b, 0x3f,
 0x13, 0x89, 0x1d, 0xbf, 0xc5, 0xa7, 0x93, 0x0d, 0x3f, 0x9a, 0x83, 0x7c, 0xdd, 0x8f, 0x7b, 0x29,
 0x5d, 0x23, 0x24, 0xfd, 0x60, 0x35, 0x7c, 0xb7, 0xa7, 0xe5, 0xaf, 0xa8, 0xd6, 0x4f, 0x17, 0xd7,
 0x7a, 0x9c, 0x6a, 0x2d, 0xee, 0x71, 0xff, 0x00, 0x86, 0x3f, 0x9c, 0xbd, 0x27, 0x4d, 0xd1, 0xce,
 0x28, 0xf7, 0x97, 0xf3, 0x90, 0x83, 0xec, 0x99, 0x2a, 0xb1, 0xb1, 0x17, 0x47, 0x54, 0xf2, 0x20,
 0xb7, 0x9d, 0xd7, 0x87, 0xac, 0x47, 0x09, 0x8e, 0x7c, 0x46, 0xb1, 0xad, 0x57, 0x39, 0xcb, 0xa2,
 0x22, 0x76, 0xa9, 0xd1, 0x70, 0x1c, 0x39, 0x30, 0xec, 0x39, 0x90, 0x55, 0x12, 0xab, 0xbc, 0xa8,
 0x8a, 0x9d, 0x7e, 0xe3, 0x47, 0x42, 0xd1, 0xce, 0x7d, 0x4c, 0x5e, 0x7c, 0xab, 0xe3, 0xfd, 0x9b,
 0xba, 0x8e, 0x78, 0xc5, 0x8a, 0x63, 0xe7, 0x2c, 0xea, 0xd5, 0x22, 0xad, 0x2c, 0x2b, 0x48, 0xab,
 0x4f, 0xa1, 0x45, 0x9e, 0x6e, 0x25, 0x59, 0x58, 0x45, 0xcd, 0x2c, 0x2b, 0x48, 0xab, 0x4c, 0xee,
 0xa8, 0xb2, 0xb2, 0xb5, 0x48, 0x2b, 0x4b, 0x2a, 0xde, 0x24, 0x5c, 0xd2, 0xf7, 0x54, 0x4a, 0xb2,
 0xb4, 0x8a, 0xb4, 0xb1, 0xba, 0x45, 0x5a, 0x67, 0x75, 0x44, 0xbb, 0xc4, 0x38, 0xd7, 0x2c, 0x43,
 0x8c, 0x26, 0x64, 0x63, 0x3b, 0x23, 0x1f, 0x9a, 0xf7, 0x68, 0x8b, 0x9c, 0xb2, 0x35, 0xcb, 0x30,
 0xe3, 0xdc, 0x4b, 0x0e, 0x35, 0xcc, 0xec, 0x8d, 0x73, 0x3b, 0xb6, 0x45, 0xce, 0xa1, 0xc7, 0xb9,
 0x66, 0x1c, 0x7b, 0x89, 0x21, 0xc6, 0x5e, 0xa6, 0x76, 0x47, 0xba, 0x95, 0xbb, 0x64, 0x5c, 0xf2,
 0x1c, 0x7b, 0x96, 0x21, 0xc7, 0xb8, 0x8e, 0x1c, 0x7b, 0x96, 0x19, 0x1e, 0xe5, 0x44, 0xb6, 0xc5,
 0xdf, 0x2f, 0xf8, 0x43, 0x3b, 0x7f, 0x6b, 0xb8, 0xd3, 0xba, 0xa4, 0x0f, 0xb1, 0x61, 0xcf, 0xcd,
 0xef, 0x6f, 0x6e, 0xde, 0xda, 0xae, 0x30, 0xbf, 0xe4, 0x7e, 0xc5, 0x86, 0x88, 0x7a, 0x9c, 0x3f,
 0xc3, 0xaf, 0xda, 0x1e, 0x8f, 0x17, 0xf0, 0xe3, 0xec, 0x61, 0x80, 0x60, 0x98, 0xbe, 0x3f, 0x3f,
 0xec, 0x0c, 0x17, 0x0e, 0x99, 0x9f, 0x9a, 0xdc, 0x58, 0x94, 0xa0, 0x31, 0x5c, 0xed, 0xd4, 0xe6,
 0xba, 0x74, 0x4d, 0x4d, 0x85, 0x36, 0x5f, 0xb4, 0x35, 0xe5, 0x93, 0x71, 0xa5, 0xff, 0x00, 0x55,
 0x71, 0xb3, 0x78, 0x2d, 0x3b, 0x73, 0x69, 0xce, 0x55, 0xff, 0x00, 0x17, 0x47, 0xfe, 0xa9, 0xf5,
 0x5c, 0x28, 0xe9, 0x63, 0x87, 0xaa, 0xd6, 0x5b, 0x0d, 0xf8, 0xc4, 0x38, 0xf9, 0xf5, 0x33, 0x8e,
 0xfc, 0x76, 0x7c, 0x5e, 0x9b, 0x2c, 0xda, 0x2a, 0xf2, 0xc9, 0x98, 0xda, 0xff, 0x00, 0xaa, 0xb8,
 0x92, 0x6c, 0xa3, 0x69, 0x0b, 0xcb, 0x25, 0x63, 0x9f, 0xb2, 0x38, 0xfb, 0x5e, 0x14, 0x74, 0xd7,
 0xb0, 0xb5, 0x0a, 0x61, 0x3a, 0x21, 0xa3, 0xfe, 0xa3, 0x7e, 0xc8, 0x8d, 0x64, 0xcf, 0xc9, 0xf1,
 0x02, 0x6c, 0x97, 0x69, 0x4b, 0xcb, 0x24, 0x63, 0xab, 0xfe, 0xa8, 0xe3, 0xac, 0xf8, 0x2a, 0xe4,
 0x4c, 0xeb, 0x96, 0x36, 0xb9, 0x2d, 0x8a, 0xe3, 0x99, 0x63, 0x15, 0xc3, 0xa4, 0xdb, 0x27, 0x30,
 0xc5, 0x8f, 0x31, 0x2e, 0xac, 0x62, 0x39, 0xcd, 0xd1, 0x13, 0x55, 0xed, 0x53, 0xe9, 0x08, 0x53,
 0x09, 0x62, 0xdc, 0x19, 0x9d, 0x17, 0xb0, 0xc5, 0xb5, 0xf6, 0xb5, 0x66, 0xbb, 0x2b, 0xe2, 0x66,
 0x7c, 0x36, 0x6d, 0x92, 0xf3, 0xaa, 0x9d, 0xa3, 0x29, 0x6c, 0x41, 0x51, 0x53, 0xca, 0x34, 0xd8,
 0x33, 0x4b, 0xd4, 0xb9, 0x06, 0x6f, 0x8a, 0x71, 0x38, 0xb5, 0xb2, 0xab, 0x96, 0x61, 0xc6, 0xff,
 0x00, 0xf1, 0x0a, 0x99, 0x49, 0x8d, 0x99, 0xe5, 0xbe, 0x5a, 0xf8, 0xe5, 0xff, 0x00, 0x60, 0xe3,
 0xe2, 0x13, 0xec, 0x6f, 0x0e, 0xc8, 0xf5, 0x76, 0x73, 0x97, 0xd3, 0x5d, 0x74, 0xc5, 0xdc, 0xbf,
 0xee, 0x54, 0xf8, 0xe4, 0xee, 0xb4, 0xb3, 0xbe, 0x28, 0x72, 0x6b, 0x6e, 0x51, 0xba, 0x4c, 0xe2,
 0xb7, 0x5f, 0xa4, 0xfd, 0x40, 0xc9, 0x19, 0x5e, 0x1e, 0x5e, 0xc8, 0xb8, 0x1e, 0x09, 0x0a, 0x1e,
 0xeb, 0x64, 0xb0, 0xf8, 0x30, 0x95, 0x34, 0xfc, 0xa4, 0x62, 0x2b, 0x97, 0xe3, 0x72, 0xaa, 0x9f,
 0x99, 0xd9, 0x6a, 0x02, 0x4d, 0xe6, 0x2c, 0x3a, 0x55, 0xc9, 0xaa, 0x46, 0x9b, 0x85, 0x0d, 0x53,
 0xae, 0xaf, 0x44, 0xfd, 0xe7, 0xeb, 0x6e, 0xb2, 0xd1, 0x75, 0x6f, 0xe2, 0xaf, 0x23, 0x1a, 0x8c,
 0xbc, 0x36, 0x68, 0xd5, 0x69, 0xfd, 0xfd, 0x76, 0x69, 0xf1, 0xe4, 0x9c, 0xde, 0xc2, 0x8c, 0x59,
 0x65, 0x4e, 0xc3, 0x78, 0x8f, 0x20, 0x8e, 0x4d, 0x51, 0x11, 0x52, 0xc2, 0xd9, 0x9c, 0x3f, 0x9f,
 0x92, 0x29, 0xa8, 0x79, 0xfd, 0x47, 0x49, 0x98, 0xf2, 0x86, 0xa1, 0x12, 0x5e, 0xc5, 0x58, 0xb2,
 0xd6, 0x36, 0x79, 0x89, 0x05, 0x45, 0xe4, 0x72, 0x8d, 0xb8, 0x6d, 0x53, 0x01, 0xd9, 0x9c, 0xa3,
 0x20, 0x47, 0x67, 0x8c, 0x31, 0xb9, 0x86, 0x6f, 0xcb, 0xe1, 0xf0, 0xdf, 0xba, 0xbb, 0xbc, 0xb7,
 0xe2, 0x3b, 0xf2, 0x1b, 0xaf, 0x2e, 0xd5, 0xd3, 0x87, 0x53, 0x93, 0x4c, 0xbb, 0xba, 0x8b, 0x74,
 0xcb, 0xde, 0xdc, 0x6b, 0x1e, 0x2d, 0x9a, 0x2c, 0xb2, 0xaf, 0x04, 0x6e, 0xa6, 0xbd, 0x98, 0x73,
 0x0e, 0x5b, 0xc0, 0x91, 0x7c, 0x73, 0x8f, 0x61, 0x92, 0x0a, 0x9c, 0xdb, 0x1a, 0x65, 0xad, 0x77,
 0xea, 0xeb, 0xaf, 0xcc, 0x7c, 0x83, 0x9e, 0x36, 0xc9, 0x9f, 0xb3, 0x64, 0x58, 0x8d, 0x99, 0xc6,
 0xe2, 0xc8, 0x49, 0xb9, 0x78, 0x4a, 0xc8, 0x2a, 0xc1, 0x86, 0x89, 0xd1, 0x55, 0x3c, 0xa7, 0x7c,
 0x6a, 0xa7, 0x3e, 0x7b, 0xde, 0xe7, 0xab, 0xdc, 0xe5, 0x57, 0x2a, 0xea, 0xaa, 0xab, 0xaa, 0xaf,
 0xc6, 0x6e, 0xf7, 0xd3, 0x0e, 0x76, 0x2f, 0x64, 0xe2, 0xde, 0x39, 0x6f, 0xb7, 0xdb, 0xfb, 0xbe,
 0xbc, 0xcc, 0x1b, 0x70, 0xd9, 0xd6, 0x1c, 0x8e, 0x49, 0x79, 0xf9, 0xac, 0x4e, 0x22, 0x7e, 0x4c,
 0xa4, 0xb2, 0xe8, 0xab, 0xfa, 0x4f, 0xdd, 0x43, 0x9c, 0xe6, 0x5f, 0x08, 0x89, 0xb8, 0xc8, 0xf8,
 0x58, 0x06, 0x5f, 0x83, 0x2e, 0x8b, 0xf8, 0xb1, 0xa7, 0x22, 0x54, 0x77, 0xa7, 0x71, 0xba, 0x27,
 0xce, 0xa7, 0x08, 0x5d, 0x57, 0x98, 0xc7, 0x04, 0xc0, 0xb1, 0x9c, 0x6e, 0x61, 0x20, 0xe0, 0xf8,
 0x54, 0xec, 0xfc, 0x4d, 0x74, 0xdd, 0x97, 0x80, 0xe8, 0x9a, 0x7a, 0x74, 0x4e, 0x06, 0x27, 0x35,
 0xfb, 0xbb, 0x0c, 0x5e, 0xcc, 0xf4, 0xdc, 0x1f, 0xb5, 0x7a, 0xef, 0xf7, 0x9f, 0xfe, 0x43, 0x1e,
 0x3b, 0x8a, 0x4e, 0x63, 0x58, 0xb4, 0xde, 0x2b, 0x3f, 0x11, 0x22, 0x4d, 0xcd, 0xc5, 0x74, 0x58,
 0xce, 0x46, 0xa3, 0x51, 0x5c, 0xbc, 0xf8, 0x27, 0x04, 0x28, 0x17, 0x71, 0xac, 0x36, 0x77, 0x08,
 0xc5, 0x26, 0x70, 0xcc, 0x4a, 0x59, 0xf2, 0xb3, 0x92, 0xd1, 0x16, 0x1c, 0x68, 0x2f, 0xe6, 0xc7,
 0x27, 0x34, 0x52, 0x91, 0xa9, 0xe8, 0x29, 0x15, 0x8a, 0xc4, 0x57, 0xcb, 0xe4, 0xfa, 0x43, 0xc1,
 0x55, 0x9b, 0xd9, 0x33, 0x17, 0xff, 0x00, 0xf2, 0x29, 0xf6, 0x48, 0x75, 0xc7, 0xc2, 0xd5, 0x0e,
 0x59, 0xe0, 0x93, 0x0f, 0x7f, 0x24, 0xe3, 0x0b, 0xd3, 0x12, 0x6f, 0xd9, 0x34, 0xec, 0x4f, 0x82,
 0x76, 0x9a, 0x6b, 0xed, 0x8e, 0x1f, 0x24, 0xf6, 0x8a, 0xdb, 0x75, 0x2c, 0xbf, 0x78, 0xfd, 0x21,
 0xcc, 0xf6, 0xf1, 0x0f, 0x77, 0x65, 0x78, 0xca, 0xda, 0x0f, 0xdb, 0x30, 0xf9, 0x44, 0xfa, 0xe7,
 0xc2, 0x02, 0x1e, 0xee, 0xc9, 0x71, 0xb5, 0xb4, 0x1f, 0xb6, 0x61, 0xf2, 0x32, 0x9c, 0x6d, 0x64,
 0xef, 0x93, 0xf2, 0x7b, 0x3f, 0x63, 0xe7, 0x7d, 0x0c, 0xcf, 0xfe, 0xd3, 0xfa, 0x43, 0xd4, 0x3e,
 0xad, 0xd9, 0x9c, 0x83, 0x65, 0x36, 0x7d, 0x81, 0xc2, 0x6b, 0x74, 0xd6, 0x51, 0xb1, 0x1d, 0xe9,
 0x76, 0xae, 0x5f, 0xa4, 0xf9, 0x48, 0xfb, 0x2b, 0x28, 0xc0, 0x46, 0xe5, 0x1c, 0x1d, 0x11, 0x38,
 0x7b, 0x02, 0x07, 0xd9, 0xa1, 0xb7, 0xa7, 0xce, 0xd7, 0x99, 0x6b, 0xf6, 0xbf, 0x24, 0xd7, 0x4f,
 0x8e, 0x3b, 0xcf, 0xf4, 0x7a, 0xf8, 0x45, 0x59, 0xb9, 0x74, 0x89, 0x2d, 0x15, 0x9a, 0x6a, 0x8e,
 0x63, 0x91, 0x7e, 0x34, 0xd0, 0x72, 0xf8, 0x46, 0x08, 0xb0, 0x7c, 0x95, 0xe1, 0xd8, 0x77, 0x31,
 0x7f, 0x0d, 0x9e, 0x16, 0x99, 0x36, 0x98, 0x7c, 0x56, 0xf4, 0xd1, 0xea, 0x97, 0x04, 0x3d, 0x89,
 0xfc, 0x63, 0xbd, 0x2a, 0x78, 0x87, 0x96, 0x7d, 0xa2, 0x1d, 0xa3, 0x60, 0x52, 0x4d, 0x4c, 0xbf,
 0x88, 0x4e, 0x2b, 0x7c, 0xa8, 0xb3, 0x28, 0xcd, 0x6c, 0xd6, 0xeb, 0xf4, 0xb9, 0x4e, 0x8a, 0xf8,
 0x56, 0x35, 0x3d, 0x82, 0xc1, 0xd7, 0x20, 0xef, 0xa2, 0x73, 0x9d, 0x8b, 0xaf, 0xc8, 0xd3, 0x7b,
 0x7c, 0x2b, 0x1e, 0xa7, 0x43, 0x3c, 0x70, 0x56, 0x1f, 0x33, 0xeb, 0x19, 0x66, 0xda, 0xec, 0x9b,
 0xf7, 0x2a, 0x7c, 0x23, 0xe7, 0xfd, 0xaa, 0x43, 0x48, 0x59, 0xf3, 0x12, 0x6a, 0x76, 0xb9, 0x8e,
 0xf9, 0x58, 0xd5, 0x3e, 0x8e, 0x89, 0x09, 0x7a, 0x1f, 0x3b, 0xed, 0x85, 0x37, 0x76, 0x87, 0x89,
 0x27, 0x44, 0x85, 0xf6, 0x6d, 0x34, 0x75, 0x7b, 0x6f, 0x86, 0x3e, 0xff, 0x00, 0xd1, 0xda, 0xfb,
 0x31, 0x6d, 0xf5, 0x16, 0x8f, 0xc3, 0xfa, 0xc3, 0x51, 0x3a, 0x16, 0xc4, 0x13, 0x5c, 0x63, 0x11,
 0xff, 0x00, 0x36, 0x4f, 0xae, 0x87, 0x3d, 0x3a, 0x36, 0xc2, 0x9b, 0xbd, 0x8c, 0xe2, 0x49, 0xfd,
 0x15, 0x3e, 0xba, 0x1d, 0x57, 0x4f, 0x9d, 0xb5, 0x34, 0xfb, 0xbd, 0x3f, 0x55, 0x9d, 0xb4, 0x79,
 0x3e, 0xce, 0xa4, 0xad, 0x34, 0x1d, 0xb3, 0xc7, 0x58, 0x58, 0x0c, 0xa4, 0xba, 0x2e, 0x95, 0xa6,
 0x35, 0x5b, 0xa3, 0x5b, 0xeb, 0x53, 0xa2, 0xb9, 0x8a, 0x73, 0x1d, 0xb9, 0xea, 0x90, 0xf0, 0x94,
 0xec, 0x55, 0x8a, 0xbf, 0x50, 0xf4, 0x9d, 0x4a, 0xdb, 0x69, 0x6d, 0xff, 0x00, 0x3e, 0x6f, 0x21,
 0xd1, 0xa3, 0x96, 0xb2, 0x9f, 0x9f, 0xe9, 0x2e, 0x5e, 0xa5, 0xac, 0x25, 0x20, 0xbb, 0x12, 0x95,
 0x49, 0x87, 0x35, 0xb0, 0x6b, 0x32, 0xa2, 0xbb, 0x92, 0x37, 0x54, 0xd7, 0x5f, 0x88, 0xab, 0xd8,
 0x1a, 0xaa, 0x1e, 0x42, 0xb3, 0xb4, 0xee, 0xf7, 0xd3, 0x1b, 0xc6, 0xce, 0xee, 0xec, 0xc9, 0x97,
 0x75, 0x5d, 0x31, 0xa9, 0x1d, 0x3b, 0x3f, 0xb2, 0x90, 0x5c, 0xc7, 0x97, 0xff, 0x00, 0xc7, 0x52,
 0x3d, 0xe9, 0xc3, 0x38, 0x87, 0x1e, 0xa7, 0x77, 0x1d, 0x7b, 0x37, 0xd3, 0x0e, 0x87, 0xfe, 0xdf,
 0xc3, 0xf5, 0x4f, 0xf2, 0x77, 0x17, 0x66, 0x3c, 0xbf, 0xfe, 0x39, 0x92, 0xef, 0x0e, 0x61, 0xb4,
 0x58, 0xf2, 0x53, 0x59, 0x96, 0x24, 0xcc, 0x8c, 0xc4, 0x29, 0x88, 0x71, 0x21, 0xb1, 0x55, 0xd0,
 0xd7, 0x54, 0xde, 0xd3, 0x45, 0x4f, 0x99, 0x0d, 0x75, 0x15, 0x4f, 0x14, 0xe2, 0xeb, 0x3a, 0x9e,
 0x4d, 0x56, 0x3e, 0x16, 0xac, 0x43, 0x97, 0xa2, 0xe9, 0x58, 0xf4, 0x99, 0x39, 0xd6, 0xd3, 0x3e,
 0x1b, 0x3c, 0x37, 0xbd, 0x91, 0x4c, 0x2a, 0x4e, 0x4f, 0x4a, 0x2a, 0xf0, 0x7c, 0x36, 0xc4, 0x44,
 0xba, 0x2e, 0x9f, 0xbc, 0xd1, 0x0d, 0xb7, 0x65, 0x0e, 0xd3, 0x35, 0x6e, 0xfb, 0xe9, 0x78, 0x89,
 0xf4, 0x29, 0xab, 0xa6, 0xdf, 0x8e, 0xaa, 0x93, 0xf8, 0xb7, 0x75, 0x2a, 0xf2, 0xd2, 0xde, 0x3f,
 0x07, 0x52, 0x73, 0x48, 0x39, 0x85, 0x95, 0x69, 0x05, 0x69, 0xee, 0xe2, 0xcf, 0x0d, 0xba, 0xb2,
 0xb5, 0x08, 0x39, 0xa5, 0xa5, 0x69, 0x07, 0x34, 0xa8, 0x95, 0x45, 0x95, 0x95, 0xa4, 0x55, 0xa5,
 0x97, 0x34, 0x82, 0xb0, 0xa8, 0xb2, 0xa2, 0xca, 0xca, 0xde, 0x3c, 0x88, 0x2b, 0x4b, 0x4a, 0xdb,
 0x18, 0xdc, 0x88, 0x88, 0xaa, 0xaa, 0x88, 0x88, 0x9a, 0xaa, 0xaf, 0x61, 0x5c, 0xb6, 0x54, 0x4a,
 0xbb, 0x91, 0x11, 0x15, 0x55, 0x51, 0x11, 0x39, 0xaa, 0x9a, 0x0e, 0x6f, 0xcc, 0x89, 0x32, 0xe7,
 0xc8, 0x48, 0x3d, 0x52, 0x07, 0x28, 0x91, 0x13, 0xf3, 0x96, 0x4b, 0x7d, 0x24, 0xb3, 0xa6, 0x66,
 0x59, 0xb7, 0x3a, 0x43, 0x0f, 0x7a, 0xa4, 0xba, 0x2e, 0x91, 0x22, 0x27, 0x38, 0xb6, 0xfd, 0x1f,
 0xa4, 0xd4, 0x8f, 0x2b, 0xd5, 0xba, 0xc4, 0xdf, 0x7c, 0x38, 0x67, 0xc3, 0xe7, 0x3d, 0xde, 0x97,
 0xa6, 0xf4, 0xee, 0x1b, 0x65, 0xcb, 0x1e, 0x3f, 0x28, 0xec, 0x01, 0x39, 0x02, 0x71, 0x53, 0x75,
 0xca, 0x19, 0x61, 0x7c, 0x89, 0xfc, 0x46, 0x1e, 0x9f, 0x95, 0x0a, 0x0b, 0xbe, 0x97, 0x7a, 0x8e,
 0x97, 0x49, 0xa3, 0xc9, 0xab, 0xc9, 0xc2, 0x9f, 0xed, 0x0e, 0xd7, 0x53, 0xa9, 0xa6, 0x9e, 0x9c,
 0xaf, 0x23, 0x27, 0x60, 0x4e, 0x84, 0x8d, 0xc4, 0xa6, 0xd9, 0xa4, 0x45, 0x4d, 0x60, 0xb1, 0x53,
 0x92, 0x7b, 0xe5, 0xfd, 0xc6, 0xd0, 0xac, 0xe0, 0x58, 0x56, 0x11, 0x56, 0x9f, 0x40, 0xd1, 0x69,
 0x71, 0xe9, 0x31, 0x46, 0x3a, 0x7f, 0xf5, 0xe4, 0xf5, 0x1a, 0xab, 0x6a, 0x2f, 0xce, 0xca, 0xca,
 0xcd, 0x08, 0x2b, 0x4b, 0x2a, 0xd2, 0x2a, 0xd3, 0x99, 0x12, 0xd5, 0x16, 0x56, 0x56, 0x91, 0x56,
 0x96, 0x15, 0x84, 0x55, 0xa5, 0x44, 0xab, 0x92, 0xb2, 0xb7, 0x89, 0x17, 0x34, 0xb0, 0xad, 0x22,
 0xad, 0x2e, 0x2c, 0xad, 0xd5, 0x95, 0xa4, 0x55, 0xa5, 0x97, 0x35, 0x08, 0x2b, 0x0c, 0xee, 0xa8,
 0x97, 0x4b, 0x87, 0x18, 0xce, 0xc8, 0xd7, 0x14, 0x32, 0x31, 0x99, 0x91, 0x8f, 0xcd, 0xbb, 0xb8,
 0x91, 0x63, 0x86, 0x46, 0xb9, 0x9d, 0x91, 0xee, 0x27, 0x64, 0x6b, 0x99, 0xe1, 0xc6, 0xb9, 0x9d,
 0xdb, 0x22, 0xc7, 0x10, 0xe3, 0x5c, 0xce, 0xc8, 0xd7, 0x13, 0xb2, 0x31, 0x9d, 0x91, 0xae, 0x56,
 0xeb, 0x8b, 0x9c, 0x32, 0x35, 0xcb, 0x0c, 0x8f, 0x71, 0x2b, 0x23, 0x5c, 0xb0, 0xc8, 0xd7, 0x33,
 0xbb, 0x6c, 0x5d, 0xf3, 0xd6, 0xdc, 0x5d, 0xbd, 0xb4, 0xec, 0x55, 0x7a, 0xa4, 0x1f, 0xb2, 0x61,
 0xa4, 0x9b, 0x96, 0xd9, 0xd7, 0x7f, 0x68, 0xf8, 0x9a, 0xda, 0x17, 0xd9, 0x30, 0xd3, 0x4f, 0x59,
 0xa7, 0xfe, 0x15, 0x7e, 0xd0, 0xf5, 0x98, 0x3f, 0x85, 0x5f, 0xb4, 0x3a, 0x87, 0x83, 0x3b, 0xb7,
 0x36, 0x8e, 0xe5, 0xfe, 0x81, 0x1b, 0xfa, 0xa7, 0xd3, 0xd0, 0xe3, 0xdc, 0xf9, 0x6b, 0xc1, 0xcd,
 0xdb, 0x9b, 0x41, 0x72, 0xff, 0x00, 0x41, 0x8d, 0xfd, 0x53, 0xe9, 0x18, 0x71, 0xee, 0x74, 0xdd,
 0x4a, 0x7f, 0x7d, 0xf9, 0x3a, 0xad, 0x7d, 0xb6, 0xcd, 0xf9, 0x1e, 0x43, 0x8f, 0x72, 0xcc, 0x38,
 0xf7, 0x11, 0x43, 0x8f, 0x72, 0xc4, 0x39, 0x8b, 0x9c, 0x2d, 0xdc, 0x58, 0xb9, 0xf4, 0x29, 0x8b,
 0x96, 0xa1, 0x4c, 0xdc, 0x41, 0x0e, 0x3f, 0x0e, 0x65, 0x88, 0x53, 0x17, 0x33, 0xbb, 0x64, 0x5d,
 0xb0, 0xc2, 0x99, 0xb9, 0x6a, 0x14, 0xcf, 0x1e, 0x66, 0xbd, 0x0e, 0x62, 0xe5, 0x98, 0x73, 0x1d,
 0x54, 0xa8, 0xb3, 0x75, 0x72, 0x39, 0x2f, 0x86, 0xbc, 0x6a, 0x99, 0x03, 0x02, 0x4e, 0x98, 0xab,
 0x97, 0xfd, 0xca, 0x9f, 0x25, 0x9f, 0x52, 0xf8, 0x62, 0xc5, 0xa9, 0x91, 0x70, 0x44, 0xe9, 0x89,
 0xbb, 0xec, 0x94, 0xf9, 0x68, 0xef, 0xb4, 0x5f, 0xc1, 0x87, 0x69, 0xa7, 0x9d, 0xf1, 0xc4, 0x9e,
 0x64, 0x14, 0x47, 0x67, 0x9c, 0x05, 0xab, 0xc9, 0x71, 0x39, 0x64, 0xff, 0x00, 0x7a, 0xd3, 0xf5,
 0x01, 0x93, 0xaa, 0x91, 0x5e, 0x9b, 0xdf, 0x94, 0xbf, 0x49, 0xf9, 0x7d, 0x90, 0x97, 0x4c, 0xf1,
 0x80, 0xaf, 0x4c, 0x4a, 0x5b, 0xed, 0x5a, 0x7e, 0x90, 0x24, 0xdf, 0xf6, 0x67, 0xf1, 0xfc, 0xa5,
 0xfa, 0x4e, 0x3e, 0xbe, 0x76, 0x9a, 0x99, 0x6f, 0xc6, 0x61, 0xb8, 0x4a, 0xe2, 0x2a, 0xdd, 0x3c,
 0xa1, 0x8c, 0x29, 0xb8, 0x31, 0x93, 0x48, 0x88, 0x9a, 0xf5, 0x43, 0x48, 0x83, 0x36, 0xa9, 0xda,
 0x5e, 0x81, 0x3a, 0xbd, 0x4e, 0x14, 0x5e, 0x58, 0x8c, 0xbb, 0xf9, 0x9a, 0x67, 0x3c, 0x4f, 0x0e,
 0xcb, 0xb9, 0x53, 0x15, 0xcc, 0x73, 0x8e, 0x45, 0x95, 0xc3, 0x65, 0x22, 0x4d, 0x45, 0x4d, 0x74,
 0x57, 0x23, 0x1a, 0xab, 0xbb, 0xe9, 0x55, 0xd1, 0x3e, 0x33, 0xf2, 0xc7, 0x3b, 0x66, 0x3c, 0x53,
 0x37, 0x66, 0x9c, 0x43, 0x31, 0x63, 0x11, 0x96, 0x2c, 0xec, 0xf4, 0x65, 0x8b, 0x11, 0x7b, 0x1a,
 0x8b, 0xc9, 0x89, 0xd1, 0xad, 0x4d, 0x11, 0x13, 0xa2, 0x1f, 0x7b, 0xf8, 0x55, 0x62, 0x31, 0xd9,
 0xe0, 0xf7, 0x9a, 0x92, 0x03, 0x95, 0x1c, 0xf8, 0x50, 0x18, 0xed, 0x17, 0xf2, 0x5d, 0x31, 0x0d,
 0x1d, 0xf3, 0x6a, 0x7e, 0x78, 0x2f, 0x33, 0xb4, 0xd2, 0x4f, 0x2a, 0xee, 0xd9, 0x5a, 0xd7, 0x7d,
 0xe2, 0x02, 0x22, 0xaa, 0xf0, 0x3b, 0xfe, 0xc1, 0xbc, 0x1d, 0xe6, 0xb3, 0xa6, 0x07, 0x03, 0x34,
 0x66, 0x59, 0xc8, 0xf8, 0x76, 0x11, 0x1d, 0x55, 0x65, 0x20, 0x40, 0x6a, 0x57, 0x99, 0x6a, 0x2e,
 0x8a, 0xfd, 0x57, 0x83, 0x19, 0xaa, 0x68, 0x8b, 0xa2, 0xaa, 0xd9, 0x38, 0xaf, 0x00, 0x6f, 0x3f,
 0x88, 0xfd, 0x45, 0xd8, 0xf2, 0xe1, 0xf8, 0xb6, 0xc8, 0xb2, 0x9c, 0xf6, 0x17, 0xb8, 0xb2, 0x8f,
 0xc2, 0x25, 0xda, 0xdd, 0xce, 0x4d, 0x73, 0x21, 0xa3, 0x1c, 0xdf, 0x4a, 0x39, 0xae, 0x45, 0x4e,
 0xa6, 0xfc, 0x97, 0xe1, 0x0d, 0x5a, 0xaf, 0x79, 0xc3, 0x6c, 0x7e, 0x6e, 0x77, 0x97, 0xb6, 0x2d,
 0xb3, 0x8c, 0xbc, 0xd6, 0xfb, 0x0f, 0x2a, 0xc9, 0xc7, 0x8a, 0xde, 0x35, 0xa7, 0x75, 0x98, 0x7a,
 0xaf, 0x5f, 0x2f, 0x87, 0xc8, 0x88, 0x6d, 0xd0, 0xe4, 0x20, 0xcb, 0x40, 0x48, 0x12, 0xb0, 0x21,
 0x40, 0x84, 0x89, 0xa2, 0x43, 0x84, 0xc4, 0x63, 0x53, 0xe2, 0x4e, 0x06, 0xe5, 0x33, 0x87, 0xf3,
 0xf2, 0x4d, 0x77, 0x35, 0xce, 0x61, 0xd9, 0x6b, 0x02, 0x9d, 0xc7, 0x71, 0x78, 0xec, 0x97, 0x91,
 0x91, 0x84, 0xb1, 0xa3, 0x3d, 0xdd, 0x13, 0xb1, 0x3a, 0xaa, 0xae, 0x88, 0x89, 0xda, 0xaa, 0x86,
 0x69, 0x96, 0x25, 0xe4, 0xf5, 0x5a, 0x3c, 0xd9, 0x27, 0x6b, 0xcc, 0xcb, 0xf3, 0xcf, 0x6e, 0x6e,
 0x47, 0x6d, 0x7f, 0x35, 0xab, 0x57, 0x87, 0x8d, 0x63, 0xa7, 0xfb, 0x46, 0x96, 0x32, 0xcd, 0x18,
 0xa4, 0x4c, 0x6f, 0x31, 0xe2, 0x58, 0xc4, 0x56, 0xee, 0x3e, 0x7a, 0x6a, 0x24, 0xc2, 0xb7, 0x5d,
 0x77, 0x77, 0xdc, 0xae, 0xd3, 0xe2, 0xd7, 0x41, 0x69, 0x6f, 0x61, 0x86, 0x9c, 0x31, 0xd6, 0xb3,
 0xf2, 0x88, 0x7d, 0x4d, 0xe0, 0x75, 0x0a, 0xa6, 0x45, 0xc6, 0x97, 0xff, 0x00, 0x73, 0x6f, 0xd9,
 0x21, 0xda, 0x62, 0xcb, 0xd8, 0xe4, 0x5e, 0x05, 0x2c, 0x48, 0x99, 0x17, 0x1e, 0x6f, 0x6b, 0x71,
 0x36, 0x2f, 0xcb, 0x09, 0x3d, 0x47, 0x73, 0x8b, 0x2f, 0x63, 0x95, 0x8e, 0xfb, 0x57, 0x67, 0xcd,
 0x7a, 0xfe, 0x97, 0x9e, 0xbb, 0x25, 0xbf, 0xe7, 0x94, 0x39, 0x0f, 0x84, 0x4c, 0x1d, 0xcd, 0x8f,
 0xe3, 0xae, 0xd3, 0x92, 0x41, 0xfb, 0x66, 0x1f, 0x1c, 0xa9, 0xf6, 0xbf, 0x84, 0xb4, 0x1d, 0xcd,
 0x8b, 0x63, 0xee, 0xd3, 0x92, 0x40, 0xfb, 0x78, 0x67, 0xc5, 0x0a, 0x6a, 0xcd, 0x6d, 0xec, 0xf4,
 0xde, 0xc9, 0xe3, 0xf7, 0x7a, 0x2b, 0x47, 0xfe, 0xd3, 0xfa, 0x40, 0x3e, 0xda, 0xca, 0x30, 0xbf,
 0x82, 0x38, 0x32, 0xe9, 0xfd, 0xef, 0x81, 0xf6, 0x6d, 0x3e, 0x26, 0x4e, 0x47, 0xdd, 0x19, 0x3a,
 0x0a, 0xae, 0x4d, 0xc1, 0x17, 0xae, 0x1d, 0x2f, 0xf6, 0x6d, 0x37, 0x69, 0x27, 0x6b, 0x4b, 0x85,
 0xed, 0xaf, 0x86, 0x0c, 0x5f, 0x79, 0xfd, 0x1e, 0xbe, 0x0a, 0x74, 0x30, 0x44, 0x85, 0xe4, 0xbb,
 0x87, 0x60, 0xd9, 0xf0, 0x94, 0xc1, 0x16, 0x17, 0x92, 0xbe, 0x85, 0x3b, 0x28, 0xbb, 0xe7, 0xf4,
 0xbf, 0x8c, 0x3e, 0x0e, 0x8b, 0xfc, 0x63, 0xbd, 0x2a, 0x79, 0xd8, 0x7b, 0x17, 0xf8, 0xd7, 0xfe,
 0x92, 0x91, 0x3a, 0x27, 0xdd, 0x61, 0xf4, 0x77, 0x83, 0xec, 0x3d, 0xed, 0x9d, 0x35, 0x7f, 0xa6,
 0xc6, 0xfa, 0x18, 0x6f, 0xaf, 0x85, 0x63, 0x4c, 0xf0, 0x73, 0x87, 0xbd, 0xb3, 0x56, 0xaf, 0xf4,
 0xf8, 0xdf, 0x43, 0x0e, 0x86, 0xf8, 0x47, 0xa1, 0xd2, 0xdf, 0xf7, 0x55, 0x7c, 0x9b, 0xab, 0xdf,
 0x6d, 0x7e, 0x5f, 0xbc, 0x94, 0xbe, 0x12, 0x74, 0x3e, 0x6c, 0xdb, 0x4a, 0x6e, 0xed, 0x23, 0x13,
 0x4b, 0x42, 0xfb, 0x26, 0x9f, 0x51, 0xbe, 0x11, 0xf3, 0x06, 0xdc, 0x53, 0x77, 0x69, 0xd8, 0xaa,
 0x5a, 0x0f, 0xd9, 0x30, 0xd1, 0xd4, 0x6d, 0xbe, 0x28, 0xfb, 0xbb, 0xaf, 0x64, 0xed, 0xbe, 0xaa,
 0xff, 0x00, 0xe9, 0xfe, 0xb0, 0xd2, 0x50, 0xe9, 0xbe, 0x0f, 0xed, 0xde, 0xc7, 0x31, 0x34, 0xfe,
 0x88, 0xdf, 0xb4, 0x69, 0xcc, 0x8e, 0xa7, 0xe0, 0xea, 0xdd, 0xec, 0x7b, 0x15, 0x4e, 0x92, 0x6d,
 0xfb, 0x46, 0x9c, 0x0d, 0x0c, 0xed, 0x9e, 0xbf, 0x77, 0xad, 0xeb, 0x13, 0xb6, 0x8b, 0x27, 0xd9,
 0xd6, 0x9f, 0x09, 0x3a, 0x1c, 0xc7, 0x6f, 0x32, 0x8b, 0xe2, 0xac, 0x36, 0x69, 0x13, 0xf1, 0x23,
 0xbd, 0x8b, 0x6d, 0xe6, 0xa2, 0xff, 0x00, 0x54, 0xeb, 0xaf, 0x85, 0x63, 0x52, 0xda, 0x9e, 0x0e,
 0xfc, 0x53, 0x25, 0x4f, 0x42, 0x84, 0xc5, 0x74, 0x68, 0x08, 0x93, 0x10, 0xd1, 0x13, 0x9a, 0xb3,
 0x8a, 0xfc, 0xda, 0x9e, 0x87, 0x57, 0x13, 0x93, 0x05, 0xab, 0x0f, 0x09, 0xd2, 0x75, 0x31, 0x8b,
 0x57, 0x8e, 0xd6, 0xf2, 0xdf, 0xf5, 0xf0, 0x7c, 0xe2, 0x9d, 0x0b, 0xf8, 0x0c, 0x38, 0x11, 0xb1,
 0xa9, 0x28, 0x33, 0x4d, 0x47, 0xc0, 0x7c, 0x76, 0x36, 0x22, 0x6b, 0xa6, 0xa8, 0xab, 0xa2, 0xf2,
 0x28, 0x29, 0xeb, 0x1e, 0xe6, 0x39, 0x1c, 0xd5, 0xd1, 0xc8, 0xba, 0xa2, 0xf4, 0x53, 0xca, 0xc4,
 0xc4, 0x4c, 0x4b, 0xe9, 0x96, 0x89, 0x98, 0x98, 0x77, 0x47, 0x64, 0x2c, 0xaa, 0x8a, 0xbf, 0x82,
 0x93, 0x9f, 0xf8, 0x78, 0x9e, 0xb2, 0x0b, 0x91, 0x32, 0xaf, 0xf8, 0xa9, 0x3b, 0xe8, 0x9e, 0xb1,
 0xb6, 0x4e, 0xc6, 0x20, 0x66, 0x0c, 0x0a, 0x04, 0xf4, 0x27, 0xa5, 0x66, 0xa2, 0x32, 0x61, 0x9a,
 0xf1, 0x63, 0xd1, 0x38, 0xfc, 0xbc, 0xd0, 0x6a, 0xe8, 0x6a, 0x7b, 0x1c, 0x58, 0x74, 0xd9, 0x2b,
 0x16, 0xad, 0x63, 0xc7, 0xf0, 0x87, 0xcf, 0x32, 0xeb, 0x75, 0x98, 0xaf, 0x34, 0xbd, 0xe7, 0x78,
 0xfc, 0x5a, 0x9f, 0xb4, 0x4c, 0xaf, 0xfe, 0x2a, 0x4e, 0xfa, 0x27, 0xac, 0x8a, 0xe4, 0x5c, 0xaf,
 0xd9, 0x85, 0xa7, 0x7d, 0x13, 0xd6, 0x6d, 0x11, 0xdd, 0x0e, 0x0c, 0x27, 0xc5, 0x8a, 0xf6, 0xb2,
 0x1b, 0x1a, 0xae, 0x7b, 0x95, 0x74, 0x46, 0xa2, 0x73, 0x53, 0x8d, 0x4e, 0xed, 0x0b, 0x1d, 0x4c,
 0x56, 0x62, 0x2c, 0x9c, 0xc3, 0x3d, 0x8a, 0xe8, 0x8a, 0xb0, 0xa1, 0x44, 0x84, 0xd5, 0x44, 0x6f,
 0x62, 0x75, 0x34, 0xea, 0xad, 0xa4, 0xd3, 0x6d, 0xce, 0x91, 0xe3, 0xf8, 0x43, 0x9b, 0xa1, 0x8d,
 0x7e, 0xb7, 0x7e, 0x19, 0x27, 0xc3, 0xf1, 0x96, 0xf6, 0xec, 0x8f, 0x95, 0xd3, 0xfb, 0xd6, 0x9d,
 0xf4, 0x4f, 0x59, 0x63, 0x0c, 0xcb, 0x38, 0x26, 0x17, 0x36, 0x93, 0x52, 0x32, 0x29, 0x0a, 0x32,
 0x22, 0xa2, 0x3a, 0xa3, 0x97, 0x82, 0xf3, 0xe0, 0xaa, 0x69, 0x52, 0x9b, 0x4e, 0x9f, 0x66, 0x89,
 0x37, 0x86, 0xcb, 0x46, 0x4e, 0xd5, 0x86, 0xe7, 0x31, 0x7f, 0x7a, 0x1b, 0xa6, 0x4f, 0xcc, 0x70,
 0xf3, 0x24, 0x08, 0xf1, 0x61, 0xc8, 0xc5, 0x96, 0x48, 0x2a, 0x8d, 0x72, 0xbd, 0xc8, 0xe4, 0x55,
 0x5e, 0xc4, 0x5f, 0xfb, 0xec, 0x33, 0xa6, 0xcf, 0xa1, 0xcb, 0x78, 0x8c, 0x71, 0x1b, 0xfd, 0x95,
 0xaa, 0xc1, 0xd4, 0x70, 0xe3, 0x99, 0xcb, 0x69, 0xe3, 0xf3, 0xf1, 0xdc, 0xd9, 0x5a, 0x41, 0x5a,
 0x59, 0x73, 0x48, 0x2b, 0x4e, 0xdf, 0x93, 0xa8, 0xe4, 0xae, 0xad, 0x20, 0xad, 0x2c, 0xab, 0x48,
 0x2b, 0x4a, 0xdd, 0x51, 0x65, 0x75, 0x69, 0x05, 0x69, 0x65, 0xcd, 0x20, 0xad, 0x2a, 0x25, 0x51,
 0x2a, 0xea, 0xc3, 0x9e, 0xe7, 0xfc, 0xc7, 0xbe, 0xf7, 0xe1, 0x12, 0x11, 0x3c, 0x84, 0xe1, 0x1e,
 0x22, 0x2f, 0xe3, 0x2f, 0xbd, 0x4b, 0x75, 0x36, 0x0d, 0xa1, 0xe3, 0x8b, 0x84, 0x61, 0xc9, 0x2d,
 0x2e, 0xed, 0x26, 0xe6, 0x51, 0x51, 0xaa, 0x9f, 0x90, 0xce, 0xd7, 0x7a, 0x7b, 0x13, 0xe3, 0xe8,
 0x72, 0x67, 0x2e, 0xab, 0xa9, 0xe7, 0xba, 0xcf, 0x51, 0x9a, 0xfe, 0xe3, 0x1c, 0xfd, 0xde, 0x8f,
 0xa3, 0x68, 0x62, 0xd1, 0xef, 0xf2, 0x7e, 0x5f, 0xdc, 0x1e, 0xa2, 0x2a, 0xf2, 0x4d, 0x4f, 0x10,
 0xdd, 0x36, 0x7d, 0x85, 0x48, 0xab, 0xbc, 0x69, 0x3f, 0x1e, 0x5d, 0x37, 0x57, 0x48, 0x10, 0xe2,
 0x44, 0x6a, 0x71, 0xf7, 0xca, 0x8a, 0xbf, 0x21, 0xe7, 0xf4, 0xd8, 0x27, 0x3e, 0x48, 0xa4, 0x4e,
 0xce, 0xff, 0x00, 0x51, 0x9a, 0x30, 0xe3, 0x9b, 0xcc, 0x6e, 0xb5, 0x93, 0x72, 0xad, 0x14, 0x66,
 0x23, 0x89, 0x43, 0xd6, 0x22, 0xf9, 0x50, 0xa0, 0xb9, 0x3f, 0x16, 0xee, 0xbd, 0x8d, 0xc1, 0xcd,
 0x05, 0x9c, 0x91, 0xd7, 0xff, 0x00, 0x3d, 0x2b, 0xdf, 0xb7, 0xd6, 0x45, 0x67, 0x64, 0x7c, 0xf6,
 0x57, 0xbe, 0x6f, 0xac, 0xf7, 0x3a, 0x4c, 0x78, 0x34, 0xb8, 0xf8, 0x52, 0x63, 0xd6, 0x1e, 0x3f,
 0x51, 0x97, 0x3e, 0xa2, 0xfc, 0xef, 0x13, 0xe9, 0x3e, 0x0f, 0x15, 0xa4, 0x55, 0xa0, 0xb3, 0x92,
 0x3e, 0x7b, 0x2d, 0xdf, 0x37, 0xd6, 0x78, 0xd9, 0xa9, 0x37, 0xb9, 0x18, 0xd9, 0xb9, 0x77, 0x39,
 0x57, 0x82, 0x24, 0x56, 0xaa, 0xaf, 0xa1, 0x35, 0x39, 0x91, 0x9e, 0x9f, 0x54, 0x7a, 0xc3, 0x4c,
 0x52, 0xfb, 0x79, 0x4f, 0xa2, 0x2a, 0xc2, 0x2a, 0xd2, 0xc2, 0xb4, 0x82, 0xb4, 0xdd, 0xba, 0x62,
 0xca, 0xea, 0xde, 0x24, 0x55, 0xa5, 0x85, 0x69, 0x05, 0x69, 0x51, 0x2b, 0x8b, 0x2b, 0xab, 0x48,
 0xab, 0x0b, 0x0a, 0xde, 0x24, 0x55, 0xa5, 0x44, 0xab, 0x75, 0x65, 0x69, 0x15, 0x69, 0x61, 0x5a,
 0x45, 0x5a, 0x54, 0x4a, 0xb7, 0x6c, 0x0c, 0x8c, 0x66, 0x64, 0x55, 0xea, 0x2a, 0x63, 0xd5, 0x39,
 0xea, 0x66, 0x64, 0x4f, 0x49, 0xf9, 0xbb, 0x77, 0x06, 0x2c, 0x6a, 0xc8, 0xd7, 0x33, 0xb2, 0x35,
 0xc5, 0x2c, 0x8a, 0xb7, 0x33, 0xc3, 0x88, 0xb7, 0x33, 0x12, 0xb8, 0xb9, 0xab, 0x23, 0x5c, 0xcf,
 0x0e, 0x35, 0xc5, 0x2c, 0x88, 0xbd, 0x14, 0xcc, 0xc8, 0xab, 0x73, 0x3b, 0xae, 0x2c, 0x6e, 0xc8,
 0xc6, 0x76, 0x46, 0xb8, 0xa1, 0x91, 0x56, 0xe6, 0x66, 0x45, 0x5b, 0x99, 0xdd, 0xb2, 0x2e, 0xe2,
 0x9b, 0x5e, 0x76, 0xf6, 0xd0, 0x71, 0x25, 0xea, 0x90, 0xbe, 0xcd, 0xa6, 0xa4, 0xa6, 0xd5, 0xb5,
 0x4d, 0xe7, 0xe7, 0xa9, 0xf7, 0x6e, 0xaa, 0xea, 0x90, 0xfb, 0x3f, 0xf4, 0xda, 0x6a, 0xdb, 0x8f,
 0xf7, 0xae, 0xf9, 0x0f, 0x5f, 0xa7, 0xfe, 0x15, 0x7e, 0xd0, 0xf6, 0x9a, 0x69, 0xfd, 0xcd, 0x7e,
 0xd0, 0xe8, 0x3e, 0x0f, 0xee, 0xdc, 0xcf, 0x8e, 0x5f, 0xe8, 0x51, 0x7f, 0xaa, 0x7d, 0x08, 0xc8,
 0xd7, 0x3e, 0x76, 0xd8, 0x66, 0xf3, 0x33, 0xb3, 0x95, 0x51, 0x53, 0xfb, 0x4e, 0x2f, 0x67, 0xe8,
 0x9d, 0xe2, 0x1c, 0x65, 0x3a, 0x4e, 0xa7, 0x3f, 0xbe, 0xfc, 0x9d, 0x2f, 0x53, 0xb6, 0xd9, 0xff,
 0x00, 0x23, 0x98, 0x71, 0x8c, 0xf0, 0xe3, 0xdc, 0x4d, 0x0e, 0x32, 0x99, 0xe1, 0xc5, 0x5b, 0x9c,
 0x0d, 0xdc, 0x18, 0xb9, 0xd4, 0x28, 0xf7, 0x2c, 0xc3, 0x8f, 0xc7, 0x98, 0x92, 0x1c, 0x65, 0xb9,
 0x9e, 0x1c, 0x65, 0x33, 0xbb, 0x64, 0x5c, 0xf2, 0x1c, 0x7b, 0x96, 0x61, 0xc7, 0xb8, 0x8a, 0x1c,
 0x75, 0x2c, 0xb2, 0x3f, 0xa4, 0xa8, 0x96, 0xd8, 0xbb, 0x99, 0x78, 0x5a, 0xc5, 0xa9, 0x92, 0xb0,
 0x74, 0xe9, 0x88, 0xbb, 0xec, 0x94, 0xf9, 0xa0, 0xfa, 0x33, 0xc2, 0x99, 0xea, 0xfc, 0x9d, 0x84,
 0xa7, 0xfe, 0xe0, 0xbf, 0x64, 0xa7, 0xce, 0x9a, 0x2f, 0x45, 0x3d, 0x0e, 0x83, 0xf8, 0x10, 0xef,
 0x34, 0x73, 0xbe, 0x28, 0x38, 0xc8, 0xeb, 0xa6, 0x74, 0xc1, 0x17, 0xa6, 0x23, 0x2f, 0xf6, 0xad,
 0x3f, 0x41, 0xbd, 0x93, 0xfd, 0x95, 0xfc, 0x7f, 0x29, 0x7e, 0x93, 0xf3, 0xe3, 0x25, 0xea, 0x99,
 0xc3, 0x06, 0x5d, 0x17, 0x86, 0x21, 0x03, 0xed, 0x1a, 0x7d, 0xe1, 0x5d, 0x6a, 0xbb, 0xf4, 0x97,
 0xe9, 0x38, 0xdd, 0x4a, 0x76, 0x9a, 0xb5, 0xeb, 0x2d, 0xb4, 0xc3, 0x61, 0x85, 0x33, 0x72, 0xdc,
 0x29, 0xa5, 0xea, 0x6b, 0x70, 0xa3, 0xaf, 0x52, 0xd4, 0x29, 0x85, 0xd7, 0x99, 0xd6, 0xc5, 0x9c,
 0x6a, 0xe4, 0x64, 0xda, 0x2e, 0x13, 0xed, 0xaf, 0x67, 0xf8, 0xe6, 0x5d, 0x45, 0x4a, 0x93, 0xf2,
 0x4f, 0x87, 0x09, 0x57, 0x92, 0x44, 0xd3, 0x56, 0x7f, 0xb4, 0x88, 0x7e, 0x73, 0x4d, 0xc0, 0x8d,
 0x2d, 0x35, 0x16, 0x5e, 0x62, 0x13, 0xa1, 0x46, 0x84, 0xf5, 0x64, 0x46, 0x39, 0x34, 0x56, 0xb9,
 0x17, 0x45, 0x45, 0x4b, 0x2a, 0x29, 0xfa, 0x41, 0x0a, 0x65, 0x7a, 0x9c, 0x0f, 0xc2, 0x23, 0x62,
 0xf1, 0xf3, 0x0c, 0xf4, 0x6c, 0xdd, 0x94, 0x20, 0x35, 0xf8, 0x8c, 0x4f, 0x2a, 0x7a, 0x41, 0xba,
 0x25, 0x75, 0xff, 0x00, 0x09, 0x0f, 0xb3, 0x7f, 0xab, 0x7b, 0x79, 0xa7, 0x1e, 0x0b, 0xd8, 0xe8,
 0xb5, 0x11, 0x59, 0x9a, 0xdb, 0xe6, 0xe5, 0xe0, 0xcb, 0x1e, 0x52, 0xf9, 0x5d, 0x38, 0x29, 0xd8,
 0xfc, 0x1f, 0xf6, 0xff, 0x00, 0x99, 0x76, 0x50, 0xc8, 0x98, 0x5a, 0x4b, 0x33, 0x19, 0xcb, 0xf1,
 0xa2, 0x54, 0x74, 0x84, 0x68, 0x8a, 0xc5, 0x84, 0xf5, 0xe6, 0xe8, 0x4f, 0xd1, 0x77, 0x55, 0x7b,
 0x51, 0x51, 0x51, 0x79, 0xf0, 0x5e, 0x27, 0x23, 0x9e, 0x93, 0x9a, 0x92, 0x99, 0x89, 0x2d, 0x39,
 0x2d, 0x1a, 0x5e, 0x3c, 0x37, 0x6e, 0xbe, 0x1c, 0x56, 0x2b, 0x5c, 0xd5, 0xe8, 0xa8, 0xbc, 0x50,
 0xc1, 0xa2, 0xf4, 0x53, 0xb5, 0xb5, 0x62, 0xd1, 0xb4, 0xb9, 0x8f, 0xb5, 0xb1, 0x2f, 0x0d, 0x1c,
 0xb3, 0xec, 0x05, 0x74, 0x8e, 0x46, 0xc5, 0x62, 0xcd, 0xee, 0xf0, 0x64, 0x69, 0xc8, 0x6c, 0x87,
 0xad, 0xdc, 0xd4, 0x55, 0xd3, 0xe2, 0x3e, 0x71, 0xdb, 0x2e, 0xd9, 0xb3, 0x7e, 0xd4, 0x26, 0x5a,
 0xcc, 0x62, 0x3c, 0x39, 0x3c, 0x2e, 0x13, 0xf7, 0xe0, 0x61, 0xb2, 0x88, 0xad, 0x82, 0xc5, 0xf7,
 0xce, 0xd7, 0x8b, 0xdd, 0x77, 0x72, 0xec, 0x44, 0x39, 0xba, 0x35, 0x55, 0x79, 0x29, 0xd7, 0x76,
 0x35, 0xb0, 0x5c, 0xdb, 0x9f, 0xa6, 0xe0, 0x4d, 0xce, 0x40, 0x8b, 0x81, 0xe0, 0x2a, 0xe4, 0x58,
 0x93, 0xd3, 0x30, 0xd5, 0x1d, 0x11, 0xbd, 0x20, 0xb1, 0x74, 0x57, 0xad, 0xf8, 0x36, 0xfd, 0x86,
 0xbe, 0x38, 0xf1, 0x46, 0xe9, 0x98, 0x8d, 0xf7, 0x97, 0x22, 0x54, 0x5d, 0x0f, 0x0f, 0xa4, 0x3c,
 0x32, 0x36, 0x5f, 0x80, 0xe4, 0x6c, 0x2b, 0x28, 0xce, 0x65, 0x5c, 0x3d, 0x25, 0xa4, 0x12, 0x0c,
 0x4c, 0x3e, 0x65, 0xea, 0xba, 0xbe, 0x2c, 0x66, 0xad, 0x46, 0xc4, 0x88, 0xef, 0xca, 0x7b, 0x91,
 0xce, 0xd5, 0x7f, 0x9a, 0x88, 0x9c, 0x34, 0x3e, 0x70, 0xd1, 0x7a, 0x29, 0x54, 0xbc, 0x5e, 0xbc,
 0xa1, 0x4f, 0xaa, 0xbc, 0x04, 0x66, 0x5b, 0x1b, 0x0d, 0xcd, 0x78, 0x76, 0xbe, 0x5c, 0x38, 0xb2,
 0xd1, 0xd1, 0xb6, 0x54, 0x7b, 0x55, 0x7e, 0x64, 0xf9, 0x4f, 0xa4, 0x62, 0xcb, 0xd8, 0xf8, 0xbf,
 0xc0, 0xd3, 0x34, 0x43, 0xcb, 0xdb, 0x66, 0x95, 0xc3, 0xe6, 0xe2, 0x53, 0x94, 0xc7, 0x20, 0xbb,
 0x0f, 0x72, 0xaa, 0xe8, 0x89, 0x11, 0x55, 0x1d, 0x09, 0x57, 0xfd, 0x36, 0xa3, 0x7f, 0xd2, 0x3e,
 0xf2, 0x99, 0xc3, 0xd7, 0x8f, 0x92, 0x27, 0x27, 0x19, 0xd9, 0xe6, 0xba, 0xa7, 0x4f, 0x9c, 0x99,
 0x66, 0xf1, 0xf3, 0x70, 0xaf, 0x0a, 0x38, 0x0a, 0xcd, 0x87, 0x66, 0x17, 0x69, 0xc9, 0x25, 0xff,
 0x00, 0xe2, 0x21, 0x9f, 0x0b, 0xa9, 0xf7, 0xe7, 0x85, 0x9c, 0xa3, 0xa1, 0x6c, 0x13, 0x32, 0x3f,
 0x4e, 0x5e, 0xc6, 0xff, 0x00, 0x89, 0x84, 0x7c, 0x08, 0xa8, 0xbd, 0x14, 0xbe, 0x5c, 0xbc, 0x5c,
 0xee, 0x8b, 0x86, 0x71, 0x60, 0x9a, 0xcf, 0x7f, 0xec, 0xf1, 0x3f, 0x71, 0xf7, 0xe6, 0x4a, 0x97,
 0xd7, 0x24, 0xe0, 0x4b, 0xa7, 0x3c, 0x36, 0x5f, 0xec, 0x9a, 0x7c, 0x08, 0x88, 0xbd, 0x17, 0x91,
 0xfa, 0x21, 0x91, 0x20, 0x6b, 0x91, 0x32, 0xfa, 0xe9, 0xcf, 0x0b, 0x96, 0xfb, 0x26, 0x9b, 0x71,
 0x5b, 0x8c, 0xba, 0xcf, 0x6a, 0xb1, 0x7b, 0xdc, 0x38, 0xe3, 0xf1, 0x9f, 0xd1, 0x86, 0x24, 0xbd,
 0x8a, 0xd1, 0x60, 0x2e, 0xeb, 0xb8, 0x76, 0x29, 0xb0, 0xc5, 0x97, 0xb1, 0x52, 0x3c, 0xbf, 0x92,
 0xee, 0x1d, 0x8a, 0x72, 0xa3, 0x23, 0xe7, 0xd6, 0xd2, 0x4c, 0x4b, 0xf3, 0xa2, 0x2f, 0xf1, 0xaf,
 0xfd, 0x25, 0x22, 0x4e, 0x2a, 0x2d, 0x57, 0xf0, 0x5f, 0xc6, 0x52, 0x28, 0x8b, 0xd1, 0x4e, 0x03,
 0xed, 0x50, 0xfa, 0x87, 0xc1, 0xaa, 0x1e, 0xf6, 0xcc, 0x5a, 0xbf, 0xd3, 0xe3, 0xfd, 0x0c, 0x3a,
 0x43, 0xe0, 0xa1, 0xa1, 0x78, 0x30, 0xc2, 0x57, 0x6c, 0xad, 0xab, 0xa7, 0xf7, 0xc2, 0x3f, 0xd0,
 0xc3, 0xa6, 0x3e, 0x0a, 0xf4, 0x3b, 0x6c, 0x17, 0xda, 0x90, 0xf8, 0xef, 0x5a, 0xb6, 0xdd, 0x43,
 0x37, 0xfa, 0xa4, 0xa5, 0xf0, 0x8f, 0x95, 0xb6, 0xf4, 0x9b, 0xbb, 0x54, 0xc5, 0x92, 0xd0, 0x7e,
 0xc9, 0x87, 0xd7, 0x2f, 0x82, 0xbd, 0x0f, 0x92, 0xbc, 0x20, 0x5a, 0xa9, 0xb5, 0x9c, 0x5d, 0x34,
 0x5e, 0x50, 0x7e, 0xc5, 0x84, 0x6b, 0x6d, 0xbd, 0x23, 0xee, 0xef, 0x3d, 0x8e, 0xb6, 0xfa, 0xbb,
 0xff, 0x00, 0xa7, 0xfa, 0xc3, 0x41, 0x3a, 0xcf, 0x83, 0x53, 0x77, 0xb3, 0x0e, 0x2f, 0xc3, 0xfb,
 0x89, 0xbf, 0x68, 0xd3, 0x93, 0xe8, 0xbd, 0x14, 0xeb, 0xfe, 0x0b, 0xec, 0x57, 0x66, 0x3c, 0x65,
 0x34, 0x5f, 0xfc, 0x8b, 0x7e, 0xd1, 0xa7, 0x13, 0x4b, 0x3b, 0x65, 0xab, 0xd9, 0x75, 0xb9, 0xdb,
 0x41, 0x97, 0xec, 0xed, 0x4f, 0x85, 0x63, 0x0b, 0xe0, 0xa2, 0xa2, 0xa2, 0xb5, 0x15, 0x17, 0x9a,
 0x2f, 0x68, 0xd9, 0xf0, 0x57, 0xa7, 0xcc, 0x61, 0x7c, 0x15, 0xe8, 0x7a, 0x28, 0xbb, 0xe5, 0x95,
 0xc8, 0xf9, 0x73, 0x6a, 0x99, 0x52, 0x2e, 0x5a, 0xcc, 0x31, 0x29, 0x43, 0x5f, 0x17, 0xcc, 0xb9,
 0x62, 0x4b, 0x3f, 0xb1, 0x3a, 0xb3, 0xd2, 0x9a, 0xfc, 0x9a, 0x1a, 0x7e, 0x8a, 0x87, 0xd7, 0x79,
 0x97, 0x2f, 0xc8, 0x63, 0xd8, 0x5c, 0x5c, 0x37, 0x12, 0x81, 0x56, 0x0b, 0xf8, 0xa2, 0xa7, 0x07,
 0x31, 0xdd, 0x8e, 0x6a, 0xf6, 0x2a, 0x1c, 0x03, 0x3b, 0xec, 0xcb, 0x1f, 0xc0, 0x22, 0xbe, 0x34,
 0xac, 0x17, 0xe2, 0x38, 0x7a, 0x2e, 0xa9, 0x1a, 0x0b, 0x75, 0x73, 0x53, 0xf9, 0xed, 0x4e, 0x29,
 0xe9, 0x4d, 0x50, 0xe9, 0x35, 0x7a, 0x4b, 0x52, 0xd3, 0x6a, 0x79, 0x7e, 0x8f, 0xa2, 0x74, 0x6e,
 0xb9, 0x8b, 0x53, 0x8e, 0x31, 0x66, 0x9d, 0xaf, 0x1d, 0xfe, 0x7f, 0xee, 0xd5, 0x72, 0xfe, 0x39,
 0x89, 0x60, 0x53, 0xa9, 0x37, 0x86, 0xcc, 0xba, 0x13, 0xd5, 0x34, 0x73, 0x79, 0xb5, 0xe9, 0xd1,
 0xc9, 0xda, 0x86, 0xf9, 0x2d, 0xb5, 0xc9, 0x84, 0x83, 0xa4, 0xd6, 0x09, 0x06, 0x24, 0x4d, 0x38,
 0xba, 0x1c, 0x75, 0x6a, 0x2f, 0xc4, 0xa8, 0xa7, 0x32, 0x56, 0xb9, 0x17, 0x45, 0x6a, 0xa2, 0xfa,
 0x0f, 0x34, 0x5e, 0x8a, 0x68, 0xc5, 0xaa, 0xcd, 0x86, 0x36, 0xa5, 0xb6, 0x77, 0x1a, 0x8d, 0x06,
 0x9b, 0x53, 0x3b, 0xe5, 0xae, 0xf3, 0xff, 0x00, 0x3b, 0x36, 0xcc, 0xd9, 0x9e, 0xf1, 0x5c, 0x7e,
 0x0b, 0xa5, 0x37, 0x21, 0xc9, 0xca, 0x3b, 0xf1, 0xa1, 0x42, 0xd5, 0x55, 0xff, 0x00, 0xa4, 0xe5,
 0xe7, 0xe8, 0xe4, 0x6a, 0x6b, 0xd7, 0x50, 0xd1, 0x7a, 0x28, 0xd7, 0x00, 0xcb, 0xf8, 0xbe, 0x39,
 0x31, 0x47, 0x0c, 0x92, 0x8b, 0x1d, 0x75, 0xd1, 0xcf, 0xd3, 0x46, 0x37, 0xd2, 0xe5, 0xe0, 0x84,
 0xde, 0xf9, 0x33, 0xdb, 0x7b, 0x4c, 0xcc, 0xb6, 0xe3, 0xc7, 0x87, 0x4b, 0x8f, 0x6a, 0xc4, 0x56,
 0xaa, 0x12, 0x52, 0xd1, 0xe6, 0xe6, 0xe1, 0x4b, 0x4b, 0x43, 0x74, 0x48, 0xd1, 0x5c, 0x8d, 0x63,
 0x1b, 0xcd, 0x55, 0x4e, 0xfb, 0x95, 0x30, 0x48, 0x78, 0x16, 0x07, 0x02, 0x41, 0x8a, 0x8b, 0x11,
 0x13, 0x7a, 0x33, 0x93, 0xf2, 0x9e, 0xbc, 0xfd, 0x5f, 0x11, 0x5b, 0x22, 0xe4, 0x59, 0x7c, 0xbb,
 0x0b, 0xd9, 0x33, 0x0e, 0x6c, 0xce, 0x22, 0xf6, 0xe8, 0xe8, 0x88, 0x9e, 0x4c, 0x34, 0xed, 0x46,
 0xfa, 0xcd, 0x9d, 0xd0, 0x5c, 0x9d, 0x8a, 0x7a, 0x1e, 0x99, 0xa3, 0x9c, 0x1f, 0xbc, 0xbf, 0xf8,
 0xa7, 0xf9, 0x3c, 0x87, 0x59, 0xea, 0xd5, 0xd4, 0xcf, 0xba, 0xc5, 0x3f, 0xb3, 0x1f, 0xcd, 0x51,
 0x5a, 0x41, 0x5a, 0x5a, 0x73, 0x17, 0xa1, 0x8d, 0xcc, 0x5e, 0x87, 0x73, 0xbb, 0xa3, 0x89, 0x57,
 0x56, 0x90, 0x73, 0x4b, 0x2e, 0x62, 0xf4, 0x20, 0xac, 0x5e, 0x85, 0x6e, 0xbe, 0x4a, 0xee, 0x69,
 0x8d, 0xc8, 0x88, 0x8a, 0xaa, 0xba, 0x22, 0x73, 0x5e, 0x85, 0xa7, 0x32, 0xc2, 0x6c, 0xe7, 0x30,
 0xe9, 0x2c, 0xaf, 0x88, 0xcc, 0xb7, 0x54, 0x72, 0x41, 0x56, 0xb5, 0x7a, 0x2b, 0xbc, 0x9f, 0xde,
 0x62, 0xf9, 0x22, 0x94, 0x9b, 0x4f, 0xc9, 0xbb, 0x0d, 0x67, 0x25, 0xe2, 0x91, 0xf3, 0x71, 0xcc,
 0xd9, 0x8a, 0x2e, 0x2d, 0x8e, 0x4c, 0xcd, 0xa3, 0x95, 0x61, 0xab, 0xb7, 0x61, 0x27, 0x46, 0x27,
 0x04, 0xf5, 0xfc, 0x62, 0x83, 0xdd, 0x17, 0xa2, 0x86, 0x8b, 0xd1, 0x4f, 0x03, 0x7b, 0xcd, 0xed,
 0x36, 0x9f, 0x39, 0x7d, 0x1e, 0x94, 0x8a, 0x56, 0x2b, 0x5f, 0x28, 0x78, 0x7b, 0xa8, 0x68, 0xbd,
 0x14, 0x34, 0x5e, 0x8a, 0x42, 0x9e, 0x01, 0xee, 0x8b, 0xd1, 0x43, 0x45, 0xe8, 0xa0, 0x03, 0x1c,
 0xb7, 0xa2, 0xe3, 0xf2, 0x1f, 0xe7, 0x0c, 0xfa, 0x45, 0xda, 0x2f, 0x45, 0x18, 0xe5, 0x94, 0x5f,
 0x6c, 0x38, 0x7f, 0x05, 0xff, 0x00, 0xcc, 0x33, 0xe9, 0x37, 0x69, 0xff, 0x00, 0x8b, 0x5f, 0xbc,
 0x35, 0xe6, 0xfe, 0x1d, 0xbe, 0xd2, 0xec, 0x4e, 0x6a, 0x6a, 0xa4, 0x15, 0xa5, 0x97, 0x31, 0x75,
 0xe4, 0xa4, 0x15, 0x8b, 0xd1, 0x4f, 0xa4, 0x45, 0x9e, 0x02, 0x25, 0x59, 0x5a, 0xa4, 0x15, 0xa5,
 0xa5, 0x62, 0xf4, 0x20, 0xac, 0x5e, 0x8a, 0x67, 0x75, 0x44, 0xab, 0xab, 0x48, 0x2b, 0x0b, 0x2e,
 0x62, 0xf4, 0x52, 0x0e, 0x65, 0x94, 0xbd, 0xd7, 0x16, 0x56, 0x56, 0xe8, 0x41, 0x5a, 0x5a, 0x56,
 0x2f, 0x42, 0x0e, 0x62, 0xf4, 0x33, 0xba, 0xa2, 0xcf, 0xbd, 0x3d, 0xc8, 0x36, 0x65, 0xf0, 0x2f,
 0x09, 0xee, 0xd7, 0xd6, 0x1e, 0xe4, 0x3b, 0x33, 0xf8, 0x19, 0x85, 0x77, 0x6b, 0xeb, 0x37, 0x2a,
 0xd7, 0x0a, 0xd7, 0x3e, 0x4f, 0xee, 0x31, 0xfd, 0x31, 0xe8, 0xf6, 0xdf, 0x0f, 0x87, 0xe9, 0x8f,
 0x46, 0x9d, 0xee, 0x43, 0xb3, 0x3f, 0x81, 0x98, 0x57, 0x76, 0xbe, 0xb3, 0xd4, 0xd9, 0x1e, 0xcd,
 0x13, 0x96, 0x4d, 0xc2, 0xbb, 0xb5, 0xf5, 0x9b, 0x85, 0x7b, 0x85, 0x6b, 0x8f, 0x71, 0x8b, 0xe9,
 0x8f, 0x43, 0xe1, 0xb0, 0xfd, 0x11, 0xe8, 0xd4, 0x13, 0x64, 0xbb, 0x37, 0x4e, 0x59, 0x3b, 0x0a,
 0x4f, 0xfe, 0x35, 0xf5, 0x92, 0x4d, 0x93, 0xec, 0xe1, 0x3f, 0x91, 0xf8, 0x5f, 0x76, 0xbe, 0xb3,
 0x6d, 0xad, 0x70, 0xad, 0x71, 0xee, 0x31, 0x7d, 0x31, 0xe9, 0x07, 0xc3, 0xe2, 0xfa, 0x63, 0xd1,
 0xa9, 0xa6, 0xca, 0x76, 0x74, 0x9c, 0xb2, 0x86, 0x17, 0xdd, 0xaf, 0xac, 0xf5, 0x36, 0x57, 0xb3,
 0xbf, 0x82, 0x38, 0x5f, 0x76, 0xbe, 0xb3, 0x6b, 0xad, 0x70, 0xac, 0x3d, 0xc6, 0x2f, 0xa6, 0x3d,
 0x0f, 0x87, 0xc5, 0xf4, 0xc7, 0xa3, 0x89, 0xe6, 0xec, 0x85, 0x92, 0xe5, 0xb3, 0x0c, 0xcc, 0x18,
 0x39, 0x5f, 0x0b, 0x6b, 0x1b, 0xbb, 0xa2, 0x51, 0xd7, 0xf2, 0x50, 0x55, 0xed, 0x2b, 0x28, 0x7c,
 0x1a, 0xc2, 0xfb, 0x84, 0x37, 0x3c, 0xf1, 0x17, 0x5c, 0xd1, 0x39, 0xc7, 0xde, 0x7d, 0x44, 0x12,
 0xd4, 0xb9, 0x51, 0x8a, 0x91, 0xf2, 0x85, 0xc6, 0x2c, 0x71, 0xfe, 0x58, 0xf4, 0x65, 0xc8, 0xb9,
 0x0f, 0x26, 0xcd, 0x63, 0xb4, 0xa3, 0x65, 0x9c, 0x31, 0xcc, 0xa2, 0xf5, 0xd1, 0x20, 0xe9, 0xc7,
 0x81, 0xbe, 0xa6, 0xcd, 0x32, 0x1a, 0x72, 0xca, 0xd8, 0x77, 0xea, 0x2f, 0xac, 0xd7, 0xf6, 0x77,
 0x17, 0xf8, 0x45, 0xcf, 0xfb, 0x9d, 0xff, 0x00, 0xb8, 0xe8, 0xd5, 0xae, 0x62, 0x70, 0xe3, 0x9f,
 0xf2, 0xc7, 0xa3, 0x13, 0x87, 0x1c, 0xf9, 0xd6, 0x3d, 0x1a, 0xd2, 0x6c, 0xdb, 0x22, 0xa7, 0xf2,
 0x5f, 0x0e, 0xfd, 0x45, 0xf5, 0x92, 0x4d, 0x9c, 0x64, 0x64, 0xe5, 0x96, 0x30, 0xff, 0x00, 0xd4,
 0x5f, 0x59, 0xb1, 0xd6, 0xb8, 0x56, 0xb9, 0x8f, 0x71, 0x8f, 0xe9, 0x8f, 0x46, 0x3d, 0xc6, 0x3f,
 0xa6, 0x3d, 0x1a, 0xf7, 0xb9, 0xde, 0x48, 0x4e, 0x59, 0x6b, 0x0f, 0xfd, 0x45, 0xf5, 0x9e, 0xa6,
 0xcf, 0xb2, 0x52, 0x72, 0xcb, 0x72, 0x1f, 0xa8, 0xbe, 0xb3, 0x60, 0x48, 0xd7, 0x3d, 0xaf, 0x71,
 0xee, 0x71, 0xfd, 0x31, 0xe8, 0x7b, 0x9c, 0x7f, 0x4c, 0x7a, 0x35, 0xf4, 0xc8, 0x19, 0x31, 0x39,
 0x65, 0xc9, 0x0f, 0xd4, 0x5f, 0x59, 0x24, 0xc8, 0x59, 0x3b, 0xb3, 0x2e, 0xc8, 0xfe, 0xaa, 0xfa,
 0xc7, 0xb5, 0x93, 0xa8, 0x56, 0x1e, 0xe7, 0x1f, 0xd3, 0x0c, 0xfb, 0x9c, 0x7f, 0x4c, 0x7a, 0x39,
 0x96, 0xd5, 0x36, 0x79, 0x91, 0xe6, 0x70, 0x99, 0x36, 0x4d, 0x65, 0x6c, 0x2e, 0x61, 0x8d, 0x98,
 0x55, 0x46, 0xc4, 0x85, 0xbc, 0x88, 0xbb, 0x8b, 0xc7, 0x99, 0xce, 0xfd, 0xcb, 0xf6, 0x73, 0xf0,
 0x23, 0x02, 0xfd, 0x9b, 0xef, 0x3b, 0x2e, 0xd3, 0x22, 0xeb, 0x86, 0x4a, 0x7f, 0x9c, 0x2f, 0xd5,
 0x53, 0x42, 0xa9, 0x73, 0x64, 0x44, 0x56, 0x36, 0x85, 0xc4, 0x44, 0x46, 0xd0, 0x41, 0x84, 0x6c,
 0xc7, 0x67, 0x6c, 0xc5, 0x64, 0xde, 0xcc, 0x95, 0x82, 0x31, 0xed, 0x98, 0x86, 0xad, 0x72, 0x4b,
 0xf1, 0x45, 0xde, 0x4e, 0x3c, 0xce, 0xe5, 0xed, 0x37, 0x2b, 0xea, 0xab, 0xe2, 0x49, 0x45, 0x55,
 0x55, 0x5f, 0xc5, 0x39, 0xae, 0x19, 0x17, 0xf0, 0x9c, 0xa7, 0x1f, 0xcf, 0xc3, 0xfa, 0xc8, 0x76,
 0x15, 0x8d, 0xc5, 0x74, 0x5e, 0xd3, 0x16, 0xa5, 0x6d, 0xe7, 0x0c, 0x4d, 0x62, 0xde, 0x70, 0x54,
 0x99, 0x43, 0x2c, 0xa7, 0xf7, 0x96, 0x51, 0x3f, 0xd1, 0x5f, 0x59, 0xea, 0x65, 0x3c, 0xb6, 0x9c,
 0xb0, 0x79, 0x4f, 0xd5, 0x51, 0x9d, 0x63, 0xda, 0xc4, 0xfb, 0xaa, 0x76, 0x86, 0x3d, 0xdd, 0x3b,
 0x16, 0xfb, 0x56, 0xcb, 0xc9, 0xc7, 0xc5, 0x32, 0xbf, 0xaa, 0xa2, 0x0c, 0xd2, 0xdc, 0xb9, 0x84,
 0x27, 0xb1, 0xe5, 0xf0, 0x99, 0x48, 0xb3, 0x8e, 0x4d, 0x77, 0x55, 0x3c, 0x96, 0x27, 0x55, 0xe3,
 0xf3, 0x1b, 0x4e, 0x23, 0x3e, 0xc9, 0x39, 0x08, 0xf3, 0x4f, 0xe2, 0xd8, 0x50, 0xd5, 0xea, 0x9d,
 0x74, 0x4e, 0x47, 0x22, 0x9a, 0x9b, 0x8b, 0x33, 0x31, 0x12, 0x62, 0x33, 0xd5, 0xd1, 0x22, 0x39,
 0x5c, 0xe5, 0x5e, 0xaa, 0x3d, 0xd5, 0x3b, 0x41, 0xc2, 0xbd, 0x89, 0x73, 0x26, 0x4f, 0xca, 0x99,
 0x92, 0x79, 0x27, 0x71, 0xec, 0xb9, 0x86, 0x62, 0x33, 0x0d, 0x6e, 0xe3, 0x62, 0x47, 0x81, 0xaa,
 0xb5, 0xbd, 0x12, 0xc2, 0xcf, 0x72, 0xfd, 0x9c, 0xfc, 0x08, 0xc0, 0xbf, 0x66, 0xfb, 0xcd, 0xa2,
 0xa2, 0xf5, 0x2f, 0xe1, 0x18, 0x6c, 0xf6, 0x2b, 0x11, 0x59, 0x29, 0x0f, 0x54, 0x6f, 0xe3, 0x44,
 0x72, 0xe8, 0xd6, 0xfa, 0x54, 0xd9, 0xb6, 0xde, 0x10, 0xb8, 0x8d, 0x9a, 0x6c, 0x96, 0xce, 0x32,
 0x0c, 0x94, 0xdc, 0x29, 0xb9, 0x4c, 0x9d, 0x82, 0xc0, 0x8f, 0x05, 0xc8, 0xf8, 0x71, 0x19, 0x2f,
 0xa3, 0x98, 0xe4, 0xe4, 0xa9, 0xc7, 0x99, 0xd2, 0xb0, 0x2c, 0x72, 0x56, 0x14, 0x46, 0xc1, 0xc5,
 0x24, 0xe1, 0x46, 0x87, 0xca, 0xb3, 0x5b, 0xe5, 0xb7, 0xd2, 0x9d, 0xa8, 0x7b, 0x13, 0x27, 0x62,
 0x4d, 0x87, 0xbc, 0xc9, 0xa9, 0x47, 0xbb, 0xde, 0xea, 0xe4, 0xf9, 0xd5, 0x04, 0x18, 0x8c, 0xac,
 0xde, 0x1f, 0x1a, 0x8c, 0xe4, 0x07, 0xc2, 0x7f, 0x34, 0xd7, 0x92, 0xdd, 0x17, 0x92, 0x93, 0x6a,
 0xc5, 0xbc, 0xe1, 0x8d, 0xa0, 0xe7, 0x6b, 0x98, 0x3e, 0x58, 0xc7, 0xf0, 0xb9, 0x0c, 0x32, 0x7b,
 0x09, 0x90, 0xc4, 0xa5, 0x1e, 0xef, 0x65, 0x23, 0x22, 0xb3, 0x7d, 0x9a, 0xa2, 0x6e, 0xb5, 0x7d,
 0x3c, 0x5c, 0x73, 0x5f, 0x72, 0xfd, 0x9c, 0xfc, 0x08, 0xc0, 0xbf, 0x66, 0xfb, 0xcd, 0xa5, 0x62,
 0xaa, 0xa2, 0x22, 0xb9, 0x74, 0x4e, 0x56, 0x3c, 0xa9, 0x73, 0x31, 0x11, 0x11, 0xb4, 0x32, 0xa7,
 0x91, 0x76, 0x4f, 0xb3, 0xe8, 0xd9, 0x9a, 0x52, 0x34, 0x1c, 0x97, 0x82, 0xc3, 0x74, 0xab, 0x92,
 0x61, 0x1e, 0xd9, 0x7d, 0x15, 0xaa, 0xd5, 0x45, 0x6a, 0xa7, 0x1f, 0x7d, 0xa1, 0xde, 0x1d, 0x2d,
 0x01, 0xdc, 0x5d, 0x09, 0x8e, 0x55, 0xe2, 0xba, 0xa1, 0xa4, 0x6c, 0xc7, 0x4f, 0xed, 0xe9, 0x85,
 0xe7, 0xe4, 0x31, 0x3e, 0x75, 0xf5, 0x1b, 0xa5, 0x6b, 0x89, 0x88, 0x9f, 0x36, 0x26, 0x37, 0x6b,
 0x5b, 0x4e, 0xc0, 0x30, 0x5c, 0x57, 0x24, 0xe2, 0x12, 0x38, 0x9e, 0x17, 0x2b, 0x39, 0x2b, 0x16,
 0x9d, 0x48, 0x31, 0x99, 0xbc, 0xd7, 0x69, 0x11, 0xaa, 0x9a, 0xa5, 0x95, 0x11, 0x4e, 0x26, 0xbb,
 0x2f, 0xd9, 0xcf, 0xc0, 0x8c, 0x0b, 0xf6, 0x6f, 0xbc, 0xee, 0xf9, 0xe2, 0x36, 0xb9, 0x5e, 0x71,
 0x35, 0xf7, 0x9f, 0x5d, 0x0e, 0x61, 0x52, 0xe6, 0x76, 0xd8, 0x88, 0x88, 0xf2, 0x6a, 0xcb, 0xb2,
 0xfd, 0x9c, 0xe8, 0xbf, 0xc0, 0x8c, 0x0b, 0x97, 0x9b, 0x7d, 0xe7, 0x7b, 0xc0, 0xb2, 0xee, 0x07,
 0x07, 0x03, 0x90, 0x81, 0x0b, 0x0b, 0x96, 0x87, 0x0a, 0x1c, 0xb4, 0x36, 0xb1, 0x8d, 0x6f, 0x06,
 0xb5, 0x1a, 0x88, 0x88, 0x96, 0x39, 0x6b, 0xa2, 0x70, 0x5e, 0x3d, 0x87, 0x60, 0xc2, 0x23, 0x69,
 0x85, 0x49, 0xf1, 0xfc, 0xc3, 0x3e, 0xaa, 0x04, 0xdf, 0x1d, 0x6f, 0x1b, 0x5a, 0x22, 0x51, 0x5c,
 0xbd, 0x82, 0xaf, 0x3c, 0x36, 0x5f, 0xf5, 0x48, 0xbb, 0x2e, 0x60, 0x4a, 0xd5, 0x45, 0xc2, 0xe5,
 0xbf, 0x54, 0xbd, 0x5a, 0xe7, 0x8b, 0x1b, 0x82, 0xf1, 0x33, 0xbc, 0xb5, 0x7c, 0x26, 0x0f, 0xa2,
 0x3d, 0x21, 0xf3, 0x72, 0xec, 0xbf, 0x67, 0x3a, 0xaf, 0xf0, 0x23, 0x02, 0xe7, 0xe6, 0xdf, 0x78,
 0x7b, 0x97, 0xec, 0xe7, 0xe0, 0x46, 0x05, 0xfb, 0x37, 0xde, 0x6d, 0x2b, 0x13, 0x8a, 0xf1, 0x3c,
 0xa9, 0x73, 0x0e, 0x43, 0x6a, 0xd9, 0x76, 0x48, 0xca, 0x32, 0x59, 0x5f, 0xd8, 0xf2, 0x59, 0x73,
 0x0f, 0x96, 0x83, 0xec, 0x88, 0x8e, 0xa7, 0x0a, 0x1e, 0xeb, 0x75, 0x5d, 0xdd, 0x57, 0xe6, 0x43,
 0x6a, 0x5c, 0xa1, 0x96, 0x57, 0xfb, 0xcb, 0x29, 0xfa, 0xa5, 0x1d, 0x9d, 0x45, 0xd3, 0x2e, 0xf3,
 0xe3, 0xec, 0x88, 0x9f, 0xb8, 0xd8, 0xeb, 0x5c, 0xae, 0x53, 0x1f, 0x37, 0x1a, 0xfa, 0x2d, 0x35,
 0xed, 0x36, 0xb6, 0x38, 0x99, 0x9f, 0xc2, 0x0a, 0x17, 0x26, 0xe5, 0x8f, 0xf1, 0x24, 0x9f, 0xea,
 0x9c, 0x8f, 0x68, 0x3b, 0x37, 0xc8, 0x33, 0x59, 0xba, 0x76, 0x3c, 0xd6, 0x4f, 0xc1, 0xa3, 0xc5,
 0x76, 0xe6, 0xf4, 0x48, 0x90, 0x35, 0x72, 0xf9, 0x0d, 0x4e, 0x2b, 0xa9, 0xdc, 0xeb, 0x70, 0xe6,
 0x73, 0x1c, 0xf1, 0x17, 0x5c, 0xd1, 0x36, 0xba, 0xfb, 0xcf, 0xa8, 0x86, 0x26, 0xd3, 0x3e, 0x72,
 0xac, 0x5a, 0x6c, 0x38, 0x67, 0x7c, 0x74, 0x88, 0x9f, 0xc2, 0x22, 0x1c, 0xf3, 0xdc, 0xbf, 0x67,
 0x3f, 0x02, 0x30, 0x2f, 0xd9, 0xbe, 0xf3, 0x70, 0xd9, 0x56, 0xce, 0xb2, 0x24, 0xae, 0x2d, 0x38,
 0xe9, 0x4c, 0xa5, 0x84, 0xcb, 0x39, 0xd2, 0xe8, 0x8a, 0xb0, 0xa0, 0xee, 0xaa, 0xa6, 0xfa, 0x70,
 0x5e, 0x25, 0x7a, 0x97, 0x36, 0xcd, 0x99, 0xc5, 0xfc, 0x29, 0x37, 0xc7, 0xfb, 0x9d, 0x3e, 0xb2,
 0x18, 0x8f, 0x09, 0xdd, 0xb6, 0xf4, 0xad, 0xe3, 0x8d, 0xa3, 0x78, 0x96, 0xc4, 0xb9, 0x17, 0x28,
 0xaf, 0x3c, 0xbf, 0x25, 0xfa, 0x8b, 0xeb, 0x3c, 0x5c, 0x89, 0x93, 0xfb, 0x72, 0xfc, 0x8f, 0xea,
 0x2f, 0xac, 0x79, 0x5a, 0xe1, 0x58, 0xbf, 0x7b, 0x7e, 0xf3, 0xea, 0xe3, 0xfc, 0x0e, 0x9b, 0xff,
 0x00, 0x1d, 0x7d, 0x21, 0xaf, 0x4c, 0xe4, 0x8c, 0x91, 0x02, 0x0b, 0xe3, 0x47, 0xc0, 0x70, 0xf8,
 0x70, 0xd8, 0x9a, 0xb9, 0xce, 0x6a, 0xa2, 0x22, 0x7c, 0xa6, 0x8f, 0x8d, 0xca, 0x65, 0x37, 0xc4,
 0x74, 0x2c, 0x2f, 0x2d, 0x48, 0x43, 0x62, 0x7e, 0x79, 0xf0, 0xd5, 0x5c, 0xb7, 0x44, 0xd7, 0x87,
 0xc6, 0x34, 0xcf, 0x18, 0xf3, 0xa7, 0xa7, 0x9d, 0x25, 0x01, 0xeb, 0xec, 0x58, 0x0e, 0xd1, 0x74,
 0xe4, 0xf7, 0xa7, 0x35, 0xf4, 0x27, 0x24, 0x35, 0xca, 0xb7, 0x33, 0xef, 0x6f, 0xf5, 0x49, 0xf0,
 0x5a, 0x6f, 0xfc, 0x71, 0xe9, 0x0d, 0x72, 0x7b, 0x67, 0x59, 0x0a, 0x7a, 0x6a, 0x24, 0xd4, 0xe6,
 0x4f, 0xc1, 0xa3, 0xc7, 0x88, 0xba, 0xbe, 0x23, 0xe5, 0xf5, 0x57, 0x2d, 0xf8, 0x98, 0x7d, 0xcb,
 0xf6, 0x73, 0xf0, 0x23, 0x02, 0xfd, 0x9b, 0xef, 0x36, 0xc8, 0x09, 0x16, 0x3c, 0x56, 0xc2, 0x82,
 0xc7, 0xc4, 0x88, 0xe5, 0xd1, 0xad, 0x6a, 0x6a, 0xaa, 0x3b, 0x83, 0x95, 0x71, 0xb8, 0x8c, 0x47,
 0x2c, 0x28, 0x30, 0xf5, 0xfc, 0x97, 0xc5, 0x44, 0x5f, 0x98, 0xd6, 0xe4, 0xc4, 0x44, 0x46, 0xd0,
 0xe7, 0x1e, 0xe5, 0xfb, 0x39, 0xf8, 0x11, 0x81, 0x7e, 0xcd, 0xf7, 0x8f, 0xb0, 0x6c, 0xb9, 0x95,
 0x70, 0xc8, 0x70, 0xe5, 0xe1, 0x65, 0x7c, 0x25, 0xd2, 0xac, 0xe0, 0x90, 0x16, 0x0e, 0x8d, 0x44,
 0xb6, 0x8b, 0xc0, 0x71, 0x8a, 0x61, 0xd8, 0x86, 0x18, 0xe4, 0x49, 0xc8, 0x0e, 0x62, 0x2a, 0xe8,
 0x8f, 0x4e, 0x2d, 0x5f, 0x8d, 0x0a, 0x35, 0x2e, 0x55, 0x6d, 0x6a, 0xce, 0xf5, 0x9d, 0x93, 0x93,
 0x1d, 0x32, 0x46, 0xd7, 0x88, 0x9f, 0xbb, 0x72, 0xc0, 0xb2, 0x7e, 0xce, 0x31, 0x88, 0x0b, 0x12,
 0x06, 0x58, 0xc3, 0x9b, 0x11, 0xbf, 0xc6, 0x42, 0x73, 0x17, 0x79, 0xbf, 0x3f, 0x14, 0xb8, 0xcb,
 0xdc, 0xd3, 0x21, 0x2f, 0xf2, 0x5b, 0x0d, 0xfd, 0x45, 0xf5, 0x9a, 0x26, 0x1b, 0x88, 0xcc, 0x61,
 0xf3, 0x90, 0xe6, 0xa5, 0x9f, 0xba, 0xf6, 0x2f, 0xc4, 0xa9, 0xda, 0x8b, 0x65, 0x3a, 0xbe, 0x17,
 0x89, 0x41, 0xc4, 0x24, 0x21, 0x4e, 0x41, 0xfc, 0x48, 0x8d, 0xd7, 0x4e, 0xd6, 0xaf, 0x6a, 0x7c,
 0x45, 0xfb, 0xfc, 0xbf, 0x54, 0xfa, 0xb5, 0x7c, 0x1e, 0x9f, 0xe8, 0x8f, 0x48, 0x21, 0x5d, 0x98,
 0xe4, 0x05, 0xe7, 0x95, 0x70, 0xdf, 0xd4, 0x5f, 0x59, 0xe7, 0xb9, 0x86, 0xcf, 0xfe, 0x09, 0xe1,
 0xbf, 0xa8, 0xbe, 0xb3, 0x68, 0xaa, 0x88, 0x15, 0x90, 0x7b, 0xfc, 0xbf, 0x54, 0xfa, 0x9f, 0x0b,
 0x83, 0xe8, 0x8f, 0x48, 0x6a, 0xde, 0xe5, 0xfb, 0x3e, 0xf8, 0x29, 0x86, 0xf7, 0x6b, 0xeb, 0x0f,
 0x72, 0xed, 0x9f, 0x2f, 0xf2, 0x4f, 0x0d, 0xee, 0xd7, 0xd6, 0x6d, 0x35, 0xae, 0x09, 0x1a, 0xe6,
 0x7e, 0x23, 0x2f, 0xd5, 0x3e, 0xac, 0xfc, 0x2e, 0x0f, 0xa2, 0x3d, 0x21, 0xaa, 0xfb, 0x96, 0xec,
 0xf7, 0xb7, 0x29, 0xe1, 0x9d, 0xda, 0xfa, 0xc5, 0x59, 0xb3, 0x64, 0xdb, 0x3d, 0x98, 0xcb, 0xd3,
 0x8c, 0xf6, 0x9d, 0x85, 0x44, 0x56, 0xc3, 0xdf, 0x46, 0xba, 0x12, 0xaa, 0x79, 0x2b, 0xaf, 0x2d,
 0x6c, 0x6f, 0xf5, 0xae, 0x78, 0xf7, 0xb5, 0xec, 0x73, 0x1f, 0xc5, 0xae, 0x4d, 0x15, 0x3a, 0xa1,
 0x89, 0xcf, 0x96, 0x63, 0x69, 0xb4, 0xfa, 0xb3, 0x5d, 0x3e, 0x2a, 0xcc, 0x4c, 0x56, 0x3d, 0x21,
 0xf3, 0x7f, 0xb9, 0x7e, 0xce, 0x7e, 0x04, 0x60, 0x5f, 0xb3, 0x7d, 0xe1, 0xee, 0x5f, 0xb3, 0x9f,
 0x81, 0x18, 0x17, 0xec, 0xdf, 0x79, 0xb9, 0x62, 0xb0, 0x1f, 0x21, 0x88, 0xc7, 0x93, 0x7a, 0xae,
 0xb0, 0x9e, 0xa8, 0x8b, 0xd5, 0x3b, 0x17, 0xe4, 0xd0, 0xab, 0x52, 0xe6, 0xa6, 0xe6, 0xaf, 0xee,
 0x5f, 0xb3, 0x9f, 0x81, 0x18, 0x17, 0xec, 0xdf, 0x78, 0x7b, 0x97, 0xec, 0xe7, 0xe0, 0x46, 0x05,
 0xfb, 0x37, 0xde, 0x6d, 0x15, 0x2e, 0x15, 0x17, 0xa8, 0x1a, 0xbf, 0xb9, 0x7e, 0xce, 0x7e, 0x04,
 0x60, 0x5f, 0xb3, 0x7d, 0xe1, 0xee, 0x5f, 0xb3, 0x9f, 0x81, 0x18, 0x17, 0xec, 0xdf, 0x79, 0xb4,
 0x54, 0xb8, 0x54, 0xb8, 0x1a, 0xbf, 0xb9, 0x7e, 0xce, 0x7e, 0x04, 0x60, 0x5f, 0xb3, 0x7d, 0xe5,
 0xdc, 0x07, 0x65, 0xbb, 0x38, 0x76, 0x35, 0x24, 0xd5, 0xc9, 0x38, 0x1a, 0x6b, 0x1d, 0x89, 0xc2,
 0x5a, 0xfe, 0x91, 0xdd, 0x4b, 0x97, 0xb2, 0xfc, 0x5f, 0xc3, 0xb2, 0x3c, 0x7f, 0xba, 0x19, 0xf4,
 0x8f, 0x2f, 0x18, 0x3c, 0xfc, 0x25, 0xb6, 0xae, 0xc9, 0x76, 0x6f, 0xf0, 0x3b, 0x0a, 0xee, 0xd7,
 0xd6, 0x78, 0xbb, 0x24, 0xd9, 0xb7, 0xc0, 0xdc, 0x2b, 0xbb, 0x5f, 0x59, 0xb8, 0x2c, 0x6b, 0x9e,
 0x56, 0xb9, 0xbb, 0xe2, 0x73, 0x7d, 0x73, 0xeb, 0x2d, 0x1f, 0x0d, 0x87, 0xe8, 0x8f, 0x46, 0x9f,
 0xee, 0x47, 0xb3, 0x6f, 0x81, 0xb8, 0x57, 0x76, 0xbe, 0xb0, 0xf7, 0x22, 0xd9, 0xaf, 0xc0, 0xcc,
 0x2b, 0xbb, 0x5f, 0x59, 0xb8, 0x56, 0xb8, 0x56, 0xb9, 0x9f, 0x89, 0xcd, 0xf5, 0xcf, 0xac, 0xb3,
 0xf0, 0xd8, 0x7e, 0x98, 0xf4, 0x69, 0xfe, 0xe4, 0x5b, 0x34, 0xf8, 0x19, 0x85, 0x77, 0x6b, 0xeb,
 0x3c, 0x5d, 0x90, 0xec, 0xd3, 0xe0, 0x5e, 0x13, 0xdd, 0xaf, 0xac, 0xdc, 0x6b, 0x5c, 0x2b, 0x5c,
 0x7c, 0x56, 0x7f, 0xae, 0x7d, 0x64, 0xf8, 0x7c, 0x5f, 0x4c, 0x7a, 0x34, 0xdf, 0x72, 0x1d, 0x99,
 0xfc, 0x0b, 0xc2, 0x7b, 0xb5, 0xf5, 0x87, 0xb9, 0x06, 0xcc, 0xbe, 0x05, 0xe1, 0x3d, 0xda, 0xfa,
 0xcd, 0xca, 0xb5, 0xc2, 0xb5, 0xc7, 0xc5, 0x67, 0xfa, 0xe7, 0xd6, 0x4f, 0x87, 0xc5, 0xf4, 0xc7,
 0xa4, 0x17, 0x56, 0xb8, 0x57, 0xb8, 0xb6, 0xb5, 0xc2, 0xbd, 0xcd, 0x0d, 0xc6, 0x55, 0xae, 0x15,
 0xee, 0x2d, 0xad, 0x70, 0xaf, 0x70, 0x19, 0x56, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xcf, 0x2b, 0x00,
 0xca, 0xb5, 0xc2, 0xb5, 0xc5, 0xb5, 0xee, 0x15, 0xae, 0x06, 0x8d, 0x9d, 0xa2, 0xeb, 0x99, 0xa6,
 0xd7, 0x5f, 0x79, 0xf5, 0x10, 0x4d, 0x52, 0xe5, 0xbc, 0xe7, 0x1b, 0x5c, 0xcb, 0x37, 0xc7, 0xde,
 0x7d, 0x44, 0x13, 0xd5, 0xb8, 0x1b, 0x76, 0xcf, 0xa2, 0xff, 0x00, 0x08, 0x79, 0xfe, 0x61, 0xff,
 0x00, 0xb8, 0xe8, 0x75, 0x8e, 0x5d, 0x90, 0x62, 0xfe, 0x1f, 0xe7, 0xf9, 0x87, 0xfe, 0xe3, 0x7f,
 0xac, 0x03, 0x25, 0x8c, 0x15, 0xae, 0x2d, 0xad, 0x70, 0xaf, 0x70, 0x19, 0x56, 0xb8, 0x56, 0x16,
 0xd6, 0x0a, 0xc0, 0x32, 0x58, 0xd7, 0x0a, 0xd7, 0x16, 0xd6, 0x0a, 0xc0, 0x27, 0xda, 0x4c, 0x5d,
 0x70, 0xc9, 0x4e, 0x3f, 0x9f, 0x5f, 0xaa, 0xa6, 0x8b, 0x52, 0xe6, 0xd7, 0xb4, 0x68, 0xda, 0xe1,
 0xb2, 0x9c, 0x7f, 0x3e, 0xbf, 0x55, 0x4d, 0x1e, 0xad, 0xc0, 0x6b, 0x86, 0x44, 0xfc, 0x25, 0x2b,
 0xc7, 0xf3, 0xec, 0xfa, 0xc8, 0x75, 0xc7, 0x46, 0xf2, 0x97, 0x8f, 0x69, 0xc5, 0x70, 0xe8, 0xba,
 0x62, 0x12, 0xcb, 0xaf, 0xe7, 0x99, 0xf5, 0x90, 0xeb, 0x2e, 0x8d, 0xe5, 0x2f, 0x1e, 0xd0, 0x18,
 0xd6, 0xb8, 0x56, 0x16, 0xd6, 0x0a, 0xd7, 0x03, 0x16, 0x73, 0x8c, 0xbe, 0xd6, 0xa7, 0x34, 0x55,
 0xe4, 0xd4, 0x5f, 0x46, 0xf2, 0x1c, 0xc6, 0xa2, 0xf5, 0x3a, 0x5e, 0x26, 0xc4, 0x9d, 0xc3, 0xe3,
 0xca, 0x2a, 0xa2, 0x55, 0x86, 0xad, 0x45, 0xe8, 0xbd, 0x9f, 0x39, 0xca, 0xa2, 0xab, 0xe1, 0x45,
 0x7c, 0x28, 0x8d, 0xdd, 0x7b, 0x15, 0x5a, 0xe4, 0x5e, 0xc5, 0x4e, 0x60, 0x5a, 0x58, 0xbc, 0x35,
 0xd7, 0x53, 0xaa, 0xe5, 0xd8, 0x70, 0xa4, 0xf0, 0x59, 0x58, 0x30, 0xd1, 0x13, 0x58, 0x68, 0xf7,
 0x2a, 0x7e, 0x53, 0x9c, 0x9a, 0xaa, 0xfc, 0xe7, 0x1e, 0xab, 0xf1, 0x9b, 0x8e, 0x57, 0xcd, 0x72,
 0xf0, 0xe4, 0xe1, 0xc9, 0x62, 0x0f, 0x58, 0x6b, 0x0d, 0x37, 0x59, 0x17, 0x4d, 0x51, 0x53, 0xb3,
 0x5e, 0x8a, 0x07, 0x40, 0xad, 0x72, 0x9e, 0x2f, 0x2b, 0x03, 0x13, 0x92, 0x7c, 0xac, 0x76, 0xa2,
 0xef, 0x27, 0x92, 0xee, 0xd6, 0x3b, 0xb1, 0x50, 0xab, 0x2f, 0x3d, 0x2f, 0x30, 0xc4, 0x74, 0xbc,
 0x78, 0x71, 0x53, 0xab, 0x1c, 0x8a, 0x64, 0x58, 0xc0, 0x72, 0xf8, 0xfb, 0xd0, 0x63, 0xbe, 0x0b,
 0xf8, 0x3d, 0x8e, 0x56, 0xbb, 0xd2, 0x8b, 0xa1, 0x1a, 0x97, 0x3d, 0xcc, 0x2f, 0x46, 0xe3, 0xd3,
 0xc8, 0x9c, 0x12, 0xbb, 0x8a, 0x35, 0x6e, 0x07, 0x46, 0xd9, 0xb4, 0x4d, 0x30, 0xe9, 0xc5, 0xd7,
 0x9c, 0x64, 0x4f, 0xf6, 0x4d, 0xae, 0xb1, 0xa3, 0x6c, 0xea, 0x37, 0xe0, 0xd9, 0xbf, 0xf2, 0xe9,
 0xf5, 0x50, 0xd9, 0xeb, 0x5c, 0x0a, 0xf9, 0xda, 0x2f, 0xf0, 0x66, 0x6f, 0x8f, 0xbc, 0xfa, 0xe8,
 0x73, 0x5a, 0x97, 0x37, 0xac, 0xe7, 0x1b, 0x5c, 0xb7, 0x37, 0xfe, 0x87, 0xd7, 0x43, 0x9b, 0xd5,
 0xb8, 0x17, 0x5d, 0x11, 0x74, 0x5e, 0x3d, 0x87, 0x5c, 0xc2, 0x63, 0x7e, 0x0b, 0x94, 0xff, 0x00,
 0x20, 0xcf, 0xaa, 0x87, 0x16, 0x58, 0xbc, 0x17, 0xd0, 0x75, 0x8c, 0x2e, 0x37, 0xe0, 0xc9, 0x4e,
 0x3f, 0x98, 0x67, 0xd5, 0x40, 0x1d, 0x24, 0x6b, 0x82, 0xc6, 0xe0, 0xa2, 0xda, 0xd7, 0x05, 0x8d,
 0xc1, 0x78, 0x81, 0xcb, 0x56, 0x27, 0x15, 0xe2, 0x15, 0x2e, 0x52, 0x58, 0xbc, 0x57, 0x88, 0x55,
 0xb8, 0x1d, 0x3f, 0x67, 0xd1, 0xb4, 0xcb, 0xdc, 0xff, 0x00, 0x3e, 0xff, 0x00, 0xdc, 0x6c, 0x55,
 0xee, 0x69, 0xd9, 0x06, 0x36, 0x99, 0x7f, 0x9f, 0xe7, 0xdf, 0xfb, 0x87, 0xf5, 0xee, 0x03, 0x2a,
 0xd7, 0x39, 0xa6, 0x76, 0x8b, 0xae, 0x67, 0x9b, 0xe3, 0xef, 0x3e, 0xa2, 0x1b, 0xcd, 0x6b, 0x9c,
 0xe3, 0x3a, 0x45, 0xfe, 0x12, 0xcd, 0xf1, 0xf7, 0x9f, 0x51, 0x00, 0xa9, 0x52, 0xe6, 0xd5, 0xb3,
 0x68, 0xba, 0x62, 0x73, 0x7c, 0x7f, 0x30, 0x9f, 0x59, 0x0d, 0x22, 0xad, 0xcd, 0xa3, 0x67, 0x31,
 0x74, 0xc4, 0xa6, 0xd7, 0x5f, 0xcc, 0x27, 0xd6, 0x40, 0x3a, 0x4a, 0xc6, 0x17, 0x66, 0x4c, 0x4d,
 0x64, 0x30, 0x49, 0x99, 0x86, 0xbb, 0x48, 0x9b, 0xbb, 0x90, 0xff, 0x00, 0x49, 0x78, 0x27, 0xaf,
 0xe2, 0x3c, 0xad, 0x73, 0x57, 0xda, 0x24, 0xda, 0xa6, 0x1d, 0x2d, 0x05, 0x1d, 0xf8, 0xf1, 0x95,
 0xcb, 0xf1, 0x27, 0xde, 0x06, 0xa9, 0x52, 0xfc, 0x4f, 0x6a, 0x5c, 0xa5, 0x56, 0xe5, 0x8c, 0x31,
 0xec, 0x7e, 0x23, 0x2c, 0xc8, 0x8e, 0x6a, 0x31, 0x62, 0xb5, 0x1c, 0xaa, 0xbc, 0x34, 0xd4, 0x0e,
 0x9f, 0x94, 0xb0, 0xd8, 0x78, 0x64, 0x83, 0x22, 0x3d, 0x89, 0xec, 0xb8, 0xad, 0x45, 0x88, 0xee,
 0xd4, 0x45, 0xfc, 0x94, 0xb7, 0xef, 0x1d, 0x56, 0x13, 0xae, 0x25, 0x27, 0xaa, 0xff, 0x00, 0x6e,
 0x4b, 0x77, 0xcd, 0xf5, 0x87, 0x8c, 0xa5, 0x3c, 0xf2, 0x5b, 0xbe, 0x6f, 0xac, 0x06, 0x53, 0x8d,
 0x83, 0x39, 0x2b, 0x12, 0x5a, 0x3b, 0x51, 0xf0, 0xe2, 0x37, 0x47, 0x22, 0xfd, 0x3e, 0x94, 0x39,
 0x84, 0xc6, 0x19, 0x88, 0x43, 0x9e, 0x8d, 0x2b, 0x0a, 0x56, 0x3c, 0x55, 0x86, 0xf5, 0x6e, 0xad,
 0x86, 0xaa, 0x8b, 0x7d, 0x4d, 0xf7, 0xc6, 0x72, 0x7d, 0xb3, 0x92, 0xdd, 0xf3, 0x7d, 0x61, 0xe3,
 0x39, 0x3f, 0x3d, 0x96, 0xef, 0x9b, 0xeb, 0x03, 0x4c, 0x97, 0xcb, 0x78, 0xdc, 0x6d, 0x35, 0x95,
 0x48, 0x49, 0xd6, 0x24, 0x44, 0x6f, 0xde, 0x6d, 0xf9, 0x46, 0x42, 0x77, 0x09, 0x96, 0x8d, 0x06,
 0x6a, 0x34, 0x27, 0xb1, 0xee, 0x47, 0xb5, 0xac, 0x55, 0x5d, 0xd5, 0xed, 0xfd, 0xc6, 0x4f, 0x19,
 0x4a, 0x79, 0xe4, 0xb7, 0x7c, 0xdf, 0x59, 0x28, 0x73, 0xf2, 0xd1, 0x5f, 0xbb, 0x0e, 0x66, 0x03,
 0xdd, 0xcf, 0x46, 0xc4, 0x45, 0x5f, 0x99, 0x40, 0x6c, 0x91, 0xae, 0x0b, 0x1a, 0xe2, 0xda, 0xc1,
 0x5a, 0xe0, 0x32, 0xac, 0x15, 0x85, 0xb5, 0x82, 0xb5, 0xc0, 0x65, 0x5a, 0xe1, 0x5a, 0xe2, 0xda,
 0xc1, 0x58, 0x04, 0xd9, 0xff, 0x00, 0x0e, 0x59, 0x88, 0x0d, 0xc4, 0xe0, 0x37, 0x58, 0x90, 0x53,
 0x48, 0xa8, 0x89, 0xc5, 0x59, 0xd7, 0xe2, 0x34, 0x6a, 0x8b, 0xd4, 0xea, 0x4b, 0x17, 0x54, 0x54,
 0x5d, 0x15, 0x17, 0x9a, 0x29, 0xcf, 0xb3, 0x66, 0x10, 0xb8, 0x74, 0x75, 0x99, 0x96, 0x6a, 0xfb,
 0x12, 0x22, 0xf6, 0x7e, 0x6d, 0x7a, 0x7a, 0x3a, 0x00, 0xba, 0xa5, 0xcd, 0x97, 0x27, 0x43, 0xc1,
 0x71, 0x04, 0x74, 0x9c, 0xec, 0xaa, 0x2c, 0xd2, 0x6a, 0xe6, 0x3a, 0xa3, 0x92, 0xa2, 0x7a, 0x11,
 0x79, 0xa1, 0xa6, 0xd5, 0xb9, 0x28, 0x53, 0x2f, 0x85, 0x11, 0xb1, 0x21, 0xbd, 0x58, 0xf6, 0xae,
 0xad, 0x72, 0x2e, 0x8a, 0x8b, 0xd4, 0x0e, 0xab, 0xed, 0x73, 0x02, 0xf3, 0x1f, 0xf7, 0xaf, 0xf5,
 0x87, 0xb5, 0xcc, 0x0f, 0xcc, 0x7f, 0xde, 0xbf, 0xd6, 0x2a, 0xca, 0xf9, 0x91, 0x98, 0x9c, 0x34,
 0x97, 0x98, 0x56, 0xb2, 0x71, 0xa9, 0xcb, 0x92, 0x44, 0x4e, 0xa9, 0x7e, 0xa8, 0x3d, 0xad, 0x70,
 0x2b, 0xfb, 0x5c, 0xc0, 0x7c, 0xc7, 0xfd, 0xeb, 0xfd, 0x66, 0x49, 0x7c, 0x0b, 0x06, 0x81, 0x1d,
 0x91, 0xe1, 0x49, 0xee, 0xc4, 0x86, 0xe4, 0x73, 0x56, 0xa3, 0x97, 0x45, 0x4f, 0x8c, 0xc9, 0x5e,
 0xe1, 0x5a, 0xe0, 0x32, 0xad, 0x70, 0xad, 0xaf, 0x68, 0xb6, 0xb5, 0xc2, 0xb5, 0xc0, 0x65, 0x5a,
 0xe1, 0x5e, 0xe2, 0xda, 0xd7, 0x0a, 0xf7, 0x01, 0x95, 0x6b, 0x85, 0x7b, 0x8b, 0x6b, 0x1e, 0xd6,
 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5b, 0x58, 0x2b, 0x00, 0xba, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5,
 0x82, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xdc, 0x39, 0x80, 0xc6, 0xbd,
 0xc2, 0xbd, 0xc5, 0xd5, 0x82, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7,
 0x03, 0x4c, 0xce, 0x31, 0x7f, 0x84, 0x73, 0x4b, 0xaf, 0xbc, 0xfa, 0xa8, 0x28, 0xaa, 0x9d, 0x4b,
 0x39, 0xba, 0x2e, 0xb9, 0x86, 0x67, 0x8f, 0xbd, 0xfa, 0xa8, 0x2a, 0xaa, 0x06, 0xd5, 0x90, 0xe3,
 0x7e, 0x1e, 0xff, 0x00, 0xe0, 0x7f, 0xee, 0x37, 0xda, 0xd7, 0x39, 0x0e, 0x19, 0x89, 0xc7, 0xc3,
 0xa6, 0xbd, 0x93, 0x2c, 0xac, 0xdf, 0xdd, 0x56, 0xf9, 0x6d, 0xd5, 0x34, 0x51, 0xa7, 0xb6, 0xfc,
 0x5b, 0xac, 0xb7, 0x75, 0xf7, 0x81, 0xd2, 0xab, 0x5c, 0x2b, 0x5c, 0xe6, 0xbe, 0xdb, 0xf1, 0x6e,
 0xb2, 0xdd, 0xd7, 0xde, 0x1e, 0xdb, 0xf1, 0x6e, 0xb2, 0xdd, 0xd7, 0xde, 0x07, 0x4a, 0xad, 0x70,
 0xac, 0x73, 0x5f, 0x6d, 0xf8, 0xb7, 0x59, 0x6e, 0xeb, 0xef, 0x18, 0xe5, 0xcc, 0xc7, 0x3f, 0x3f,
 0x8a, 0x36, 0x5a, 0x61, 0x60, 0x53, 0x56, 0x39, 0x7c, 0x96, 0x68, 0xbc, 0x13, 0xd2, 0x06, 0xf3,
 0x58, 0x2b, 0x0b, 0xab, 0x5c, 0x2b, 0x00, 0xab, 0x68, 0x51, 0xbf, 0x07, 0x4a, 0xf1, 0xfc, 0xfa,
 0xfd, 0x55, 0x34, 0xaa, 0xa9, 0xd4, 0xd9, 0xb3, 0xfc, 0x5d, 0x70, 0xf9, 0x6f, 0xf2, 0xeb, 0xf5,
 0x54, 0xd3, 0x6a, 0x80, 0xc2, 0x56, 0x32, 0x36, 0x6a, 0x0b, 0xb5, 0xe5, 0x11, 0xab, 0xf3, 0xa1,
 0xd5, 0xd6, 0x3d, 0xce, 0x2e, 0xb1, 0x74, 0xe3, 0xaa, 0x9d, 0x4e, 0x56, 0x69, 0x23, 0x4b, 0x42,
 0x8c, 0xd5, 0x45, 0x47, 0xb1, 0x1c, 0x9f, 0x1a, 0x00, 0xd6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae,
 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x35, 0xfc, 0xcd, 0x81, 0xa6, 0x22, 0xe5, 0x9a, 0x95, 0x73, 0x59,
 0x33, 0xa6, 0x8e, 0x45, 0xe0, 0x91, 0x3d, 0x4a, 0x5f, 0xad, 0x70, 0xac, 0x07, 0x3b, 0x9c, 0x85,
 0x31, 0x29, 0x12, 0x9c, 0xd4, 0x17, 0xc2, 0x77, 0xf3, 0x93, 0x9f, 0xa1, 0x7b, 0x4c, 0x35, 0x74,
 0xed, 0x3a, 0x44, 0x47, 0x43, 0x8a, 0xc5, 0x64, 0x46, 0xb5, 0xed, 0x5e, 0x68, 0xe4, 0xd5, 0x05,
 0x53, 0x38, 0x16, 0x11, 0x1d, 0x55, 0x7d, 0x8f, 0x49, 0x57, 0xb6, 0x13, 0x95, 0xbf, 0x37, 0x20,
 0x34, 0xd6, 0x4c, 0x39, 0x8e, 0xde, 0x63, 0xdc, 0xd7, 0x27, 0x6b, 0x57, 0x45, 0xf9, 0x86, 0x52,
 0x99, 0x93, 0x16, 0x95, 0xd1, 0x19, 0x3a, 0xf7, 0xb5, 0x3f, 0x26, 0x27, 0x96, 0x9f, 0x39, 0x7a,
 0x67, 0x2a, 0xc2, 0x5d, 0x56, 0x5a, 0x75, 0xed, 0x5e, 0x91, 0x1a, 0x8b, 0xf3, 0xa0, 0xaa, 0x73,
 0x2f, 0xe2, 0x90, 0x35, 0x56, 0x43, 0x64, 0x76, 0xa7, 0xf8, 0x27, 0x6a, 0xbf, 0x22, 0x81, 0x86,
 0x76, 0x75, 0xf3, 0x73, 0x71, 0x66, 0xa2, 0xee, 0xa3, 0xe2, 0xb9, 0x5e, 0xed, 0xde, 0x5a, 0xa9,
 0x86, 0xad, 0xca, 0x6f, 0x73, 0x98, 0xf5, 0x63, 0xda, 0xad, 0x72, 0x2e, 0x8a, 0x8a, 0x9a, 0x2a,
 0x28, 0x55, 0x03, 0xa0, 0xec, 0xf6, 0x2e, 0x98, 0x6c, 0xd7, 0x1f, 0xcf, 0xa7, 0xd5, 0x43, 0x66,
 0xad, 0x73, 0x4a, 0xc8, 0x11, 0x7f, 0x07, 0xcd, 0x71, 0xfc, 0xf2, 0x7d, 0x54, 0x36, 0x4a, 0xd7,
 0x03, 0x0e, 0x71, 0x8d, 0xfc, 0x1c, 0x9a, 0x4f, 0xd0, 0xfa, 0xc8, 0x73, 0xba, 0xa8, 0x6e, 0x99,
 0xba, 0x36, 0xb9, 0x7a, 0x6b, 0x8f, 0xbc, 0xfa, 0xc8, 0x73, 0xe4, 0x8b, 0x70, 0x2e, 0x2c, 0x54,
 0xd1, 0x78, 0xf6, 0x1d, 0x4f, 0x0b, 0x8c, 0x9e, 0x2c, 0x95, 0xe3, 0xf9, 0x96, 0x7d, 0x54, 0x39,
 0x0d, 0x43, 0xa4, 0xe0, 0x33, 0x29, 0x13, 0x05, 0x93, 0x7a, 0x2f, 0xe6, 0x5a, 0x9f, 0x27, 0x00,
 0x1f, 0x56, 0xb8, 0x2c, 0x6e, 0x0b, 0xc4, 0x5d, 0x5a, 0xe7, 0x8f, 0x8d, 0xa3, 0x55, 0x75, 0xe4,
 0x9a, 0x81, 0xcd, 0x96, 0x2a, 0x6a, 0xa1, 0x55, 0x3a, 0xa9, 0x4e, 0xa8, 0x54, 0x03, 0xa4, 0x64,
 0x38, 0xdf, 0x80, 0x74, 0xd7, 0x94, 0x77, 0xfe, 0xe1, 0xfd, 0x6b, 0x9a, 0x5e, 0x43, 0x9a, 0x45,
 0xc3, 0x23, 0xc3, 0xd7, 0x8b, 0x23, 0x6b, 0xf2, 0xa2, 0x7a, 0x8d, 0x8e, 0xb0, 0x0c, 0x6b, 0x1c,
 0xef, 0x38, 0x45, 0xfe, 0x11, 0xcd, 0x71, 0xf7, 0x9f, 0x55, 0x0d, 0xce, 0xbf, 0x53, 0x9e, 0xe6,
 0xc8, 0xdb, 0xd9, 0x82, 0x69, 0x75, 0xed, 0x6a, 0x7f, 0xb2, 0x80, 0x57, 0xaa, 0x9d, 0x4d, 0x9b,
 0x67, 0xb1, 0x74, 0xc4, 0x66, 0x97, 0x5f, 0xcc, 0x27, 0xd6, 0x43, 0x4d, 0xaa, 0x6c, 0x99, 0x02,
 0x2e, 0x98, 0x8c, 0xd7, 0x1f, 0xcc, 0xa7, 0xd6, 0x40, 0x3a, 0x1d, 0x63, 0x53, 0xda, 0x24, 0x5d,
 0x5b, 0x23, 0xd3, 0x57, 0xff, 0x00, 0x54, 0x77, 0x5a, 0xe6, 0xb3, 0x9f, 0xd7, 0x7a, 0x4a, 0x56,
 0x2f, 0xbd, 0x8a, 0xa8, 0xbf, 0x1a, 0x7d, 0xc0, 0x6b, 0x75, 0x6e, 0x15, 0x53, 0xa9, 0x4e, 0xa9,
 0x92, 0x51, 0xcc, 0x89, 0x35, 0x09, 0x91, 0x15, 0x77, 0x1d, 0x11, 0xad, 0x76, 0x8b, 0xc7, 0x45,
 0x5e, 0x20, 0x67, 0xa8, 0xde, 0x89, 0xf2, 0x06, 0xfb, 0x7a, 0x27, 0xc8, 0x6d, 0xde, 0xd6, 0xb0,
 0x9d, 0x7f, 0xba, 0x7b, 0xdf, 0xb8, 0x3d, 0xad, 0x61, 0x3d, 0x66, 0x7b, 0xdf, 0xb8, 0x0d, 0x46,
 0xa3, 0x7a, 0x27, 0xc8, 0x15, 0x1b, 0xd1, 0x3e, 0x43, 0x6d, 0xf6, 0xb5, 0x84, 0xff, 0x00, 0x49,
 0xef, 0x7e, 0xe3, 0x58, 0xcc, 0x70, 0x25, 0xe4, 0x31, 0x47, 0x4b, 0x4b, 0x2b, 0xf7, 0x11, 0x8d,
 0x55, 0xde, 0x76, 0xab, 0xaa, 0x81, 0x86, 0xa3, 0x7a, 0x27, 0xc8, 0x3e, 0xc8, 0xae, 0x45, 0xc7,
 0xda, 0xe4, 0x44, 0xe1, 0x05, 0xeb, 0xf4, 0x1a, 0xb5, 0x53, 0x63, 0xc8, 0x3a, 0xac, 0xfc, 0xcc,
 0x6e, 0xc6, 0x42, 0x46, 0xfc, 0x6a, 0xbf, 0x70, 0x1d, 0x12, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0x82,
 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b,
 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x42, 0x3a, 0xc2, 0x8f, 0x05, 0xf0, 0x62, 0xb1,
 0x1f, 0x0d, 0xe9, 0xa3, 0x9a, 0xa9, 0xc1, 0x50, 0xa3, 0x58, 0x2b, 0x01, 0xa6, 0x66, 0x3c, 0x26,
 0x26, 0x19, 0x1f, 0x7e, 0x1a, 0xab, 0xe5, 0x5e, 0xbe, 0x43, 0x97, 0x9b, 0x6c, 0xbf, 0xf7, 0xc4,
 0x51, 0x54, 0xe8, 0xf1, 0xd6, 0x14, 0x78, 0x2f, 0x83, 0x19, 0x88, 0xf8, 0x6f, 0x4d, 0x1c, 0xd5,
 0xed, 0x43, 0x43, 0xcc, 0x58, 0x54, 0x4c, 0x36, 0x2d, 0x48, 0x6a, 0xe7, 0xca, 0xb9, 0x7c, 0x97,
 0x76, 0xb6, 0xcb, 0xeb, 0x02, 0xab, 0x26, 0x1c, 0xc7, 0xb5, 0xec, 0x7b, 0x9a, 0xe6, 0xae, 0xa8,
 0xe4, 0x5d, 0x15, 0x14, 0xde, 0xb2, 0xc6, 0x65, 0x6c, 0xfb, 0x5b, 0x2b, 0x36, 0xe4, 0x6c, 0xd2,
 0x27, 0x07, 0x72, 0x48, 0xbf, 0x79, 0xce, 0x2a, 0xdc, 0x1b, 0x19, 0x5a, 0xe4, 0x73, 0x5c, 0xad,
 0x72, 0x2e, 0xa8, 0xa8, 0xbc, 0x51, 0x40, 0xec, 0xf5, 0xae, 0x15, 0xae, 0x6a, 0x59, 0x5f, 0x1f,
 0xf1, 0x84, 0x2f, 0x63, 0xcc, 0x39, 0x12, 0x69, 0x89, 0xcf, 0xfc, 0x22, 0x75, 0xf4, 0xf5, 0x1e,
 0x56, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x1e, 0x2c, 0x6b, 0x80, 0xca, 0xb5, 0xc2, 0xb5,
 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0x0a, 0xd7, 0x01, 0x8d,
 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x05, 0x6b, 0x80, 0xb6, 0xb5, 0xc2, 0xb0, 0xba, 0xb5, 0xc2, 0xb5,
 0xc0, 0x63, 0x5a, 0xe7, 0xb5, 0x85, 0xb5, 0x82, 0xb5, 0xc0, 0x65, 0x58, 0xf2, 0xb0, 0xba, 0xb5,
 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x03, 0x53, 0xcd, 0x91,
 0x7f, 0x84, 0x13, 0x3c, 0x7d, 0xef, 0xd5, 0x41, 0x55, 0x4b, 0x99, 0xf3, 0x4c, 0x5d, 0x71, 0xe9,
 0x9d, 0x3f, 0x9b, 0xf5, 0x50, 0x59, 0x56, 0xe0, 0x5c, 0xa9, 0x70, 0xa9, 0x72, 0x78, 0x14, 0xb4,
 0x3c, 0x42, 0x7f, 0xd8, 0xf1, 0x62, 0x3d, 0x8d, 0xdc, 0x57, 0x6a, 0xdd, 0x35, 0xe1, 0xa7, 0x51,
 0xef, 0xb5, 0xa9, 0x4f, 0x3b, 0x98, 0xf9, 0x1a, 0x06, 0xbf, 0x52, 0xe1, 0x52, 0xe6, 0xc1, 0xed,
 0x6a, 0x53, 0xce, 0xe6, 0x3e, 0x46, 0xfa, 0x83, 0xda, 0xd4, 0xa7, 0x9d, 0xcc, 0x7c, 0x8d, 0xf5,
 0x01, 0xaf, 0xd4, 0x1c, 0xe4, 0xd8, 0xba, 0x63, 0x8c, 0xe3, 0xf9, 0xb7, 0xfd, 0x06, 0x7f, 0x6b,
 0x52, 0x9e, 0x77, 0x31, 0xf2, 0x34, 0xb5, 0x85, 0xe0, 0xf2, 0xf8, 0x7c, 0xe2, 0x4c, 0xc3, 0x98,
 0x8a, 0xf7, 0x23, 0x55, 0xba, 0x39, 0x13, 0x4e, 0x3e, 0x80, 0x36, 0x8a, 0xc7, 0xb5, 0x85, 0xb5,
 0xae, 0x15, 0xae, 0x02, 0xec, 0xf9, 0x17, 0x5c, 0x3e, 0x5b, 0xfc, 0xb2, 0xfd, 0x55, 0x34, 0xfa,
 0x86, 0xc3, 0x9e, 0x23, 0x6b, 0x21, 0x2d, 0xc7, 0xf3, 0xcb, 0xf5, 0x54, 0xd4, 0xaa, 0xdc, 0x0b,
 0x89, 0x13, 0x89, 0xb8, 0x65, 0x0c, 0x6a, 0x1a, 0xca, 0xb7, 0x0f, 0x8f, 0x11, 0x19, 0x11, 0x9c,
 0x21, 0x6f, 0x2f, 0xe3, 0x37, 0xa7, 0xa5, 0x0d, 0x11, 0x8e, 0x7b, 0xd5, 0x51, 0x88, 0xae, 0x54,
 0x45, 0x5d, 0x13, 0xa2, 0x26, 0xaa, 0x79, 0x54, 0x0e, 0xbf, 0x5b, 0xb4, 0xaf, 0x0b, 0x12, 0x95,
 0x8d, 0x34, 0xe9, 0x68, 0x51, 0xd8, 0xf8, 0xad, 0x6e, 0xf3, 0x9a, 0x8b, 0xae, 0x89, 0xe9, 0x39,
 0x62, 0xcd, 0xc7, 0x56, 0x6e, 0x2c, 0x78, 0xaa, 0xde, 0x9b, 0xeb, 0xa1, 0x67, 0x02, 0x9e, 0xf6,
 0x1e, 0x2b, 0x02, 0x32, 0xae, 0x8d, 0x57, 0x6e, 0xbf, 0xd0, 0xbc, 0x00, 0xea, 0x55, 0x8d, 0x7e,
 0x67, 0x37, 0xca, 0xc3, 0x73, 0x99, 0x0e, 0x5e, 0x3c, 0x47, 0x35, 0x55, 0x17, 0x7b, 0x46, 0xa6,
 0xa5, 0xea, 0xda, 0x76, 0x9a, 0x4e, 0x6a, 0x96, 0x59, 0x5c, 0x49, 0xd1, 0x9a, 0x9f, 0xd8, 0xa3,
 0xf9, 0x49, 0xd1, 0x1d, 0xda, 0x9f, 0xbc, 0x07, 0x11, 0xf3, 0x8c, 0xdb, 0xb8, 0x41, 0x97, 0x83,
 0x0d, 0x3f, 0x9c, 0xaa, 0xef, 0x51, 0xb0, 0xe0, 0x58, 0xaf, 0x8c, 0x70, 0xf6, 0x46, 0x73, 0x9b,
 0x55, 0x3c, 0x98, 0xa8, 0x9d, 0x8e, 0x39, 0x7d, 0x4b, 0x96, 0x24, 0x31, 0x19, 0x99, 0x18, 0xd5,
 0x65, 0xa2, 0xab, 0x15, 0x78, 0x2a, 0x73, 0x45, 0x4b, 0xa0, 0x1d, 0x5a, 0xb5, 0xc2, 0xb7, 0x0e,
 0x2a, 0x68, 0x0d, 0xcd, 0xf3, 0xa8, 0xdd, 0x1d, 0x2f, 0x2e, 0xe5, 0xeb, 0xc5, 0x3f, 0x79, 0x56,
 0x7b, 0x31, 0xe2, 0x33, 0x70, 0x9d, 0x09, 0x62, 0x32, 0x14, 0x37, 0x26, 0x8a, 0x90, 0xd3, 0x45,
 0x54, 0xe9, 0xa8, 0x1e, 0xe2, 0xf3, 0x49, 0x31, 0x8a, 0x4d, 0x47, 0x62, 0xea, 0xd7, 0xc5, 0x72,
 0xa2, 0xeb, 0xcf, 0x89, 0x56, 0xa1, 0x4e, 0xa5, 0xc2, 0xad, 0xc0, 0xdf, 0xb2, 0x2c, 0x4d, 0xdc,
 0x32, 0x33, 0xbd, 0xf4, 0x6f, 0xa1, 0x10, 0xd8, 0x2b, 0x5c, 0xd6, 0xf2, 0xc3, 0x56, 0x5f, 0x05,
 0x82, 0xd7, 0x6a, 0x8e, 0x7e, 0xb1, 0x15, 0x16, 0xfc, 0xbe, 0x61, 0x9d, 0x6b, 0x81, 0x0c, 0xd9,
 0x17, 0x5c, 0xbf, 0x33, 0xc7, 0xde, 0xfd, 0x64, 0x34, 0x1a, 0x97, 0x36, 0xec, 0xd3, 0x1b, 0x5c,
 0x06, 0x67, 0xfd, 0x1f, 0xac, 0x86, 0x8b, 0x56, 0xe0, 0x5c, 0xa9, 0x73, 0x6e, 0xc9, 0x78, 0xb3,
 0x16, 0x5f, 0xc5, 0xd1, 0x1c, 0x88, 0xf6, 0x2a, 0xba, 0x1e, 0xab, 0xf8, 0xc9, 0xda, 0x86, 0x8c,
 0xc7, 0xb9, 0xef, 0x6b, 0x1b, 0xc5, 0xce, 0x54, 0x44, 0x4e, 0xaa, 0x0b, 0x11, 0xf0, 0xe2, 0x69,
 0xab, 0x98, 0xf6, 0xaf, 0xa1, 0x51, 0x50, 0x0e, 0xbb, 0x5a, 0xe5, 0x5c, 0x5a, 0x79, 0x92, 0xb8,
 0x6c, 0xc4, 0x67, 0xb9, 0x13, 0x46, 0x2a, 0x25, 0xd5, 0x53, 0x44, 0x43, 0x40, 0x81, 0x99, 0x71,
 0x48, 0x4c, 0x46, 0xd7, 0x6c, 0x44, 0x4e, 0x4b, 0x11, 0x9a, 0xaf, 0xca, 0x55, 0xc4, 0x31, 0x69,
 0xc9, 0xf5, 0x6f, 0xb2, 0x63, 0x6f, 0x35, 0xbc, 0x9a, 0x89, 0xa3, 0x53, 0xe2, 0x03, 0xd4, 0x88,
 0xba, 0x73, 0x0a, 0x97, 0x29, 0xd4, 0xb8, 0x36, 0x23, 0x9c, 0xe4, 0x6a, 0x71, 0x55, 0x5d, 0x11,
 0x10, 0x0d, 0x97, 0x29, 0xe2, 0xad, 0x90, 0x9f, 0x73, 0x23, 0x3f, 0x76, 0x0c, 0x64, 0xdd, 0x73,
 0x97, 0x93, 0x57, 0xb1, 0x7e, 0x9f, 0x94, 0xde, 0xab, 0xa2, 0xf1, 0xd7, 0x5d, 0x78, 0x9c, 0x8a,
 0x3a, 0x45, 0x81, 0x19, 0xd0, 0xa3, 0x31, 0x58, 0xf6, 0xae, 0x8a, 0x8b, 0xd8, 0x5d, 0x91, 0xc7,
 0x71, 0x19, 0x36, 0x24, 0x38, 0x33, 0x1a, 0xb1, 0x39, 0x35, 0xe9, 0xbc, 0x89, 0xe8, 0x03, 0xa7,
 0xba, 0x3a, 0x35, 0x15, 0xce, 0x5d, 0x11, 0x38, 0xaa, 0xaf, 0x61, 0xcd, 0xf1, 0x69, 0xc4, 0x9a,
 0xc4, 0xe6, 0x66, 0x1a, 0xed, 0x5a, 0xf8, 0x8a, 0xad, 0xf4, 0x72, 0x43, 0x0c, 0xfe, 0x3d, 0x88,
 0xce, 0xc2, 0x58, 0x51, 0xa3, 0xa3, 0x61, 0xaf, 0x36, 0xb1, 0xbb, 0xa8, 0xa2, 0xfa, 0x97, 0x02,
 0xe5, 0x43, 0x65, 0xc8, 0x4f, 0xfe, 0xda, 0x9a, 0x7f, 0x48, 0x6d, 0x6f, 0xcf, 0xf7, 0x1a, 0x75,
 0x5b, 0x9b, 0x8e, 0x4d, 0x86, 0xe8, 0x18, 0x73, 0xa3, 0xb9, 0x34, 0x58, 0xee, 0xd5, 0x3f, 0x45,
 0x38, 0x27, 0xef, 0x03, 0x6d, 0xad, 0x71, 0x7e, 0x63, 0x87, 0xec, 0xcc, 0x1e, 0x3c, 0x36, 0xa6,
 0xaf, 0x6a, 0x6f, 0xb5, 0x2e, 0x9c, 0x7e, 0x8d, 0x4f, 0x2b, 0x5c, 0x2b, 0x5c, 0x0e, 0x7d, 0x52,
 0xff, 0x00, 0x39, 0xea, 0x45, 0x54, 0xe2, 0x8b, 0xa2, 0x96, 0x33, 0x24, 0x92, 0xc8, 0xce, 0xac,
 0x48, 0x6d, 0xfe, 0xd7, 0x8a, 0xaa, 0xac, 0x5f, 0x7a, 0xbd, 0xad, 0x15, 0x55, 0xb8, 0x1d, 0x43,
 0x03, 0xc5, 0x59, 0x88, 0x48, 0x32, 0x2a, 0x39, 0x2a, 0x35, 0x11, 0xb1, 0x5b, 0xda, 0x8e, 0xfb,
 0xf9, 0x97, 0xab, 0xa1, 0xc9, 0xe4, 0xe7, 0xa6, 0x25, 0x23, 0x24, 0x59, 0x78, 0xae, 0x86, 0xfb,
 0x76, 0xa7, 0x45, 0x4e, 0xd1, 0xc3, 0x33, 0x74, 0xf2, 0x33, 0x47, 0x41, 0x80, 0xe7, 0x7b, 0xed,
 0x15, 0x3e, 0x6d, 0x40, 0xdf, 0x63, 0xcd, 0xc3, 0x81, 0x05, 0xf1, 0xa3, 0x3d, 0x19, 0x0d, 0x89,
 0xab, 0x95, 0x4e, 0x73, 0x8a, 0x4f, 0x3a, 0x77, 0x10, 0x8d, 0x34, 0xbc, 0x2a, 0x3b, 0x54, 0x4e,
 0x89, 0xc9, 0x3e, 0x62, 0xb6, 0x25, 0x8c, 0x4e, 0x62, 0x0a, 0x9e, 0xc8, 0x8b, 0xe4, 0x22, 0xea,
 0x8c, 0x6a, 0x68, 0xd4, 0xf8, 0xbb, 0x4a, 0x75, 0x2e, 0x05, 0xca, 0x9d, 0x54, 0xdd, 0xb2, 0x5c,
 0x35, 0x81, 0x85, 0x2c, 0x67, 0x70, 0x74, 0x77, 0xef, 0x27, 0xe8, 0xa7, 0x04, 0xfd, 0xe6, 0x91,
 0x84, 0xca, 0xc4, 0xc4, 0x27, 0x1b, 0x01, 0xbc, 0x19, 0xcd, 0xee, 0xf7, 0xa8, 0x74, 0x08, 0x4f,
 0x64, 0x28, 0x6d, 0x86, 0xc4, 0x46, 0xb5, 0xa8, 0x88, 0xd4, 0xe8, 0x80, 0x33, 0xad, 0x70, 0xac,
 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63,
 0x5a, 0xe1, 0x58, 0x5d, 0x5a, 0xe1, 0x59, 0x3a, 0x80, 0xca, 0xb1, 0xe5, 0x6b, 0x8b, 0xab, 0x05,
 0x60, 0x18, 0xd6, 0xb9, 0x18, 0xce, 0x64, 0x68, 0x4e, 0x85, 0x15, 0xa8, 0xf6, 0x39, 0x34, 0x73,
 0x5c, 0x9c, 0x15, 0x0a, 0x15, 0xae, 0x15, 0x93, 0xa8, 0x1a, 0xa6, 0x62, 0xc3, 0x1f, 0x86, 0xc6,
 0xa9, 0x09, 0x5c, 0xf9, 0x67, 0xaf, 0x92, 0xe5, 0xfc, 0x95, 0xe8, 0xa2, 0x9a, 0x8b, 0xd4, 0xdf,
 0x66, 0x29, 0x4c, 0x40, 0x7c, 0x08, 0xed, 0x47, 0xc3, 0x7a, 0x68, 0xe4, 0x53, 0x9f, 0x62, 0x50,
 0x5f, 0x25, 0x3b, 0x12, 0x59, 0xeb, 0xae, 0xe2, 0xf0, 0x5e, 0xa9, 0xd8, 0xa0, 0x58, 0x97, 0x9a,
 0x8b, 0x2f, 0x1d, 0x91, 0xe0, 0xbd, 0x5b, 0x11, 0x8b, 0xab, 0x54, 0xe8, 0x98, 0x56, 0x24, 0xc9,
 0xf9, 0x18, 0x73, 0x2c, 0xe1, 0xbc, 0x9a, 0x39, 0xba, 0xfe, 0x2b, 0xbb, 0x50, 0xe5, 0x75, 0x2e,
 0x6c, 0x19, 0x2b, 0x10, 0x58, 0x73, 0x91, 0x25, 0x1c, 0xef, 0x26, 0x2b, 0x77, 0x9b, 0xfa, 0x49,
 0xf7, 0x01, 0xbf, 0x56, 0xb8, 0x57, 0x4e, 0xa2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x95, 0x60, 0xac,
 0x2d, 0xad, 0x70, 0xad, 0x70, 0x19, 0x56, 0x0a, 0xc2, 0xda, 0xd7, 0x0a, 0xd7, 0x01, 0x95, 0x60,
 0xac, 0x2d, 0x48, 0xd7, 0x3d, 0xaf, 0x70, 0x16, 0xd6, 0xd7, 0xb4, 0x2a, 0xdc, 0x5b, 0x5e, 0xe1,
 0x5a, 0xe0, 0x32, 0x48, 0xd7, 0x0a, 0xc2, 0xda, 0xd7, 0x0a, 0xd7, 0x01, 0x95, 0x6b, 0x82, 0xc6,
 0xb8, 0xb6, 0xbd, 0xc2, 0xbd, 0xc0, 0x65, 0x5b, 0x5e, 0xd0, 0xad, 0x71, 0x6d, 0x7b, 0x85, 0x7b,
 0x81, 0xad, 0x66, 0x78, 0xba, 0xe3, 0x73, 0x0b, 0xfa, 0x3f, 0x55, 0x05, 0xa9, 0x12, 0xe6, 0x4c,
 0xcb, 0x17, 0xf0, 0xd4, 0xc7, 0xfa, 0x3f, 0x55, 0x05, 0xb5, 0x40, 0xd9, 0xb2, 0x7c, 0x4d, 0x31,
 0x8e, 0x7f, 0x9a, 0x77, 0xee, 0x37, 0x0a, 0xb7, 0x34, 0x0c, 0xa5, 0x17, 0x4c, 0x5f, 0xff, 0x00,
 0x89, 0xdf, 0xb8, 0xdb, 0xab, 0x5c, 0x06, 0x55, 0x82, 0xb0, 0xb6, 0xb0, 0x56, 0xb8, 0x0c, 0x6b,
 0x5c, 0x2b, 0x5c, 0x5d, 0x5e, 0xe1, 0x5e, 0xe0, 0x32, 0x58, 0xc7, 0x95, 0xae, 0x2e, 0xad, 0x70,
 0xaf, 0x70, 0x29, 0x67, 0x58, 0xba, 0xc8, 0xcb, 0xa7, 0xfe, 0xaa, 0xfd, 0x55, 0x35, 0x5d, 0xf5,
 0xb9, 0xbb, 0xd6, 0xb8, 0x56, 0x4b, 0x01, 0xad, 0x65, 0x98, 0x9f, 0x86, 0xe5, 0xf5, 0x4e, 0x1e,
 0x57, 0x3f, 0xd1, 0x53, 0x36, 0x60, 0xc3, 0x1f, 0x2b, 0x15, 0xd3, 0x12, 0xcc, 0x73, 0xa5, 0xdc,
 0xba, 0xf0, 0xe2, 0xac, 0xb7, 0xa0, 0x7f, 0x5b, 0xd0, 0x15, 0xae, 0x06, 0x91, 0x57, 0xa1, 0xeb,
 0x5e, 0xe7, 0xb9, 0x1a, 0xd4, 0x57, 0x39, 0x79, 0x22, 0x26, 0xaa, 0x6d, 0xb1, 0x25, 0xa4, 0x62,
 0x3b, 0x7a, 0x24, 0xa4, 0x07, 0x2f, 0x55, 0x62, 0x19, 0x60, 0xa4, 0x08, 0x3f, 0xc4, 0xc2, 0x87,
 0x0f, 0xf4, 0x5a, 0x88, 0x05, 0xdc, 0x36, 0x62, 0x33, 0xf0, 0xf8, 0x0e, 0x98, 0x63, 0xa1, 0xc5,
 0xdc, 0x4d, 0xf6, 0xbb, 0x9e, 0xa7, 0xb3, 0xf0, 0xa0, 0xce, 0xcb, 0x3a, 0x5e, 0x3a, 0x6a, 0xd5,
 0xe4, 0xbd, 0xad, 0x5e, 0xa8, 0x55, 0xaf, 0x70, 0xaf, 0x70, 0x35, 0x7c, 0x4b, 0x0e, 0x9b, 0x91,
 0x7a, 0xaa, 0xb1, 0x62, 0x42, 0xec, 0x88, 0xd4, 0xe1, 0xf1, 0xf4, 0x28, 0x55, 0xb9, 0xbb, 0xd6,
 0xb9, 0x5a, 0x3c, 0xb4, 0x94, 0x75, 0xd6, 0x2c, 0xac, 0x17, 0x2f, 0x5d, 0xde, 0x20, 0x6a, 0x15,
 0x0f, 0x6a, 0x9b, 0x32, 0xe1, 0x58, 0x5a, 0xae, 0xbe, 0xc6, 0x44, 0xf4, 0x3d, 0xde, 0xb3, 0xd6,
 0xe1, 0x98, 0x63, 0x57, 0x54, 0x95, 0x62, 0xfa, 0x55, 0x54, 0x0d, 0x65, 0xb1, 0x15, 0xce, 0x46,
 0xb5, 0x15, 0xca, 0xbc, 0x11, 0x13, 0x8a, 0x8f, 0xb0, 0x4c, 0x1a, 0x24, 0x48, 0x8d, 0x8f, 0x3c,
 0xdd, 0xc8, 0x69, 0xc5, 0x21, 0xaf, 0x37, 0x7a, 0x7a, 0x20, 0xce, 0x03, 0x65, 0xe0, 0x26, 0x90,
 0x60, 0xc3, 0x87, 0xfa, 0x2d, 0x44, 0x32, 0xac, 0x7b, 0x80, 0xc9, 0x22, 0xe8, 0x0b, 0x1a, 0xe2,
 0xda, 0xd7, 0x0a, 0xd7, 0x00, 0xcc, 0xf1, 0x75, 0xc0, 0xe6, 0x3f, 0xd1, 0xfa, 0xc8, 0x69, 0x15,
 0x16, 0xe6, 0xef, 0x5a, 0xe1, 0x5b, 0xd0, 0x06, 0x9d, 0x25, 0x13, 0xfb, 0x72, 0x07, 0x3f, 0xe3,
 0x5b, 0xf4, 0xa1, 0xb5, 0x63, 0xf8, 0x53, 0x27, 0x9e, 0xe9, 0x89, 0x75, 0x6b, 0x26, 0x3b, 0x53,
 0xb1, 0xff, 0x00, 0x7d, 0xcc, 0xf5, 0x92, 0xc1, 0x5e, 0xe0, 0x69, 0xb3, 0x50, 0xe3, 0xca, 0xc4,
 0xa7, 0x31, 0x09, 0xd0, 0xdd, 0xfc, 0xe4, 0xe1, 0xf2, 0x98, 0xaa, 0x6b, 0xc4, 0xdd, 0x5f, 0x11,
 0xb1, 0x1b, 0xba, 0xf4, 0x6b, 0x9b, 0xd1, 0x53, 0x54, 0x2b, 0xac, 0xa6, 0x1e, 0xab, 0xaa, 0xc9,
 0xc0, 0x55, 0xfd, 0x00, 0x35, 0x48, 0x6e, 0x74, 0x47, 0xa3, 0x21, 0xb5, 0xcf, 0x72, 0xf2, 0x46,
 0xa6, 0xaa, 0x6c, 0xd9, 0x7b, 0x09, 0x74, 0x08, 0x8d, 0x9b, 0x9c, 0x6a, 0x54, 0x4e, 0x2c, 0x87,
 0xcf, 0x76, 0xeb, 0x72, 0xe4, 0x1a, 0x50, 0x53, 0x48, 0x30, 0xe1, 0xc3, 0x4f, 0xe6, 0xb5, 0x10,
 0x9d, 0x6b, 0x80, 0x63, 0x78, 0x7c, 0x1c, 0x45, 0x88, 0xf4, 0x54, 0x87, 0x30, 0xd4, 0xd1, 0xaf,
 0xd3, 0x9d, 0x96, 0xc6, 0xa1, 0x3b, 0x2d, 0x35, 0x26, 0xfd, 0xd9, 0x88, 0x4e, 0x6f, 0x47, 0x69,
 0xe4, 0xaf, 0xa1, 0x4d, 0xbe, 0xbd, 0xcf, 0x1d, 0x15, 0x1c, 0xd5, 0x6b, 0x91, 0x15, 0x17, 0x9a,
 0x2a, 0x70, 0x03, 0x49, 0xaa, 0x8b, 0xda, 0x09, 0x13, 0x55, 0xd1, 0x35, 0x55, 0xb1, 0xb6, 0xbe,
 0x52, 0x41, 0xeb, 0xab, 0xa4, 0xe0, 0x2a, 0xfe, 0x82, 0x19, 0x60, 0xb2, 0x5e, 0x0a, 0xeb, 0x06,
 0x04, 0x28, 0x6b, 0xd5, 0xac, 0x44, 0x01, 0x3e, 0x0d, 0x83, 0x46, 0x98, 0x88, 0xd8, 0xb3, 0x8d,
 0x74, 0x28, 0x09, 0xc7, 0x75, 0x78, 0x39, 0xfe, 0xa4, 0x36, 0xe6, 0xc4, 0x6b, 0x5a, 0x8d, 0x6a,
 0x22, 0x22, 0x26, 0x88, 0x89, 0xc9, 0x05, 0xd5, 0xae, 0x15, 0xee, 0x03, 0x2a, 0xd7, 0x0a, 0xd7,
 0x16, 0xd6, 0xb8, 0x56, 0xb8, 0x17, 0x66, 0x9b, 0x0a, 0x6a, 0x03, 0xa0, 0x47, 0x6a, 0x3e, 0x1b,
 0x93, 0x8a, 0x1a, 0x8e, 0x2b, 0x84, 0x4c, 0xca, 0x39, 0xcf, 0x82, 0x8e, 0x8f, 0x07, 0x9a, 0x2b,
 0x53, 0xca, 0x6a, 0x5d, 0x3f, 0x79, 0xb0, 0xd6, 0xb8, 0x24, 0x6b, 0x81, 0xa4, 0x54, 0x0a, 0x86,
 0xdf, 0x31, 0x02, 0x4e, 0x61, 0x75, 0x8d, 0x2f, 0x09, 0xeb, 0xd5, 0x5b, 0xc7, 0xe5, 0x2b, 0x78,
 0xaf, 0x0b, 0xd7, 0x5f, 0x62, 0xa7, 0xeb, 0xbb, 0xd6, 0x06, 0xb0, 0xb1, 0x6f, 0xa0, 0xc7, 0x0c,
 0xc3, 0x66, 0xe7, 0x55, 0x15, 0x1a, 0xb0, 0xe1, 0x76, 0xc4, 0x7a, 0x68, 0x9f, 0x12, 0x76, 0x8f,
 0x60, 0x4a, 0xc8, 0xc0, 0x5d, 0x61, 0x4a, 0xc2, 0x6a, 0xf5, 0xdd, 0xd5, 0x7e, 0x72, 0xd5, 0x6b,
 0x81, 0x63, 0x0d, 0x97, 0x81, 0x21, 0x2e, 0x90, 0x60, 0x36, 0xee, 0x72, 0xf3, 0x72, 0xdc, 0xb5,
 0x54, 0x5b, 0x5a, 0xe1, 0x5a, 0xe0, 0x32, 0xac, 0x15, 0x6e, 0x2d, 0xaf, 0x70, 0xad, 0x70, 0x18,
 0xd6, 0xb9, 0xed, 0x6b, 0x8b, 0x6b, 0xdc, 0x2b, 0xdc, 0x06, 0x4b, 0x1a, 0xe1, 0x5a, 0xe2, 0xda,
 0xc0, 0x91, 0xee, 0x01, 0x13, 0x30, 0xe1, 0x90, 0xd7, 0x45, 0x9a, 0xde, 0x54, 0xec, 0x6b, 0x15,
 0x7f, 0x71, 0x82, 0x26, 0x6a, 0xc3, 0xdb, 0xf8, 0x89, 0x1d, 0xde, 0x86, 0x69, 0xfb, 0xcd, 0x2b,
 0x13, 0x45, 0x81, 0x88, 0x47, 0x84, 0xbc, 0x37, 0x62, 0x2e, 0x9e, 0x8e, 0x68, 0x56, 0xaa, 0x07,
 0x4d, 0xc2, 0xf1, 0x48, 0x78, 0x84, 0xb5, 0x78, 0x6c, 0x7b, 0x13, 0x79, 0x5b, 0xa3, 0xb9, 0xf0,
 0xff, 0x00, 0xec, 0xb3, 0x5a, 0xe6, 0x9b, 0x93, 0xa7, 0x9a, 0x8c, 0x8d, 0x28, 0xe7, 0x68, 0xe5,
 0x5d, 0xf6, 0xeb, 0xdb, 0xd8, 0xa6, 0xc3, 0x5b, 0xa2, 0x80, 0xca, 0xa9, 0xab, 0x67, 0x55, 0x6a,
 0x4c, 0x4b, 0xc5, 0x4f, 0xc6, 0x73, 0x15, 0xab, 0xf1, 0x2f, 0xde, 0x37, 0xac, 0x6a, 0xb9, 0xb6,
 0x75, 0xb1, 0x67, 0x99, 0x05, 0xab, 0xad, 0x16, 0xaa, 0x3b, 0xd2, 0xbd, 0x9f, 0x40, 0x14, 0xaa,
 0xdc, 0xbb, 0x81, 0xcc, 0x2c, 0x3c, 0x62, 0x55, 0xc8, 0xab, 0xfc, 0x62, 0x27, 0xcb, 0xc0, 0x49,
 0x54, 0xbb, 0x81, 0xb9, 0x62, 0x62, 0xf2, 0xcd, 0x4e, 0xc8, 0x88, 0xef, 0x89, 0x38, 0x81, 0xd2,
 0xab, 0x05, 0x6d, 0x7b, 0x45, 0xa9, 0x1a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75,
 0x7b, 0x85, 0x7b, 0x80, 0xc9, 0x63, 0x5c, 0x12, 0x35, 0xc5, 0xb5, 0xee, 0x15, 0xae, 0x03, 0x2a,
 0xf7, 0x3c, 0xab, 0x71, 0x75, 0x7b, 0x85, 0x6b, 0x80, 0xba, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae,
 0x15, 0x80, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xda, 0xf7, 0x0a, 0xd7, 0x01, 0x95, 0x7b, 0x85, 0x6b,
 0x8b, 0x6b, 0xdc, 0xf6, 0xb0, 0x0c, 0x6b, 0x5c, 0x2b, 0xdc, 0x5b, 0x5e, 0xe7, 0xb5, 0x80, 0x41,
 0x98, 0xa2, 0xfe, 0x18, 0x8e, 0xaa, 0xbe, 0xf7, 0xea, 0xa0, 0xbe, 0xad, 0xc9, 0x66, 0x08, 0xba,
 0xe2, 0xf1, 0xf8, 0xfb, 0xdf, 0xa1, 0x0a, 0x15, 0x40, 0x69, 0x23, 0x88, 0x45, 0x93, 0x8f, 0x5a,
 0x0a, 0xb7, 0x7f, 0x75, 0x5b, 0xe5, 0x26, 0xa9, 0xa2, 0x97, 0xfd, 0xb2, 0xe2, 0x1d, 0x60, 0x77,
 0x7f, 0x79, 0xae, 0x55, 0x0a, 0xa0, 0x6c, 0x7e, 0xd9, 0x71, 0x0f, 0xfd, 0x1e, 0xef, 0xef, 0x0f,
 0x6c, 0xb8, 0x87, 0x58, 0x1d, 0xdf, 0xde, 0x6b, 0x95, 0x02, 0xa8, 0x1b, 0x1f, 0xb6, 0x5c, 0x43,
 0xac, 0x0e, 0xef, 0xef, 0x0f, 0x6c, 0xb8, 0x87, 0x58, 0x1d, 0xdf, 0xde, 0x6b, 0x95, 0x42, 0xa8,
 0x1b, 0xc6, 0x5f, 0xc5, 0x66, 0x27, 0x92, 0x35, 0x75, 0x67, 0x91, 0xbb, 0xa6, 0xeb, 0x74, 0xe7,
 0xaf, 0xa8, 0x6b, 0x5a, 0xe6, 0xa1, 0x94, 0xa3, 0x70, 0x99, 0xe3, 0xef, 0x7f, 0x78, 0xfa, 0xb5,
 0xc0, 0x63, 0x5e, 0xe1, 0x5a, 0xe2, 0xea, 0xc1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xac, 0x2d, 0x48,
 0xf7, 0x3d, 0xac, 0x03, 0x1a, 0xc1, 0x5a, 0xe2, 0xda, 0xf7, 0x0a, 0xf7, 0x01, 0x95, 0x6b, 0x85,
 0x7b, 0x8b, 0x52, 0x3d, 0xc1, 0x63, 0xdc, 0x06, 0x55, 0xae, 0x15, 0x85, 0xd5, 0x8f, 0x16, 0x3d,
 0xc0, 0x65, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x3c, 0x58, 0xd7, 0x01, 0x95, 0x6b, 0x85, 0x6b,
 0x8b, 0xab, 0x5c, 0xf2, 0xb5, 0xc0, 0x65, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01,
 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0x6b, 0xdc, 0x2b, 0xdc, 0x06, 0x55, 0xae, 0x15, 0xae, 0x2e, 0xad,
 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0x16, 0xd7, 0xb9, 0xea, 0x46, 0xb8, 0x0c, 0x6b, 0x05,
 0x61, 0x75, 0x6e, 0x3c, 0xcf, 0x16, 0x3d, 0xc0, 0x65, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x3c,
 0x58, 0xf7, 0x01, 0x95, 0x60, 0xac, 0x2d, 0x48, 0xd7, 0x3d, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56,
 0xb8, 0xb6, 0xbd, 0xcf, 0x52, 0x35, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xd4, 0x8d, 0x73, 0xda,
 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0x6b, 0xdc, 0x2b, 0xdc, 0x06, 0x55, 0x82, 0xb5, 0xc5,
 0xb5, 0xae, 0x7b, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x6a, 0x46, 0xb9, 0xed, 0x6b, 0x80,
 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xb5, 0xee, 0x15, 0xee, 0x03, 0x2a, 0xd7, 0x0a, 0xd7, 0x16, 0xa4,
 0x7b, 0x82, 0xc7, 0xb8, 0x0c, 0xab, 0x05, 0x6b, 0x8b, 0xab, 0x05, 0x6b, 0x80, 0xc6, 0xb0, 0x56,
 0xb8, 0xb6, 0xbd, 0xcf, 0x6b, 0x00, 0xbb, 0x35, 0xc1, 0x5a, 0xac, 0x9c, 0x62, 0x70, 0x72, 0x6e,
 0xbe, 0xca, 0x9c, 0x84, 0x35, 0x6e, 0x6d, 0x91, 0x9c, 0xc8, 0xd0, 0xdd, 0x0e, 0x22, 0x23, 0x9a,
 0xe4, 0xd1, 0x51, 0x4d, 0x63, 0x13, 0xc3, 0xa3, 0x4a, 0xb9, 0x5f, 0x09, 0x16, 0x2c, 0x1e, 0xa9,
 0xcd, 0xbe, 0x9f, 0x58, 0x10, 0x85, 0x32, 0xf8, 0x51, 0x1b, 0x12, 0x13, 0xd5, 0x8f, 0x6a, 0xea,
 0x8a, 0x83, 0xa8, 0x19, 0xa2, 0x3b, 0x5a, 0x89, 0x1a, 0x03, 0x22, 0x2a, 0x76, 0xa2, 0xee, 0xea,
 0x6a, 0xd5, 0x42, 0xa8, 0x1b, 0x34, 0xd6, 0x66, 0x99, 0x88, 0xcd, 0xd8, 0x30, 0xd9, 0x07, 0x5f,
 0xca, 0xd7, 0x55, 0xf8, 0x84, 0xeb, 0x19, 0x5c, 0xaa, 0xe5, 0x76, 0xaa, 0xab, 0xaa, 0xaa, 0xf6,
 0x94, 0x6a, 0x85, 0x55, 0xea, 0x05, 0xda, 0xb7, 0x1f, 0xe5, 0x48, 0x2a, 0x8e, 0x7c, 0xeb, 0xd3,
 0x86, 0x9b, 0x8c, 0xd7, 0xb7, 0xaa, 0x89, 0x70, 0xbc, 0x3e, 0x2c, 0xd3, 0x92, 0x24, 0x5d, 0x61,
 0xc1, 0xea, 0xbc, 0xdd, 0xe8, 0x36, 0x88, 0x6f, 0x64, 0x36, 0x36, 0x1c, 0x34, 0x46, 0xb1, 0xa9,
 0xa2, 0x22, 0x76, 0x00, 0xce, 0xb5, 0xc2, 0xbd, 0xc5, 0xcb, 0x1a, 0xe0, 0x91, 0xae, 0x03, 0x1a,
 0xd7, 0x0a, 0xd7, 0x16, 0xd6, 0xb8, 0x57, 0xb8, 0x0c, 0xab, 0xdc, 0x2b, 0x5c, 0x5b, 0x5e, 0xe1,
 0x5e, 0xe0, 0x32, 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x9e, 0x57, 0xb8, 0x0b, 0xab, 0x05, 0x6b,
 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xc2, 0xba, 0x75, 0x17, 0x56, 0x0a, 0xd7, 0x01, 0x8d,
 0x6b, 0x85, 0x61, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15,
 0xae, 0x01, 0x39, 0x87, 0x41, 0x9a, 0x99, 0x7c, 0x77, 0xc6, 0x88, 0xd7, 0x3b, 0x4d, 0x51, 0x34,
 0xd3, 0x96, 0x86, 0x1f, 0x13, 0xcb, 0xf9, 0xc4, 0x6f, 0x91, 0x0c, 0xd5, 0xae, 0x15, 0x80, 0xc3,
 0xe2, 0x69, 0x7f, 0x38, 0x8d, 0xf2, 0x20, 0x78, 0x9e, 0x5f, 0xce, 0x23, 0x7c, 0x88, 0x66, 0xad,
 0x70, 0xad, 0x70, 0x30, 0xf8, 0x9e, 0x5f, 0xce, 0x23, 0x7c, 0x88, 0x1e, 0x27, 0x97, 0xf3, 0x88,
 0xdf, 0x22, 0x19, 0xab, 0x5c, 0x2b, 0x5c, 0x0c, 0x3e, 0x27, 0x97, 0xf3, 0x88, 0xdf, 0x22, 0x07,
 0x89, 0xe5, 0xfc, 0xe2, 0x37, 0xc8, 0x86, 0x64, 0x8d, 0x70, 0xad, 0x70, 0x33, 0x61, 0xd2, 0xd0,
 0xe4, 0x77, 0xe9, 0xc4, 0x7b, 0xf7, 0xf4, 0xd7, 0x7b, 0x4e, 0x1a, 0x7f, 0xf6, 0x5b, 0xad, 0x71,
 0x75, 0x6b, 0x85, 0x60, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x58,
 0x2b, 0x0b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70,
 0x18, 0xd6, 0xb8, 0x56, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x05, 0x6b, 0x8b, 0xab, 0x5c,
 0x2b, 0x00, 0xc6, 0xb5, 0xc2, 0xb0, 0xba, 0xb0, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d,
 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xac, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0x3d,
 0xac, 0x2d, 0xac, 0x15, 0xae, 0x03, 0x1a, 0xc1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d,
 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xca, 0xb0, 0x56, 0x16, 0xd6, 0xb8, 0x56, 0xb8,
 0x0c, 0x6b, 0x05, 0x61, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xba, 0x05, 0x71, 0x75, 0x6b, 0x85,
 0x60, 0x19, 0x56, 0x0a, 0xc2, 0xda, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab,
 0x05, 0x60, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x65, 0x58, 0x2b, 0x0b,
 0x6b, 0x5c, 0x2b, 0x5c, 0x06, 0x55, 0x8f, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad,
 0x73, 0xda, 0xc2, 0xda, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x05, 0x6b,
 0x80, 0xc6, 0xb5, 0xc2, 0xb0, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x58, 0x2b, 0x5c, 0x5d, 0x5a,
 0xe1, 0x58, 0x06, 0x35, 0x82, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x06, 0x79, 0x99, 0x49, 0x39,
 0x85, 0x55, 0x89, 0x05, 0xa8, 0xef, 0x7c, 0xde, 0x0a, 0x54, 0x76, 0x11, 0x2a, 0xab, 0xe4, 0xc5,
 0x8c, 0xdf, 0x8d, 0x14, 0xc9, 0x5a, 0xe1, 0x5a, 0xe0, 0x62, 0x6e, 0x11, 0x2a, 0x9c, 0xe3, 0x46,
 0x77, 0xc6, 0x88, 0x5b, 0x97, 0x94, 0x92, 0x97, 0x54, 0x56, 0x41, 0x45, 0x72, 0x76, 0xbb, 0xca,
 0x53, 0x0d, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb0, 0xba, 0xb5, 0xc2, 0xb0, 0x0c, 0x6b,
 0x5c, 0x2b, 0x5c, 0x5d, 0x58, 0x2b, 0x00, 0xc6, 0xb0, 0x56, 0x17, 0x56, 0xb8, 0x56, 0x01, 0x95,
 0x63, 0xca, 0xc2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b,
 0x5c, 0x05, 0xb5, 0xae, 0x15, 0x85, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x2a, 0xd7, 0x3c, 0xad, 0x71,
 0x75, 0x7b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb0, 0xba, 0xbd, 0xc2, 0xb5, 0xc0, 0x63, 0x5a,
 0xe1, 0x5a, 0xe2, 0xea, 0xf7, 0x0a, 0xf7, 0x01, 0x95, 0x63, 0xca, 0xd7, 0x17, 0x56, 0xb8, 0x56,
 0xb8, 0x0c, 0x6b, 0x05, 0x5b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x7b, 0x56, 0xe2,
 0xda, 0xf7, 0x0a, 0xd7, 0x01, 0x8d, 0x63, 0xda, 0xd7, 0x16, 0xd6, 0xb8, 0x57, 0xb8, 0x0c, 0x6b,
 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x73, 0xda, 0xc2, 0xda, 0xd7, 0x0a,
 0xd7, 0x01, 0x95, 0x63, 0xca, 0xd7, 0x17, 0x57, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x05, 0x6b, 0x8b,
 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xaf, 0x70, 0x18, 0xd6,
 0x3d, 0xad, 0x71, 0x6d, 0x6b, 0x85, 0x6b, 0x80, 0xca, 0xa8, 0x56, 0x16, 0xd6, 0x0a, 0xf7, 0x01,
 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0x82, 0xb5, 0xc5, 0xd5, 0xae,
 0x15, 0xae, 0x03, 0x25, 0x8c, 0x79, 0x56, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85,
 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0xdc, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xaf, 0x70,
 0x18, 0xd6, 0xb9, 0xed, 0x5b, 0x8b, 0x6b, 0x5c, 0x2b, 0x5c, 0x06, 0x55, 0x6e, 0x79, 0x5a, 0xe2,
 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x95, 0x63, 0xca, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6a,
 0xdc, 0xf5, 0x23, 0x0b, 0x6b, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xaf, 0x70,
 0xad, 0x70, 0x19, 0x2c, 0x63, 0xca, 0xc2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x9e, 0xd6,
 0x16, 0xd6, 0xb8, 0x56, 0xb8, 0x0c, 0xaa, 0x9e, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x64,
 0xb1, 0x8f, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5e, 0xe0, 0x31, 0xad, 0x70, 0xad, 0x71, 0x75, 0x7b,
 0x85, 0x7b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xee, 0x15, 0xee, 0x03, 0x1a, 0xd7, 0x0a,
 0xd7, 0x17, 0x56, 0xb8, 0x24, 0x6b, 0x80, 0xc6, 0xb5, 0xcf, 0x6a, 0xdc, 0x5b, 0x5a, 0xe1, 0x5a,
 0xe0, 0x31, 0xab, 0x70, 0xac, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0x0a, 0xd7, 0x17, 0x56,
 0xb8, 0x57, 0xb8, 0x0c, 0x6b, 0x05, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x55, 0x6e, 0x78,
 0xb1, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb9, 0xed, 0x6b, 0x8b, 0x6b, 0x5c, 0x2b,
 0x5c, 0x06, 0x55, 0x6e, 0x78, 0xb1, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0x0a, 0xd7,
 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0b, 0xab, 0x5c, 0x2b, 0x5c, 0x5b, 0x5e, 0xe1, 0x5e, 0xe0, 0x32,
 0xad, 0x70, 0xac, 0x2d, 0xad, 0x70, 0xad, 0x70, 0x19, 0x56, 0xb8, 0x56, 0x16, 0xd7, 0xb8, 0x56,
 0xb8, 0x0c, 0x96, 0x30, 0x56, 0x16, 0xd6, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0xf6, 0xb6, 0xa2,
 0xda, 0xf7, 0x0a, 0xf7, 0x01, 0x95, 0x60, 0xad, 0x71, 0x6d, 0x7b, 0x85, 0x7b, 0x80, 0xca, 0xb0,
 0x56, 0x16, 0xd7, 0xb8, 0x56, 0xb8, 0x0c, 0xab, 0x05, 0x61, 0x6d, 0x6b, 0x85, 0x6b, 0x80, 0xca,
 0xb0, 0x56, 0x16, 0xd7, 0xb8, 0x57, 0xb8, 0x0c, 0xaa, 0x85, 0x61, 0x6d, 0x7b, 0x85, 0x6b, 0x80,
 0xca, 0xa8, 0x55, 0x16, 0xd7, 0xb8, 0x57, 0xb8, 0x0c, 0xab, 0x02, 0x46, 0xb8, 0xb6, 0xbd, 0xc2,
 0xbd, 0xc0, 0x65, 0x58, 0x2a, 0x8b, 0x6b, 0xdc, 0x2b, 0x5c, 0x06, 0x55, 0x42, 0xb5, 0xc5, 0xb5,
 0xae, 0x15, 0xee, 0x03, 0x2a, 0xd7, 0x0a, 0xc2, 0xda, 0xf7, 0x0a, 0xd7, 0x01, 0x8d, 0x63, 0xd4,
 0x8d, 0x71, 0x6d, 0x6b, 0x85, 0x7b, 0x80, 0xca, 0xbd, 0xc2, 0xb0, 0xb6, 0xb5, 0xc2, 0xb5, 0xc0,
 0x65, 0x58, 0x2a, 0x8b, 0x6b, 0x5c, 0x2b, 0x5c, 0x06, 0x55, 0x42, 0xb0, 0xb6, 0xbd, 0xc2, 0xbd,
 0xc0, 0x63, 0x5a, 0xe7, 0xb5, 0x85, 0xb5, 0xee, 0x15, 0xee, 0x03, 0x25, 0x8d, 0x70, 0x48, 0xc2,
 0xda, 0xf7, 0x0a, 0xf7, 0x01, 0x92, 0xc6, 0x04, 0x8c, 0x2d, 0xaf, 0x70, 0xad, 0x70, 0x19, 0x56,
 0xb8, 0x55, 0x16, 0xd7, 0xb8, 0x57, 0xb8, 0x0c, 0xab, 0x05, 0x6b, 0x8b, 0x6b, 0xdc, 0x2b, 0x5c,
 0x06, 0x55, 0x42, 0xa8, 0xb6, 0xbd, 0xc2, 0xbd, 0xc0, 0x65, 0x54, 0x2b, 0x0b, 0x6b, 0x5c, 0x2b,
 0xdc, 0x06, 0x55, 0x82, 0xb0, 0xb6, 0xbd, 0xc2, 0xbd, 0xc0, 0x65, 0x58, 0x2b, 0x5c, 0x5b, 0x5a,
 0xe1, 0x5a, 0xe0, 0x32, 0xad, 0x70, 0xac, 0x2d, 0xaf, 0x70, 0xaf, 0x70, 0x19, 0x56, 0xb8, 0x55,
 0x16, 0xd7, 0xb8, 0x57, 0xb8, 0x0c, 0xab, 0x5c, 0x2b, 0xdc, 0x5b, 0x5e, 0xe1, 0x5a, 0xe0, 0x32,
 0xac, 0x79, 0x58, 0x5c, 0x91, 0xee, 0x7b, 0x58, 0x06, 0x35, 0x82, 0xb0, 0xb6, 0xb5, 0xc2, 0xbd,
 0xc0, 0x65, 0x5a, 0xe1, 0x58, 0x5b, 0x5e, 0xe1, 0x5e, 0xe0, 0x32, 0xaa, 0x15, 0x45, 0xb5, 0xae,
 0x15, 0xee, 0x03, 0x25, 0x8d, 0x70, 0x48, 0xc2, 0xda, 0xd7, 0x0a, 0xf7, 0x01, 0x95, 0x60, 0xad,
 0x71, 0x6d, 0x7b, 0x85, 0x7b, 0x80, 0xc6, 0xb5, 0xcf, 0x6b, 0x0b, 0x6b, 0xdc, 0x2b, 0xdc, 0x06,
 0x35, 0xae, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0x3d, 0xaa, 0x2d, 0xaf, 0x70,
 0xaf, 0x70, 0x17, 0x56, 0x0a, 0xc2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x60, 0xad, 0x71, 0x75,
 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x79, 0x5a, 0xe0, 0x32, 0xad,
 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x60, 0x18, 0xd6, 0x0a, 0xc2, 0xea, 0xd7, 0x0a, 0xd7, 0x01,
 0x8d, 0x60, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb0, 0xba, 0xb5, 0xc2,
 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b,
 0x8b, 0x96, 0x35, 0xc1, 0x23, 0x00, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03,
 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb9, 0xe2, 0xc6, 0xb8, 0x0c, 0xab, 0x5c, 0x2b, 0x5c, 0x5c,
 0xb1, 0x82, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b,
 0x85, 0x61, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae,
 0x03, 0x1a, 0xd7, 0x0a, 0xd7, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x5c, 0x5d,
 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xac, 0x7b, 0x58, 0x5b, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70,
 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xb8, 0xf3, 0x0a,
 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x35, 0xae, 0x15, 0xae,
 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63,
 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b, 0x85, 0x6b, 0x8b, 0xab, 0x05,
 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xcb, 0xd4, 0x2b,
 0x5c, 0x5c, 0xb1, 0xae, 0x79, 0x5e, 0xe0, 0x32, 0x58, 0xd7, 0x04, 0x8d, 0x71, 0x75, 0x6b, 0x9e,
 0x2c, 0x6b, 0x80, 0xca, 0xb8, 0x56, 0xb8, 0xb6, 0xbd, 0xcf, 0x52, 0x30, 0x0c, 0x6b, 0x5c, 0x2b,
 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x32, 0xac, 0x79, 0x58, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31,
 0xad, 0x70, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x60, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xb5, 0x23, 0x5c,
 0xf6, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x05, 0x8d, 0x70, 0x18, 0xd6, 0xb8,
 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7,
 0x01, 0x8d, 0x60, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5, 0xcb,
 0x1a, 0xe1, 0x5a, 0xe0, 0x31, 0xad, 0x70, 0xac, 0x2e, 0x58, 0xc0, 0x91, 0x80, 0x63, 0x5a, 0xe1,
 0x5a, 0xe2, 0xd4, 0x8d, 0x73, 0xd5, 0x8d, 0x70, 0x16, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2,
 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x60, 0xad, 0x71,
 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc9, 0x63, 0x1e, 0x56, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b,
 0x5c, 0x2b, 0x5c, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x32, 0xac, 0x15, 0x6e, 0x2d, 0xac, 0x15, 0xae,
 0x03, 0x2a, 0xc7, 0x95, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0x0a, 0xc2, 0xea, 0xd7,
 0x0a, 0xd7, 0x01, 0x8d, 0x60, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc9, 0x63, 0x1e, 0x56,
 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x65, 0x59, 0x3a, 0x9e, 0x56, 0xb8, 0xba, 0xbd, 0xc2, 0xb5,
 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xc0, 0x31, 0xac, 0x15, 0xae, 0x2e, 0xad,
 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x1e, 0xa4,
 0x61, 0x6d, 0x6b, 0x85, 0x6b, 0x80, 0xc9, 0x63, 0x5c, 0xf2, 0xb0, 0xba, 0xb5, 0xc2, 0xb5, 0xc0,
 0x63, 0x59, 0x02, 0xb0, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x65, 0x58, 0xf2, 0xb0, 0xba, 0xb5, 0xc2,
 0xb5, 0xc0, 0x63, 0x58, 0x2b, 0x0b, 0xab, 0x5c, 0x2b, 0x5c, 0x06, 0x29, 0x1a, 0xe0, 0xb1, 0xae,
 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0x0a, 0xc2, 0xea, 0xd7, 0x0a, 0xd7, 0x01, 0x8d, 0x6b,
 0x9e, 0xd6, 0x4e, 0xa2, 0xda, 0xd7, 0x0a, 0xf7, 0x01, 0x8d, 0x60, 0xac, 0x2e, 0xad, 0x70, 0xad,
 0x70, 0x18, 0xd6, 0xb8, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x58, 0x2b, 0x5c, 0x5d,
 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xac, 0x15, 0xae, 0x2e, 0xad, 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8,
 0x56, 0x17, 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x20, 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0,
 0x63, 0x5a, 0xe1, 0x58, 0x5d, 0x5a, 0xe1, 0x5a, 0xe0, 0x31, 0xac, 0x15, 0x85, 0xd5, 0xae, 0x15,
 0xae, 0x03, 0x1a, 0xd7, 0x0a, 0xc2, 0xe5, 0x8d, 0x70, 0xad, 0x70, 0x18, 0xd6, 0xb8, 0x56, 0x17,
 0x56, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x05, 0x61, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc9, 0x63, 0x1e,
 0x56, 0xb8, 0xba, 0xb5, 0xc2, 0xb5, 0xc0, 0x63, 0x5a, 0xe1, 0x5a, 0xe2, 0xea, 0xd7, 0x0a, 0xd7,
 0x01, 0x8d, 0x60, 0xad, 0x71, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb0, 0x56, 0x17, 0x56, 0xb8,
 0x56, 0xb8, 0x0c, 0x6b, 0x05, 0x61, 0x75, 0x6b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xc2, 0xb5, 0xc5,
 0xd5, 0xae, 0x15, 0xae, 0x03, 0x1a, 0xc8, 0x7b, 0x5a, 0xe2, 0xda, 0xd7, 0x0a, 0xd7, 0x01, 0x75,
 0x63, 0xca, 0xc2, 0xea, 0xf7, 0x0a, 0xf7, 0x01, 0x95, 0x53, 0xca, 0xc2, 0xea, 0xf7, 0x0a, 0xf7,
 0x01, 0x95, 0x60, 0xac, 0x2d, 0xaf, 0x70, 0xaf, 0x70, 0x19, 0x56, 0x3c, 0xad, 0x71, 0x75, 0x6b,
 0x85, 0x6b, 0x80, 0xca, 0xa8, 0x55, 0x16, 0xd7, 0xb8, 0x57, 0xb8, 0x0c, 0xaa, 0x85, 0x51, 0x6d,
 0x7b, 0x85, 0x7b, 0x80, 0xca, 0xa9, 0xe5, 0x61, 0x75, 0x7b, 0x85, 0x6b, 0x80, 0xc6, 0xb5, 0xcf,
 0x6a, 0x8b, 0x6b, 0x5c, 0x2b, 0xdc, 0x06, 0x55, 0x4f, 0x2b, 0x0b, 0xab, 0xdc, 0x2b, 0xdc, 0x06,
 0x35, 0xae, 0x15, 0x85, 0xd5, 0xee, 0x15, 0xee, 0x03, 0x2a, 0xa7, 0x95, 0xae, 0x2e, 0xaf, 0x70,
 0xaf, 0x70, 0x19, 0x56, 0x0a, 0xd7, 0x16, 0xd7, 0xb8, 0x57, 0xb8, 0x0c, 0x6b, 0x5c, 0x2b, 0x0b,
 0xab, 0xdc, 0x2b, 0xdc, 0x06, 0x55, 0x42, 0xa8, 0xb6, 0xbd, 0xc2, 0xbd, 0xc0, 0x65, 0x54, 0x2a,
 0x8b, 0x6b, 0xdc, 0x2b, 0xdc, 0x06, 0x55, 0x82, 0xa8, 0xb6, 0xbd, 0xc2, 0xbd, 0xc0, 0x65, 0x5e,
 0xe7, 0x95, 0xae, 0x2e, 0xaf, 0x70, 0xad, 0x70, 0x19, 0x55, 0x0a, 0xa2, 0xda, 0xf7, 0x0a, 0xf7,
 0x01, 0x95, 0x50, 0xaa, 0x2d, 0xaf, 0x70, 0xaf, 0x70, 0x18, 0xd6, 0x3d, 0xac, 0x2d, 0xaf, 0x70,
 0xaf, 0x70, 0x19, 0x2c, 0x6b, 0x85, 0x61, 0x6d, 0x7b, 0x85, 0x7b, 0x80, 0xca, 0xb0, 0x56, 0x16,
 0xd7, 0xb8, 0x56, 0xb8, 0x0c, 0x6b, 0x05, 0x61, 0x75, 0x7b, 0x85, 0x6b, 0x80, 0xc6, 0xb1, 0xed,
 0x51, 0x6d, 0x7b, 0x85, 0x7b, 0x80, 0xca, 0xa8, 0x55, 0x16, 0xd7, 0xb8, 0x56, 0xb8, 0x0c, 0xab,
 0x1e, 0x56, 0xb8, 0xba, 0xbd, 0xc2, 0xbd, 0xc0, 0x65, 0x54, 0x2a, 0x8b, 0x6b, 0xdc, 0x2b, 0xdc,
 0x06, 0x35, 0x8f, 0x6a, 0x8b, 0x6b, 0xdc, 0x2b, 0xdc, 0x06, 0x35, 0xae, 0x15, 0xae, 0x2e, 0xaf,
 0x70, 0xaf, 0x70, 0x19, 0x55, 0x3c, 0xac, 0x2e, 0xaf, 0x70, 0xaf, 0x70, 0x19, 0x56, 0x3c, 0xac,
 0x2e, 0xaf, 0x70, 0xaf, 0x70, 0x19, 0x56, 0x0a, 0xc2, 0xda, 0xf7, 0x0a, 0xf7, 0x01, 0x8d, 0x6b,
 0x85, 0x6b, 0x8b, 0xab, 0xdc, 0x2b, 0xdc, 0x06, 0x35, 0xae, 0x7b, 0x54, 0x5b, 0x5e, 0xe1, 0x5e,
 0xe0, 0x32, 0xaa, 0x79, 0x58, 0x5d, 0x5e, 0xe1, 0x5e, 0xe0, 0x32, 0x58, 0xc7, 0x95, 0xae, 0x2e,
 0xaf, 0x70, 0xaf, 0x70, 0x18, 0xd6, 0x3d, 0xac, 0xbd, 0x45, 0xa9, 0x1a, 0xe1, 0x5a, 0xe0, 0x31,
 0xac, 0x7b, 0x58, 0x5b, 0x5a, 0xe1, 0x5e, 0xe0, 0x32, 0xad, 0x70, 0x58, 0xd7, 0x16, 0xd7, 0xb8,
 0x57, 0xb8, 0x0c, 0xaa, 0x85, 0x51, 0x6d, 0x7b, 0x85, 0x7b, 0x81, 0x47, 0x79, 0xdd, 0x43, 0x79,
 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde, 0x77, 0x52, 0x20, 0x04, 0xb7, 0x9d, 0xd4, 0x37,
 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d, 0xe7, 0x75, 0x22, 0x00, 0x4b, 0x79, 0xdd, 0x43,
 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde, 0x77, 0x52, 0x20, 0x04, 0xb7, 0x9d, 0xd4,
 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d, 0xe7, 0x75, 0x22, 0x00, 0x4b, 0x79, 0xdd,
 0x43, 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde, 0x77, 0x52, 0x20, 0x04, 0xb7, 0x9d,
 0xd4, 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d, 0xe7, 0x75, 0x22, 0x00, 0x4b, 0x79,
 0xdd, 0x43, 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde, 0x77, 0x52, 0x20, 0x04, 0xb7,
 0x9d, 0xd4, 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d, 0xe7, 0x75, 0x22, 0x00, 0x4b,
 0x79, 0xdd, 0x43, 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde, 0x77, 0x52, 0x20, 0x04,
 0xb7, 0x9d, 0xd4, 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d, 0xe7, 0x75, 0x22, 0x00,
 0x4b, 0x79, 0xdd, 0x43, 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde, 0x77, 0x52, 0x20,
 0x04, 0xb7, 0x9d, 0xd4, 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d, 0xe7, 0x75, 0x22,
 0x00, 0x4b, 0x79, 0xdd, 0x43, 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde, 0x77, 0x52,
 0x20, 0x04, 0xb7, 0x9d, 0xd4, 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d, 0xe7, 0x75,
 0x22, 0x00, 0x4b, 0x79, 0xdd, 0x43, 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde, 0x77,
 0x52, 0x20, 0x04, 0xb7, 0x9d, 0xd4, 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d, 0xe7,
 0x75, 0x22, 0x00, 0x4b, 0x79, 0xdd, 0x43, 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50, 0xde,
 0x77, 0x52, 0x20, 0x04, 0xb7, 0x9d, 0xd4, 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75, 0x0d,
 0xe7, 0x75, 0x22, 0x00, 0x4b, 0x79, 0xdd, 0x43, 0x79, 0xdd, 0x48, 0x80, 0x12, 0xde, 0x77, 0x50,
 0xde, 0x77, 0x52, 0x20, 0x04, 0xb7, 0x9d, 0xd4, 0x37, 0x9d, 0xd4, 0x88, 0x01, 0x2d, 0xe7, 0x75,
 0x0d, 0xe7, 0x75, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0xf1,
 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf7, 0x4e, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x74, 0xe3, 0x1c,
 0xa3, 0xba, 0x79, 0xd7, 0xba, 0xa0, 0x16, 0xfc, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0xd3, 0x83, 0xc5,
 0xd3, 0xfe, 0x63, 0x33, 0xdd, 0x38, 0x72, 0x8e, 0xe7, 0x3a, 0xf7, 0x54, 0x02, 0xdf, 0x8b, 0xa7,
 0xfc, 0xc6, 0x67, 0xba, 0x70, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0xa7, 0x0e, 0x51, 0xdc, 0xe7,
 0x5e, 0xea, 0x80, 0x5b, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf7, 0x4e, 0x0f, 0x17, 0x4f, 0xf9,
 0x8c, 0xcf, 0x74, 0xe1, 0xca, 0x3b, 0x9c, 0xeb, 0xdd, 0x50, 0x0b, 0x7e, 0x2e, 0x9f, 0xf3, 0x19,
 0x9e, 0xe9, 0xc1, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xee, 0x9c, 0x39, 0x47, 0x73, 0x9d, 0x7b,
 0xaa, 0x01, 0x6f, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xdd, 0x38, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d,
 0xd3, 0x87, 0x28, 0xee, 0x73, 0xaf, 0x75, 0x40, 0x2d, 0xf8, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0xa7,
 0x07, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xba, 0x70, 0xe5, 0x1d, 0xce, 0x75, 0xee, 0xa8, 0x05, 0xbf,
 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x74, 0xe0, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf7, 0x4e, 0x1c,
 0xa3, 0xb9, 0xce, 0xbd, 0xd5, 0x00, 0xb7, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xee, 0x9c, 0x1e,
 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xe9, 0xc3, 0x94, 0x77, 0x39, 0xd7, 0xba, 0xa0, 0x16, 0xfc, 0x5d,
 0x3f, 0xe6, 0x33, 0x3d, 0xd3, 0x83, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xdd, 0x38, 0x72, 0x8e, 0xe7,
 0x3a, 0xf7, 0x54, 0x02, 0xdf, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xba, 0x70, 0x78, 0xba, 0x7f, 0xcc,
 0x66, 0x7b, 0xa7, 0x0e, 0x51, 0xdc, 0xe7, 0x5e, 0xea, 0x80, 0x5b, 0xf1, 0x74, 0xff, 0x00, 0x98,
 0xcc, 0xf7, 0x4e, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x74, 0xe1, 0xca, 0x3b, 0x9c, 0xeb, 0xdd,
 0x50, 0x0b, 0x7e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xe9, 0xc1, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99,
 0xee, 0x9c, 0x39, 0x47, 0x73, 0x9d, 0x7b, 0xaa, 0x01, 0x6f, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xdd,
 0x38, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0xd3, 0x87, 0x28, 0xee, 0x73, 0xaf, 0x75, 0x40, 0x2d,
 0xf8, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0xa7, 0x07, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xba, 0x70, 0xe5,
 0x1d, 0xce, 0x75, 0xee, 0xa8, 0x05, 0xbf, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x74, 0xe0, 0xf1, 0x74,
 0xff, 0x00, 0x98, 0xcc, 0xf7, 0x4e, 0x1c, 0xa3, 0xb9, 0xce, 0xbd, 0xd5, 0x00, 0xb7, 0xe2, 0xe9,
 0xff, 0x00, 0x31, 0x99, 0xee, 0x9c, 0x1e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xe9, 0xc3, 0x94, 0x77,
 0x39, 0xd7, 0xba, 0xa0, 0x16, 0xfc, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0xd3, 0x83, 0xc5, 0xd3, 0xfe,
 0x63, 0x33, 0xdd, 0x38, 0x72, 0x8e, 0xe7, 0x3a, 0xf7, 0x54, 0x02, 0xdf, 0x8b, 0xa7, 0xfc, 0xc6,
 0x67, 0xba, 0x70, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0xa7, 0x0e, 0x51, 0xdc, 0xe7, 0x5e, 0xea,
 0x80, 0x5b, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf7, 0x4e, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf,
 0x74, 0xe1, 0xca, 0x3b, 0x9c, 0xeb, 0xdd, 0x50, 0x0b, 0x7e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xe9,
 0xc1, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xee, 0x9c, 0x39, 0x47, 0x73, 0x9d, 0x7b, 0xaa, 0x01,
 0x6f, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xdd, 0x38, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0xd3, 0x87,
 0x28, 0xee, 0x73, 0xaf, 0x75, 0x40, 0x2d, 0xf8, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0xa7, 0x07, 0x8b,
 0xa7, 0xfc, 0xc6, 0x67, 0xba, 0x70, 0xe5, 0x1d, 0xce, 0x75, 0xee, 0xa8, 0x05, 0xbf, 0x17, 0x4f,
 0xf9, 0x8c, 0xcf, 0x74, 0xe0, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf7, 0x4e, 0x1c, 0xa3, 0xb9,
 0xce, 0xbd, 0xd5, 0x00, 0xb7, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xee, 0x9c, 0x1e, 0x2e, 0x9f,
 0xf3, 0x19, 0x9e, 0xe9, 0xc3, 0x94, 0x77, 0x39, 0xd7, 0xba, 0xa0, 0x16, 0xfc, 0x5d, 0x3f, 0xe6,
 0x33, 0x3d, 0xd3, 0x83, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xdd, 0x38, 0x72, 0x8e, 0xe7, 0x3a, 0xf7,
 0x54, 0x02, 0xdf, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xba, 0x70, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b,
 0xa7, 0x0e, 0x51, 0xdc, 0xe7, 0x5e, 0xea, 0x80, 0x5b, 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf7,
 0x4e, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x74, 0xe1, 0xca, 0x3b, 0x9c, 0xeb, 0xdd, 0x50, 0x0b,
 0x7e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xe9, 0xc1, 0xe2, 0xe9, 0xff, 0x00, 0x31, 0x99, 0xee, 0x9c,
 0x39, 0x47, 0x73, 0x9d, 0x7b, 0xaa, 0x01, 0x6f, 0xc5, 0xd3, 0xfe, 0x63, 0x33, 0xdd, 0x38, 0x3c,
 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0xd3, 0x87, 0x28, 0xee, 0x73, 0xaf, 0x75, 0x40, 0x2d, 0xf8, 0xba,
 0x7f, 0xcc, 0x66, 0x7b, 0xa7, 0x07, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xba, 0x70, 0xe5, 0x1d, 0xce,
 0x75, 0xee, 0xa8, 0x05, 0xbf, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x74, 0xe0, 0xf1, 0x74, 0xff, 0x00,
 0x98, 0xcc, 0xf7, 0x4e, 0x1c, 0xa3, 0xb9, 0xce, 0xbd, 0xd5, 0x00, 0xb7, 0xe2, 0xe9, 0xff, 0x00,
 0x31, 0x99, 0xee, 0x9c, 0x1e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xe9, 0xc3, 0x94, 0x77, 0x39, 0xd7,
 0xba, 0xa0, 0x16, 0xfc, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0xd3, 0x83, 0xc5, 0xd3, 0xfe, 0x63, 0x33,
 0xdd, 0x38, 0x72, 0x8e, 0xe7, 0x3a, 0xf7, 0x54, 0x02, 0xdf, 0x8b, 0xa7, 0xfc, 0xc6, 0x67, 0xba,
 0x70, 0x78, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0xa7, 0x0e, 0x51, 0xdc, 0xe7, 0x5e, 0xea, 0x80, 0x5b,
 0xf1, 0x74, 0xff, 0x00, 0x98, 0xcc, 0xf7, 0x4e, 0x0f, 0x17, 0x4f, 0xf9, 0x8c, 0xcf, 0x74, 0xe1,
 0xca, 0x3b, 0x9c, 0xeb, 0xdd, 0x50, 0x0b, 0x7e, 0x2e, 0x9f, 0xf3, 0x19, 0x9e, 0xe9, 0xc1, 0xe2,
 0xe9, 0xff, 0x00, 0x31, 0x99, 0xee, 0x9c, 0x39, 0x47, 0x73, 0x9d, 0x7b, 0xaa, 0x01, 0x6f, 0xc5,
 0xd3, 0xfe, 0x63, 0x33, 0xdd, 0x38, 0x3c, 0x5d, 0x3f, 0xe6, 0x33, 0x3d, 0xd3, 0x87, 0x28, 0xee,
 0x73, 0xaf, 0x75, 0x40, 0x2d, 0xf8, 0xba, 0x7f, 0xcc, 0x66, 0x7b, 0xa7, 0x07, 0x8b, 0xa7, 0xfc,
 0xc6, 0x67, 0xba, 0x70, 0xe5, 0x1d, 0xce, 0x75, 0xee, 0xa8, 0x05, 0xbf, 0x17, 0x4f, 0xf9, 0x8c,
 0xd7, 0x74, 0xef, 0x51, 0xef, 0x8b, 0x31, 0x0f, 0x30, 0x9a, 0xee, 0x9c, 0x39, 0x57, 0xb9, 0xce,
 0xbd, 0xdf, 0xff, 0xd9};
static const unsigned char PIC_960x720_2[] = { 
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xe1, 0x00, 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d,
 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x17,
 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x54, 0x68, 0x65,
 0x20, 0x47, 0x49, 0x4d, 0x50, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x05, 0x03, 0x04, 0x04, 0x04, 0x03,
 0x05, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0c, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0f,
 0x0b, 0x0b, 0x09, 0x0c, 0x11, 0x0f, 0x12, 0x12, 0x11, 0x0f, 0x11, 0x11, 0x13, 0x16, 0x1c, 0x17,
 0x13, 0x14, 0x1a, 0x15, 0x11, 0x11, 0x18, 0x21, 0x18, 0x1a, 0x1d, 0x1d, 0x1f, 0x1f, 0x1f, 0x13,
 0x17, 0x22, 0x24, 0x22, 0x1e, 0x24, 0x1c, 0x1e, 0x1f, 0x1e, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x05,
 0x05, 0x05, 0x07, 0x06, 0x07, 0x0e, 0x08, 0x08, 0x0e, 0x1e, 0x14, 0x11, 0x14, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0xff,
 0xc0, 0x00, 0x11, 0x08, 0x02, 0xd0, 0x03, 0xc0, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03,
 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1d, 0x00, 0x01, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x01, 0x02, 0x05, 0x06, 0x07, 0x08,
 0x09, 0xff, 0xc4, 0x00, 0x62, 0x10, 0x00, 0x02, 0x01, 0x02, 0x03, 0x04, 0x03, 0x05, 0x10, 0x0c,
 0x0a, 0x07, 0x06, 0x07, 0x01, 0x00, 0x00, 0x01, 0x02, 0x03, 0x13, 0x04, 0x05, 0x61, 0x06, 0x07,
 0x11, 0x12, 0x21, 0x31, 0xd1, 0x15, 0x41, 0x51, 0x55, 0x93, 0x08, 0x14, 0x17, 0x22, 0x25, 0x71,
 0x81, 0x91, 0x94, 0xa1, 0xb1, 0xb2, 0xb3, 0xc1, 0xd2, 0xd3, 0x16, 0x23, 0x32, 0x42, 0x45, 0x52,
 0x56, 0x65, 0x74, 0x92, 0xa5, 0xe1, 0x44, 0x53, 0x54, 0x62, 0x64, 0x72, 0x73, 0xa3, 0xa4, 0xc2,
 0x18, 0x33, 0x43, 0x46, 0x83, 0xa2, 0xc3, 0x09, 0x24, 0x26, 0x82, 0x84, 0xf0, 0x34, 0x35, 0x36,
 0x63, 0x75, 0x85, 0x95, 0xe2, 0xff, 0xc4, 0x00, 0x1c, 0x01, 0x01, 0x00, 0x02, 0x03, 0x01, 0x01,
 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x06,
 0x05, 0x07, 0x08, 0xff, 0xc4, 0x00, 0x3f, 0x11, 0x01, 0x00, 0x02, 0x02, 0x01, 0x02, 0x02, 0x07,
 0x05, 0x07, 0x02, 0x04, 0x06, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x13, 0x52,
 0x05, 0x91, 0x12, 0x14, 0x21, 0x31, 0x41, 0x51, 0x71, 0x06, 0x33, 0x53, 0x61, 0xb1, 0x15, 0x22,
 0x32, 0x42, 0x81, 0xa1, 0xd1, 0xc1, 0xf0, 0x16, 0x23, 0x43, 0xe1, 0x24, 0x34, 0x35, 0x62, 0x72,
 0xb2, 0x82, 0x92, 0xf1, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00,
 0x3f, 0x00, 0xf3, 0xe6, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x71, 0x3e, 0x8b, 0xb7, 0xcc, 0xf6, 0x85,
 0xc4, 0xd5, 0xc4, 0x99, 0xa3, 0x0d, 0x13, 0xb4, 0xed, 0x0b, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb8,
 0x93, 0xb5, 0xb6, 0x89, 0xa3, 0x56, 0x89, 0x5a, 0x30, 0xe2, 0x5b, 0x69, 0xda, 0x17, 0x13, 0x57,
 0x12, 0x66, 0x8c, 0x34, 0x4e, 0xd3, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x89, 0x3b, 0x5a,
 0x25, 0x13, 0x46, 0xad, 0x12, 0xb4, 0x61, 0xa2, 0xdb, 0x4e, 0xd0, 0xb4, 0x6a, 0xe2, 0x4c, 0xd1,
 0xab, 0x44, 0xed, 0x6d, 0xa2, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5c, 0x49, 0xda, 0x62, 0x50, 0xb8,
 0x98, 0x68, 0x95, 0xc4, 0xc3, 0x45, 0xb6, 0xb6, 0xd0, 0xb4, 0x6a, 0xe2, 0x4c, 0xd1, 0xab, 0x44,
 0xed, 0x3b, 0x44, 0xe2, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x13, 0xb4, 0xed, 0x0b, 0x89, 0x86, 0x89,
 0x5c, 0x4c, 0x34, 0x5b, 0x6b, 0x6d, 0x0b, 0x46, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x3b, 0x4e, 0xd1,
 0x38, 0x9a, 0xb4, 0x4c, 0xe2, 0x6a, 0xd1, 0x3b, 0x5b, 0x68, 0x5a, 0x30, 0xd1, 0x2b, 0x89, 0x87,
 0x12, 0xdb, 0x4e, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x13, 0xb4, 0xc4, 0xa2, 0x68, 0xd5,
 0xc4, 0x95, 0xa3, 0x0e, 0x24, 0xed, 0x68, 0x94, 0x2d, 0x18, 0x68, 0x95, 0xa3, 0x57, 0x12, 0xdb,
 0x4e, 0xd1, 0x34, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x13, 0xb5, 0xb6, 0x89, 0xa3, 0x57, 0x12, 0x66,
 0x8d, 0x5c, 0x49, 0xda, 0x62, 0x50, 0xb8, 0x9a, 0xb4, 0x4c, 0xe2, 0x61, 0xc4, 0xb6, 0xd3, 0xb4,
 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a, 0xd1, 0x3b, 0x5b, 0x68, 0x9c, 0x4d, 0x5a, 0x25, 0x68, 0xc3,
 0x44, 0xed, 0x3b, 0x42, 0xd1, 0x82, 0x57, 0x13, 0x0d, 0x16, 0xda, 0x76, 0x8c, 0x1b, 0x38, 0x98,
 0x68, 0x94, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd6, 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8e, 0x6f,
 0x6e, 0x67, 0x68, 0x5a, 0x30, 0xe2, 0x4a, 0xd1, 0x87, 0x12, 0x76, 0xb6, 0xd0, 0xb4, 0x6a, 0xe2,
 0x4c, 0xd1, 0xab, 0x89, 0x3b, 0x4e, 0xd1, 0x34, 0x6a, 0xe2, 0x4a, 0xd1, 0x86, 0x89, 0xda, 0xdb,
 0x42, 0xd1, 0xab, 0x44, 0xcd, 0x18, 0x71, 0x2d, 0xb4, 0xed, 0x0b, 0x46, 0xad, 0x13, 0x38, 0x9a,
 0xb4, 0x4e, 0xd3, 0xb4, 0x4d, 0x1a, 0xb8, 0x92, 0xb4, 0x61, 0xa2, 0x76, 0xb4, 0x4a, 0x17, 0x13,
 0x57, 0x12, 0x66, 0x8c, 0x38, 0x96, 0xda, 0x76, 0x85, 0xc4, 0xd5, 0xa2, 0x67, 0x13, 0x56, 0x89,
 0xda, 0xdb, 0x44, 0xd1, 0xab, 0x44, 0xad, 0x18, 0x68, 0x9d, 0xa7, 0x68, 0x5c, 0x4d, 0x5a, 0x26,
 0xe0, 0x61, 0xa2, 0xdb, 0x4c, 0x4a, 0x16, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x68, 0x9d, 0xad, 0xb4,
 0x2d, 0x18, 0x68, 0x95, 0xa3, 0x0d, 0x13, 0xb4, 0xed, 0x0b, 0x89, 0xab, 0x89, 0x33, 0x46, 0xad,
 0x16, 0xda, 0xdb, 0x44, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb8, 0x93, 0xb4, 0xed, 0x0b, 0x46, 0x1a,
 0x25, 0x71, 0x30, 0xd1, 0x3b, 0x5b, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa2, 0xdb, 0x4e,
 0xd0, 0xb4, 0x61, 0xa2, 0x66, 0xb4, 0x35, 0x71, 0x27, 0x69, 0xda, 0x16, 0x8c, 0x34, 0x4a, 0xe2,
 0x61, 0xa2, 0x76, 0xb6, 0xd0, 0xb4, 0x6a, 0xe2, 0x4c, 0xd1, 0xab, 0x45, 0xb6, 0x9d, 0xa2, 0x71,
 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa2, 0x76, 0xb6, 0xd0, 0xb4, 0x61, 0xa2, 0x57, 0x13, 0x56, 0x8b,
 0x6d, 0x3b, 0x44, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4e, 0xd6, 0xda, 0x27, 0x13, 0x57, 0x12,
 0x56, 0x8c, 0x34, 0x4e, 0xd3, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a, 0xe2, 0x4e, 0xd3, 0xb4,
 0x4d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xd1, 0x6d, 0xad, 0xb4, 0x2d, 0x18, 0x68, 0x99, 0xa3, 0x57,
 0x12, 0x76, 0x9d, 0xa2, 0x06, 0xed, 0x18, 0xe0, 0x4a, 0x5a, 0x83, 0x3c, 0x0c, 0x12, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x89, 0xc4, 0xd5,
 0xc4, 0xb1, 0x28, 0x1a, 0x38, 0x9c, 0xbc, 0x4b, 0x96, 0x89, 0x40, 0xd1, 0x8e, 0x04, 0xad, 0x18,
 0x71, 0x2d, 0xb4, 0xed, 0x0b, 0x46, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x3b, 0x5b, 0x68, 0x9a, 0x35,
 0x71, 0x26, 0x68, 0xd5, 0xa2, 0x76, 0x9d, 0xa1, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x0d, 0x16, 0xda,
 0xd1, 0x28, 0x5a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x76, 0x9d, 0xa2, 0x68, 0xd5, 0xa2, 0x66,
 0x8d, 0x5a, 0x27, 0x69, 0xda, 0x17, 0x13, 0x0d, 0x12, 0xb8, 0x9a, 0xb4, 0x5b, 0x6b, 0x6d, 0x13,
 0x46, 0xad, 0x13, 0x38, 0x9a, 0xb4, 0x4e, 0xd3, 0xb4, 0x4e, 0x26, 0xad, 0x12, 0xb4, 0x61, 0xa2,
 0x76, 0xb6, 0xd0, 0xb4, 0x61, 0xa2, 0x57, 0x13, 0x57, 0x12, 0x76, 0x9d, 0xa2, 0x68, 0xd5, 0xa2,
 0x66, 0x8d, 0x5c, 0x4b, 0x6d, 0x6d, 0xa2, 0x68, 0xd5, 0xc4, 0x95, 0xa3, 0x0d, 0x13, 0x12, 0x9d,
 0xa1, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5c, 0x4b, 0x6d, 0x3b, 0x44, 0xd1, 0xab, 0x44, 0xcd, 0x1a,
 0xb4, 0x4e, 0xd6, 0xda, 0x26, 0x8d, 0x5c, 0x49, 0x5a, 0x30, 0xe2, 0x4e, 0xd3, 0xb4, 0x2d, 0x1a,
 0xb4, 0x4c, 0xd1, 0xab, 0x45, 0xb6, 0xb6, 0xd1, 0x34, 0x6a, 0xe2, 0x4c, 0xe2, 0x6a, 0xd1, 0x3b,
 0x4e, 0xd1, 0x34, 0x6a, 0xe2, 0x4a, 0xd1, 0x86, 0x89, 0xda, 0x76, 0x85, 0xc4, 0xd5, 0xa2, 0x67,
 0x13, 0x56, 0x8b, 0x6d, 0x68, 0x94, 0x4e, 0x26, 0xad, 0x13, 0x38, 0x9a, 0xb4, 0x4e, 0xd3, 0xb4,
 0x2d, 0x18, 0x68, 0x95, 0xa3, 0x0d, 0x13, 0xb5, 0xa2, 0x50, 0xb8, 0x9a, 0xb4, 0x4c, 0xd1, 0xab,
 0x45, 0xb6, 0x9d, 0xa2, 0x68, 0xd5, 0xc4, 0x99, 0xc4, 0xd5, 0xc4, 0x9d, 0xad, 0xb4, 0x2d, 0x18,
 0x68, 0x95, 0xa3, 0x57, 0x12, 0x76, 0x9d, 0xa2, 0x68, 0xd5, 0xc4, 0x99, 0xa3, 0x56, 0x8b, 0x6d,
 0x3b, 0x42, 0xd1, 0x86, 0x89, 0x9a, 0x35, 0x68, 0x9d, 0xad, 0xb4, 0x2d, 0x18, 0x71, 0x25, 0x71,
 0x35, 0x68, 0x9d, 0xa7, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0xdb, 0x4e, 0xd1, 0x70,
 0x66, 0x09, 0x1c, 0x4c, 0x38, 0x93, 0xb5, 0xb6, 0xd0, 0x19, 0xe0, 0x60, 0x90, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xee, 0x52, 0xa7, 0xa1, 0x1c, 0xa9, 0x97, 0xa5, 0x02,
 0x39, 0x53, 0x39, 0x08, 0xb3, 0x8e, 0x8b, 0x28, 0xca, 0x99, 0x1b, 0x81, 0x76, 0x54, 0xf4, 0x23,
 0x95, 0x3d, 0x0b, 0xc5, 0x99, 0x22, 0xca, 0x6e, 0x26, 0xae, 0x25, 0xa9, 0x40, 0x8e, 0x50, 0x2f,
 0x16, 0x5e, 0x2c, 0x81, 0xc4, 0xd5, 0xa2, 0x67, 0x13, 0x56, 0x8b, 0x6d, 0x68, 0x94, 0x2d, 0x18,
 0x71, 0x25, 0x71, 0x30, 0xe2, 0x4e, 0xd3, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x45, 0xb6,
 0xb6, 0xd1, 0x34, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x13, 0xb4, 0xed, 0x0b, 0x46, 0x1a, 0x25, 0x68,
 0xc3, 0x89, 0x3b, 0x5b, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x71, 0x35, 0x71, 0x2d, 0xb4, 0xed, 0x0b,
 0x46, 0x1c, 0x49, 0x9a, 0x35, 0x71, 0x27, 0x69, 0x89, 0x42, 0xd1, 0x86, 0x89, 0x5a, 0x30, 0xe2,
 0x4e, 0xd6, 0xda, 0x16, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x71, 0x2d, 0xb4, 0xc4, 0xa2, 0x68, 0xd5,
 0xc4, 0x99, 0xa3, 0x57, 0x12, 0x76, 0x9d, 0xa1, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x27, 0x6b,
 0x6d, 0x13, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x5b, 0x69, 0xda, 0x17, 0x13, 0x0d, 0x13, 0x38,
 0x9a, 0xb4, 0x4e, 0xd6, 0x89, 0x42, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xad, 0x13, 0xb4, 0xed, 0x13,
 0x46, 0xad, 0x13, 0x38, 0x9a, 0xb4, 0x5b, 0x6b, 0x6d, 0x0b, 0x89, 0x86, 0x89, 0x5a, 0x30, 0xd1,
 0x3b, 0x4e, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x89, 0x3b, 0x4e, 0xd1, 0x34, 0x6a, 0xd1,
 0x2b, 0x46, 0x1a, 0x2d, 0xb5, 0xb6, 0x85, 0xc4, 0xc3, 0x89, 0x2b, 0x46, 0x1a, 0x26, 0x25, 0x31,
 0x28, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0x62, 0x56, 0xda, 0x26, 0x8d, 0x5a, 0x26, 0x71,
 0x35, 0x68, 0xb6, 0xd3, 0xb4, 0x2d, 0x18, 0x71, 0x25, 0x68, 0xc3, 0x89, 0x3b, 0x4e, 0xd0, 0xb4,
 0x6a, 0xd1, 0x33, 0x46, 0xae, 0x24, 0xed, 0x6d, 0xa2, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x56, 0x8b,
 0x6d, 0x3b, 0x42, 0xe2, 0x61, 0xa2, 0x56, 0x8c, 0x34, 0x4e, 0xd6, 0xda, 0x17, 0x13, 0x56, 0x89,
 0x9c, 0x4d, 0x5a, 0x27, 0x69, 0xda, 0x27, 0x13, 0x56, 0x89, 0x5c, 0x4c, 0x34, 0x5b, 0x69, 0xda,
 0x16, 0x8c, 0x34, 0x4a, 0xe2, 0x61, 0xa2, 0x76, 0xb6, 0xd0, 0xb4, 0x63, 0x83, 0x25, 0x71, 0x35,
 0x68, 0x9d, 0xa7, 0x68, 0xc1, 0xb3, 0x46, 0x1a, 0x27, 0x69, 0x60, 0x00, 0x48, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0xfa, 0x1a, 0x50, 0x23, 0x95, 0x32, 0xf4, 0xa9, 0x91, 0xca, 0x99, 0xc4, 0x45, 0x9c, 0x34,
 0x59, 0x42, 0x54, 0xf4, 0x23, 0x95, 0x32, 0xf4, 0xa9, 0x91, 0xca, 0x9e, 0x86, 0x48, 0xb3, 0x24,
 0x59, 0x46, 0x54, 0xc8, 0xe5, 0x02, 0xf4, 0xa9, 0x91, 0xca, 0x05, 0xe2, 0xcb, 0xc5, 0x94, 0x65,
 0x4c, 0x8e, 0x50, 0x2f, 0x4a, 0x99, 0x1c, 0xa9, 0x97, 0x8b, 0x2f, 0x16, 0x51, 0x70, 0x35, 0x68,
 0xb9, 0x2a, 0x64, 0x52, 0xa6, 0x5e, 0x2c, 0xc9, 0x16, 0x56, 0x71, 0x35, 0x68, 0xb0, 0xe0, 0x68,
 0xe2, 0x5a, 0x25, 0x68, 0x94, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x89, 0x6d, 0xad, 0xb4, 0x2d,
 0x18, 0x68, 0x95, 0xa3, 0x0d, 0x13, 0xb4, 0xed, 0x0b, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x5b,
 0x69, 0xda, 0x26, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x71, 0x27, 0x6b, 0x44, 0xa1, 0x68, 0xc3, 0x44,
 0xad, 0x18, 0x68, 0x9d, 0xa7, 0x68, 0x5c, 0x4d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0xb6, 0xd6, 0xda,
 0x27, 0x13, 0x56, 0x89, 0x9a, 0x35, 0x68, 0x9d, 0xa7, 0x68, 0x5a, 0x30, 0xd1, 0x2b, 0x89, 0xab,
 0x44, 0xed, 0x3b, 0x44, 0xe2, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x13, 0xb5, 0xb6, 0x85, 0xc4, 0xc3,
 0x44, 0xce, 0x26, 0xad, 0x16, 0xda, 0x76, 0x85, 0xa3, 0x0d, 0x12, 0xb4, 0x6a, 0xd1, 0x31, 0x2b,
 0x44, 0xa2, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x89, 0xda, 0x76, 0x85, 0xa3, 0x0d, 0x13, 0x38,
 0x9a, 0xb8, 0x96, 0xda, 0xdb, 0x42, 0xd1, 0x86, 0x89, 0x5a, 0x35, 0x68, 0x9d, 0xa7, 0x68, 0x9c,
 0x4d, 0x5c, 0x49, 0x9a, 0x35, 0xe0, 0x4e, 0xd3, 0xb4, 0x2d, 0x18, 0xe0, 0x4c, 0xd1, 0xab, 0x89,
 0x6d, 0xad, 0x12, 0x85, 0xa3, 0x56, 0x89, 0x9a, 0x35, 0x68, 0x9d, 0xa6, 0x25, 0x13, 0x46, 0xae,
 0x24, 0xcd, 0x1a, 0xb4, 0x4e, 0xd6, 0xda, 0x17, 0x13, 0x56, 0x89, 0x9a, 0x30, 0xe2, 0x5b, 0x69,
 0xda, 0x16, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x68, 0x9d, 0xad, 0xb4, 0x4e, 0x26, 0xad, 0x13, 0x34,
 0x6a, 0xd1, 0x6d, 0xa7, 0x68, 0x5c, 0x4d, 0x5c, 0x49, 0x9a, 0x30, 0xd1, 0x3b, 0x4e, 0xd0, 0xb4,
 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x89, 0x3b, 0x5b, 0x68, 0x9c, 0x4d, 0x5a, 0x25, 0x68, 0xc7, 0x02,
 0xdb, 0x4e, 0xd0, 0xb8, 0x98, 0x71, 0x25, 0x68, 0xc3, 0x89, 0x3b, 0x5b, 0x68, 0x5a, 0x35, 0x68,
 0x99, 0xa3, 0x57, 0x12, 0x76, 0x9d, 0xa1, 0x68, 0xc3, 0x89, 0x2f, 0x03, 0x0d, 0x16, 0xda, 0x76,
 0x85, 0xa3, 0x1c, 0xbe, 0x02, 0x56, 0x8c, 0x38, 0x93, 0x12, 0xb6, 0xd0, 0xf0, 0x04, 0x8e, 0x26,
 0xae, 0x24, 0xed, 0x3b, 0x6a, 0x0c, 0xb4, 0xcc, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x9a, 0x95, 0x32, 0x29, 0x53, 0x2f,
 0xca, 0x99, 0x14, 0xa9, 0x9c, 0x04, 0x59, 0xf3, 0xe8, 0xba, 0x8c, 0xa0, 0x47, 0x2a, 0x65, 0xe9,
 0x40, 0x8e, 0x50, 0x2f, 0x16, 0x5e, 0x2c, 0xa3, 0x28, 0x68, 0x47, 0x28, 0x17, 0xa5, 0x4c, 0x8e,
 0x54, 0xf4, 0x32, 0x45, 0x99, 0x22, 0xca, 0x32, 0xa6, 0x45, 0x28, 0x68, 0x5f, 0x94, 0x08, 0xe5,
 0x4c, 0xbc, 0x59, 0x78, 0xb2, 0x8c, 0xa9, 0x91, 0x4a, 0x99, 0x7a, 0x54, 0xc8, 0xe5, 0x4c, 0xbc,
 0x59, 0x78, 0xb2, 0x8c, 0xa0, 0x47, 0x2a, 0x65, 0xe9, 0x53, 0x23, 0x95, 0x33, 0x24, 0x59, 0x92,
 0x2c, 0xa3, 0x28, 0x1a, 0x38, 0xb4, 0x5d, 0x94, 0x08, 0xe5, 0x4c, 0xbc, 0x59, 0x92, 0x2c, 0xa6,
 0xd1, 0x87, 0x12, 0xc4, 0xa9, 0x9a, 0x38, 0x17, 0x8b, 0x2d, 0x16, 0x40, 0xe2, 0x6a, 0xd1, 0x33,
 0x8e, 0x86, 0x1c, 0x49, 0x89, 0x5b, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x71, 0x35, 0x68, 0xb6, 0xd6,
 0xda, 0x16, 0x8c, 0x34, 0x4a, 0xd1, 0x86, 0x89, 0xda, 0x76, 0x85, 0xc4, 0xd5, 0xc4, 0x99, 0xc4,
 0xd5, 0xa2, 0x76, 0x9d, 0xa2, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0xdb, 0x5b, 0x68, 0x5c,
 0x4c, 0x34, 0x4a, 0xd1, 0x86, 0x89, 0xda, 0x76, 0x85, 0xc4, 0xd5, 0xa2, 0x67, 0x13, 0x57, 0x12,
 0x76, 0xb6, 0xd1, 0x34, 0x6a, 0xd1, 0x2b, 0x46, 0x1a, 0x2d, 0xb4, 0xed, 0x0b, 0x89, 0x87, 0x12,
 0x56, 0x8c, 0x34, 0x4e, 0xd3, 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x38, 0x9a, 0xb8, 0x93, 0xb5, 0xb6,
 0x85, 0xa3, 0x0d, 0x12, 0xb4, 0x61, 0xa2, 0x76, 0x9d, 0xa1, 0x68, 0xc3, 0x89, 0x2b, 0x46, 0xad,
 0x16, 0x89, 0x4e, 0xd1, 0x34, 0x6a, 0xe2, 0x4c, 0xd1, 0xab, 0x89, 0x3b, 0x5a, 0x25, 0x0b, 0x89,
 0x86, 0x89, 0x5a, 0x30, 0xd1, 0x6d, 0xa7, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa2, 0x76,
 0xb6, 0xd1, 0x38, 0x9a, 0xb4, 0x4c, 0xd1, 0xab, 0x89, 0x3b, 0x4c, 0x4a, 0x16, 0x8c, 0x34, 0x4a,
 0xe2, 0x6a, 0xd1, 0x6d, 0xad, 0xb4, 0x4d, 0x18, 0x68, 0x95, 0xa3, 0x56, 0x89, 0xda, 0x76, 0x89,
 0xc4, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x26, 0x25, 0x6d, 0xa1, 0x68, 0xc3, 0x44, 0xae, 0x26, 0x1c,
 0x4b, 0x6d, 0x3b, 0x42, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4e, 0xd6, 0xda, 0x27, 0x13, 0x57,
 0x12, 0x66, 0x8d, 0x5c, 0x49, 0xda, 0x76, 0x85, 0xa3, 0x0d, 0x13, 0x34, 0x6a, 0xe2, 0x5a, 0x25,
 0x3b, 0x42, 0xd6, 0x86, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x4e, 0xd6, 0xda, 0x26, 0x8d, 0x5c, 0x49,
 0x9a, 0x35, 0x71, 0x27, 0x69, 0xda, 0x17, 0x13, 0x57, 0x12, 0x67, 0x13, 0x0d, 0x16, 0xda, 0x76,
 0x85, 0xa3, 0x57, 0x12, 0x67, 0x13, 0x56, 0x89, 0xda, 0xd1, 0x28, 0x5c, 0x4c, 0x38, 0x92, 0xb4,
 0x61, 0xa2, 0x76, 0x9d, 0xa1, 0xe0, 0x60, 0x95, 0xa3, 0x0d, 0x16, 0xda, 0x76, 0x8c, 0x1b, 0x34,
 0x63, 0x80, 0x4b, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0xfa, 0xb6, 0x50, 0x23, 0x95, 0x32, 0xf4, 0xa9, 0x91, 0xca, 0x07, 0xce, 0x22, 0xcf, 0x9a, 0xc5,
 0x94, 0x65, 0x4c, 0x8e, 0x54, 0xcb, 0xd2, 0x81, 0x1c, 0xa9, 0x97, 0x8b, 0x32, 0x45, 0x94, 0x65,
 0x02, 0x39, 0x53, 0x2f, 0x4a, 0x99, 0x1c, 0xa9, 0x99, 0x22, 0xcb, 0xc5, 0xd4, 0x65, 0x02, 0x29,
 0x43, 0x42, 0xfc, 0xa0, 0x45, 0x2a, 0x65, 0xe2, 0xcc, 0x91, 0x65, 0x19, 0x53, 0x23, 0x95, 0x32,
 0xf4, 0xa9, 0x91, 0xca, 0x06, 0x48, 0xb2, 0xf1, 0x65, 0x19, 0x53, 0x23, 0x95, 0x32, 0xf4, 0xa9,
 0x91, 0xca, 0x05, 0xe2, 0xcc, 0x91, 0x75, 0x19, 0x40, 0x8e, 0x54, 0xcb, 0xd2, 0xa7, 0xa1, 0x1c,
 0xa9, 0xe8, 0x5e, 0x2c, 0xbc, 0x59, 0x42, 0x54, 0xc8, 0xe5, 0x02, 0xf4, 0xa9, 0xe8, 0x47, 0x2a,
 0x65, 0xe2, 0xcc, 0x91, 0x65, 0x19, 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47, 0x28, 0x19, 0x22,
 0xcb, 0xc5, 0x94, 0x9c, 0x59, 0xab, 0x45, 0xb9, 0x53, 0xd0, 0x8e, 0x54, 0xcb, 0xc5, 0x97, 0x8b,
 0x2b, 0x38, 0x9a, 0xb4, 0x4e, 0xe0, 0x6a, 0xe2, 0x5b, 0x6b, 0x44, 0xa1, 0x68, 0xd5, 0xa2, 0x67,
 0x13, 0x57, 0x12, 0x76, 0xb6, 0xd1, 0x38, 0x9a, 0xb4, 0x4c, 0xd1, 0xab, 0x45, 0xb6, 0x9d, 0xa1,
 0x68, 0xc3, 0x44, 0xad, 0x18, 0x68, 0x9d, 0xad, 0x12, 0x85, 0xa3, 0x56, 0x89, 0x9c, 0x4d, 0x5a,
 0x27, 0x69, 0xda, 0x26, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x71, 0x27, 0x6b, 0x6d, 0x0b, 0x46, 0xae,
 0x24, 0xcd, 0x18, 0x71, 0x2d, 0xb4, 0xed, 0x0b, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4e, 0xd3,
 0xb4, 0x4d, 0x1a, 0xb8, 0x93, 0x38, 0x9a, 0xb4, 0x4e, 0xd6, 0xda, 0x16, 0x8d, 0x5a, 0x26, 0x68,
 0xc3, 0x45, 0xb6, 0x9d, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x62, 0x56, 0xda, 0x26,
 0x8d, 0x5a, 0x25, 0x71, 0x30, 0xd1, 0x3b, 0x4e, 0xd0, 0xb8, 0x9a, 0xb8, 0x93, 0x34, 0x61, 0xa2,
 0xdb, 0x4e, 0xd0, 0xb8, 0x9a, 0xb4, 0x4c, 0xe2, 0x6a, 0xe2, 0x4c, 0x4a, 0xdb, 0x42, 0xd1, 0x86,
 0x89, 0x9a, 0x35, 0x68, 0x9d, 0xa6, 0x25, 0x0b, 0x89, 0xab, 0x89, 0x33, 0x46, 0x1a, 0x2d, 0xb5,
 0xb6, 0x85, 0xa3, 0x56, 0x89, 0x9c, 0x4d, 0x5c, 0x49, 0xda, 0x62, 0x50, 0xb4, 0x61, 0xa2, 0x56,
 0x8c, 0x34, 0x4e, 0xd6, 0x89, 0x42, 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x16, 0xda, 0x76, 0x89,
 0xa3, 0x56, 0x89, 0x9a, 0x35, 0x71, 0x26, 0x25, 0x3b, 0x42, 0xd1, 0x86, 0x89, 0x5a, 0x35, 0x68,
 0xb6, 0xd6, 0xda, 0x26, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0x9d, 0xa7, 0x68, 0x9c, 0x4d, 0x5a,
 0x26, 0x71, 0x35, 0x68, 0x9d, 0xad, 0xb4, 0x2d, 0x18, 0x68, 0x95, 0xc4, 0xc3, 0x44, 0xed, 0x3b,
 0x42, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x5b, 0x69, 0x89, 0x42, 0xe2, 0x61, 0xa2, 0x67, 0x13,
 0x56, 0x89, 0xda, 0xdb, 0x42, 0xe2, 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x89, 0x31, 0x29, 0xda, 0x26,
 0x8d, 0x5a, 0x26, 0x68, 0xd5, 0xa2, 0xdb, 0x5b, 0x68, 0x9a, 0x35, 0x68, 0x95, 0xc4, 0xc3, 0x89,
 0x3b, 0x4e, 0xd1, 0x03, 0x76, 0x8c, 0x34, 0x4e, 0xd2, 0xd4, 0x0e, 0x00, 0x90, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0xfb, 0x06, 0x54, 0xc8, 0xe5, 0x4c, 0xe4, 0x27, 0x48, 0x86, 0x54, 0xf4,
 0x3e, 0x61, 0x16, 0x7c, 0xbf, 0xdb, 0x0a, 0x32, 0xa6, 0x47, 0x2a, 0x65, 0xe9, 0x53, 0xd0, 0x8e,
 0x54, 0xcc, 0x91, 0x65, 0xa2, 0xca, 0x32, 0xa6, 0x47, 0x28, 0x17, 0xa5, 0x02, 0x29, 0x53, 0x2f,
 0x16, 0x5e, 0x2c, 0xa3, 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x95, 0x32, 0x39, 0x40, 0xbc, 0x59, 0x78,
 0xb2, 0x8c, 0xa9, 0x91, 0xca, 0x05, 0xe9, 0x53, 0x23, 0x95, 0x33, 0x24, 0x59, 0x92, 0x2c, 0xa3,
 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x95, 0x32, 0x39, 0x40, 0xbc, 0x59, 0x78, 0xb2, 0x8c, 0xa1, 0xa1,
 0x1c, 0xa9, 0x97, 0xa5, 0x4c, 0x8e, 0x54, 0xf4, 0x2f, 0x16, 0x64, 0x8b, 0x28, 0x4a, 0x04, 0x72,
 0xa6, 0x5e, 0x94, 0x34, 0x23, 0x95, 0x32, 0xf1, 0x65, 0xe2, 0xca, 0x32, 0xa6, 0x47, 0x28, 0x17,
 0xa5, 0x0d, 0x08, 0xe5, 0x03, 0x24, 0x59, 0x92, 0x2c, 0xa3, 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x95,
 0x32, 0x39, 0x40, 0xbc, 0x59, 0x78, 0xb2, 0x8c, 0xa0, 0x45, 0x2a, 0x65, 0xf9, 0x53, 0x22, 0x95,
 0x32, 0xf1, 0x66, 0x48, 0xb2, 0x94, 0xa0, 0x68, 0xe2, 0x5c, 0x95, 0x32, 0x39, 0x40, 0xc9, 0x16,
 0x5e, 0x2c, 0xaa, 0xe2, 0x6a, 0xe2, 0x58, 0x94, 0x0d, 0x1c, 0x4b, 0x44, 0xaf, 0x12, 0x81, 0xa3,
 0x0d, 0x12, 0xb4, 0x61, 0xc4, 0xb6, 0xd3, 0x12, 0x87, 0x81, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4e,
 0xd6, 0xda, 0x26, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x71, 0x27, 0x69, 0xda, 0x17, 0x13, 0x56, 0x89,
 0x9a, 0x30, 0xd1, 0x6d, 0xad, 0xb4, 0x2e, 0x26, 0xad, 0x13, 0x38, 0x9a, 0xb4, 0x4c, 0x4a, 0x62,
 0x51, 0x38, 0x9a, 0xb4, 0x4c, 0xd1, 0xab, 0x44, 0xed, 0x3b, 0x42, 0xe2, 0x6a, 0xd1, 0x33, 0x46,
 0xae, 0x24, 0xed, 0x68, 0x94, 0x4d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x45, 0xb6, 0x9d, 0xa2, 0x71,
 0x35, 0x71, 0x26, 0x68, 0xd5, 0xa2, 0x76, 0x98, 0x94, 0x2d, 0x18, 0x68, 0x95, 0xc4, 0xd5, 0xc4,
 0x9d, 0xad, 0x12, 0x89, 0xa3, 0x5e, 0x04, 0xcd, 0x1a, 0xb8, 0x96, 0xda, 0x76, 0x89, 0xa3, 0x57,
 0x12, 0x66, 0x8d, 0x5a, 0x27, 0x6b, 0x6d, 0x0b, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb8, 0x96, 0xda,
 0x76, 0x89, 0xa3, 0x56, 0x89, 0x9a, 0x35, 0x68, 0x9d, 0xad, 0xb4, 0x4d, 0x1a, 0xb8, 0x92, 0xb4,
 0x61, 0xa2, 0x76, 0x9d, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x0e, 0x25, 0xb6, 0xb6, 0xd0, 0xb4,
 0x6a, 0xd1, 0x33, 0x89, 0xaf, 0x02, 0x76, 0x9d, 0xa1, 0x68, 0xc3, 0x44, 0xad, 0x18, 0x68, 0x9d,
 0xa6, 0x25, 0x0b, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x5b, 0x6b, 0x44, 0xa2, 0x68, 0xd5, 0xa2,
 0x67, 0x13, 0x57, 0x12, 0x76, 0x9d, 0xa1, 0x71, 0x30, 0xd1, 0x2b, 0x46, 0x1a, 0x27, 0x6b, 0x6d,
 0x0b, 0x89, 0xab, 0x89, 0x33, 0x46, 0xad, 0x16, 0xda, 0x62, 0x51, 0x34, 0x6a, 0xd1, 0x33, 0x89,
 0xab, 0x89, 0x3b, 0x4e, 0xd0, 0xb4, 0x61, 0xa2, 0x56, 0x8c, 0x34, 0x4e, 0xd6, 0xda, 0x16, 0x8d,
 0x5c, 0x49, 0x9a, 0x35, 0x71, 0x2d, 0xb4, 0xed, 0x0b, 0x46, 0x1a, 0x26, 0x68, 0xd5, 0xa2, 0x76,
 0xb6, 0xd0, 0xb4, 0x61, 0xc4, 0x95, 0xc4, 0xd5, 0xa2, 0x62, 0x53, 0xb4, 0x4d, 0x1a, 0xb4, 0x4c,
 0xd1, 0xab, 0x45, 0xb6, 0x9d, 0xa2, 0xe0, 0x60, 0x91, 0xc4, 0xc3, 0x89, 0x3b, 0x5b, 0x6d, 0x01,
 0x96, 0x8c, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xdc, 0x9d, 0x2d, 0x08, 0x67, 0x47, 0x43, 0x96, 0x9d, 0x2d,
 0x08, 0x27, 0x4b, 0x43, 0xe4, 0xd1, 0x77, 0x05, 0x7e, 0x3b, 0x89, 0x9d, 0x22, 0x29, 0xd2, 0x39,
 0x59, 0xd2, 0xd0, 0x82, 0x74, 0xb4, 0x32, 0xc5, 0xda, 0x97, 0xe3, 0xe9, 0xc6, 0x4a, 0x99, 0x1c,
 0xa9, 0x9c, 0x8c, 0xe9, 0x68, 0x43, 0x3a, 0x5a, 0x19, 0x22, 0xec, 0x13, 0x5b, 0x55, 0xc7, 0xca,
 0x1a, 0x11, 0xca, 0x05, 0xf9, 0x53, 0xd0, 0x8a, 0x54, 0xf4, 0x2f, 0x16, 0x44, 0x59, 0x46, 0x54,
 0xc8, 0xe5, 0x02, 0xf4, 0xa9, 0x91, 0xca, 0x06, 0x48, 0xb3, 0x24, 0x59, 0x46, 0x54, 0xc8, 0xe5,
 0x02, 0xf4, 0xa9, 0x91, 0xca, 0x05, 0xe2, 0xcb, 0xc5, 0x94, 0x65, 0x4c, 0x8a, 0x54, 0xcb, 0xf2,
 0x81, 0x14, 0xa9, 0x97, 0x8b, 0x2f, 0x16, 0x51, 0x95, 0x3d, 0x08, 0xe5, 0x4c, 0xbd, 0x2a, 0x64,
 0x72, 0xa6, 0x64, 0x8b, 0x32, 0x45, 0x94, 0x65, 0x4c, 0x8e, 0x54, 0xcb, 0xd2, 0x81, 0x1c, 0xa9,
 0x97, 0x8b, 0x2f, 0x17, 0x51, 0x95, 0x32, 0x29, 0x40, 0xbd, 0x28, 0x11, 0xca, 0x99, 0x78, 0xb3,
 0x24, 0x59, 0x46, 0x54, 0xc8, 0xe5, 0x4c, 0xbd, 0x2a, 0x64, 0x72, 0x81, 0x78, 0xb2, 0xf1, 0x65,
 0x19, 0x53, 0x23, 0x95, 0x32, 0xf4, 0xa0, 0x47, 0x2a, 0x66, 0x48, 0xb3, 0x24, 0x59, 0x46, 0x50,
 0xd0, 0x8e, 0x54, 0xf4, 0x2f, 0x4a, 0x99, 0x1c, 0xa9, 0x97, 0x8b, 0x2f, 0x16, 0x51, 0x95, 0x32,
 0x37, 0x02, 0xec, 0xa9, 0xe8, 0x69, 0x28, 0x17, 0x8b, 0x32, 0x45, 0x94, 0x9a, 0xd0, 0xc3, 0x45,
 0x99, 0x53, 0x23, 0x94, 0x0b, 0xc5, 0x97, 0x8b, 0x20, 0x71, 0x35, 0x68, 0x99, 0xc7, 0x81, 0xab,
 0x45, 0xb6, 0xb4, 0x4a, 0x16, 0x8c, 0x34, 0x4a, 0xe2, 0x61, 0xa2, 0x76, 0x9d, 0xa1, 0x71, 0x35,
 0x68, 0x99, 0xa3, 0x56, 0x8b, 0x6d, 0x6d, 0xa2, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xc4, 0x9d,
 0xa7, 0x68, 0x5a, 0x30, 0xe2, 0x4a, 0xe2, 0x61, 0xa2, 0x76, 0xb6, 0xd0, 0xb8, 0x9a, 0xb8, 0x93,
 0x34, 0x6a, 0xd1, 0x6d, 0xa7, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xc4, 0x9d, 0xa7, 0x68,
 0x5a, 0x30, 0xd1, 0x2b, 0x46, 0x1c, 0x49, 0x89, 0x5b, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x68, 0xd5,
 0xa2, 0xdb, 0x4c, 0x4a, 0x16, 0x8c, 0x34, 0x4c, 0xd1, 0xab, 0x89, 0x3b, 0x4e, 0xd0, 0xb4, 0x61,
 0xa2, 0x56, 0x8d, 0x5c, 0x49, 0x89, 0x5b, 0x68, 0x9a, 0x35, 0x71, 0x26, 0x71, 0x35, 0x68, 0x9d,
 0xa7, 0x68, 0x5c, 0x4c, 0x35, 0xa1, 0x33, 0x46, 0xad, 0x16, 0xda, 0xdb, 0x42, 0xe2, 0x6a, 0xd1,
 0x33, 0x89, 0xab, 0x89, 0x3b, 0x4e, 0xd1, 0x34, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x16, 0xda, 0xdb,
 0x42, 0xe2, 0x61, 0xa2, 0x56, 0x8c, 0x34, 0x4e, 0xd3, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a,
 0xe2, 0x4e, 0xd3, 0xb4, 0x4e, 0x26, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x6d, 0xad, 0xb4, 0x4e, 0x26,
 0x8e, 0x24, 0xcd, 0x18, 0x68, 0x9d, 0xa7, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x0e, 0x24, 0xed,
 0x6d, 0xa1, 0x68, 0xd5, 0xc4, 0x99, 0xa3, 0x56, 0x8b, 0x6d, 0x3b, 0x42, 0xd6, 0x86, 0x39, 0x49,
 0x5a, 0x30, 0xd1, 0x3b, 0x5b, 0x68, 0x5a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xc4, 0x9d, 0xa7, 0x68,
 0x9a, 0x35, 0x71, 0x25, 0x71, 0x30, 0xd1, 0x6d, 0xa7, 0x68, 0x9a, 0x35, 0x71, 0x25, 0x68, 0xc3,
 0x44, 0xed, 0x6d, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x76, 0x9d, 0xa1, 0x68, 0xc3,
 0x44, 0xce, 0x26, 0xad, 0x16, 0x89, 0x4e, 0xd0, 0xb4, 0x61, 0xa2, 0x57, 0x13, 0x56, 0x89, 0xda,
 0xdb, 0x44, 0xd1, 0x86, 0x89, 0x5c, 0x4d, 0x5a, 0x27, 0x69, 0xda, 0x30, 0x6c, 0xd1, 0x86, 0x99,
 0x29, 0x60, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0xfb, 0xee, 0x74, 0xb4, 0x20, 0x9d, 0x1d, 0x0e, 0x5e, 0xa5, 0x1e, 0x1d, 0x68, 0x82, 0x74, 0xb4,
 0x3e, 0x39, 0x17, 0x73, 0xf9, 0x38, 0xee, 0x26, 0x74, 0x74, 0x21, 0x9d, 0x2d, 0x0e, 0x56, 0x74,
 0x88, 0x67, 0x4b, 0x43, 0x24, 0x5d, 0xa7, 0x7e, 0x3b, 0x89, 0x9d, 0x22, 0x19, 0xd2, 0x39, 0x69,
 0xd2, 0x20, 0x9d, 0x2d, 0x0c, 0xb1, 0x76, 0x9d, 0xf8, 0xee, 0x2a, 0x74, 0x88, 0x27, 0x4b, 0x43,
 0x96, 0x9d, 0x2d, 0x08, 0x27, 0x48, 0xc9, 0x17, 0x69, 0xdf, 0x8e, 0xe2, 0xa5, 0x4b, 0x42, 0x39,
 0x53, 0xd0, 0xe4, 0xe7, 0x4b, 0x42, 0x19, 0xd2, 0xd0, 0xc9, 0x17, 0x6b, 0x5b, 0x14, 0xc3, 0x8e,
 0x95, 0x32, 0x29, 0x53, 0x39, 0x09, 0xd2, 0x22, 0x95, 0x33, 0x24, 0x59, 0x4d, 0xcc, 0x7b, 0xd4,
 0x25, 0x4c, 0x8e, 0x50, 0x2f, 0x4a, 0x9e, 0x84, 0x72, 0xa6, 0x5e, 0x2c, 0xb4, 0x59, 0x46, 0x50,
 0x23, 0x95, 0x32, 0xf4, 0xa0, 0x47, 0x2a, 0x66, 0x48, 0xb3, 0x24, 0x59, 0x46, 0x50, 0xd0, 0x8e,
 0x50, 0x2f, 0x4a, 0x04, 0x72, 0xa6, 0x5e, 0x2c, 0xbc, 0x59, 0x42, 0x54, 0xc8, 0xe5, 0x4f, 0x42,
 0xf4, 0xa0, 0x47, 0x28, 0x17, 0x8b, 0x32, 0x45, 0xd4, 0x65, 0x4c, 0x8e, 0x50, 0x2f, 0x4a, 0x99,
 0x1c, 0xa9, 0x99, 0x22, 0xcb, 0xc5, 0x94, 0x65, 0x4c, 0x8e, 0x54, 0xcb, 0xd2, 0xa6, 0x47, 0x2a,
 0x65, 0xe2, 0xcb, 0xc5, 0x94, 0x65, 0x02, 0x39, 0x53, 0x2f, 0x4a, 0x1a, 0x11, 0x4a, 0x99, 0x78,
 0xb3, 0x24, 0x59, 0x4a, 0x54, 0xf4, 0x22, 0x95, 0x32, 0xf4, 0xa0, 0x47, 0x28, 0x17, 0x8b, 0x2f,
 0x16, 0x51, 0x95, 0x32, 0x39, 0x40, 0xbd, 0x2a, 0x7a, 0x11, 0xca, 0x06, 0x48, 0xb3, 0x24, 0x59,
 0x46, 0x50, 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47, 0x28, 0x68, 0x5e, 0x2c, 0xbc, 0x59, 0x45, 0xc0,
 0xd5, 0xc4, 0xb9, 0x28, 0x11, 0xca, 0x99, 0x78, 0xb3, 0x24, 0x59, 0x55, 0xa3, 0x57, 0x12, 0xc4,
 0xa0, 0x68, 0xe2, 0x5a, 0x25, 0x68, 0x94, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x89, 0x6d, 0xad,
 0xb4, 0x2d, 0x18, 0x71, 0x25, 0x68, 0xc3, 0x44, 0xed, 0x3b, 0x42, 0xd1, 0xab, 0x44, 0xcd, 0x1a,
 0xb4, 0x5b, 0x69, 0x89, 0x44, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb8, 0x93, 0xb5, 0xb6, 0x85, 0xa3,
 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x27, 0x69, 0xda, 0x26, 0x8d, 0x5a, 0x26, 0x68, 0xd5, 0xa2, 0x76,
 0xb6, 0xd1, 0x70, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8b, 0x6d, 0x3b, 0x42, 0xd1, 0x86, 0x89, 0x5c,
 0x4c, 0x34, 0x4e, 0xd3, 0xb4, 0x2e, 0x26, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x3b, 0x5b, 0x68, 0x5c,
 0x4c, 0x34, 0x4c, 0xe2, 0x6a, 0xd1, 0x6d, 0xa7, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12,
 0x76, 0xb4, 0x4a, 0x27, 0x13, 0x56, 0x89, 0x9a, 0x35, 0x68, 0x9d, 0xa6, 0x25, 0x0b, 0x46, 0x1a,
 0x26, 0x71, 0x35, 0x71, 0x2d, 0xb5, 0xb6, 0x85, 0xa3, 0x0e, 0x24, 0xad, 0x1a, 0xb8, 0x93, 0xb4,
 0xed, 0x13, 0x46, 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x5b, 0x69, 0xda, 0x16, 0x8c, 0x34, 0x4c, 0xd1,
 0xab, 0x89, 0x3b, 0x5b, 0x68, 0x5a, 0x30, 0xd1, 0x2b, 0x46, 0xad, 0x13, 0xb4, 0xed, 0x13, 0x46,
 0xae, 0x24, 0xcd, 0x1a, 0xb4, 0x4e, 0xd6, 0xda, 0x17, 0x13, 0x56, 0x89, 0x9a, 0x30, 0xd1, 0x6d,
 0xa7, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x76, 0x9d, 0xa2, 0x68, 0xd5, 0xa2, 0x66,
 0x8d, 0x5a, 0x2d, 0x12, 0xb6, 0xd0, 0xb8, 0x9a, 0xb8, 0x93, 0x34, 0x61, 0xa2, 0x76, 0x9d, 0xa1,
 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x57, 0x12, 0x76, 0xb6, 0xd1, 0x38, 0x9a, 0xb4, 0x4c, 0xd1, 0xab,
 0x45, 0xb6, 0x9d, 0xa1, 0x71, 0x35, 0x71, 0x26, 0x68, 0xc3, 0x89, 0x3b, 0x5b, 0x68, 0x5a, 0x35,
 0x68, 0x99, 0xc4, 0xd5, 0xc4, 0x9d, 0xa7, 0x68, 0x9a, 0x35, 0x68, 0x95, 0xa3, 0x0d, 0x16, 0xda,
 0x76, 0x85, 0xa3, 0x0d, 0x12, 0xb4, 0x61, 0xc4, 0x9d, 0xad, 0xb4, 0x5d, 0x26, 0x09, 0x1a, 0x35,
 0x71, 0x27, 0x69, 0xdb, 0x50, 0x67, 0x81, 0x82, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x07, 0xe9, 0x25, 0x6c, 0x26, 0x85, 0x3a, 0xb8, 0x5e, 0x1d, 0xe3, 0xb5, 0x56, 0xc2, 0x68, 0x52,
 0xad, 0x84, 0xd0, 0xf8, 0x65, 0x73, 0x36, 0xf3, 0xf8, 0x7f, 0xe4, 0xeb, 0x15, 0x28, 0x35, 0xde,
 0x2b, 0xce, 0x96, 0x87, 0x63, 0xad, 0x84, 0xd0, 0xa5, 0x5b, 0x09, 0xa1, 0xb1, 0x5c, 0xaf, 0x2b,
 0x2f, 0x0a, 0x61, 0xc1, 0xce, 0x96, 0x84, 0x13, 0xa5, 0xa1, 0xcc, 0xd5, 0xc3, 0xb5, 0xde, 0x2b,
 0x4e, 0x8f, 0x0e, 0xf1, 0x9a, 0xb7, 0x79, 0xd9, 0x38, 0xda, 0x71, 0x33, 0xa5, 0xa1, 0x0c, 0xe9,
 0x68, 0x72, 0xb3, 0xa5, 0xa1, 0x0c, 0xe9, 0x68, 0x64, 0x8b, 0xb4, 0xef, 0xc7, 0x71, 0x53, 0xa5,
 0xa1, 0x04, 0xe8, 0xe8, 0x72, 0xd3, 0xa3, 0xa1, 0x04, 0xe8, 0xe8, 0x65, 0x8b, 0xb4, 0xef, 0xc7,
 0x71, 0x53, 0xa5, 0xa1, 0x04, 0xe9, 0x68, 0x72, 0xd3, 0xa3, 0xa1, 0x0c, 0xe9, 0x19, 0x22, 0xed,
 0x3b, 0xf1, 0xdc, 0x4c, 0xe9, 0x11, 0x4a, 0x9b, 0x39, 0x49, 0xd2, 0xd0, 0x86, 0x74, 0xb4, 0x32,
 0x45, 0xda, 0x96, 0xc1, 0x31, 0xee, 0x71, 0x92, 0xa6, 0x47, 0x28, 0x1c, 0x8c, 0xe9, 0x68, 0x43,
 0x2a, 0x5c, 0x3b, 0xc6, 0x48, 0xbb, 0x0c, 0xc4, 0xc2, 0x84, 0xa9, 0xe8, 0x45, 0x2a, 0x65, 0xf9,
 0x53, 0xd0, 0x8e, 0x54, 0xcc, 0x91, 0x64, 0xc5, 0x94, 0x25, 0x4f, 0x42, 0x39, 0x40, 0xbd, 0x2a,
 0x7a, 0x11, 0xca, 0x99, 0x78, 0xb2, 0xf1, 0x65, 0x19, 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47,
 0x28, 0x19, 0x22, 0xcc, 0x91, 0x65, 0x19, 0x53, 0xd0, 0x8e, 0x54, 0xcb, 0xd2, 0x81, 0x1c, 0xa9,
 0x97, 0x8b, 0x2f, 0x16, 0x51, 0x95, 0x32, 0x39, 0x53, 0x2f, 0x4a, 0x99, 0x14, 0xa9, 0x97, 0x8b,
 0x32, 0x45, 0x94, 0x65, 0x02, 0x39, 0x53, 0x2f, 0x4a, 0x99, 0x1c, 0xa9, 0x97, 0x8b, 0x2f, 0x16,
 0x51, 0x94, 0x08, 0xe5, 0x0d, 0x0b, 0xd2, 0x81, 0x1c, 0xa1, 0xa1, 0x92, 0x2c, 0xc9, 0x16, 0x51,
 0x95, 0x32, 0x39, 0x53, 0x2f, 0x4a, 0x04, 0x72, 0x81, 0x78, 0xb2, 0xf1, 0x65, 0x19, 0x53, 0x22,
 0x95, 0x32, 0xf4, 0xa9, 0x91, 0xca, 0x99, 0x78, 0xb3, 0x24, 0x5d, 0x46, 0x50, 0x23, 0x95, 0x32,
 0xf4, 0xa9, 0x91, 0xca, 0x99, 0x92, 0x2c, 0xbc, 0x59, 0x46, 0x50, 0x34, 0x70, 0x65, 0xd9, 0x40,
 0x8e, 0x54, 0xcb, 0xc5, 0x97, 0x8b, 0x29, 0xb4, 0x61, 0xc4, 0xb3, 0x2a, 0x64, 0x6e, 0x05, 0xe2,
 0x57, 0x8b, 0x20, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xc4, 0x9d, 0xad, 0xb4, 0x4d, 0x1a, 0xb8,
 0x93, 0x38, 0x9a, 0xb4, 0x5b, 0x6b, 0x6d, 0x0b, 0x89, 0x86, 0x89, 0x5a, 0x30, 0xe2, 0x4e, 0xd3,
 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a, 0xd1, 0x3b, 0x4e, 0xd1, 0x34, 0x6a, 0xd1, 0x33, 0x89,
 0xab, 0x45, 0xb6, 0xb4, 0x4a, 0x17, 0x13, 0x0d, 0x12, 0xb4, 0x61, 0xa2, 0x76, 0x9d, 0xa1, 0x68,
 0xd5, 0xc4, 0x99, 0xa3, 0x56, 0x89, 0xda, 0xdb, 0x44, 0xd1, 0xab, 0x44, 0xae, 0x26, 0x1c, 0x49,
 0xda, 0x76, 0x85, 0xc4, 0xc3, 0x89, 0x2b, 0x46, 0x1a, 0x2d, 0xb4, 0xed, 0x0b, 0x46, 0xad, 0x13,
 0x34, 0x6a, 0xe2, 0x4e, 0xd6, 0x89, 0x42, 0xd1, 0x86, 0x89, 0x5a, 0x30, 0xd1, 0x3b, 0x4e, 0xd0,
 0xb4, 0x61, 0xc4, 0x95, 0xa3, 0x57, 0x12, 0xdb, 0x5b, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x57,
 0x12, 0x76, 0x9d, 0xa1, 0x68, 0xc3, 0x44, 0xad, 0x18, 0x68, 0xb6, 0xd3, 0xb4, 0x2d, 0x18, 0x68,
 0x95, 0xa3, 0x56, 0x89, 0xda, 0xd1, 0x28, 0x9c, 0x4d, 0x5a, 0x26, 0x68, 0xd5, 0xa2, 0x62, 0x53,
 0xb4, 0x2d, 0x18, 0x68, 0x95, 0xc4, 0xc3, 0x45, 0xb6, 0xb4, 0x4a, 0x16, 0x8d, 0x5a, 0x26, 0x68,
 0xd5, 0xa2, 0x76, 0x9d, 0xa2, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x89, 0xda, 0xdb, 0x42, 0xd1,
 0x86, 0x89, 0x9c, 0x4d, 0x5c, 0x4b, 0x6d, 0x3b, 0x42, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4e,
 0xd3, 0xb4, 0x4d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xe2, 0x4e, 0xd6, 0xda, 0x16, 0x8d, 0x78, 0x13,
 0x34, 0x61, 0xc4, 0xb6, 0xd3, 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x38, 0x9a, 0xb4, 0x4e, 0xd6, 0xda,
 0x26, 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0x9d, 0xa7, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x0d,
 0x16, 0xda, 0x76, 0x85, 0xa3, 0x56, 0x89, 0x9c, 0x4d, 0x78, 0x13, 0xb5, 0xa2, 0x50, 0xb8, 0x98,
 0x68, 0x95, 0xa3, 0x0d, 0x13, 0xb4, 0xed, 0x0b, 0x89, 0x82, 0x57, 0x13, 0x0d, 0x16, 0xda, 0x76,
 0x8c, 0x1b, 0x34, 0x63, 0x81, 0x29, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xea, 0x05, 0x0c, 0x73, 0xe1,
 0xc2, 0x5d, 0x2b, 0x52, 0xcc, 0x67, 0x46, 0xaa, 0xf0, 0x33, 0xab, 0xd2, 0xc4, 0xea, 0x5b, 0xa3,
 0x8a, 0xe1, 0xdf, 0x3f, 0x3d, 0xc5, 0xf4, 0xe9, 0xe3, 0x24, 0x4f, 0xbd, 0xcd, 0x55, 0xc2, 0xa6,
 0xb8, 0xae, 0x92, 0x9d, 0x6c, 0x26, 0x83, 0x0f, 0x8d, 0x6b, 0xef, 0x8b, 0xb4, 0xf1, 0x54, 0xea,
 0x2e, 0x13, 0x5e, 0xd1, 0x9a, 0xb9, 0x74, 0xa5, 0xf0, 0x52, 0xee, 0x1a, 0xb6, 0x13, 0x42, 0x9d,
 0x6c, 0x26, 0x87, 0x67, 0x95, 0x18, 0x54, 0x5c, 0x60, 0xd3, 0x2a, 0xd6, 0xc2, 0x68, 0x6c, 0x53,
 0x33, 0xcf, 0xcd, 0xe1, 0xfb, 0x75, 0x6a, 0xb8, 0x56, 0xbb, 0xc5, 0x5a, 0x94, 0x1a, 0xef, 0x1d,
 0x9e, 0xb6, 0x13, 0x42, 0x95, 0x6c, 0x26, 0x86, 0xc5, 0x73, 0x3c, 0x9c, 0xdc, 0x09, 0x87, 0x5e,
 0x9d, 0x22, 0x19, 0xd2, 0xd0, 0xe6, 0xeb, 0x61, 0x74, 0x2a, 0xd4, 0xc3, 0xb5, 0xde, 0x33, 0xd7,
 0x23, 0xcc, 0xc9, 0xc5, 0x98, 0xf8, 0x38, 0x79, 0xd2, 0xd0, 0x86, 0x74, 0x8e, 0x5a, 0x74, 0x74,
 0x20, 0x9d, 0x2d, 0x0c, 0xb1, 0x76, 0x95, 0xf8, 0xee, 0x2a, 0x74, 0xb4, 0x20, 0x9d, 0x2d, 0x0e,
 0x99, 0xbd, 0x5d, 0xf0, 0xec, 0xbe, 0xee, 0xf6, 0x82, 0x86, 0x49, 0x9d, 0xe0, 0x33, 0x8c, 0x46,
 0x26, 0xbe, 0x16, 0x38, 0xa8, 0xcb, 0x07, 0x46, 0x9c, 0xa0, 0xa1, 0x29, 0xce, 0x29, 0x37, 0x2a,
 0x91, 0x7c, 0x78, 0xc1, 0xf7, 0xbc, 0x07, 0x4e, 0x97, 0x9a, 0x6f, 0x60, 0x1f, 0xe0, 0x8d, 0xa6,
 0xf7, 0x35, 0x0f, 0xae, 0x2f, 0x19, 0x08, 0xf0, 0x7e, 0x4e, 0x4a, 0xc5, 0xa9, 0x49, 0x98, 0x97,
 0xaf, 0x4e, 0x96, 0x84, 0x13, 0xa5, 0xa1, 0xe4, 0x92, 0xf3, 0x4c, 0x6c, 0x0b, 0xfc, 0x11, 0xb4,
 0xbe, 0xe6, 0xa1, 0xf5, 0xc4, 0x72, 0xf3, 0x4a, 0xec, 0x13, 0xfc, 0x13, 0xb4, 0x9e, 0xe6, 0xa1,
 0xf5, 0xc6, 0x48, 0xcb, 0x0d, 0x7b, 0xf8, 0x0f, 0x32, 0x7f, 0xe9, 0xcb, 0xd6, 0x67, 0x4b, 0x42,
 0x19, 0xd2, 0xd0, 0xf2, 0x89, 0x79, 0xa4, 0x76, 0x11, 0xfe, 0x09, 0xda, 0x3f, 0x73, 0xd1, 0xfa,
 0xd2, 0x39, 0x79, 0xa3, 0xb6, 0x15, 0xfe, 0x0a, 0xda, 0x3f, 0x73, 0xd1, 0xfa, 0xd2, 0xf1, 0x9a,
 0xbf, 0x36, 0xb5, 0xfe, 0xcf, 0x73, 0xbe, 0x18, 0xa5, 0xea, 0xd2, 0xa7, 0xa1, 0x14, 0xa9, 0x9e,
 0x55, 0x2f, 0x34, 0x5e, 0xc3, 0x3f, 0xc1, 0x5b, 0x45, 0xee, 0x7a, 0x3f, 0x5a, 0x69, 0x2f, 0x34,
 0x46, 0xc4, 0x3f, 0xc1, 0x7b, 0x43, 0xee, 0x7a, 0x3f, 0x5a, 0x64, 0x8c, 0xf4, 0xf9, 0xb0, 0xcf,
 0xd9, 0xff, 0x00, 0x11, 0x8f, 0x76, 0x29, 0x7a, 0xa4, 0xa9, 0x91, 0xca, 0x07, 0x95, 0xbf, 0x34,
 0x2e, 0xc4, 0xbf, 0xc1, 0x7b, 0x41, 0xee, 0x7a, 0x3f, 0x5a, 0x68, 0xfc, 0xd0, 0x7b, 0x14, 0xff,
 0x00, 0x06, 0x6d, 0x07, 0xb9, 0xe8, 0xfd, 0x69, 0x78, 0xe4, 0x53, 0xe6, 0x47, 0x81, 0x78, 0x97,
 0xe0, 0xcb, 0xd4, 0xe5, 0x4c, 0x8e, 0x54, 0xcf, 0x2e, 0x7e, 0x68, 0x1d, 0x8b, 0x7f, 0x83, 0x33,
 0xff, 0x00, 0x21, 0x47, 0xeb, 0x4d, 0x1e, 0xff, 0x00, 0xf6, 0x31, 0xfe, 0x0c, 0xcf, 0xfc, 0x85,
 0x1f, 0xad, 0x2d, 0x1c, 0x8a, 0x7c, 0xd7, 0x8f, 0x03, 0xf1, 0x1f, 0xc1, 0x97, 0xa8, 0x4a, 0x04,
 0x52, 0xa6, 0x74, 0xad, 0x8e, 0xde, 0xde, 0xcd, 0x6d, 0x5e, 0xd1, 0x61, 0xb2, 0x2c, 0xbb, 0x03,
 0x9b, 0x52, 0xc4, 0xe2, 0x14, 0xdc, 0x25, 0x5e, 0x95, 0x38, 0xc1, 0x72, 0xc5, 0xc9, 0xf1, 0x6a,
 0x6d, 0xf5, 0x27, 0xde, 0x3b, 0xfc, 0xa1, 0xa1, 0x9a, 0x99, 0x62, 0xd1, 0xb8, 0x96, 0xa7, 0x23,
 0x8d, 0x9b, 0x8b, 0x7f, 0x43, 0x35, 0x7d, 0x19, 0xf7, 0xfb, 0x54, 0x65, 0x0d, 0x08, 0xe5, 0x4c,
 0xbd, 0x2a, 0x64, 0x72, 0xa6, 0x66, 0x8b, 0x31, 0x45, 0x94, 0x65, 0x02, 0x39, 0x53, 0x2f, 0x4a,
 0x04, 0x72, 0xa6, 0x5e, 0x2c, 0xbc, 0x59, 0x46, 0x54, 0xc8, 0xa5, 0x02, 0xfc, 0xa0, 0x45, 0x2a,
 0x65, 0xe2, 0xcc, 0x91, 0x65, 0x19, 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47, 0x28, 0x68, 0x5e,
 0x2c, 0xbc, 0x59, 0x46, 0x54, 0xc8, 0xe5, 0x4c, 0xbd, 0x2a, 0x64, 0x72, 0xa6, 0x64, 0x8b, 0x32,
 0x45, 0x94, 0x65, 0x4c, 0x8e, 0x54, 0xf4, 0x2f, 0x4a, 0x04, 0x72, 0xa6, 0x5e, 0x2c, 0xbc, 0x59,
 0x46, 0x54, 0xc8, 0xa5, 0x02, 0xfc, 0xa0, 0x47, 0x2a, 0x65, 0xe2, 0xcc, 0x91, 0x65, 0x09, 0x53,
 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47, 0x2a, 0x7a, 0x19, 0x22, 0xcb, 0xc5, 0x94, 0x9c, 0x4d, 0x5a,
 0x2d, 0xca, 0x99, 0x1c, 0xa9, 0x97, 0x8b, 0x2f, 0x16, 0x56, 0x71, 0x30, 0xd1, 0x33, 0x83, 0x35,
 0x71, 0x2d, 0x12, 0xb4, 0x4a, 0x16, 0x8c, 0x34, 0x4a, 0xe2, 0x61, 0xc4, 0x9d, 0xad, 0xb4, 0x2d,
 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xd1, 0x6d, 0xa7, 0x68, 0x5c, 0x4c, 0x38, 0x92, 0xb4, 0x61, 0xc4,
 0x9d, 0xad, 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xe2, 0x4e, 0xd3, 0xb4, 0x4e, 0x26, 0xae,
 0x24, 0xcd, 0x1a, 0xb4, 0x5b, 0x6b, 0x6d, 0x0b, 0x46, 0x1a, 0x25, 0x71, 0x30, 0xe2, 0x4e, 0xd3,
 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a, 0xe2, 0x4e, 0xd3, 0xb4, 0x4d, 0x1a, 0xb8, 0x93, 0x38,
 0x9a, 0xb4, 0x4e, 0xd6, 0xda, 0x16, 0x8d, 0x5a, 0x26, 0x68, 0xc3, 0x45, 0xb6, 0x9d, 0xa1, 0x68,
 0xd5, 0xa2, 0x67, 0x13, 0x57, 0x12, 0x76, 0xb6, 0xd1, 0x34, 0x6a, 0xd1, 0x2b, 0x46, 0x1a, 0x27,
 0x69, 0x89, 0x42, 0xe2, 0x6a, 0xe2, 0x4d, 0xc0, 0xc3, 0x45, 0xb6, 0x98, 0x94, 0x3c, 0x0d, 0x5a,
 0x26, 0x71, 0x35, 0x71, 0x27, 0x6b, 0x6d, 0x13, 0x89, 0xab, 0x44, 0xad, 0x18, 0x68, 0x9d, 0xa7,
 0x68, 0x5c, 0x4d, 0x5c, 0x49, 0x9a, 0x30, 0xd1, 0x6d, 0xad, 0xb4, 0x2d, 0x1a, 0xb4, 0x4c, 0xd1,
 0xab, 0x89, 0x3b, 0x4e, 0xd0, 0xb4, 0x61, 0xa2, 0x56, 0x8c, 0x34, 0x4e, 0xd3, 0xb4, 0x2d, 0x1a,
 0xb8, 0x93, 0x34, 0x6a, 0xd1, 0x6d, 0xad, 0xb4, 0x2d, 0x18, 0x71, 0x26, 0x68, 0xd5, 0xc4, 0x9d,
 0xa7, 0x68, 0x5a, 0x30, 0xd1, 0x2b, 0x89, 0x86, 0x89, 0xda, 0xdb, 0x42, 0xd1, 0x87, 0x12, 0x56,
 0x8d, 0x5a, 0x2d, 0xb4, 0xed, 0x13, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4e, 0xd6, 0xda, 0x16,
 0x8c, 0x34, 0x4a, 0xe2, 0x6a, 0xd1, 0x3b, 0x4e, 0xd1, 0x38, 0x9a, 0xb4, 0x4c, 0xd1, 0xab, 0x45,
 0xb6, 0x9d, 0xa1, 0x71, 0x30, 0xd1, 0x33, 0x89, 0xab, 0x44, 0xed, 0x6d, 0xa1, 0x68, 0xc3, 0x44,
 0xae, 0x26, 0x1c, 0x49, 0xda, 0x76, 0x85, 0xa3, 0x56, 0x89, 0x9a, 0x23, 0xa8, 0xe1, 0x08, 0xb9,
 0x4e, 0x51, 0x8c, 0x57, 0x7d, 0xbe, 0x08, 0x9f, 0x4a, 0x22, 0x37, 0x2b, 0x44, 0xb4, 0x68, 0xd7,
 0x81, 0x5a, 0xbe, 0x6d, 0x97, 0x53, 0x6d, 0x3c, 0x44, 0x64, 0xff, 0x00, 0x98, 0x9b, 0xfd, 0xc5,
 0x59, 0x67, 0xd8, 0x14, 0xfa, 0x23, 0x5a, 0x5e, 0xb4, 0x57, 0x69, 0xa7, 0x7f, 0x14, 0xe1, 0xe3,
 0x9d, 0x5b, 0x2c, 0x79, 0xb3, 0xd7, 0x8f, 0x96, 0xde, 0xea, 0xcb, 0x92, 0x07, 0x18, 0xb3, 0xec,
 0x0b, 0xeb, 0x85, 0x65, 0xeb, 0xc5, 0x76, 0x93, 0x52, 0xcd, 0xb2, 0xfa, 0x9d, 0x0a, 0xba, 0x8b,
 0xfe, 0x72, 0x68, 0x53, 0xc5, 0x78, 0x79, 0x27, 0x51, 0x96, 0x3c, 0xd3, 0x3c, 0x7c, 0xb1, 0xef,
 0xac, 0xae, 0x83, 0x58, 0x4e, 0x15, 0x23, 0xcd, 0x4e, 0x71, 0x9c, 0x7c, 0x31, 0x7c, 0x51, 0xb1,
 0xbf, 0x13, 0x13, 0x1b, 0x86, 0x2f, 0x70, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xd0, 0xaa, 0x75, 0xf5, 0x2c, 0xd3, 0xc4, 0x6a, 0x70, 0x74,
 0xeb, 0x6a, 0x4f, 0x4e, 0xbe, 0xa7, 0xe7, 0x68, 0x97, 0xb7, 0x17, 0x73, 0xd4, 0xb1, 0x3a, 0x96,
 0xe9, 0x62, 0x9f, 0x84, 0xeb, 0xd4, 0xeb, 0xea, 0x59, 0xa7, 0x88, 0xd4, 0x98, 0x96, 0x5a, 0xe4,
 0x76, 0x5a, 0x38, 0xc6, 0xb8, 0x74, 0x97, 0xa8, 0xe3, 0x79, 0x97, 0x09, 0xf0, 0x67, 0x56, 0xa5,
 0x88, 0xd4, 0xb5, 0x4b, 0x13, 0xa9, 0x78, 0xb3, 0x2d, 0x72, 0x3b, 0x3a, 0xb3, 0x55, 0x74, 0x34,
 0x9e, 0xa4, 0x35, 0x70, 0xbe, 0x04, 0x71, 0x34, 0x71, 0x6d, 0x77, 0xcb, 0xf8, 0x7c, 0x73, 0x5c,
 0x3a, 0x4c, 0x95, 0xc9, 0x30, 0xb4, 0xd6, 0x97, 0xf7, 0xa2, 0xad, 0x84, 0xd0, 0xa5, 0x5b, 0x09,
 0xa1, 0xce, 0xc2, 0xbd, 0x1a, 0x8b, 0xd3, 0x2e, 0x0c, 0x4f, 0x0f, 0x19, 0xae, 0x31, 0x69, 0xad,
 0x0c, 0xf5, 0xcc, 0xd4, 0xcb, 0xc1, 0x8b, 0x7b, 0x9d, 0x5a, 0xb6, 0x13, 0x42, 0xa5, 0x5c, 0x33,
 0x5d, 0xe3, 0xb4, 0xd6, 0xc2, 0x68, 0x52, 0xad, 0x84, 0xd0, 0xd9, 0xae, 0x67, 0x93, 0x9b, 0xc3,
 0xff, 0x00, 0x27, 0xc2, 0x1e, 0x6e, 0x48, 0x72, 0x6f, 0x67, 0x2b, 0x5f, 0x98, 0xa8, 0xfc, 0xbe,
 0x20, 0xf0, 0x43, 0xe8, 0x5f, 0x37, 0xbd, 0x3b, 0x5b, 0xe1, 0xca, 0xa3, 0xf9, 0x82, 0x8b, 0xff,
 0x00, 0x11, 0x88, 0x3e, 0x7a, 0x36, 0xab, 0x3b, 0x8d, 0xbd, 0xbe, 0x1d, 0x3d, 0x0c, 0x15, 0xa8,
 0x00, 0x25, 0xb2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x2f, 0x33, 0xaa, 0xe3,
 0xbd, 0xdc, 0xa1, 0x7f, 0x36, 0xbf, 0xc8, 0x4c, 0xfa, 0xd6, 0x54, 0xcf, 0x93, 0x7c, 0xcd, 0xeb,
 0x9b, 0x7c, 0x39, 0x3a, 0xfe, 0x66, 0x23, 0xe4, 0x26, 0x7d, 0x7b, 0x2a, 0x7a, 0x1b, 0xfc, 0x59,
 0xd5, 0x1f, 0x32, 0xfb, 0x67, 0x33, 0x1c, 0xfa, 0xff, 0x00, 0xf1, 0x8f, 0xd6, 0xca, 0x12, 0x86,
 0x84, 0x72, 0xa6, 0x5e, 0x95, 0x3d, 0x08, 0xe5, 0x4c, 0xdc, 0x8b, 0x39, 0x38, 0xb2, 0x8c, 0xa9,
 0xe8, 0x47, 0x2a, 0x65, 0xe9, 0x40, 0x8e, 0x54, 0xf4, 0x2f, 0x16, 0x64, 0x8b, 0x28, 0xca, 0x99,
 0x14, 0xa0, 0x5e, 0x94, 0x08, 0xe5, 0x02, 0xf1, 0x65, 0xe2, 0xca, 0x32, 0xa6, 0x47, 0x28, 0x17,
 0xa5, 0x4c, 0x8e, 0x54, 0xcb, 0xc5, 0x99, 0x22, 0xca, 0x32, 0xa6, 0x47, 0x2a, 0x65, 0xe9, 0x53,
 0x23, 0x94, 0x0c, 0x91, 0x65, 0xe2, 0xca, 0x32, 0xa6, 0x47, 0x2a, 0x65, 0xe9, 0x40, 0x8a, 0x54,
 0xcb, 0xc5, 0x99, 0x22, 0xca, 0x52, 0x81, 0x14, 0xa9, 0x97, 0xa5, 0x02, 0x39, 0x53, 0x2f, 0x16,
 0x5e, 0x2c, 0xa3, 0x2a, 0x64, 0x72, 0x81, 0x7a, 0x54, 0xc8, 0xe5, 0x4c, 0xc9, 0x16, 0x64, 0x8b,
 0x28, 0xca, 0x99, 0x1c, 0xa0, 0x5e, 0x95, 0x32, 0x39, 0x53, 0x2f, 0x16, 0x5e, 0x2c, 0xa3, 0x2a,
 0x64, 0x52, 0xa6, 0x5f, 0x95, 0x32, 0x29, 0x53, 0x2f, 0x16, 0x64, 0x8b, 0x29, 0x4a, 0x06, 0x8e,
 0x25, 0xc9, 0x53, 0x23, 0x95, 0x33, 0x24, 0x59, 0x78, 0xb2, 0xab, 0x46, 0xae, 0x25, 0x89, 0x40,
 0xd1, 0xc7, 0x81, 0x68, 0x95, 0xe2, 0x50, 0x34, 0x61, 0xa2, 0x57, 0x13, 0x0e, 0x25, 0xb6, 0x9d,
 0xa1, 0x68, 0xd5, 0xc4, 0x99, 0xc4, 0xd5, 0xa2, 0x76, 0xb6, 0xd1, 0x34, 0x6a, 0xe2, 0x4c, 0xd1,
 0xab, 0x44, 0xed, 0x3b, 0x42, 0xd1, 0x86, 0x89, 0x9c, 0x4d, 0x5a, 0x2d, 0xb4, 0xed, 0x0b, 0x46,
 0xad, 0x13, 0x38, 0x9a, 0xb4, 0x4e, 0xd6, 0xda, 0x26, 0x8d, 0x5a, 0x26, 0x68, 0xd5, 0xa2, 0x76,
 0x9d, 0xa1, 0x71, 0x35, 0x68, 0x99, 0xc4, 0xc3, 0x45, 0xb6, 0xb6, 0xd0, 0xb4, 0x6a, 0xd1, 0x33,
 0x89, 0xab, 0x44, 0xed, 0x3b, 0x44, 0xe2, 0x6a, 0xe2, 0x4c, 0xd1, 0xab, 0x44, 0xed, 0x6d, 0xa1,
 0x68, 0xd5, 0xc4, 0x99, 0xc4, 0xc3, 0x89, 0x3b, 0x4e, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x46, 0xae,
 0x25, 0xb6, 0x9d, 0xa2, 0x71, 0x35, 0x71, 0x25, 0x68, 0xc3, 0x44, 0xed, 0x6d, 0xa1, 0xe0, 0x6a,
 0xe2, 0x4c, 0xd1, 0x87, 0x12, 0x76, 0x9d, 0xa1, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x2d, 0xb5,
 0xb6, 0x89, 0xa3, 0x57, 0x12, 0x67, 0x13, 0x56, 0x89, 0xda, 0x62, 0x50, 0xb8, 0x9a, 0xb4, 0x4c,
 0xd1, 0x86, 0x89, 0xda, 0xd1, 0x28, 0x5a, 0x35, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0xdb, 0x4e, 0xd0,
 0xb4, 0x61, 0xa2, 0x57, 0x13, 0x0d, 0x13, 0xb4, 0xed, 0x0b, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4,
 0x5b, 0x6b, 0x44, 0xa2, 0x68, 0xd5, 0xa2, 0x67, 0x13, 0x57, 0x12, 0x62, 0x53, 0xb4, 0x2d, 0x18,
 0x68, 0x95, 0xa3, 0x0d, 0x13, 0xb5, 0xa2, 0x50, 0xb8, 0x9a, 0xb8, 0x93, 0x38, 0x9a, 0xb4, 0x5b,
 0x69, 0xda, 0x26, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x71, 0x27, 0x6b, 0x6d, 0x0b, 0x46, 0xb3, 0xe5,
 0x84, 0x5c, 0xa4, 0xd4, 0x62, 0x97, 0x16, 0xdb, 0xe8, 0x44, 0xcd, 0x1d, 0x2b, 0x69, 0x33, 0x79,
 0x63, 0x2b, 0x4b, 0x0d, 0x42, 0x4d, 0x61, 0xe0, 0xf8, 0x36, 0x9f, 0xdd, 0xbf, 0x0f, 0xac, 0x68,
 0x78, 0x8f, 0x88, 0xe3, 0xe0, 0xe2, 0xf4, 0xed, 0xed, 0x99, 0xf7, 0x47, 0xcd, 0xb3, 0xc5, 0xe3,
 0xdb, 0x91, 0x7d, 0x47, 0xb9, 0x73, 0x35, 0xda, 0x28, 0xc5, 0xba, 0x58, 0x18, 0xa9, 0x3e, 0xa7,
 0x56, 0x4b, 0xa3, 0xd8, 0x47, 0x5e, 0xc4, 0xe2, 0x2b, 0xe2, 0x27, 0xcf, 0x5e, 0xac, 0xea, 0x3d,
 0x5f, 0x51, 0x10, 0x3e, 0x7f, 0xcc, 0xf1, 0x2e, 0x47, 0x32, 0xdb, 0xc9, 0x6f, 0x67, 0xcb, 0xe0,
 0xe8, 0xb0, 0xf1, 0xb1, 0xe1, 0x8f, 0xdd, 0x80, 0x00, 0x68, 0xb3, 0x80, 0x00, 0x24, 0xa1, 0x5a,
 0xad, 0x09, 0xf3, 0xd1, 0xa9, 0x28, 0x4b, 0xc2, 0x99, 0xcd, 0xe5, 0xb9, 0xda, 0x93, 0x54, 0xf1,
 0x89, 0x27, 0xd4, 0xaa, 0x25, 0xf0, 0xa3, 0x80, 0x06, 0xff, 0x00, 0x0b, 0xc4, 0xb9, 0x1c, 0x2b,
 0x6f, 0x15, 0xbd, 0x9f, 0x2f, 0x83, 0x0e, 0x5c, 0x14, 0xcb, 0x1f, 0xbd, 0x0e, 0xf4, 0xb8, 0x34,
 0x9a, 0x69, 0xa7, 0xd4, 0xd7, 0x7c, 0x1d, 0x73, 0x21, 0xcc, 0xdd, 0x09, 0xac, 0x35, 0x79, 0x7d,
 0xa6, 0x4f, 0xd2, 0xb7, 0xf7, 0xaf, 0xb0, 0xec, 0xcd, 0x1f, 0x46, 0xf0, 0xdf, 0x11, 0xc7, 0xcf,
 0xc5, 0xd4, 0xa7, 0xb2, 0x7e, 0x31, 0xf2, 0x78, 0x59, 0xf0, 0x5b, 0x0d, 0xbd, 0x19, 0x68, 0x0c,
 0xb4, 0x60, 0xf4, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x72,
 0xc2, 0xb6, 0xa4, 0xf0, 0xad, 0xa9, 0xc4, 0x42, 0xae, 0xa4, 0xf0, 0xac, 0x7e, 0x72, 0x89, 0x7a,
 0x31, 0x77, 0x31, 0x4e, 0xb6, 0xa4, 0xf4, 0xeb, 0x6a, 0x70, 0xd0, 0xad, 0xa9, 0x62, 0x15, 0xb5,
 0x26, 0x25, 0x92, 0x2e, 0xe6, 0x69, 0xd7, 0xd4, 0xb3, 0x4e, 0xbe, 0xa7, 0x09, 0x4e, 0xb6, 0xa4,
 0xf4, 0xeb, 0x6a, 0x5a, 0x25, 0x92, 0x2e, 0xe7, 0x69, 0x62, 0x35, 0x2c, 0xd2, 0xc4, 0xea, 0x70,
 0x34, 0xeb, 0xea, 0x58, 0xa7, 0x5f, 0x52, 0xd1, 0x2c, 0xb1, 0x77, 0x62, 0xa5, 0x8a, 0xd4, 0xbb,
 0x43, 0x18, 0xd7, 0x0e, 0x12, 0x3a, 0xcd, 0x3c, 0x46, 0xa5, 0x9a, 0x58, 0x9d, 0x4b, 0x45, 0x99,
 0x6b, 0x91, 0xda, 0xe9, 0x63, 0x23, 0x35, 0xc2, 0x69, 0x32, 0x47, 0x0a, 0x55, 0x57, 0xa5, 0x6b,
 0xd6, 0x3a, 0xdd, 0x2c, 0x57, 0x0e, 0xf9, 0x72, 0x8e, 0x2d, 0xae, 0xf9, 0x78, 0xbc, 0xc3, 0x27,
 0xa5, 0x16, 0xf7, 0xbe, 0x24, 0xff, 0x00, 0xb4, 0x32, 0x9d, 0xad, 0xf4, 0xe5, 0x11, 0xe1, 0xfe,
 0xee, 0xd1, 0x7f, 0xe2, 0x71, 0x27, 0xcd, 0xe7, 0xd1, 0x9f, 0xf6, 0x82, 0x55, 0x75, 0xb7, 0xcb,
 0x94, 0x49, 0xbe, 0x3c, 0x36, 0x76, 0x8a, 0xff, 0x00, 0x13, 0x89, 0x3e, 0x73, 0x3d, 0x8c, 0x33,
 0xbc, 0x71, 0x2b, 0x44, 0x44, 0x47, 0xb0, 0x00, 0x19, 0x52, 0xf5, 0x59, 0x79, 0x9d, 0xb7, 0xc6,
 0xba, 0xf6, 0x3f, 0xf6, 0x96, 0x13, 0xeb, 0x4d, 0x5f, 0x99, 0xef, 0x7b, 0xeb, 0xaf, 0x64, 0x3f,
 0x68, 0xe1, 0x7e, 0xb4, 0xfd, 0x15, 0xad, 0x84, 0xd0, 0xa7, 0x5b, 0x09, 0xa1, 0x86, 0xb9, 0xb6,
 0xf1, 0xf2, 0x73, 0x79, 0x35, 0xf7, 0x44, 0x7f, 0x7f, 0xf2, 0xfc, 0xf4, 0x7e, 0x67, 0xed, 0xee,
 0xae, 0xbd, 0x91, 0xfd, 0xa3, 0x85, 0xfa, 0xd3, 0x57, 0xb8, 0x0d, 0xed, 0xae, 0xbd, 0x92, 0xfd,
 0xa3, 0x85, 0xfa, 0xd3, 0xf4, 0x06, 0xae, 0x15, 0xae, 0xf1, 0x56, 0xa5, 0x06, 0xba, 0xd1, 0x92,
 0x2d, 0x12, 0xd2, 0xbf, 0x8b, 0x72, 0xab, 0xfc, 0xb1, 0xe5, 0x3f, 0xe5, 0xf0, 0x33, 0xdc, 0x1e,
 0xf6, 0x57, 0xfb, 0xa7, 0xfb, 0x43, 0x0b, 0xf5, 0x86, 0x1e, 0xe1, 0xb7, 0xb0, 0xba, 0xf6, 0x53,
 0xf6, 0x86, 0x17, 0xeb, 0x0f, 0xbc, 0xe7, 0x4b, 0x42, 0x19, 0xd2, 0xd0, 0xc9, 0x1a, 0x6b, 0x5b,
 0xc7, 0x79, 0x71, 0xfc, 0xb5, 0xf2, 0x9f, 0xf2, 0xf8, 0x41, 0xee, 0x23, 0x7a, 0xcb, 0xaf, 0x65,
 0x7f, 0x68, 0x61, 0xbe, 0xb0, 0xc3, 0xdc, 0x5e, 0xf5, 0x17, 0x5e, 0xcb, 0x7f, 0x8f, 0xc3, 0x7d,
 0x61, 0xf7, 0x4c, 0xe9, 0x68, 0x43, 0x3a, 0x45, 0xa2, 0xb5, 0x60, 0xb7, 0xda, 0x2e, 0x64, 0x7f,
 0x2d, 0x7c, 0xa7, 0xfc, 0xbe, 0x50, 0xdc, 0x7e, 0xea, 0x76, 0xf7, 0x66, 0xf7, 0x9b, 0x96, 0x67,
 0x19, 0xde, 0x43, 0xe7, 0x4c, 0x05, 0x08, 0xd6, 0x55, 0x2a, 0xf9, 0xee, 0x84, 0xf9, 0x79, 0xa9,
 0x4e, 0x2b, 0xa2, 0x33, 0x6d, 0xf4, 0xb4, 0xba, 0x8f, 0xa4, 0xe7, 0x47, 0x43, 0x96, 0x9d, 0x1d,
 0x08, 0x27, 0x4b, 0x43, 0x3e, 0x39, 0x8a, 0xc6, 0xa1, 0xce, 0x78, 0xa7, 0x27, 0x2f, 0x88, 0x65,
 0x8c, 0xb9, 0x62, 0x22, 0x62, 0x35, 0xec, 0xff, 0x00, 0xfb, 0x3f, 0x37, 0x15, 0x3a, 0x5a, 0x10,
 0xce, 0x91, 0xca, 0xce, 0x96, 0x84, 0x33, 0xa5, 0xa1, 0x9a, 0x2e, 0xf1, 0x6f, 0xc7, 0xd3, 0x8b,
 0x95, 0x3d, 0x08, 0xe5, 0x4f, 0x43, 0x91, 0x9d, 0x22, 0x19, 0xd2, 0x32, 0xc5, 0xd8, 0x26, 0xb6,
 0xab, 0x8f, 0x94, 0x08, 0xe5, 0x4c, 0xbf, 0x2a, 0x64, 0x52, 0xa7, 0xa1, 0x78, 0xb2, 0x22, 0xca,
 0x32, 0xa6, 0x47, 0x2a, 0x65, 0xe9, 0x53, 0x23, 0x95, 0x33, 0x24, 0x59, 0x92, 0x2c, 0xa3, 0x2a,
 0x64, 0x72, 0xa6, 0x5e, 0x95, 0x32, 0x39, 0x53, 0x2f, 0x16, 0x5e, 0x2c, 0xa3, 0x2a, 0x64, 0x72,
 0xa6, 0x5e, 0x95, 0x32, 0x29, 0x53, 0xd0, 0xbc, 0x59, 0x78, 0xb2, 0x8c, 0xa1, 0xa1, 0x1c, 0xa9,
 0x97, 0xa5, 0x02, 0x39, 0x53, 0x32, 0x45, 0x99, 0x22, 0xea, 0x32, 0xa6, 0x47, 0x28, 0x68, 0x5e,
 0x94, 0x08, 0xe5, 0x4c, 0xbc, 0x59, 0x78, 0xb2, 0x8c, 0xa9, 0x91, 0xca, 0x9e, 0x85, 0xe9, 0x40,
 0x8e, 0x50, 0x2f, 0x16, 0x64, 0x8b, 0x28, 0xca, 0x99, 0x1c, 0xa9, 0x97, 0xa5, 0x4c, 0x8a, 0x50,
 0x2f, 0x16, 0x5e, 0x2c, 0xa3, 0x2a, 0x64, 0x72, 0x81, 0x7a, 0x54, 0xc8, 0xe5, 0x4c, 0xc9, 0x16,
 0x64, 0x8b, 0x28, 0xca, 0x99, 0x1c, 0xa9, 0x97, 0xa5, 0x02, 0x39, 0x53, 0x2f, 0x16, 0x5e, 0x2c,
 0xa3, 0x2a, 0x64, 0x6e, 0x05, 0xe9, 0x53, 0x22, 0x94, 0x0b, 0xc5, 0x99, 0x22, 0xca, 0x6e, 0x26,
 0xae, 0x25, 0xa9, 0x53, 0x23, 0x94, 0x0b, 0xc5, 0x97, 0x8b, 0x20, 0x71, 0x35, 0x68, 0x99, 0xc7,
 0x81, 0xab, 0x45, 0xa2, 0x56, 0xda, 0x16, 0x8c, 0x34, 0x4a, 0xe2, 0x61, 0xa2, 0x62, 0x53, 0xb4,
 0x2e, 0x26, 0xae, 0x24, 0xcd, 0x18, 0x68, 0xb6, 0xd6, 0xda, 0x16, 0x8d, 0x5a, 0x26, 0x71, 0x35,
 0x68, 0x9d, 0xa7, 0x68, 0x5a, 0x30, 0xd1, 0x2b, 0x89, 0x87, 0x12, 0x76, 0x9d, 0xa1, 0x68, 0xd5,
 0xa2, 0x66, 0x8d, 0x5a, 0x2d, 0xb5, 0xb6, 0x89, 0xa3, 0x57, 0x12, 0x66, 0x8d, 0x5c, 0x49, 0xda,
 0x76, 0x85, 0xa3, 0x0d, 0x12, 0xb4, 0x61, 0xc4, 0x9d, 0xad, 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x34,
 0x6a, 0xd1, 0x6d, 0xa7, 0x68, 0x5c, 0x4c, 0x34, 0x4c, 0xd1, 0xab, 0x89, 0x3b, 0x4e, 0xd0, 0xb4,
 0x6a, 0xd1, 0x33, 0x89, 0x86, 0x89, 0xda, 0xdb, 0x42, 0xd1, 0xab, 0x89, 0x33, 0x46, 0xad, 0x16,
 0x89, 0x4c, 0x4a, 0x27, 0x13, 0x56, 0x89, 0x9a, 0x35, 0x68, 0x9d, 0xad, 0x12, 0x85, 0xc4, 0xd5,
 0xa2, 0x67, 0x13, 0x0d, 0x13, 0xb4, 0xed, 0x0b, 0x46, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x6d, 0xad,
 0xb4, 0x4e, 0x26, 0xad, 0x13, 0x34, 0x6b, 0xc0, 0x9d, 0xa7, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xc4,
 0xd5, 0xc4, 0x9d, 0xa7, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8b, 0x6d, 0x68, 0x94, 0x4e,
 0x26, 0xae, 0x24, 0xad, 0x18, 0x68, 0x9d, 0xa7, 0x68, 0x5a, 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12,
 0x76, 0xb6, 0xd1, 0x34, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x16, 0xda, 0x62, 0x5d, 0x7f, 0x6c, 0x31,
 0xaf, 0x09, 0x96, 0xd9, 0x83, 0xe1, 0x52, 0xbb, 0x71, 0x5a, 0x47, 0xbe, 0xfe, 0x6f, 0x64, 0xe8,
 0xc7, 0x37, 0xb6, 0x78, 0x9b, 0xf9, 0xd4, 0xe9, 0xa7, 0xe9, 0x68, 0xc5, 0x41, 0x7a, 0xfd, 0x6f,
 0xe1, 0xf7, 0x8e, 0x10, 0xf9, 0xdf, 0x8d, 0xf2, 0xa7, 0x91, 0xcb, 0xb7, 0xca, 0xbe, 0xc8, 0xfe,
 0x9e, 0xff, 0x00, 0xee, 0xea, 0x78, 0x18, 0xba, 0x78, 0x63, 0xe7, 0x3e, 0xd0, 0x02, 0xd6, 0x57,
 0x84, 0x96, 0x3b, 0x1f, 0x4b, 0x0b, 0x17, 0xc3, 0x9d, 0xf4, 0xbf, 0x02, 0xef, 0xb3, 0xcc, 0xc7,
 0x4b, 0x64, 0xb4, 0x52, 0xbe, 0xf9, 0x6e, 0x5a, 0xd1, 0x58, 0x99, 0x9f, 0x74, 0x33, 0x97, 0xe5,
 0xf8, 0xbc, 0x7c, 0xdc, 0x70, 0xf4, 0x9c, 0x92, 0xeb, 0x93, 0xe8, 0x8a, 0xf6, 0x4e, 0x62, 0x96,
 0xca, 0xd6, 0x71, 0x57, 0x71, 0x90, 0x8b, 0xf0, 0x46, 0x0e, 0x5f, 0x3a, 0x3b, 0x4e, 0x1b, 0x0d,
 0x4b, 0x0d, 0x42, 0x34, 0x28, 0xc1, 0x42, 0x11, 0x5c, 0x12, 0x46, 0xed, 0x1d, 0xc7, 0x13, 0xec,
 0xe7, 0x1a, 0x94, 0x8e, 0xb7, 0xef, 0x4f, 0xd7, 0x51, 0xfd, 0x9e, 0x06, 0x5f, 0x13, 0xcb, 0x6b,
 0x7e, 0xe7, 0xb2, 0x1d, 0x3e, 0xbe, 0xcb, 0xe2, 0x63, 0x1e, 0x34, 0x71, 0x14, 0xea, 0x3f, 0x04,
 0x93, 0x8f, 0x69, 0xc2, 0xe2, 0xb0, 0xd5, 0xf0, 0xb5, 0x5d, 0x2c, 0x45, 0x39, 0x53, 0x9a, 0xef,
 0x3e, 0xf9, 0xe9, 0x0d, 0x14, 0xb3, 0x7c, 0xbe, 0x9e, 0x3f, 0x09, 0x2a, 0x52, 0x49, 0x4d, 0x2e,
 0x30, 0x97, 0xe2, 0xb3, 0x1f, 0x3b, 0xec, 0xe6, 0x1b, 0x52, 0x6d, 0xc7, 0xf6, 0x5a, 0x3e, 0x1e,
 0xf8, 0x9f, 0x35, 0xf0, 0x78, 0x9d, 0xe2, 0xda, 0xc9, 0xed, 0x87, 0x9f, 0x83, 0x69, 0xc6, 0x50,
 0x9c, 0xa1, 0x25, 0xc2, 0x51, 0x7c, 0x1a, 0xf0, 0x33, 0x53, 0x88, 0x98, 0xd3, 0xdd, 0x0e, 0xdd,
 0xb3, 0xb8, 0xa7, 0x8a, 0xc0, 0x28, 0xcd, 0xf1, 0xa9, 0x49, 0xf2, 0xbd, 0x57, 0x79, 0xff, 0x00,
 0xef, 0xc0, 0x75, 0x13, 0x98, 0xd9, 0x3a, 0xae, 0x19, 0x93, 0xa5, 0xde, 0xa9, 0x06, 0xb8, 0x6a,
 0xba, 0x7b, 0x4f, 0x6b, 0xc0, 0x39, 0x53, 0xc7, 0xe6, 0x56, 0x3e, 0x16, 0xf6, 0x4f, 0xfa, 0x7f,
 0x76, 0x9f, 0x3b, 0x1c, 0x5f, 0x0c, 0xcf, 0xc6, 0x3d, 0xae, 0xce, 0xe2, 0x6a, 0xd1, 0x33, 0x46,
 0x1a, 0x3e, 0x93, 0xb7, 0x3f, 0xb4, 0x2d, 0x18, 0xe0, 0xc9, 0x5a, 0x35, 0x68, 0x98, 0x94, 0xed,
 0x18, 0x37, 0x71, 0x35, 0x68, 0xb6, 0xd2, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xb1, 0xa1,
 0x57, 0x52, 0x68, 0x55, 0xd4, 0xe2, 0xe1, 0x54, 0x9a, 0x15, 0x4f, 0xcd, 0xdb, 0x6c, 0xc5, 0x9c,
 0xac, 0x2a, 0x93, 0x42, 0xb6, 0xa7, 0x15, 0x0a, 0xa4, 0xd0, 0xab, 0xa9, 0x6d, 0xaf, 0x16, 0x72,
 0xd0, 0xad, 0xa9, 0x3d, 0x3a, 0xda, 0x9c, 0x44, 0x2a, 0xea, 0x4d, 0x0a, 0xda, 0x93, 0xb5, 0xe2,
 0xce, 0x5e, 0x9d, 0x6d, 0x4b, 0x10, 0xaf, 0xa9, 0xc3, 0xc2, 0xb6, 0xa4, 0xf0, 0xad, 0xa9, 0x68,
 0x96, 0x48, 0xbb, 0x99, 0xa7, 0x5f, 0x52, 0xc5, 0x3a, 0xfa, 0x9c, 0x2c, 0x2b, 0x13, 0xd3, 0xad,
 0xa9, 0x31, 0x2c, 0x91, 0x77, 0x37, 0x4f, 0x11, 0xa9, 0x6a, 0x9e, 0x23, 0x53, 0x82, 0xa7, 0x5b,
 0x52, 0x7a, 0x75, 0xf5, 0x2d, 0xb6, 0x58, 0xbb, 0xe4, 0x5f, 0x37, 0x7c, 0xee, 0x6f, 0x77, 0x2a,
 0x7f, 0x98, 0x28, 0xaf, 0xf1, 0x18, 0x83, 0xe7, 0xe3, 0xde, 0x7c, 0xdc, 0x13, 0xe7, 0xde, 0xbe,
 0x56, 0xff, 0x00, 0x31, 0x52, 0xf9, 0x7a, 0xe7, 0x83, 0x1e, 0xef, 0x1f, 0xee, 0xaa, 0xdc, 0xa4,
 0xee, 0xb0, 0x00, 0x0c, 0xcb, 0x3f, 0x60, 0xe5, 0x46, 0x15, 0x17, 0x18, 0x34, 0xca, 0xb5, 0xb0,
 0x9a, 0x15, 0x28, 0x63, 0x1a, 0xe1, 0xd2, 0x5e, 0xa3, 0x8d, 0x4d, 0x70, 0x97, 0x06, 0x8f, 0x16,
 0xb9, 0x26, 0x18, 0xed, 0x8e, 0x97, 0x50, 0xad, 0x84, 0xd0, 0xa5, 0x5b, 0x0b, 0xa1, 0xd8, 0xd5,
 0x9a, 0xab, 0xa1, 0xf0, 0x7a, 0x91, 0x56, 0xc2, 0xe8, 0x6c, 0x53, 0x33, 0x47, 0x37, 0x02, 0x27,
 0xdc, 0xea, 0xb5, 0xb0, 0xba, 0x15, 0x6a, 0x61, 0xda, 0xef, 0x1d, 0xa2, 0xb6, 0x13, 0x42, 0x9d,
 0x6c, 0x26, 0x86, 0xc5, 0x73, 0x3c, 0x9c, 0xdc, 0x0d, 0x3a, 0xdc, 0xe8, 0xe8, 0x41, 0x3a, 0x5a,
 0x1c, 0xf5, 0x6c, 0x2e, 0x85, 0x4a, 0xb8, 0x66, 0xbb, 0xc6, 0x7a, 0xe4, 0xdb, 0xcc, 0xcb, 0xc4,
 0x98, 0xf8, 0x38, 0x69, 0xd2, 0x21, 0x9d, 0x2d, 0x0e, 0x5a, 0xa5, 0x16, 0xbb, 0xc4, 0x13, 0xa5,
 0xa1, 0x9a, 0x2e, 0xd0, 0xc9, 0xc7, 0x71, 0x33, 0xa5, 0xa1, 0x43, 0x38, 0xc4, 0xe1, 0x32, 0xbc,
 0xaf, 0x17, 0x99, 0xe3, 0xea, 0xd9, 0xc2, 0x61, 0x28, 0x4e, 0xbd, 0x7a, 0x9c, 0xae, 0x5c, 0x94,
 0xe1, 0x17, 0x29, 0x3e, 0x09, 0x36, 0xf8, 0x24, 0xfa, 0x12, 0xe2, 0x73, 0xf3, 0xa4, 0x75, 0x2d,
 0xed, 0x52, 0xe1, 0xba, 0xdd, 0xad, 0x7c, 0x3a, 0xb2, 0x4c, 0x67, 0xc8, 0x4c, 0xc9, 0x17, 0x6b,
 0xc7, 0x16, 0x2d, 0x78, 0xac, 0xfc, 0x65, 0xd1, 0xe5, 0xbe, 0xed, 0xd6, 0x3e, 0xad, 0xa8, 0xfd,
 0x9f, 0x89, 0xfa, 0xb2, 0x39, 0x6f, 0xb3, 0x75, 0xaf, 0xfd, 0xe7, 0xff, 0x00, 0x01, 0x89, 0xfa,
 0xb3, 0xe3, 0x00, 0x47, 0x5a, 0xce, 0xaa, 0x7e, 0xc9, 0x70, 0xa7, 0xf9, 0xad, 0xe7, 0x1f, 0xe1,
 0xf6, 0x54, 0xb7, 0xd3, 0xba, 0xf7, 0xfe, 0xf3, 0xff, 0x00, 0x80, 0xc4, 0xfd, 0x59, 0xdd, 0xb2,
 0xec, 0x46, 0x17, 0x33, 0xcb, 0x70, 0xb9, 0x96, 0x06, 0xa5, 0xdc, 0x2e, 0x2e, 0x8c, 0x2b, 0xd0,
 0xa9, 0xca, 0xe3, 0xcf, 0x09, 0x45, 0x4a, 0x2f, 0x83, 0xe0, 0xd7, 0x14, 0xd7, 0x43, 0xe9, 0x3f,
 0x3f, 0xcf, 0xb4, 0x28, 0x6d, 0x66, 0x59, 0xb1, 0x1b, 0x8a, 0xd9, 0xdc, 0xf3, 0x32, 0x7c, 0xed,
 0x64, 0xd8, 0x38, 0x61, 0xe8, 0x27, 0xc2, 0x55, 0xea, 0xba, 0x11, 0xe1, 0x05, 0xf0, 0xb7, 0xde,
 0x49, 0xb3, 0x2e, 0x3c, 0xd3, 0x3e, 0xf7, 0x83, 0xe3, 0x5f, 0x67, 0x31, 0x71, 0x63, 0x1c, 0x71,
 0xf7, 0x36, 0xb4, 0xeb, 0x53, 0xaf, 0xf4, 0x88, 0x73, 0xbb, 0x55, 0x9f, 0xe4, 0x7b, 0x31, 0x97,
 0xf9, 0xfb, 0x3d, 0xcc, 0xa8, 0x60, 0xa8, 0xf4, 0xa8, 0xf3, 0xbf, 0x4d, 0x37, 0xe0, 0x8c, 0x57,
 0x4c, 0x9e, 0x89, 0x1e, 0x49, 0x9d, 0x79, 0xa1, 0x72, 0x0a, 0x15, 0xa5, 0x0c, 0xab, 0x22, 0xc7,
 0xe3, 0xa2, 0x9f, 0x0e, 0x7a, 0xb5, 0x23, 0x45, 0x4b, 0x55, 0xf7, 0x4f, 0xdb, 0xe0, 0x78, 0x3e,
 0xd9, 0xed, 0x3e, 0x6f, 0xb5, 0xb9, 0xed, 0x6c, 0xe3, 0x39, 0xc4, 0xba, 0xb5, 0xaa, 0x3e, 0x10,
 0x82, 0xe8, 0x85, 0x28, 0x77, 0xa1, 0x05, 0xde, 0x4b, 0xf7, 0xbe, 0x2c, 0xe1, 0x4a, 0xdb, 0x93,
 0x6f, 0xe5, 0x7a, 0xbc, 0x0f, 0xb1, 0xfc, 0x5c, 0x74, 0x89, 0xe4, 0xcc, 0xda, 0xdf, 0x2d, 0xea,
 0x23, 0xcb, 0xda, 0xfa, 0x0f, 0x0d, 0xe6, 0x89, 0xc1, 0x4e, 0x69, 0x62, 0xb6, 0x52, 0xbd, 0x28,
 0x77, 0xdd, 0x3c, 0x6a, 0x9b, 0xf6, 0x9c, 0x22, 0x77, 0x1d, 0x9a, 0xde, 0xfe, 0xc3, 0x67, 0x95,
 0x23, 0x45, 0xe6, 0x13, 0xcb, 0x2b, 0xcb, 0xa1, 0x53, 0xc7, 0x42, 0xda, 0x6f, 0xfa, 0xe9, 0xb8,
 0xfb, 0x6d, 0x1f, 0x25, 0x82, 0x2b, 0xca, 0xc9, 0x1e, 0xf6, 0xde, 0x7f, 0xb2, 0x7e, 0x1f, 0x92,
 0x35, 0x48, 0x9a, 0xcf, 0xe5, 0x33, 0x3f, 0xae, 0xdf, 0x78, 0x45, 0x42, 0xa4, 0x23, 0x52, 0x9c,
 0xa3, 0x38, 0x49, 0x71, 0x8c, 0xa2, 0xf8, 0xa6, 0xbc, 0x28, 0xd2, 0x54, 0xce, 0xa3, 0xb8, 0x6c,
 0x8e, 0xb6, 0x4f, 0xbb, 0x0c, 0xb2, 0x18, 0x99, 0x54, 0x75, 0xb1, 0x69, 0xe2, 0xdc, 0x65, 0x26,
 0xf9, 0x14, 0xfa, 0x62, 0x97, 0x1e, 0xa5, 0xcb, 0xca, 0xf8, 0x78, 0x5b, 0x3b, 0xc4, 0xa9, 0x9e,
 0x95, 0x2f, 0xb8, 0x89, 0x7c, 0xd7, 0x93, 0x4a, 0xe1, 0xcf, 0x7c, 0x75, 0xb6, 0xe2, 0xb3, 0x31,
 0xbf, 0x9e, 0x94, 0x65, 0x4c, 0x8a, 0xaa, 0x8d, 0x38, 0x4a, 0x73, 0x94, 0x61, 0x08, 0xae, 0x32,
 0x94, 0x9f, 0x04, 0x97, 0x85, 0x95, 0xf6, 0xc7, 0x3f, 0xca, 0xf6, 0x5b, 0x23, 0xad, 0x9b, 0xe6,
 0xd5, 0xad, 0xd0, 0xa7, 0xd1, 0x18, 0xae, 0x99, 0x54, 0x9b, 0xea, 0x84, 0x57, 0x7d, 0xbf, 0xde,
 0xfa, 0x11, 0xf2, 0xb6, 0xf1, 0x77, 0x8b, 0x9f, 0x6d, 0x8e, 0x2a, 0x70, 0xad, 0x5a, 0x58, 0x4c,
 0xb5, 0x4b, 0xed, 0x58, 0x2a, 0x52, 0xf4, 0xbc, 0x3b, 0xce, 0x6f, 0xef, 0xdf, 0xaf, 0xd1, 0xe0,
 0x48, 0xae, 0x5e, 0x4d, 0x71, 0xc7, 0xe6, 0xf5, 0xbc, 0x23, 0xc1, 0x73, 0xf8, 0x94, 0xee, 0xbe,
 0xca, 0x47, 0xbe, 0x7f, 0xc7, 0xcd, 0xee, 0x5b, 0x4b, 0xbd, 0x6d, 0x8b, 0xc9, 0xa7, 0x2a, 0x4b,
 0x30, 0x96, 0x63, 0x5e, 0x3d, 0x70, 0xc1, 0x46, 0xe2, 0xfd, 0x76, 0xd4, 0x7d, 0xa6, 0x74, 0x7c,
 0xcb, 0x7f, 0x09, 0xc9, 0xc7, 0x2f, 0xd9, 0xce, 0x8e, 0xf4, 0xeb, 0xe2, 0x7f, 0xca, 0xa3, 0xf3,
 0x9e, 0x24, 0x0d, 0x2b, 0x73, 0x72, 0xcf, 0xbb, 0xd8, 0xee, 0x38, 0xff, 0x00, 0x65, 0xf8, 0x18,
 0xa3, 0xf7, 0xe2, 0x6d, 0x3f, 0x9c, 0xff, 0x00, 0x8d, 0x3d, 0x56, 0xb6, 0xfc, 0x76, 0x8e, 0x4f,
 0xed, 0x59, 0x4e, 0x53, 0x05, 0xfc, 0xe8, 0xd4, 0x97, 0xf9, 0xd1, 0x14, 0x77, 0xdd, 0xb5, 0x1c,
 0x7d, 0x3e, 0x5b, 0x93, 0x35, 0xa5, 0x2a, 0x8b, 0xfc, 0xe7, 0x97, 0x82, 0x9e, 0xb5, 0x9b, 0xb9,
 0xbb, 0x1e, 0x09, 0xc0, 0x8f, 0xfa, 0x50, 0xf5, 0xac, 0x36, 0xfc, 0x33, 0x44, 0xd7, 0x9e, 0x72,
 0x2c, 0x15, 0x45, 0xdf, 0xb7, 0x56, 0x50, 0xf8, 0x78, 0x9c, 0xf6, 0x57, 0xbe, 0xac, 0x8a, 0xbc,
 0x94, 0x73, 0x1c, 0xaf, 0x1b, 0x83, 0x6f, 0xef, 0xa9, 0xca, 0x35, 0x62, 0xbd, 0x7e, 0xa7, 0xef,
 0x1e, 0x0e, 0x0b, 0xd7, 0x9d, 0x9e, 0xbf, 0x16, 0x2c, 0x9f, 0x67, 0xb8, 0x17, 0x8f, 0xe0, 0xd7,
 0xd2, 0x65, 0xf5, 0x96, 0x41, 0xb4, 0x19, 0x1e, 0xd0, 0x52, 0x75, 0x32, 0x8c, 0xca, 0x86, 0x2b,
 0x82, 0xe3, 0x28, 0x45, 0xf0, 0x9c, 0x56, 0xb1, 0x7c, 0x1a, 0xf6, 0x8e, 0x4a, 0x50, 0x3e, 0x41,
 0xc1, 0xe2, 0xb1, 0x38, 0x3c, 0x4d, 0x3c, 0x4e, 0x12, 0xbd, 0x5a, 0x15, 0xe9, 0xbe, 0x30, 0xa9,
 0x4e, 0x4e, 0x32, 0x8b, 0xd1, 0xa3, 0xdc, 0x37, 0x53, 0xbc, 0xee, 0xeb, 0x57, 0xa5, 0x92, 0x6d,
 0x14, 0xa1, 0x0c, 0x6c, 0xfd, 0x2e, 0x1f, 0x15, 0xc3, 0x96, 0x35, 0x9f, 0xe2, 0xc9, 0x75, 0x29,
 0x78, 0x1f, 0x53, 0xea, 0xeb, 0xeb, 0xf4, 0x78, 0xde, 0x21, 0x17, 0x9f, 0x46, 0xfe, 0xc9, 0x73,
 0x5e, 0x27, 0xf6, 0x77, 0x27, 0x16, 0xb3, 0x97, 0x04, 0xfa, 0x55, 0x8f, 0x7c, 0x7c, 0x63, 0xfc,
 0xbd, 0x2a, 0x50, 0x23, 0x95, 0x32, 0xf4, 0xa1, 0xa1, 0x1c, 0xa9, 0x9e, 0x9c, 0x59, 0xcd, 0xc5,
 0x94, 0x65, 0x4c, 0x8a, 0x54, 0xcb, 0xf2, 0x86, 0x84, 0x52, 0xa6, 0x5e, 0x2c, 0xbc, 0x59, 0xd2,
 0xb1, 0xdb, 0x77, 0xb2, 0x58, 0x3c, 0x6d, 0x7c, 0x1e, 0x27, 0x36, 0xe4, 0xaf, 0x42, 0xa4, 0xa9,
 0xd4, 0x8f, 0x9d, 0xea, 0xbe, 0x59, 0x45, 0xf0, 0x6b, 0x8a, 0x8f, 0x07, 0xd2, 0x8a, 0xf2, 0xde,
 0x1e, 0xc6, 0x3f, 0xc3, 0x1f, 0xe1, 0xab, 0x7d, 0x13, 0xc5, 0xf6, 0xd9, 0x70, 0xdb, 0x3c, 0xf1,
 0x7e, 0x71, 0xc4, 0x7c, 0xa4, 0x8e, 0x1c, 0xf1, 0x2d, 0xe2, 0xd9, 0xab, 0x69, 0x88, 0x88, 0xfe,
 0xff, 0x00, 0xe5, 0xdd, 0xe1, 0xfb, 0x39, 0xc5, 0xbd, 0x2b, 0x69, 0xb5, 0xbd, 0xb1, 0xf3, 0x8f,
 0xf0, 0xf7, 0xc9, 0x6f, 0x07, 0x63, 0x9f, 0xe1, 0x8f, 0xf0, 0xd5, 0x7e, 0x89, 0xcb, 0xe4, 0x99,
 0xb6, 0x5b, 0x9e, 0x60, 0xe7, 0x8b, 0xca, 0xf1, 0x3e, 0x78, 0xa3, 0x0a, 0x8e, 0x9c, 0xa5, 0xc9,
 0x28, 0xf0, 0x92, 0x49, 0xf0, 0xe1, 0x24, 0x9f, 0x53, 0x47, 0xcd, 0x87, 0xb5, 0xee, 0x22, 0x3c,
 0x76, 0x3f, 0x16, 0xff, 0x00, 0xa7, 0xcf, 0xe4, 0xe9, 0x9b, 0x5c, 0x1f, 0x12, 0xcb, 0x9f, 0x2f,
 0xa1, 0x68, 0x8d, 0x7f, 0xbf, 0xcd, 0xa5, 0xe2, 0x9e, 0x0f, 0x83, 0x87, 0xc7, 0xea, 0xd2, 0x66,
 0x67, 0x71, 0xef, 0xd7, 0xf8, 0x77, 0x47, 0x03, 0x8c, 0xce, 0xb3, 0xac, 0xab, 0x27, 0xa6, 0xa7,
 0x99, 0x63, 0xa8, 0xe1, 0xf8, 0xf4, 0xa8, 0xb7, 0xc6, 0x52, 0xf5, 0xa2, 0xba, 0x59, 0xd3, 0x37,
 0x81, 0xbc, 0x65, 0x42, 0xad, 0x4c, 0xb7, 0x67, 0xa7, 0x19, 0x54, 0x8b, 0x71, 0xa9, 0x8b, 0xe0,
 0x9a, 0x4f, 0xc1, 0x0f, 0x0f, 0xaf, 0xd5, 0xe0, 0xf0, 0x9e, 0x55, 0x89, 0xaf, 0x5b, 0x13, 0x5e,
 0x75, 0xf1, 0x15, 0x67, 0x5a, 0xac, 0xdf, 0x19, 0x4e, 0x72, 0x6e, 0x52, 0x7a, 0xb6, 0x64, 0xe5,
 0x78, 0xbd, 0x71, 0xcf, 0xa3, 0x8e, 0x37, 0x3f, 0xd9, 0x5f, 0x0f, 0xf0, 0x1c, 0x99, 0xab, 0x17,
 0xcd, 0x3e, 0x8c, 0x7c, 0xbe, 0x3f, 0xf6, 0x7a, 0xce, 0x3f, 0x7a, 0x19, 0x3d, 0x29, 0x38, 0xe0,
 0xf0, 0x38, 0xbc, 0x4f, 0x0f, 0xbe, 0x97, 0x08, 0x45, 0xfa, 0xdd, 0x6f, 0xde, 0x28, 0x2d, 0xea,
 0xd3, 0xe6, 0xe9, 0xc8, 0xe4, 0x97, 0x87, 0xcf, 0x5f, 0xff, 0x00, 0x93, 0xcc, 0x41, 0xe6, 0x5b,
 0xc5, 0xb9, 0x53, 0x3e, 0xcb, 0x6b, 0xfa, 0x43, 0xdd, 0xaf, 0x81, 0xf0, 0xeb, 0x1a, 0x9a, 0xef,
 0xfa, 0xcb, 0xd7, 0xf2, 0xfd, 0xe5, 0xe4, 0x75, 0xe4, 0xa1, 0x8b, 0xa1, 0x8a, 0xc2, 0x37, 0xd7,
 0x27, 0x15, 0x38, 0xaf, 0x6b, 0xa7, 0xde, 0x3b, 0x6e, 0x5b, 0x98, 0x60, 0x73, 0x2c, 0x3f, 0x9e,
 0x30, 0x18, 0xaa, 0x58, 0x8a, 0x7d, 0xf7, 0x09, 0x71, 0xe1, 0xa3, 0x5d, 0x69, 0xfa, 0xe7, 0xce,
 0x65, 0xbc, 0xab, 0x31, 0xc6, 0xe5, 0x78, 0xc8, 0xe2, 0xf0, 0x18, 0x89, 0xd0, 0xad, 0x1e, 0xfc,
 0x5f, 0x43, 0x5e, 0x06, 0xba, 0x9a, 0xd1, 0x9b, 0x38, 0x3c, 0x6b, 0x2d, 0x67, 0x59, 0x63, 0x71,
 0xfd, 0xda, 0xbc, 0x9f, 0xb3, 0xf8, 0x6d, 0x1b, 0xc3, 0x3a, 0x9f, 0xcf, 0xdb, 0x1f, 0xe5, 0xf4,
 0x4b, 0x46, 0x1c, 0x4e, 0xbd, 0xb0, 0xbb, 0x55, 0x43, 0x68, 0xf0, 0x8e, 0x15, 0x23, 0x1a, 0x38,
 0xfa, 0x31, 0x57, 0x69, 0xae, 0xa9, 0x2f, 0xc6, 0x8e, 0x9f, 0x01, 0xce, 0x66, 0x78, 0xcc, 0x2e,
 0x5d, 0x82, 0xab, 0x8c, 0xc6, 0x56, 0x8d, 0x1a, 0x14, 0xd7, 0x19, 0x4a, 0x5f, 0x06, 0xaf, 0x43,
 0xa1, 0xc7, 0x9e, 0x99, 0x29, 0xd4, 0xac, 0xfb, 0x1c, 0xb6, 0x5c, 0x19, 0x31, 0x64, 0xe9, 0x5a,
 0x3f, 0x79, 0xbb, 0x47, 0x5f, 0xce, 0xb6, 0xb7, 0x21, 0xca, 0xa5, 0x2a, 0x75, 0xf1, 0xaa, 0xad,
 0x68, 0xf5, 0xd2, 0xa2, 0xb9, 0xe5, 0xeb, 0x3e, 0x1d, 0x09, 0xfa, 0xec, 0xf3, 0xcd, 0xb0, 0xdb,
 0x8c, 0x7e, 0x71, 0x39, 0xe1, 0xb0, 0x52, 0x9e, 0x0f, 0x01, 0xd5, 0xcb, 0x17, 0xc2, 0x75, 0x17,
 0xf3, 0x9a, 0xf8, 0x17, 0xbe, 0x75, 0x13, 0xc6, 0xe5, 0x78, 0xdf, 0xa3, 0x3e, 0x8e, 0x18, 0xdf,
 0xe7, 0x2e, 0x87, 0x87, 0xe0, 0x13, 0x68, 0xf4, 0xb3, 0xce, 0xbf, 0x28, 0xff, 0x00, 0x59, 0x7a,
 0x76, 0x27, 0x79, 0xb8, 0x35, 0x2f, 0xfb, 0xbe, 0x55, 0x5e, 0xa4, 0x7c, 0x35, 0x2a, 0xa8, 0x3f,
 0x79, 0x32, 0x2a, 0x7b, 0xcd, 0xa2, 0xdf, 0xdb, 0x32, 0x7a, 0x91, 0x5f, 0xcd, 0xc4, 0x27, 0xfe,
 0x54, 0x79, 0xb0, 0x3c, 0xff, 0x00, 0xda, 0xfc, 0xbd, 0xff, 0x00, 0x17, 0xf6, 0x87, 0xab, 0x1e,
 0x0d, 0xc3, 0x88, 0xd7, 0xa3, 0xfd, 0xe7, 0xfc, 0xbd, 0x7f, 0x2e, 0xdb, 0xec, 0x83, 0x17, 0x25,
 0x0a, 0xb3, 0xaf, 0x84, 0x93, 0xfe, 0x3a, 0x1e, 0x97, 0xdb, 0x8f, 0x1f, 0x7f, 0x81, 0xd9, 0xa8,
 0x55, 0xa3, 0x88, 0xa3, 0x1a, 0xd8, 0x7a, 0xb0, 0xab, 0x4e, 0x4b, 0x8c, 0x67, 0x09, 0x26, 0x9f,
 0xb2, 0x8f, 0x9e, 0x8e, 0x4f, 0x20, 0xcf, 0x33, 0x1c, 0x93, 0x12, 0xab, 0x60, 0xab, 0x35, 0x16,
 0xfd, 0x3d, 0x29, 0x74, 0xc2, 0x7e, 0xba, 0xf9, 0xfa, 0xcd, 0xde, 0x3f, 0x8e, 0xde, 0x27, 0x59,
 0xa3, 0x71, 0xf3, 0x86, 0x8f, 0x27, 0xc0, 0x69, 0x31, 0xbc, 0x33, 0xa9, 0xf9, 0x4b, 0xdd, 0x1c,
 0x4d, 0x5a, 0x38, 0xfd, 0x97, 0xcf, 0x30, 0x99, 0xfe, 0x5c, 0xb1, 0x38, 0x7f, 0x49, 0x52, 0x3d,
 0x15, 0xa9, 0x37, 0xd3, 0x09, 0x7c, 0xeb, 0xc0, 0xce, 0x51, 0xa3, 0xa4, 0xc7, 0x92, 0xb9, 0x2b,
 0x16, 0xac, 0xee, 0x25, 0xcd, 0x64, 0xa5, 0xb1, 0xda, 0x69, 0x78, 0xd4, 0xc2, 0x26, 0x8d, 0x5a,
 0x26, 0x71, 0x35, 0x68, 0xc9, 0xb5, 0x76, 0x85, 0xa3, 0x0d, 0x12, 0xb8, 0x98, 0x68, 0x9d, 0xa7,
 0x68, 0x5c, 0x48, 0x31, 0x98, 0x8c, 0x3e, 0x12, 0x84, 0xab, 0xe2, 0xab, 0x53, 0xa3, 0x4d, 0x75,
 0xca, 0x72, 0xe0, 0x8e, 0x1b, 0x6c, 0x36, 0xa7, 0x0d, 0x92, 0x45, 0xe1, 0xe8, 0xa8, 0xd7, 0xc7,
 0x35, 0xc5, 0x53, 0xe3, 0xe9, 0x61, 0xac, 0xbb, 0x0f, 0x2e, 0xcd, 0x73, 0x3c, 0x76, 0x69, 0x89,
 0x78, 0x8c, 0x76, 0x22, 0x55, 0x67, 0xde, 0x4f, 0xee, 0x62, 0xbc, 0x09, 0x75, 0x23, 0xca, 0xe7,
 0x78, 0xbe, 0x3e, 0x34, 0xfa, 0x15, 0xfd, 0xeb, 0x7f, 0x68, 0x7b, 0x1c, 0x1f, 0x0a, 0xc9, 0xc8,
 0x8f, 0x4e, 0xde, 0xca, 0xfe, 0xaf, 0x40, 0xcc, 0xb6, 0xef, 0x2a, 0xa1, 0x27, 0x0c, 0x25, 0x2a,
 0xd8, 0xb9, 0x2e, 0xfa, 0x5c, 0x91, 0x7e, 0xcb, 0xe9, 0xf7, 0x8e, 0x1a, 0xbe, 0xf0, 0x31, 0xd2,
 0x7f, 0x69, 0xcb, 0xf0, 0xd0, 0x5f, 0xcf, 0x94, 0xa5, 0xf0, 0x70, 0x3a, 0x60, 0x39, 0xfc, 0x9e,
 0x33, 0xcb, 0xbc, 0xfb, 0x2d, 0xaf, 0xa4, 0x3d, 0xec, 0x7e, 0x13, 0xc5, 0xa4, 0x7f, 0x0e, 0xfe,
 0xae, 0xdc, 0xb6, 0xfb, 0x35, 0xe3, 0xe9, 0xb0, 0x98, 0x26, 0xb4, 0x8c, 0x97, 0xf9, 0x8b, 0x58,
 0x6d, 0xe0, 0x4b, 0x8a, 0x58, 0x9c, 0xb6, 0x2d, 0x77, 0xdd, 0x3a, 0xbc, 0x3d, 0xe6, 0xbe, 0x73,
 0xa3, 0x82, 0x95, 0xf1, 0x6e, 0x65, 0x67, 0xd9, 0x7f, 0xd1, 0x92, 0xde, 0x19, 0xc5, 0xb7, 0xf2,
 0x7e, 0xaf, 0x55, 0xcb, 0x76, 0xaf, 0x25, 0xc7, 0x35, 0x0f, 0x3c, 0x3c, 0x35, 0x47, 0xf7, 0xb5,
 0xd7, 0x2f, 0xbf, 0xd5, 0xef, 0x9c, 0xe7, 0x04, 0xd2, 0x69, 0xa6, 0x9f, 0x53, 0x3c, 0x38, 0xe6,
 0x72, 0x0d, 0xa3, 0xcc, 0x32, 0x89, 0xa8, 0xd3, 0x9b, 0xad, 0x87, 0xef, 0xd1, 0x9b, 0xe8, 0xf6,
 0x3c, 0x0c, 0xf5, 0xb8, 0x9f, 0x68, 0x27, 0x7e, 0x8e, 0x78, 0xfe, 0xb1, 0xfe, 0x1e, 0x6f, 0x27,
 0xc1, 0x63, 0x5b, 0xc3, 0x3f, 0xd2, 0x7f, 0xcb, 0xd5, 0x9a, 0x30, 0xd1, 0x5b, 0x24, 0xcd, 0x70,
 0x79, 0xc6, 0x11, 0x62, 0x30, 0x93, 0xe3, 0xc3, 0xa2, 0x70, 0x7f, 0x75, 0x07, 0xe0, 0x65, 0xd7,
 0x13, 0xa6, 0xc7, 0x92, 0xb9, 0x2b, 0x16, 0xac, 0xee, 0x25, 0xe0, 0xda, 0xb6, 0xa5, 0xa6, 0xb6,
 0x8d, 0x4c, 0x21, 0x68, 0xc3, 0x44, 0xad, 0x1a, 0xb8, 0x99, 0x36, 0x8d, 0xa2, 0x68, 0xd5, 0xc4,
 0x99, 0xa3, 0x56, 0x89, 0xda, 0x76, 0x85, 0xa3, 0x0d, 0x13, 0x34, 0x6a, 0xe2, 0x5b, 0x6b, 0x44,
 0xa1, 0x68, 0xc3, 0x44, 0xae, 0x26, 0xad, 0x13, 0x12, 0x9d, 0xa2, 0x68, 0xd5, 0xc4, 0x99, 0xa3,
 0x56, 0x89, 0xda, 0xdb, 0x79, 0x2e, 0x63, 0x56, 0xfe, 0x3f, 0x11, 0x5b, 0x8f, 0x1e, 0x7a, 0xb2,
 0x97, 0xb6, 0xc8, 0x0f, 0x57, 0xab, 0x97, 0xe0, 0x6a, 0xf1, 0xb9, 0x82, 0xc3, 0xcf, 0xfa, 0xd4,
 0x93, 0xf9, 0x8a, 0x95, 0x72, 0x0c, 0xa2, 0xa7, 0xdd, 0x60, 0x29, 0x2f, 0xea, 0xf1, 0x8f, 0xc0,
 0x72, 0x19, 0x7e, 0xcd, 0xe6, 0xb5, 0xa6, 0xd1, 0x78, 0x9d, 0xfd, 0x7f, 0xee, 0xe8, 0x29, 0xe2,
 0xf8, 0xe2, 0x22, 0x26, 0xb2, 0xf3, 0x33, 0xb2, 0x6c, 0x15, 0x15, 0x3c, 0x76, 0x22, 0xb3, 0xfb,
 0xca, 0x6a, 0x2b, 0xd9, 0x7f, 0xb8, 0xe7, 0xaa, 0xec, 0xae, 0x51, 0x2f, 0xb9, 0xa3, 0x52, 0x9f,
 0xf5, 0x6a, 0x3f, 0x9f, 0x89, 0x3e, 0x4f, 0x93, 0x61, 0xb2, 0xa9, 0x55, 0x78, 0x79, 0xd5, 0x95,
 0xde, 0x1c, 0x79, 0xda, 0x7c, 0x38, 0x71, 0xea, 0xe0, 0x97, 0x84, 0xc9, 0xe1, 0xfe, 0x09, 0xc8,
 0xe3, 0xf2, 0xa9, 0x92, 0xfa, 0x98, 0x8f, 0x94, 0xfe, 0x4a, 0xf2, 0x7c, 0x4b, 0x16, 0x5c, 0x36,
 0xad, 0x77, 0xb9, 0x5c, 0x71, 0x35, 0x68, 0x99, 0xa3, 0x56, 0x8e, 0xc3, 0x6f, 0x16, 0x25, 0x0b,
 0x89, 0xab, 0x44, 0xcd, 0x18, 0x68, 0x9d, 0xa7, 0x6f, 0x3b, 0xda, 0x3a, 0x6a, 0x96, 0x77, 0x8a,
 0x8a, 0x5c, 0x13, 0x9f, 0x37, 0xb6, 0x93, 0xf9, 0xce, 0x3c, 0xbf, 0xb4, 0x35, 0x55, 0x5c, 0xef,
 0x15, 0x38, 0xf5, 0x29, 0xf2, 0xfb, 0x5d, 0x1f, 0x31, 0x40, 0xf9, 0x67, 0x33, 0x53, 0xc8, 0xc9,
 0xe8, 0xfb, 0xb7, 0x3f, 0xab, 0xaf, 0xc1, 0xbe, 0x95, 0x77, 0xf2, 0x80, 0xe4, 0x36, 0x75, 0xf0,
 0xce, 0xb0, 0xdc, 0x3f, 0x19, 0xaf, 0x79, 0x9c, 0x79, 0xca, 0x6c, 0xb4, 0x1c, 0xf3, 0xba, 0x1e,
 0x08, 0xf3, 0x49, 0xfb, 0x4c, 0xb7, 0x87, 0xc4, 0xcf, 0x2b, 0x16, 0xbb, 0xa3, 0xf5, 0x47, 0x22,
 0x75, 0x8a, 0xdf, 0x49, 0x77, 0x36, 0x8c, 0x38, 0x92, 0xb4, 0x61, 0xa3, 0xea, 0xbb, 0x72, 0xbb,
 0x42, 0xd1, 0xab, 0x44, 0xcd, 0x1a, 0xb8, 0x93, 0xb5, 0xb6, 0x89, 0xa3, 0x57, 0x12, 0x57, 0x13,
 0x0d, 0x16, 0xda, 0x76, 0x85, 0xa3, 0x1c, 0x09, 0x5a, 0x30, 0xe2, 0x4e, 0xd6, 0xda, 0x2e, 0x06,
 0x09, 0x1a, 0x35, 0x68, 0x9d, 0xa7, 0x6d, 0x41, 0x96, 0x8c, 0x12, 0x3e, 0xab, 0x85, 0x52, 0x58,
 0x55, 0xd4, 0xe3, 0x61, 0x50, 0x96, 0x35, 0x75, 0x3f, 0x35, 0xed, 0x31, 0x67, 0x27, 0x0a, 0xa4,
 0xd0, 0xab, 0xa9, 0xc5, 0xc6, 0xa9, 0x34, 0x6a, 0xea, 0x5b, 0x6b, 0xc5, 0x9c, 0x9c, 0x2a, 0x93,
 0x42, 0xa9, 0xc6, 0x42, 0xa9, 0x2c, 0x2a, 0xea, 0x4e, 0xd7, 0x8b, 0x39, 0x48, 0x55, 0xd4, 0x9e,
 0x15, 0x75, 0x38, 0xa8, 0x55, 0x26, 0x85, 0x5d, 0x49, 0xdb, 0x24, 0x59, 0xca, 0xc2, 0xb6, 0xa4,
 0xf4, 0xeb, 0x6a, 0x71, 0x30, 0xab, 0xa9, 0x34, 0x2b, 0x6a, 0x5b, 0x6b, 0xc5, 0x9c, 0xbc, 0x2b,
 0x6a, 0x4f, 0x4e, 0xb6, 0xa7, 0x0f, 0x0a, 0xda, 0x93, 0xc2, 0xb6, 0xa4, 0xed, 0x92, 0x2e, 0xf9,
 0x63, 0xcd, 0xa5, 0x2e, 0x7d, 0xe9, 0x65, 0x8f, 0xf3, 0x25, 0x2f, 0x97, 0xae, 0x78, 0x71, 0xed,
 0x7e, 0x6c, 0x79, 0x73, 0x6f, 0x37, 0x2d, 0x7f, 0x99, 0x69, 0x7c, 0xb5, 0x73, 0xc5, 0x0e, 0x83,
 0x8d, 0xf7, 0x55, 0x7a, 0x98, 0x67, 0x74, 0x80, 0x00, 0x67, 0x64, 0x7e, 0xa9, 0x52, 0xc4, 0x6a,
 0x5b, 0xa5, 0x89, 0xd4, 0xfc, 0xcb, 0x5b, 0xc7, 0xde, 0x12, 0xea, 0xdb, 0xcd, 0xa9, 0xff, 0x00,
 0xfa, 0xf5, 0xfe, 0x99, 0x95, 0xbc, 0x8d, 0xe2, 0x2e, 0xad, 0xbd, 0xda, 0xaf, 0xff, 0x00, 0xaf,
 0x88, 0xfa, 0x67, 0x99, 0xea, 0x36, 0xf9, 0xb1, 0x45, 0x26, 0x3e, 0x2f, 0xd3, 0xea, 0x38, 0xbe,
 0x1d, 0xf2, 0xfd, 0x0c, 0x73, 0x5d, 0x1c, 0x7a, 0x0f, 0xcb, 0x35, 0xbc, 0xbd, 0xe3, 0x2e, 0xad,
 0xbf, 0xda, 0xbf, 0xff, 0x00, 0xb1, 0x88, 0xfa, 0x66, 0xcb, 0x79, 0xbb, 0xc9, 0x5d, 0x5b, 0xc1,
 0xda, 0xc5, 0xff, 0x00, 0xee, 0x71, 0x1f, 0x4c, 0xb4, 0x70, 0xad, 0xf3, 0x64, 0x8d, 0xc3, 0xf5,
 0x56, 0x15, 0xe8, 0xd4, 0x5c, 0x24, 0xb8, 0x31, 0x53, 0x0f, 0x19, 0xae, 0x31, 0xe0, 0xfd, 0x63,
 0xf2, 0xad, 0x6f, 0x43, 0x79, 0x6b, 0xab, 0x78, 0x9b, 0x5c, 0xbf, 0xfd, 0xd6, 0x23, 0xe9, 0x9b,
 0x2d, 0xea, 0x6f, 0x3e, 0x3d, 0x5b, 0xc7, 0xdb, 0x05, 0xeb, 0x67, 0x78, 0x9f, 0xa6, 0x5e, 0x38,
 0xb7, 0x8f, 0x89, 0x35, 0x8b, 0x7b, 0xe1, 0xfa, 0x8f, 0x5b, 0x09, 0xa1, 0x4e, 0xb6, 0x13, 0x43,
 0xf3, 0x15, 0xef, 0x57, 0x7a, 0x0f, 0xaf, 0x79, 0x1b, 0x62, 0xff, 0x00, 0xfd, 0xde, 0x27, 0xe9,
 0x9f, 0x4d, 0x79, 0x81, 0xb6, 0xa7, 0x6a, 0x76, 0xa3, 0x3e, 0xda, 0xba, 0x5b, 0x47, 0xb4, 0xf9,
 0xce, 0x73, 0x0a, 0x18, 0x5c, 0x3c, 0xa8, 0xc7, 0x30, 0xc7, 0xd5, 0xae, 0xa9, 0xb7, 0x39, 0xf1,
 0x71, 0x53, 0x93, 0xe0, 0xdf, 0x05, 0xd4, 0x5a, 0xd8, 0xed, 0x8e, 0xbb, 0x99, 0x6a, 0xe4, 0xe2,
 0x56, 0xde, 0xe7, 0xd2, 0x75, 0xb0, 0x9a, 0x14, 0xea, 0xe1, 0x74, 0x3b, 0x55, 0x6c, 0x26, 0x85,
 0x3a, 0xd8, 0x4d, 0x08, 0xa6, 0x67, 0x97, 0x9f, 0xc3, 0xff, 0x00, 0x27, 0x57, 0xa9, 0x41, 0xae,
 0xf1, 0xd4, 0x37, 0xbf, 0x4b, 0x86, 0xea, 0x76, 0xbd, 0xf0, 0xea, 0xc8, 0xf1, 0xbf, 0x21, 0x33,
 0xd2, 0xab, 0x61, 0x34, 0x3a, 0x4e, 0xf9, 0xf0, 0xdc, 0xbb, 0xa3, 0xdb, 0x29, 0x70, 0xea, 0xc8,
 0x71, 0xcf, 0xfc, 0x3c, 0xcd, 0x8a, 0xe5, 0xdb, 0xce, 0xf5, 0x29, 0xae, 0x48, 0x9f, 0xcd, 0xf9,
 0xa4, 0x00, 0x32, 0xbb, 0x00, 0xed, 0x1b, 0x77, 0xb6, 0x38, 0xdd, 0xa8, 0xc3, 0xe4, 0x78, 0x1a,
 0x9c, 0xd4, 0xb0, 0x39, 0x36, 0x59, 0x87, 0xc1, 0x61, 0xe8, 0xf1, 0xe8, 0xe6, 0x85, 0x38, 0xc6,
 0xa4, 0xde, 0xb2, 0x94, 0x7d, 0xa5, 0x14, 0x75, 0x70, 0x14, 0xb6, 0x3a, 0xda, 0xd1, 0x69, 0x8f,
 0x6c, 0x7b, 0x80, 0x72, 0xdb, 0x2b, 0xb3, 0x59, 0xf6, 0xd4, 0xe6, 0x6b, 0x2d, 0xd9, 0xfc, 0xaf,
 0x13, 0x98, 0x62, 0x9a, 0xe2, 0xe3, 0x4a, 0x3d, 0x10, 0x5e, 0x19, 0x49, 0xf4, 0x45, 0x6a, 0xda,
 0x47, 0xa9, 0xe1, 0x3c, 0xcd, 0x3b, 0xc5, 0xad, 0x87, 0x55, 0x6a, 0xd6, 0xc8, 0xf0, 0xb3, 0x6b,
 0x8d, 0xaa, 0xb8, 0xa9, 0xb9, 0x2d, 0x3d, 0x24, 0x24, 0xbd, 0xf2, 0x62, 0x26, 0x58, 0x73, 0x73,
 0x30, 0x60, 0x9d, 0x64, 0xbc, 0x43, 0xc5, 0x8e, 0x73, 0x60, 0x72, 0x2a, 0x9b, 0x4d, 0xb6, 0x59,
 0x56, 0x45, 0x4d, 0x4b, 0x86, 0x2f, 0x13, 0x18, 0x54, 0x6b, 0xae, 0x34, 0xd7, 0x4c, 0xdf, 0xb1,
 0x15, 0x27, 0xec, 0x1d, 0x83, 0x6d, 0x37, 0x45, 0xb7, 0xdb, 0x27, 0x42, 0x78, 0xac, 0xc7, 0x23,
 0xa9, 0x5f, 0x07, 0x05, 0xc6, 0x58, 0x9c, 0x1c, 0x95, 0x68, 0x45, 0x78, 0x5f, 0x2f, 0xa6, 0x8a,
 0xd6, 0x49, 0x23, 0xd0, 0x7c, 0xc7, 0x5b, 0x34, 0xf1, 0x79, 0xee, 0x6b, 0xb5, 0x15, 0xa9, 0xf1,
 0xa7, 0x82, 0xa4, 0xb0, 0xb8, 0x76, 0xd7, 0x45, 0xc9, 0xf4, 0xc9, 0xad, 0x54, 0x52, 0x5f, 0xf9,
 0xc9, 0xad, 0x77, 0x6d, 0x4b, 0x57, 0x9b, 0xcf, 0xc7, 0x8f, 0x87, 0x7c, 0xd8, 0xad, 0x13, 0xa8,
 0xf6, 0x6b, 0xe7, 0x3e, 0xe7, 0xd1, 0x10, 0xc3, 0x42, 0x8d, 0x28, 0x52, 0xa5, 0x05, 0x08, 0x42,
 0x2a, 0x31, 0x8a, 0x5d, 0x09, 0x2e, 0xa4, 0x47, 0x56, 0x2a, 0x11, 0x72, 0x93, 0x51, 0x8a, 0x5c,
 0x5b, 0x6f, 0x82, 0x48, 0xe5, 0x67, 0x4b, 0x43, 0xcb, 0xfc, 0xd2, 0x5b, 0x43, 0x2d, 0x9b, 0xdd,
 0xa6, 0x2a, 0x9d, 0x09, 0xf2, 0x62, 0xf3, 0x39, 0xac, 0x15, 0x26, 0x9f, 0x4a, 0x8c, 0x93, 0x73,
 0x7f, 0xaa, 0x9a, 0xf5, 0xe4, 0x8d, 0xfe, 0xa6, 0xa3, 0x6f, 0x93, 0x60, 0xe0, 0x5f, 0x93, 0x9e,
 0xb8, 0xab, 0xef, 0xb4, 0xe9, 0xf3, 0xa6, 0xfa, 0xb6, 0xde, 0xae, 0xd9, 0x6d, 0x65, 0x59, 0x61,
 0xea, 0xcb, 0xb9, 0x38, 0x39, 0x4a, 0x96, 0x0a, 0x1c, 0x7a, 0x24, 0xb8, 0xf4, 0xd4, 0x7a, 0xcb,
 0x87, 0xb5, 0xc1, 0x1d, 0x10, 0x03, 0xcf, 0xb5, 0xa6, 0xd3, 0xb9, 0x7d, 0x97, 0x8b, 0xc6, 0xc7,
 0xc5, 0xc5, 0x5c, 0x38, 0xe3, 0x51, 0x00, 0x07, 0xb9, 0xee, 0x9b, 0x72, 0x54, 0xf3, 0x4c, 0xb2,
 0x86, 0x79, 0xb5, 0xb3, 0xaf, 0x4e, 0x8d, 0x78, 0xa9, 0xd0, 0xc0, 0xd3, 0x7c, 0x92, 0x94, 0x1f,
 0x54, 0xa7, 0x2e, 0xb5, 0xc7, 0xaf, 0x82, 0xe0, 0xfa, 0xba, 0x7b, 0xc5, 0xa9, 0x49, 0xbc, 0xea,
 0x18, 0x39, 0xfe, 0x23, 0x83, 0x81, 0x8b, 0xa9, 0x9e, 0x75, 0x1f, 0x0f, 0x9c, 0xfd, 0x1e, 0x18,
 0x0f, 0xb3, 0xf0, 0x7b, 0xb9, 0xd8, 0x7c, 0x1d, 0x35, 0x4e, 0x8e, 0xca, 0xe5, 0x52, 0x8a, 0xef,
 0xd6, 0xc3, 0xaa, 0xaf, 0xdb, 0x9f, 0x16, 0x6b, 0x8c, 0xdd, 0xee, 0xc4, 0xe2, 0x60, 0xe3, 0x53,
 0x65, 0xb2, 0x98, 0xa7, 0xfc, 0x56, 0x1a, 0x34, 0xdf, 0xb7, 0x1e, 0x06, 0xc7, 0xaa, 0x5b, 0xe6,
 0xe6, 0xff, 0x00, 0xe3, 0x4e, 0x36, 0xfe, 0xee, 0xda, 0xfe, 0x8f, 0x8c, 0x81, 0xf4, 0x46, 0xf0,
 0xb7, 0x1b, 0x95, 0xd5, 0xcb, 0xeb, 0x63, 0x76, 0x4e, 0xee, 0x17, 0x19, 0x4e, 0x2e, 0x4b, 0x09,
 0x3a, 0x8e, 0x74, 0xea, 0xf0, 0xfb, 0xd8, 0xb9, 0x74, 0xc5, 0xf8, 0x38, 0xb6, 0xbd, 0x6e, 0xb3,
 0xe7, 0x99, 0xc6, 0x50, 0x9c, 0xa1, 0x38, 0xb8, 0xca, 0x2f, 0x83, 0x4d, 0x70, 0x69, 0xf8, 0x0c,
 0x19, 0x31, 0x5b, 0x1c, 0xea, 0x5d, 0x0f, 0x87, 0x78, 0xa7, 0x1f, 0xc4, 0x69, 0x37, 0xc3, 0x3e,
 0xef, 0x7c, 0x4f, 0xbe, 0x1a, 0x99, 0x8c, 0x9c, 0x64, 0xa5, 0x16, 0xd4, 0x93, 0xe2, 0x9a, 0x7d,
 0x28, 0xc0, 0x31, 0xbd, 0x17, 0xd5, 0x1b, 0xa8, 0xcf, 0xa7, 0xb4, 0xdb, 0x13, 0x84, 0xc7, 0x57,
 0x97, 0x3e, 0x2e, 0x93, 0x78, 0x7c, 0x4b, 0xf0, 0xce, 0x3c, 0x3a, 0x7d, 0x76, 0x9c, 0x5f, 0xb2,
 0x76, 0x89, 0x53, 0x3c, 0x83, 0xcc, 0xbb, 0x8b, 0x73, 0xa1, 0x9e, 0x65, 0xd2, 0x7d, 0x11, 0x95,
 0x2a, 0xd0, 0x5e, 0xba, 0x94, 0x65, 0xf0, 0x44, 0xf6, 0x99, 0x53, 0x3a, 0x1e, 0x36, 0x59, 0xbe,
 0x28, 0x99, 0x7c, 0x9f, 0xc6, 0x30, 0x47, 0x1b, 0x9b, 0x93, 0x1d, 0x7d, 0xdb, 0xdc, 0x7f, 0x5f,
 0x6a, 0x84, 0xa0, 0x47, 0x2a, 0x65, 0xe9, 0x40, 0x8e, 0x54, 0xcd, 0x98, 0xb3, 0xcf, 0x8b, 0x3e,
 0x47, 0xdb, 0x9e, 0x8d, 0xb6, 0xcf, 0x57, 0xe7, 0x2c, 0x47, 0xca, 0x48, 0xe1, 0x8e, 0x6b, 0x6f,
 0x3a, 0x36, 0xe3, 0x3e, 0x5f, 0x9c, 0xb1, 0x1f, 0x2b, 0x23, 0x85, 0x39, 0x8c, 0x9f, 0xc7, 0x2f,
 0xb1, 0x71, 0xbe, 0xe6, 0x9f, 0x48, 0xfd, 0x03, 0xb0, 0xe0, 0x76, 0xa3, 0x17, 0x80, 0xd8, 0xca,
 0xdb, 0x3d, 0x82, 0xe6, 0xa4, 0xf1, 0x38, 0xa9, 0xd5, 0xaf, 0x59, 0x3e, 0x0d, 0xc1, 0xc2, 0x11,
 0x50, 0x5e, 0xbf, 0x2b, 0xe3, 0xa7, 0x47, 0x84, 0xeb, 0xc0, 0x8a, 0x5e, 0xd4, 0xfe, 0x19, 0x5b,
 0x26, 0x2a, 0x65, 0x88, 0x8b, 0xc6, 0xf5, 0x3b, 0x01, 0xcc, 0x6c, 0xa6, 0xcd, 0xe6, 0xbb, 0x4b,
 0x98, 0xf9, 0xcf, 0x2c, 0xa1, 0xcd, 0xcb, 0xd3, 0x56, 0xac, 0xfa, 0x21, 0x49, 0x78, 0x64, 0xfe,
 0x6e, 0xb6, 0x7a, 0xde, 0x4b, 0xba, 0x1c, 0x8b, 0x0b, 0x4a, 0x2f, 0x33, 0xc4, 0x62, 0x71, 0xf5,
 0xb8, 0x7a, 0x65, 0x19, 0x5b, 0xa7, 0xec, 0x25, 0xd3, 0xef, 0x99, 0xf0, 0x71, 0x32, 0xe7, 0xf6,
 0xd6, 0x3d, 0x8d, 0x1e, 0x6f, 0x8b, 0x71, 0xb8, 0x73, 0xe8, 0xe4, 0x9f, 0x6f, 0xca, 0x3d, 0xef,
 0x0c, 0x07, 0xd0, 0x58, 0xbd, 0xd7, 0xec, 0x85, 0x5a, 0x4e, 0x14, 0xf0, 0x35, 0xb0, 0xf2, 0x6b,
 0xee, 0xe9, 0xe2, 0x26, 0xda, 0xfd, 0x66, 0xd7, 0xbc, 0x79, 0x56, 0xf0, 0xf6, 0x2b, 0x15, 0xb2,
 0xb5, 0xe1, 0x56, 0x15, 0x5e, 0x27, 0x2f, 0xad, 0x2e, 0x5a, 0x75, 0x9c, 0x78, 0x38, 0xcb, 0xaf,
 0x96, 0x5a, 0xf0, 0xef, 0xf7, 0xf8, 0x33, 0x26, 0x7e, 0x06, 0x5c, 0x35, 0xf4, 0xa7, 0xdb, 0x1f,
 0x93, 0x17, 0x0f, 0xc6, 0xb8, 0xbc, 0xbb, 0xf4, 0xe9, 0x33, 0x13, 0xf9, 0xff, 0x00, 0xb9, 0x75,
 0x20, 0x01, 0xa4, 0xf5, 0xd7, 0x32, 0x5c, 0xcb, 0x13, 0x94, 0xe6, 0x94, 0x33, 0x0c, 0x2c, 0xb8,
 0x55, 0xa3, 0x2e, 0x3c, 0x3b, 0xd2, 0x5d, 0xf8, 0xbd, 0x1a, 0xe8, 0x39, 0x8d, 0xb9, 0xda, 0x9a,
 0xfb, 0x47, 0x8d, 0x8f, 0x2a, 0x9d, 0x1c, 0x15, 0x2f, 0xf5, 0x54, 0x5b, 0xef, 0xf7, 0xe5, 0x2d,
 0x7e, 0x0f, 0x6c, 0xeb, 0x60, 0xcb, 0x19, 0xaf, 0x5c, 0x73, 0x8e, 0x27, 0xd9, 0x2c, 0x36, 0xe3,
 0xe3, 0xb6, 0x58, 0xcb, 0x31, 0xfb, 0xd1, 0xf1, 0x01, 0xcd, 0xec, 0xa6, 0xcc, 0x66, 0x5b, 0x47,
 0x89, 0x70, 0xc1, 0xc1, 0x42, 0x84, 0x1f, 0xdb, 0x6b, 0xcf, 0xee, 0x21, 0xa6, 0xaf, 0x43, 0xd2,
 0xf2, 0xcd, 0xda, 0x64, 0x18, 0x6a, 0x49, 0x63, 0x1e, 0x23, 0x1b, 0x53, 0x87, 0xa6, 0x72, 0x9b,
 0x84, 0x7d, 0x85, 0x1e, 0x95, 0xed, 0xb3, 0x63, 0x8d, 0xc0, 0xcd, 0xc8, 0x8d, 0xd6, 0x3d, 0x9f,
 0x39, 0x6a, 0x72, 0xfc, 0x57, 0x8f, 0xc5, 0x9f, 0x46, 0xf3, 0xb9, 0xf9, 0x43, 0xc6, 0x41, 0xed,
 0x19, 0x8e, 0xed, 0xb6, 0x77, 0x11, 0x49, 0xac, 0x34, 0x31, 0x18, 0x39, 0xf7, 0xa5, 0x0a, 0xae,
 0x4b, 0xd9, 0x52, 0xe2, 0x79, 0x76, 0xd5, 0x64, 0x18, 0xdd, 0x9e, 0xcc, 0x7c, 0xe9, 0x8b, 0x4a,
 0x71, 0x92, 0xe6, 0xa5, 0x56, 0x2b, 0xd2, 0xd4, 0x5d, 0xbe, 0x14, 0x39, 0x3c, 0x0c, 0xdc, 0x78,
 0xf4, 0xad, 0x1e, 0xcf, 0x9c, 0x1c, 0x3f, 0x14, 0xe3, 0xf2, 0xe7, 0xd1, 0xa4, 0xea, 0x7e, 0x52,
 0xe2, 0x00, 0x06, 0x93, 0xd1, 0x73, 0x3b, 0x1b, 0x9d, 0x54, 0xc8, 0xf3, 0xca, 0x38, 0xae, 0x67,
 0x62, 0x6f, 0x92, 0xbc, 0x57, 0x7e, 0x0f, 0xbf, 0xeb, 0xae, 0xbf, 0x60, 0xf7, 0x38, 0xb8, 0xca,
 0x2a, 0x51, 0x69, 0xc5, 0xae, 0x29, 0xae, 0xfa, 0x3e, 0x73, 0x3d, 0xd3, 0x60, 0x71, 0x4f, 0x1b,
 0xb2, 0x19, 0x75, 0x59, 0x3e, 0x32, 0x8d, 0x2b, 0x6f, 0xff, 0x00, 0x23, 0x71, 0xf8, 0x12, 0x3a,
 0x1f, 0x02, 0xe4, 0x4e, 0xed, 0x8a, 0x7e, 0xb0, 0xe6, 0x7e, 0xd0, 0xf1, 0xe2, 0x22, 0xb9, 0xa3,
 0xdf, 0xee, 0x9f, 0xf4, 0x73, 0x0e, 0x26, 0xad, 0x13, 0x38, 0x9a, 0xb8, 0x9d, 0x26, 0xdc, 0xce,
 0xd0, 0xb8, 0x9d, 0x6f, 0x6e, 0xb6, 0x86, 0x39, 0x16, 0x5e, 0xa3, 0x45, 0xa9, 0x63, 0x6b, 0xa6,
 0xa8, 0xc7, 0xaf, 0x95, 0x77, 0xe4, 0xfd, 0x6f, 0x87, 0xd9, 0x3b, 0x2d, 0x79, 0xd3, 0xa1, 0x46,
 0xa5, 0x6a, 0xb2, 0x50, 0xa7, 0x4e, 0x2e, 0x53, 0x93, 0xea, 0x49, 0x74, 0xb6, 0x78, 0x46, 0xd2,
 0xe6, 0xb5, 0x73, 0x9c, 0xe6, 0xbe, 0x3a, 0xa3, 0x7c, 0xb2, 0x97, 0x0a, 0x51, 0x7f, 0x7b, 0x05,
 0xd4, 0xbf, 0xf7, 0xdf, 0xe2, 0x79, 0x9e, 0x29, 0xcd, 0x9e, 0x36, 0x2d, 0x57, 0xf8, 0xa7, 0xfd,
 0xed, 0xeb, 0xf8, 0x47, 0x0a, 0x39, 0x59, 0x77, 0x6f, 0xe1, 0xaf, 0xfb, 0xd2, 0x85, 0x7a, 0xb5,
 0x2b, 0xd6, 0x9d, 0x6a, 0xd3, 0x95, 0x4a, 0x93, 0x6e, 0x52, 0x94, 0x9f, 0x16, 0xdf, 0x84, 0xd0,
 0x03, 0x8d, 0x99, 0xdb, 0xb5, 0x88, 0xd0, 0x0b, 0xd9, 0x26, 0x55, 0x8c, 0xce, 0x31, 0xf1, 0xc1,
 0xe0, 0xa9, 0xf3, 0x4d, 0xf4, 0xca, 0x4f, 0xa2, 0x30, 0x5e, 0x16, 0xfc, 0x07, 0xa5, 0xe4, 0xdb,
 0x09, 0x93, 0xe0, 0xe9, 0x46, 0x58, 0xc8, 0x4b, 0x1b, 0x5f, 0xbe, 0xe6, 0xda, 0x8a, 0x7a, 0x45,
 0x7c, 0xfc, 0x4d, 0xee, 0x27, 0x87, 0xe6, 0xe5, 0x7b, 0x69, 0x1e, 0xcf, 0x9c, 0xb4, 0x79, 0x7e,
 0x23, 0x87, 0x8b, 0xec, 0xbc, 0xfb, 0x7e, 0x50, 0xf2, 0x60, 0x7b, 0x84, 0xb6, 0x7b, 0x23, 0x70,
 0xe4, 0xee, 0x46, 0x07, 0x87, 0xf6, 0x11, 0xe3, 0xed, 0xf0, 0x3a, 0xfe, 0x7d, 0xb0, 0x59, 0x7e,
 0x26, 0x9c, 0xaa, 0x65, 0x8d, 0xe1, 0x2b, 0xf5, 0xa8, 0xb6, 0xdd, 0x39, 0x7b, 0x7d, 0x2b, 0xd8,
 0xf6, 0x8d, 0xdc, 0xbe, 0x05, 0x9e, 0x95, 0xdd, 0x66, 0x25, 0xa7, 0x8b, 0xc7, 0x70, 0x5e, 0xda,
 0xb4, 0x4c, 0x3c, 0xbc, 0x13, 0xe3, 0xf0, 0x98, 0x8c, 0x0e, 0x2e, 0xa6, 0x17, 0x17, 0x4a, 0x54,
 0xab, 0x53, 0x7c, 0x25, 0x17, 0xff, 0x00, 0xbe, 0xa2, 0x03, 0xc5, 0x98, 0x9a, 0xce, 0xa5, 0xec,
 0xc4, 0xc5, 0xa3, 0x70, 0xbd, 0x92, 0x66, 0x78, 0x9c, 0xa7, 0x1f, 0x0c, 0x5e, 0x1a, 0x5d, 0x2b,
 0xa2, 0x70, 0x7d, 0x53, 0x8f, 0x7d, 0x33, 0xd7, 0xb2, 0xac, 0x6d, 0x0c, 0xcb, 0x2f, 0xa5, 0x8d,
 0xc3, 0x4b, 0x8c, 0x2a, 0x2e, 0x3c, 0x1f, 0x5c, 0x5f, 0x7d, 0x3d, 0x51, 0xe2, 0x67, 0x6f, 0xdd,
 0x9e, 0x6a, 0xf0, 0xf9, 0x94, 0xb2, 0xca, 0xb2, 0xfb, 0x4e, 0x27, 0xa6, 0x1c, 0x7b, 0xd3, 0x4b,
 0xe7, 0x5f, 0x02, 0x3d, 0xaf, 0x05, 0xe7, 0x4e, 0x1c, 0xbd, 0x2b, 0x4f, 0xee, 0xdb, 0xfb, 0x4f,
 0xfd, 0xde, 0x47, 0x8b, 0x70, 0xe3, 0x2e, 0x3e, 0xad, 0x7f, 0x8a, 0x3f, 0xbc, 0x3d, 0x15, 0xa3,
 0x0e, 0x24, 0xad, 0x1a, 0xb4, 0x76, 0x71, 0x2e, 0x57, 0x68, 0x9a, 0x35, 0x68, 0x99, 0xa3, 0x56,
 0x89, 0xda, 0x76, 0x89, 0xa3, 0x56, 0x89, 0x9c, 0x4d, 0x5a, 0x2d, 0xb4, 0xed, 0x0b, 0x46, 0x1c,
 0x49, 0x5a, 0x35, 0x68, 0x9d, 0xad, 0xb4, 0x4e, 0x26, 0xad, 0x13, 0x34, 0x6a, 0xd1, 0x3b, 0x4e,
 0xd0, 0xb8, 0x98, 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0x76, 0xb6, 0xd0, 0xb4, 0x63, 0x81, 0x2b, 0x46,
 0xad, 0x16, 0xda, 0x76, 0x89, 0xc4, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x27, 0x6b, 0x6d, 0x0b, 0x45,
 0x2c, 0xeb, 0x19, 0x1c, 0xbf, 0x2e, 0xab, 0x89, 0x93, 0x5c, 0xc9, 0x70, 0x82, 0xf0, 0xc9, 0xf5,
 0x23, 0x90, 0xa8, 0xe1, 0x08, 0x4a, 0x73, 0x92, 0x8c, 0x62, 0xb8, 0xb6, 0xdf, 0x42, 0x47, 0x9e,
 0x6d, 0x46, 0x6e, 0xf3, 0x3c, 0x5a, 0x85, 0x26, 0xd6, 0x1a, 0x93, 0xf4, 0x9f, 0xce, 0x7f, 0x8c,
 0x79, 0xbe, 0x2b, 0xe2, 0x15, 0xe1, 0xe1, 0x99, 0x89, 0xfd, 0xe9, 0xf7, 0x7f, 0x9f, 0xe8, 0xdd,
 0xe0, 0xf1, 0xa7, 0x91, 0x93, 0xf2, 0x8f, 0x7b, 0x87, 0x93, 0x72, 0x93, 0x94, 0x9b, 0x6d, 0xbe,
 0x2d, 0xbe, 0xf9, 0x80, 0x0f, 0x9d, 0x3a, 0xb0, 0xec, 0x9b, 0x0d, 0x86, 0x72, 0xc4, 0x57, 0xc5,
 0x35, 0xd1, 0x18, 0xa8, 0x27, 0xab, 0xe9, 0x7f, 0x07, 0xbe, 0x75, 0xc4, 0x9b, 0x69, 0x25, 0xc5,
 0xb3, 0xd1, 0x72, 0x0c, 0x07, 0x9c, 0x32, 0xba, 0x54, 0x64, 0xb8, 0x54, 0x6b, 0x9e, 0xa7, 0xf5,
 0x9f, 0xfe, 0xf8, 0x7b, 0x07, 0xbb, 0xf6, 0x7b, 0x8d, 0x39, 0x79, 0x51, 0x92, 0x7d, 0xd5, 0xf6,
 0xff, 0x00, 0x5f, 0x87, 0xfb, 0xfc, 0x9e, 0x77, 0x89, 0x66, 0x8a, 0x61, 0xf4, 0x7e, 0x32, 0xb3,
 0xc0, 0xc3, 0x44, 0xcd, 0x1a, 0xb8, 0x9f, 0x40, 0xdb, 0x9d, 0xda, 0x16, 0x8d, 0x5c, 0x49, 0x9a,
 0x35, 0x68, 0x9d, 0xad, 0xb4, 0x4d, 0x1a, 0xb8, 0x93, 0x34, 0x6a, 0xe2, 0x4e, 0xd3, 0xb4, 0x2d,
 0x1a, 0xb4, 0x4c, 0xd1, 0x86, 0x8b, 0x6d, 0x3b, 0x42, 0xd1, 0xab, 0x89, 0x33, 0x89, 0xab, 0x44,
 0xed, 0x6d, 0xa2, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x27, 0x69, 0xdb, 0xe8, 0xa8, 0xd5, 0x25,
 0x85, 0x43, 0x8e, 0x8d, 0x4d, 0x49, 0x63, 0x50, 0xfc, 0xd9, 0xb6, 0x38, 0xb3, 0x91, 0x85, 0x5d,
 0x49, 0xa1, 0x54, 0xe3, 0x61, 0x50, 0x96, 0x35, 0x49, 0xda, 0xf1, 0x67, 0x25, 0x0a, 0xa4, 0xd0,
 0xaa, 0x71, 0x90, 0xa9, 0xa9, 0x34, 0x2a, 0xea, 0x4e, 0xd7, 0x8b, 0x39, 0x28, 0x55, 0x26, 0x85,
 0x5d, 0x4e, 0x32, 0x15, 0x49, 0x61, 0x54, 0x9d, 0xaf, 0x16, 0x72, 0x90, 0xab, 0xa9, 0x2c, 0x2a,
 0xea, 0x71, 0x90, 0xab, 0xa9, 0x34, 0x2a, 0xea, 0x4e, 0xd7, 0x8b, 0x39, 0x48, 0x55, 0xd4, 0x9a,
 0x15, 0x75, 0x38, 0xa8, 0x55, 0xd4, 0x9a, 0x15, 0x4b, 0x6d, 0x78, 0xb3, 0xe6, 0xaf, 0x35, 0xdc,
 0xb9, 0xb7, 0x93, 0x97, 0x3f, 0xcc, 0xf4, 0xbe, 0x5a, 0xb1, 0xe3, 0x47, 0xaf, 0xf9, 0xac, 0x65,
 0xcd, 0xbc, 0x5c, 0xbd, 0xfe, 0x68, 0xa7, 0xf2, 0xd5, 0x8f, 0x20, 0x3a, 0x2e, 0x2f, 0xdc, 0xd5,
 0xed, 0xf1, 0xfe, 0xee, 0x00, 0x01, 0xb0, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x54,
 0x7f, 0xd9, 0xe3, 0x56, 0xd6, 0xd1, 0x6d, 0x73, 0xe3, 0xd7, 0x84, 0xc3, 0x7c, 0x79, 0x9f, 0x2b,
 0x9f, 0x4e, 0x79, 0x81, 0x6a, 0x5b, 0xcf, 0xf6, 0xa9, 0xf8, 0x70, 0xb8, 0x7f, 0x8f, 0x33, 0x07,
 0x27, 0xee, 0xa5, 0x16, 0x9d, 0x46, 0xdf, 0x6f, 0x50, 0xc7, 0x75, 0x26, 0xf8, 0xad, 0x4b, 0x31,
 0xa9, 0x46, 0xaa, 0xfc, 0x56, 0x75, 0x6a, 0x58, 0x9d, 0x4b, 0x94, 0x71, 0x5c, 0x3b, 0xe7, 0x91,
 0x17, 0xd2, 0xb1, 0x92, 0x27, 0xde, 0xe6, 0xaa, 0xe1, 0x53, 0x5c, 0x57, 0x06, 0x8e, 0x8d, 0xbf,
 0x0c, 0x37, 0x2e, 0xe6, 0xf6, 0xda, 0x5c, 0x3a, 0xb6, 0x7b, 0x1e, 0xff, 0x00, 0xc3, 0xd4, 0x3b,
 0x65, 0x0c, 0x6b, 0x5d, 0x52, 0x3a, 0xe6, 0xfb, 0x31, 0x30, 0xa9, 0xb9, 0x5d, 0xb9, 0x4d, 0x2e,
 0x2f, 0x67, 0x33, 0x0e, 0xaf, 0xd1, 0xaa, 0x19, 0xf1, 0xe4, 0x9d, 0xc2, 0xb6, 0xc3, 0x4b, 0x7b,
 0x61, 0xf9, 0x5e, 0x00, 0x3d, 0x76, 0x50, 0xb9, 0x92, 0xe5, 0xb8, 0xcc, 0xe3, 0x38, 0xc1, 0xe5,
 0x39, 0x7d, 0x27, 0x5b, 0x17, 0x8c, 0xaf, 0x0a, 0x14, 0x20, 0xbe, 0xfa, 0x72, 0x69, 0x25, 0xed,
 0xb2, 0x99, 0xee, 0x5e, 0x62, 0x7d, 0x9a, 0x86, 0x7b, 0xbe, 0x35, 0x98, 0x56, 0xa7, 0xcd, 0x4b,
 0x27, 0xc0, 0xd4, 0xc5, 0x2e, 0x2b, 0x8a, 0xb9, 0x2e, 0x14, 0xe3, 0xf1, 0xe4, 0xd7, 0xf5, 0x48,
 0x99, 0xd4, 0x6d, 0x8f, 0x2d, 0xfd, 0x0a, 0x4d, 0xa3, 0xe0, 0xfa, 0x8f, 0x76, 0x1b, 0x07, 0x95,
 0x6c, 0x0e, 0xc9, 0x61, 0xb2, 0x3c, 0xb6, 0x94, 0x1d, 0x45, 0x15, 0x2c, 0x5e, 0x27, 0x97, 0x84,
 0xb1, 0x15, 0x78, 0x7a, 0x69, 0xbd, 0x3c, 0x0b, 0xbc, 0xb8, 0x23, 0xb2, 0x4e, 0x96, 0x87, 0x37,
 0x5b, 0x0b, 0xa1, 0x56, 0xa6, 0x1d, 0xae, 0xf0, 0xae, 0x47, 0x0f, 0xc8, 0xc1, 0x7b, 0x5a, 0x6d,
 0x6f, 0x6c, 0xcb, 0x87, 0x9d, 0x2d, 0x0e, 0x37, 0x2d, 0xc9, 0x72, 0xdc, 0xaa, 0x15, 0xe1, 0x96,
 0x60, 0x30, 0xd8, 0x38, 0x62, 0x2b, 0x3a, 0xf5, 0x63, 0x42, 0x9a, 0x82, 0x9d, 0x46, 0x92, 0x72,
 0x69, 0x77, 0xdf, 0x05, 0xd3, 0xa1, 0xd8, 0xa7, 0x47, 0x42, 0x09, 0xd2, 0xd0, 0xcb, 0x17, 0x68,
 0x5f, 0x04, 0xc4, 0x4c, 0x38, 0xa9, 0xd2, 0xd0, 0xea, 0x9b, 0x7b, 0xb0, 0x5b, 0x37, 0xb6, 0xb8,
 0x7c, 0x3d, 0x0d, 0xa1, 0xc0, 0xcf, 0x12, 0xb0, 0xce, 0x4e, 0x84, 0xa1, 0x5e, 0x74, 0xdd, 0x37,
 0x2e, 0x1c, 0x5f, 0xa5, 0x69, 0x3e, 0xa5, 0xd7, 0xc4, 0xef, 0x53, 0xa5, 0xa1, 0x0c, 0xe8, 0xe8,
 0x5e, 0x2d, 0xb6, 0xac, 0x63, 0xbe, 0x2b, 0x45, 0xe9, 0x3a, 0x98, 0xf8, 0xc3, 0xe7, 0xac, 0xeb,
 0xcc, 0xd3, 0xb2, 0xd5, 0xf9, 0xa5, 0x95, 0xe7, 0x59, 0xae, 0x06, 0x4f, 0xa9, 0x55, 0xe4, 0xad,
 0x05, 0xec, 0x70, 0x8b, 0xf7, 0xce, 0x93, 0x9c, 0xf9, 0x9a, 0xb6, 0x96, 0x87, 0x33, 0xca, 0xb3,
 0xec, 0xb3, 0x1b, 0x15, 0xd4, 0xab, 0xc2, 0x74, 0x24, 0xfd, 0x84, 0xa4, 0xbd, 0xf3, 0xeb, 0x49,
 0xd1, 0xd0, 0x86, 0x74, 0xb4, 0x27, 0xd1, 0xac, 0xb7, 0x29, 0xe3, 0x5e, 0x23, 0x8b, 0xdd, 0x7d,
 0xfd, 0x62, 0x27, 0xfe, 0xef, 0x91, 0x76, 0x13, 0x71, 0xdb, 0x57, 0x43, 0x6e, 0xf2, 0xe5, 0xb4,
 0xd9, 0x55, 0x38, 0xe4, 0xf4, 0xaa, 0x5d, 0xaf, 0x56, 0x15, 0xe1, 0x52, 0x15, 0x14, 0x57, 0x15,
 0x0e, 0x09, 0xf1, 0xe1, 0x27, 0xc1, 0x3e, 0x29, 0x74, 0x36, 0x7d, 0x3d, 0x2a, 0x3c, 0x3a, 0x12,
 0x39, 0x59, 0xd2, 0xd0, 0x86, 0x74, 0x8c, 0xd8, 0xf5, 0x4f, 0x73, 0xcb, 0xf1, 0x5e, 0x6e, 0x7f,
 0x11, 0xbd, 0x6d, 0x9b, 0x5e, 0xc8, 0xd7, 0xb3, 0xdc, 0xe2, 0xe5, 0x4f, 0x42, 0x29, 0x53, 0x39,
 0x39, 0xd1, 0xd0, 0xeb, 0x5b, 0x43, 0xb5, 0xdb, 0x29, 0x90, 0xf3, 0x2c, 0xdb, 0x68, 0x32, 0xec,
 0x2c, 0xe3, 0xd7, 0x4e, 0x55, 0xe2, 0xea, 0x7e, 0xa2, 0xe3, 0x2f, 0x78, 0xcd, 0x17, 0x88, 0x78,
 0xf5, 0xe3, 0x65, 0xbd, 0xbd, 0x1a, 0x44, 0xcc, 0xfe, 0x4b, 0xd2, 0x81, 0xf1, 0xbe, 0xfa, 0x70,
 0x14, 0xf2, 0xdd, 0xe9, 0x67, 0xd8, 0x5a, 0x51, 0x51, 0x83, 0xc4, 0x2a, 0xdc, 0x17, 0x79, 0xd4,
 0x84, 0x6a, 0x3f, 0x7e, 0x47, 0xb7, 0xed, 0x3e, 0xff, 0x00, 0xf6, 0x53, 0x04, 0xa5, 0x4f, 0x24,
 0xc1, 0x63, 0x73, 0x7a, 0xab, 0xee, 0x66, 0xe3, 0x62, 0x93, 0xf6, 0x65, 0xe9, 0xbf, 0xe5, 0x3e,
 0x7a, 0xdb, 0x8d, 0xa2, 0xc4, 0xed, 0x5e, 0xd4, 0xe3, 0x73, 0xfc, 0x5d, 0x0a, 0x34, 0x2b, 0x62,
 0x9c, 0x38, 0xd3, 0xa5, 0xc7, 0x96, 0x2a, 0x30, 0x8c, 0x17, 0x5f, 0x4f, 0x54, 0x57, 0xb2, 0x6b,
 0xf2, 0x72, 0xd6, 0xf5, 0x88, 0x87, 0x75, 0xf6, 0x4f, 0xc3, 0x79, 0x9c, 0x6c, 0xd6, 0xc9, 0x9a,
 0x93, 0x5a, 0xcc, 0x6b, 0xdb, 0xf3, 0xdc, 0x7c, 0x3d, 0xff, 0x00, 0x37, 0x0a, 0x00, 0x34, 0xdd,
 0xdb, 0xd7, 0xbc, 0xcb, 0x73, 0x7f, 0x65, 0xd9, 0xa5, 0x0e, 0xf4, 0xb0, 0x1c, 0xfe, 0xd5, 0x48,
 0xaf, 0xf3, 0x1f, 0x42, 0xca, 0x99, 0xf3, 0xbf, 0x99, 0x5d, 0x71, 0xde, 0x06, 0x3d, 0x7e, 0x6a,
 0xa8, 0xff, 0x00, 0xbd, 0xa4, 0x7d, 0x25, 0x28, 0x1e, 0xb7, 0x0e, 0xda, 0xc6, 0xf9, 0x7f, 0xda,
 0x99, 0xd7, 0x88, 0xdb, 0xe9, 0x0a, 0x32, 0xa6, 0x47, 0x2a, 0x65, 0xe9, 0x53, 0x23, 0x95, 0x3d,
 0x0d, 0xd8, 0xb3, 0x9f, 0x8b, 0x3e, 0x35, 0xdb, 0xfe, 0x8d, 0xbb, 0xda, 0x05, 0xf9, 0xcf, 0x13,
 0xf2, 0xb2, 0x38, 0x43, 0x9d, 0xde, 0x17, 0x46, 0xdf, 0x6d, 0x0a, 0xfc, 0xe9, 0x89, 0xf9, 0x59,
 0x1c, 0x11, 0xcf, 0x5f, 0xf8, 0xa5, 0xf6, 0x9e, 0x2f, 0xdc, 0xd3, 0xe9, 0x1f, 0xa0, 0x6f, 0x46,
 0x9d, 0x4a, 0xd5, 0xa1, 0x46, 0x94, 0x1c, 0xea, 0x4e, 0x4a, 0x31, 0x8a, 0xeb, 0x6d, 0xf4, 0x24,
 0x68, 0x76, 0xcd, 0xd0, 0xe0, 0x63, 0x98, 0x6f, 0x1f, 0x26, 0xa1, 0x28, 0xf1, 0x8c, 0x2b, 0x3a,
 0xcf, 0xfe, 0x1c, 0x5c, 0xd7, 0xbf, 0x14, 0x29, 0x5f, 0x4a, 0xd1, 0x5f, 0x9a, 0x79, 0x19, 0x63,
 0x0e, 0x2b, 0x64, 0x9f, 0xe5, 0x89, 0x9f, 0x27, 0xbe, 0xec, 0x36, 0xcc, 0xe1, 0xf6, 0x67, 0x67,
 0x30, 0xf9, 0x75, 0x28, 0xc5, 0xd6, 0xe5, 0x53, 0xc4, 0xd4, 0x4b, 0xa6, 0xa5, 0x47, 0xd6, 0xfd,
 0x6e, 0xf2, 0xd1, 0x1c, 0xcc, 0xa0, 0x5e, 0x95, 0x32, 0x39, 0x40, 0xea, 0x69, 0xaa, 0xc4, 0x56,
 0x3d, 0xcf, 0x91, 0xe4, 0xcf, 0x6c, 0xb7, 0x9b, 0xde, 0x77, 0x32, 0xa3, 0x2a, 0x7a, 0x1d, 0x77,
 0x78, 0x99, 0x5c, 0x33, 0x3d, 0x8b, 0xcd, 0x30, 0xd3, 0x8a, 0x94, 0xa3, 0x87, 0x95, 0x5a, 0x7a,
 0x4e, 0x0b, 0x99, 0x7b, 0xeb, 0x87, 0xb2, 0x76, 0xc9, 0x53, 0x2a, 0x66, 0x54, 0x15, 0x5c, 0x0e,
 0x22, 0x93, 0x5c, 0x54, 0xe9, 0x4a, 0x3e, 0xda, 0x2d, 0x7d, 0x5a, 0xb3, 0x59, 0xf8, 0xb2, 0x71,
 0xf3, 0x4e, 0x3c, 0x95, 0xbc, 0x7c, 0x26, 0x25, 0xf2, 0x10, 0x00, 0xe4, 0x9f, 0x5e, 0x0b, 0x59,
 0x56, 0x0a, 0xb6, 0x65, 0x99, 0x61, 0xb0, 0x18, 0x75, 0xc6, 0xae, 0x22, 0xa4, 0x69, 0xc7, 0x46,
 0xdf, 0x5b, 0xd0, 0xaa, 0x77, 0xbd, 0xc7, 0xe0, 0x56, 0x2f, 0x6d, 0x6f, 0xc9, 0x71, 0x58, 0x5c,
 0x34, 0xea, 0xaf, 0x5d, 0xf0, 0x87, 0xc1, 0x26, 0x65, 0xc1, 0x8f, 0xa9, 0x92, 0xb4, 0xf9, 0xcb,
 0x5b, 0x99, 0x9f, 0xd5, 0xf0, 0x5f, 0x2f, 0xca, 0x1e, 0xbb, 0x92, 0x65, 0x18, 0x5c, 0x9b, 0x2a,
 0xa1, 0x97, 0x60, 0xe0, 0xa3, 0x4e, 0x94, 0x78, 0x71, 0xe1, 0xd3, 0x27, 0xdf, 0x93, 0xd5, 0x96,
 0x65, 0x02, 0xf4, 0xa9, 0x91, 0xca, 0x07, 0x67, 0x4d, 0x56, 0x35, 0x1e, 0xe7, 0xcc, 0xa7, 0x2d,
 0xaf, 0x69, 0xb5, 0xa7, 0x73, 0x2a, 0x4e, 0x27, 0x4d, 0xde, 0xf6, 0x02, 0x18, 0xad, 0x90, 0xab,
 0x88, 0xe5, 0x4e, 0xa6, 0x12, 0xa4, 0x6a, 0x45, 0xf7, 0xf8, 0x37, 0xca, 0xfe, 0x1e, 0x3e, 0xc1,
 0xde, 0xe5, 0x4f, 0x43, 0x81, 0xdb, 0xca, 0x0a, 0xa6, 0xc7, 0x66, 0xd1, 0x6b, 0xab, 0x0b, 0x39,
 0x7b, 0x4b, 0x8f, 0xcc, 0x53, 0x93, 0x11, 0x7c, 0x37, 0xac, 0xfc, 0xa5, 0xb7, 0xc1, 0xcb, 0x34,
 0xe4, 0x52, 0xd1, 0xf3, 0x87, 0xce, 0xc0, 0x03, 0x8a, 0x7d, 0x2c, 0x3d, 0x8f, 0x73, 0xf3, 0x75,
 0x36, 0x45, 0xc7, 0xf8, 0xbc, 0x4c, 0xe2, 0xbd, 0xa4, 0xfe, 0x73, 0xc7, 0x0f, 0x60, 0xdc, 0xaf,
 0x4e, 0xca, 0xe2, 0x74, 0xc6, 0xcf, 0xe2, 0x40, 0xf5, 0x7c, 0x1e, 0x75, 0xc9, 0xfe, 0x92, 0xf1,
 0x7c, 0x7a, 0x3f, 0xf0, 0x9f, 0xd6, 0x1d, 0xd1, 0xc4, 0xd5, 0xa2, 0x66, 0x8d, 0x5a, 0x3a, 0xcd,
 0xb8, 0x9d, 0xba, 0x6e, 0xf5, 0x73, 0x07, 0x81, 0xd9, 0x79, 0x50, 0xa7, 0x2e, 0x15, 0x31, 0x73,
 0x54, 0xb5, 0xe5, 0xeb, 0x97, 0xc1, 0xc3, 0xd9, 0x3c, 0x6c, 0xf4, 0x0d, 0xf5, 0xe2, 0x79, 0xb3,
 0x6c, 0x06, 0x09, 0x3e, 0x8a, 0x54, 0x1d, 0x46, 0xb5, 0x94, 0xb8, 0x7f, 0x94, 0xf3, 0xf3, 0x91,
 0xf1, 0x6c, 0xbd, 0x4e, 0x4c, 0xc7, 0xcb, 0xd8, 0xee, 0xbc, 0x17, 0x17, 0x4f, 0x89, 0x59, 0xf8,
 0xcf, 0xb4, 0x00, 0xbd, 0x90, 0x61, 0xa3, 0x8b, 0xcf, 0x30, 0x18, 0x59, 0x2e, 0x31, 0xab, 0x88,
 0xa7, 0x09, 0x7a, 0xce, 0x4b, 0x8f, 0xbc, 0x79, 0xd5, 0xac, 0xda, 0xd1, 0x11, 0xf1, 0x7a, 0x97,
 0xb4, 0x56, 0xb3, 0x69, 0xf8, 0x3d, 0x6f, 0x60, 0xf2, 0x48, 0x64, 0xf9, 0x0d, 0x2e, 0x78, 0x70,
 0xc5, 0x62, 0x22, 0xaa, 0x56, 0x7c, 0x3a, 0x78, 0xbe, 0xa8, 0xfb, 0x0b, 0xdf, 0xe2, 0x73, 0xee,
 0x24, 0xcd, 0x1a, 0xb4, 0x77, 0xf8, 0x71, 0xd7, 0x15, 0x22, 0x95, 0xf7, 0x43, 0xe7, 0x59, 0x73,
 0x5b, 0x36, 0x49, 0xbd, 0xbd, 0xf2, 0x85, 0xa3, 0x0e, 0x24, 0xad, 0x18, 0x71, 0x33, 0x6d, 0x4d,
 0xba, 0x4e, 0xf4, 0x72, 0x78, 0x62, 0xb2, 0x8e, 0xe9, 0xd3, 0x87, 0xdb, 0xf0, 0xbf, 0x74, 0xd2,
 0xe9, 0x95, 0x36, 0xfa, 0x57, 0xb0, 0xfa, 0x7d, 0xb3, 0xcb, 0x0f, 0x7f, 0xcd, 0x30, 0xcb, 0x15,
 0x96, 0xe2, 0xb0, 0xd2, 0x5c, 0x55, 0x5a, 0x32, 0x87, 0xb6, 0x9a, 0x3c, 0x00, 0xe5, 0x3c, 0x77,
 0x0c, 0x53, 0x34, 0x5e, 0x3f, 0x9b, 0xfd, 0x1d, 0x6f, 0x80, 0xe7, 0x9b, 0xe1, 0xb5, 0x27, 0xf9,
 0x7f, 0xd4, 0x24, 0xc3, 0x56, 0xa9, 0x87, 0xc4, 0xd3, 0xc4, 0x52, 0x7c, 0xb5, 0x29, 0x4d, 0x4e,
 0x2f, 0xc0, 0xd3, 0xe2, 0x88, 0xc1, 0xe2, 0x44, 0xcc, 0x4e, 0xe1, 0xee, 0x4c, 0x6e, 0x35, 0x2f,
 0x76, 0xc0, 0xd7, 0x86, 0x2f, 0x05, 0x43, 0x15, 0x4f, 0xee, 0x2b, 0x53, 0x8c, 0xd7, 0xac, 0xd7,
 0x12, 0x46, 0x8e, 0x07, 0x76, 0xf8, 0x97, 0x89, 0xd9, 0x4a, 0x11, 0x6f, 0x8b, 0xa1, 0x39, 0x52,
 0x7e, 0xdf, 0x15, 0xef, 0x34, 0x76, 0x36, 0x8f, 0xa2, 0x71, 0xb3, 0x75, 0x71, 0x56, 0xff, 0x00,
 0x38, 0x87, 0x01, 0xc8, 0xc7, 0xd2, 0xcb, 0x6a, 0x7c, 0xa5, 0x0b, 0x46, 0xad, 0x13, 0x38, 0x9a,
 0xb4, 0x67, 0x89, 0x62, 0x89, 0x44, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xad, 0x13, 0xb5, 0xb6, 0x85,
 0xc4, 0xd5, 0xa2, 0x66, 0x8c, 0x34, 0x5b, 0x69, 0xda, 0x16, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x68,
 0x9d, 0xad, 0xb4, 0x4d, 0x1a, 0xb4, 0x4a, 0xd1, 0x86, 0x89, 0x89, 0x4e, 0xd0, 0xb8, 0x9a, 0xb4,
 0x4c, 0xd1, 0x86, 0x8b, 0x6d, 0x6d, 0xa1, 0x68, 0xd2, 0x5c, 0x23, 0x17, 0x29, 0x34, 0x92, 0x5c,
 0x5b, 0x7d, 0x48, 0x9a, 0x7c, 0xb1, 0x8b, 0x94, 0xda, 0x8c, 0x52, 0xe2, 0xdb, 0x7c, 0x12, 0x47,
 0x9f, 0x6d, 0x7e, 0xd1, 0xbc, 0x74, 0xa5, 0x82, 0xc0, 0xc9, 0xac, 0x2a, 0x7c, 0x27, 0x35, 0xd0,
 0xea, 0x7e, 0xef, 0x84, 0xd3, 0xe7, 0x73, 0xf1, 0xf0, 0xf1, 0xfa, 0x56, 0xf7, 0xfc, 0x23, 0xe6,
 0xdb, 0xe2, 0x71, 0x6f, 0xc9, 0xbf, 0xa3, 0x5f, 0x77, 0xc6, 0x5a, 0x6d, 0x6e, 0x7f, 0xe7, 0xe9,
 0xcb, 0x07, 0x83, 0x93, 0x58, 0x58, 0xbf, 0x4d, 0x25, 0xfe, 0xd1, 0xf6, 0x1d, 0x6c, 0x03, 0x80,
 0xe5, 0x72, 0xb2, 0x72, 0x72, 0x4e, 0x4c, 0x93, 0xed, 0x75, 0xb8, 0x70, 0xd3, 0x0d, 0x22, 0x94,
 0x00, 0x2f, 0xe4, 0x79, 0x65, 0x7c, 0xd7, 0x1b, 0x1c, 0x3d, 0x25, 0xc2, 0x2b, 0xa6, 0xa4, 0xf8,
 0x74, 0x45, 0x18, 0xb1, 0xe3, 0xb6, 0x5b, 0xc5, 0x29, 0x1b, 0x99, 0x5e, 0xf7, 0xad, 0x2b, 0x36,
 0xb4, 0xfb, 0x21, 0xc9, 0xec, 0x5e, 0x54, 0xf1, 0x58, 0xbf, 0x3f, 0x56, 0x8f, 0xda, 0x68, 0xbf,
 0x49, 0xc7, 0xef, 0xa7, 0xfb, 0xbb, 0x0e, 0xee, 0xd0, 0xc2, 0x61, 0x69, 0x61, 0x30, 0xd4, 0xf0,
 0xd4, 0x21, 0xcb, 0x4e, 0x9a, 0xe1, 0x14, 0x48, 0xe2, 0x7d, 0x1b, 0xc3, 0x78, 0x55, 0xe1, 0x61,
 0x8c, 0x71, 0xef, 0xf8, 0xfd, 0x5c, 0x9f, 0x2b, 0x93, 0x3c, 0x8c, 0x93, 0x6f, 0x87, 0xc1, 0x0b,
 0x46, 0x1a, 0x25, 0x71, 0x30, 0xd1, 0xe8, 0x6d, 0xaf, 0xb4, 0x2d, 0x1a, 0xb8, 0x93, 0x34, 0x6a,
 0xd1, 0x6d, 0xa7, 0x68, 0x9c, 0x4d, 0x5a, 0x26, 0x68, 0xd5, 0xa2, 0x76, 0xb6, 0xd0, 0xb4, 0x61,
 0xa2, 0x57, 0x13, 0x0e, 0x25, 0xb6, 0x9d, 0xa1, 0x68, 0xd7, 0x81, 0x33, 0x46, 0xad, 0x13, 0xb4,
 0xed, 0x13, 0x89, 0xab, 0x44, 0xcd, 0x1a, 0xb4, 0x4e, 0xd6, 0xdb, 0xda, 0xa3, 0x50, 0x96, 0x35,
 0x0e, 0x3e, 0x35, 0x35, 0x25, 0x8d, 0x43, 0xf3, 0x66, 0xd8, 0x22, 0xce, 0x42, 0x35, 0x09, 0x63,
 0x50, 0xe3, 0xa3, 0x53, 0x52, 0x58, 0xd4, 0xd4, 0x9d, 0xad, 0x16, 0x72, 0x31, 0xa9, 0xa9, 0x2c,
 0x6a, 0x9c, 0x74, 0x6a, 0x12, 0xc6, 0xa1, 0x3b, 0x5e, 0x2c, 0xe4, 0x63, 0x53, 0x52, 0x68, 0xd5,
 0xd4, 0xe3, 0x63, 0x53, 0x52, 0x58, 0xd4, 0x27, 0x6b, 0xc5, 0x9c, 0x94, 0x2a, 0xea, 0x4b, 0x1a,
 0xa7, 0x1b, 0x1a, 0xa4, 0xb0, 0xa8, 0x4e, 0xd7, 0x8b, 0x39, 0x38, 0x54, 0xd4, 0x96, 0x15, 0x4e,
 0x36, 0x15, 0x75, 0x25, 0x85, 0x5d, 0x4b, 0x6d, 0x78, 0xb3, 0xe7, 0xaf, 0x35, 0x3c, 0xb9, 0xb7,
 0x83, 0x80, 0x7f, 0x9a, 0x69, 0xfc, 0xad, 0x63, 0xc9, 0x4f, 0x55, 0xf3, 0x4f, 0x4b, 0x9b, 0x6f,
 0x70, 0x2f, 0xf3, 0x5d, 0x3f, 0x95, 0xaa, 0x79, 0x51, 0xd2, 0xf1, 0x3e, 0xe6, 0xae, 0x87, 0x8d,
 0xf7, 0x55, 0x00, 0x06, 0xc3, 0x3b, 0xec, 0x68, 0xee, 0x63, 0x76, 0x2f, 0xfd, 0xd9, 0xff, 0x00,
 0x1d, 0x89, 0xfa, 0xc2, 0x58, 0xee, 0x57, 0x75, 0xef, 0xaf, 0x66, 0x3f, 0xc7, 0xe2, 0x7e, 0xb0,
 0xee, 0x10, 0xaa, 0x4d, 0x0a, 0xba, 0x9c, 0xd7, 0xac, 0x65, 0xee, 0x9f, 0x37, 0x89, 0x19, 0xef,
 0xdd, 0x2e, 0x9b, 0x1d, 0xc9, 0xee, 0xb5, 0xf5, 0xec, 0xbf, 0xf8, 0xfc, 0x4f, 0xd6, 0x13, 0x47,
 0x72, 0x1b, 0xab, 0x7f, 0xee, 0xb7, 0xed, 0x0c, 0x4f, 0xd6, 0x1d, 0xca, 0x15, 0x75, 0x27, 0x85,
 0x5d, 0x4b, 0x7a, 0xc6, 0x5e, 0xe9, 0xf3, 0x5e, 0x33, 0x5f, 0xe7, 0x2e, 0x97, 0x1d, 0xc6, 0xee,
 0xa5, 0xf5, 0xec, 0xaf, 0xed, 0x0c, 0x4f, 0xd6, 0x12, 0xc3, 0x71, 0x5b, 0xa6, 0x7d, 0x7b, 0x29,
 0xfb, 0x43, 0x15, 0xf5, 0x87, 0x75, 0x85, 0x6d, 0x49, 0xe1, 0x5b, 0x52, 0x7a, 0xf9, 0x3b, 0xa7,
 0xcd, 0x78, 0xcd, 0x6f, 0x9b, 0xa4, 0xc3, 0x71, 0x1b, 0xa4, 0x7d, 0x7b, 0x27, 0xfb, 0x47, 0x15,
 0xf5, 0x87, 0x6b, 0xd8, 0x0d, 0x80, 0xd8, 0xdd, 0x86, 0xaf, 0x8a, 0xaf, 0xb2, 0xd9, 0x3f, 0x73,
 0xea, 0x62, 0xe3, 0x18, 0x57, 0x7e, 0x79, 0xab, 0x57, 0x9d, 0x45, 0xb6, 0xbf, 0xd6, 0x4a, 0x5c,
 0x3a, 0xdf, 0x51, 0xc9, 0x42, 0xb6, 0xa4, 0xf4, 0xeb, 0x6a, 0x27, 0x35, 0xed, 0x1a, 0x99, 0x95,
 0xe3, 0x2d, 0xa7, 0xdf, 0x2e, 0x6e, 0x9d, 0x7d, 0x4b, 0x34, 0xf1, 0x1a, 0x9c, 0x15, 0x3a, 0xda,
 0x96, 0x29, 0xd7, 0xd4, 0xac, 0x4a, 0xf1, 0x77, 0x3d, 0x4b, 0x13, 0xa9, 0xd7, 0x77, 0xc5, 0x89,
 0xe6, 0xdc, 0xf6, 0xda, 0x47, 0x8f, 0x5e, 0xcf, 0xe3, 0xd7, 0xf8, 0x79, 0x97, 0x29, 0xd7, 0xd4,
 0xeb, 0xdb, 0xdc, 0xaf, 0xc7, 0x74, 0x9b, 0x62, 0xb8, 0xf5, 0xe4, 0x38, 0xef, 0x90, 0x99, 0x96,
 0x93, 0xfb, 0xd0, 0xcb, 0x5b, 0xbf, 0x38, 0x00, 0x07, 0xbe, 0xda, 0x0f, 0xaf, 0xbf, 0xec, 0xe6,
 0xca, 0xd5, 0x55, 0xb6, 0xb9, 0x9c, 0xa3, 0xc5, 0xc7, 0xce, 0x74, 0x20, 0xfd, 0x7b, 0xd2, 0x97,
 0xf9, 0x4f, 0x90, 0x4f, 0xb6, 0x7f, 0xec, 0xed, 0x7e, 0x77, 0xd8, 0x5d, 0xa6, 0xc4, 0x2f, 0xf6,
 0xb9, 0xa4, 0x20, 0xff, 0x00, 0xf2, 0xd2, 0x4f, 0xfc, 0xc6, 0x0e, 0x45, 0xbd, 0x1c, 0x73, 0x28,
 0xb5, 0x62, 0xd1, 0xa9, 0x7d, 0x33, 0x5b, 0x09, 0xa1, 0x4e, 0xb6, 0x13, 0x43, 0x9c, 0x85, 0x7a,
 0x55, 0x17, 0x09, 0x2e, 0x0c, 0x4f, 0x0f, 0x19, 0xae, 0x31, 0x69, 0x9a, 0x55, 0xcc, 0xd2, 0xcb,
 0xc1, 0x8b, 0x7b, 0x9d, 0x5a, 0xb6, 0x13, 0x42, 0xa5, 0x5c, 0x33, 0x5d, 0xe3, 0xb4, 0xd6, 0xc2,
 0x68, 0x53, 0xad, 0x84, 0xd0, 0xd8, 0xae, 0x67, 0x95, 0x9b, 0xc3, 0xff, 0x00, 0x27, 0x59, 0xa9,
 0x45, 0xae, 0xb4, 0x41, 0x3a, 0x5a, 0x1d, 0x82, 0xb6, 0x13, 0x42, 0x9d, 0x6c, 0x37, 0x2a, 0x6d,
 0xf4, 0x25, 0xdf, 0x36, 0x2b, 0x95, 0xe5, 0xe5, 0xe1, 0xcc, 0x38, 0x59, 0xd2, 0x3a, 0xb6, 0xda,
 0x6d, 0x96, 0xc9, 0xec, 0x85, 0x1b, 0x9b, 0x45, 0x9e, 0x60, 0xf0, 0x32, 0x6b, 0x8c, 0x69, 0x4a,
 0x5c, 0xd5, 0x66, 0xbc, 0x31, 0xa7, 0x1e, 0x32, 0x7e, 0xc2, 0x3c, 0x47, 0x7f, 0xde, 0x68, 0x7a,
 0xd4, 0xf1, 0xd8, 0x9d, 0x9b, 0xdd, 0xee, 0x22, 0x10, 0x8d, 0x29, 0x3a, 0x78, 0x9c, 0xde, 0x3c,
 0x25, 0xce, 0xfa, 0x9c, 0x68, 0xf7, 0xb8, 0x7f, 0x3f, 0xbf, 0xf7, 0xbd, 0xe9, 0x3f, 0x99, 0x31,
 0xb8, 0xac, 0x4e, 0x37, 0x17, 0x57, 0x17, 0x8c, 0xc4, 0x56, 0xc4, 0xe2, 0x2a, 0xc9, 0xca, 0xa5,
 0x5a, 0xb3, 0x73, 0x9c, 0xdf, 0x85, 0xb7, 0xd2, 0xd9, 0x9a, 0x2d, 0x2d, 0xae, 0x37, 0x80, 0x4e,
 0x58, 0xf4, 0xb2, 0xce, 0xa3, 0xe5, 0xf1, 0xff, 0x00, 0xb3, 0xea, 0x1d, 0xaa, 0xf3, 0x4d, 0xe4,
 0x38, 0x79, 0x4e, 0x96, 0xce, 0x6c, 0xfe, 0x33, 0x30, 0x92, 0xe8, 0x55, 0xb1, 0x55, 0x15, 0x08,
 0x7a, 0xe9, 0x2e, 0x69, 0x35, 0xeb, 0xf2, 0x9e, 0x67, 0x9f, 0xf9, 0xa1, 0x37, 0x87, 0x99, 0x39,
 0x2c, 0x1d, 0x7c, 0xbf, 0x29, 0x83, 0xe8, 0x4b, 0x0b, 0x86, 0x52, 0x97, 0x0f, 0x5e, 0xa7, 0x37,
 0x4f, 0xad, 0xc0, 0xf2, 0x40, 0x3d, 0x39, 0x7b, 0x38, 0x7c, 0x17, 0x85, 0x8b, 0xfe, 0x9c, 0x4f,
 0xd7, 0xdb, 0xff, 0x00, 0x67, 0x3f, 0x9e, 0x6d, 0xa6, 0xd6, 0xe7, 0x7c, 0xcb, 0x35, 0xda, 0x4c,
 0xd3, 0x17, 0x09, 0x75, 0xd3, 0x9e, 0x26, 0x56, 0xff, 0x00, 0x55, 0x3e, 0x5f, 0x78, 0xe0, 0x00,
 0x2b, 0xb7, 0xa3, 0x4c, 0x74, 0xc7, 0x1a, 0xa4, 0x6a, 0x3f, 0x20, 0x1d, 0x97, 0x66, 0xb6, 0x0b,
 0x6c, 0xb6, 0x8d, 0xc5, 0xe4, 0xdb, 0x37, 0x98, 0xe2, 0xa9, 0xcb, 0xaa, 0xb5, 0x97, 0x0a, 0x5f,
 0xaf, 0x2e, 0x11, 0xf7, 0xca, 0x1b, 0x5f, 0xb3, 0xd9, 0x96, 0xca, 0xed, 0x0e, 0x27, 0x21, 0xce,
 0x29, 0xd3, 0xa7, 0x8e, 0xc3, 0x28, 0x3a, 0xb1, 0x84, 0xd4, 0xd4, 0x79, 0xe1, 0x19, 0xa5, 0xc5,
 0x74, 0x3e, 0x89, 0x21, 0xa5, 0x63, 0x36, 0x3b, 0x5f, 0xa7, 0x16, 0x8d, 0xfc, 0xbe, 0x2e, 0x24,
 0x00, 0x19, 0x5e, 0xbd, 0xe6, 0x51, 0x5c, 0xdb, 0xc4, 0xc7, 0xaf, 0xcd, 0x35, 0x3e, 0x5a, 0x89,
 0xf4, 0xcc, 0xa9, 0x9f, 0x35, 0x79, 0x92, 0x63, 0xcd, 0xbc, 0x7c, 0xc1, 0x7e, 0x68, 0xa9, 0xf2,
 0xd4, 0x4f, 0xa8, 0x25, 0x4c, 0xf4, 0x38, 0xd6, 0xd5, 0x1f, 0x2b, 0xfb, 0x5b, 0xb8, 0xf1, 0x19,
 0xfa, 0x42, 0x84, 0xa0, 0x47, 0x2a, 0x65, 0xe9, 0x53, 0x23, 0x95, 0x33, 0x6e, 0x2c, 0xe6, 0xa2,
 0xcf, 0x89, 0x37, 0x89, 0xd1, 0xbc, 0x0d, 0xa3, 0x5f, 0x9d, 0x71, 0x5f, 0x2b, 0x23, 0x81, 0x39,
 0xfd, 0xe3, 0xf4, 0x6f, 0x0f, 0x69, 0x17, 0xe7, 0x6c, 0x57, 0xcb, 0x48, 0xe0, 0x0f, 0x1a, 0xdf,
 0xc5, 0x2f, 0xb9, 0x71, 0x7e, 0xe2, 0x9f, 0x48, 0xfd, 0x03, 0xd1, 0xbc, 0xce, 0xd4, 0x55, 0x5d,
 0xe3, 0xd3, 0x97, 0x0f, 0xf5, 0x58, 0x4a, 0xb3, 0x5e, 0xf2, 0xf9, 0xcf, 0x39, 0x3d, 0x47, 0xcc,
 0xcb, 0x1e, 0x6d, 0xe2, 0x57, 0xd3, 0x2e, 0xaa, 0xff, 0x00, 0xe7, 0xa6, 0x64, 0xe3, 0xfd, 0xed,
 0x5a, 0x7e, 0x33, 0x3e, 0x8f, 0x03, 0x2c, 0xff, 0x00, 0xed, 0x97, 0xd1, 0x32, 0x81, 0x1c, 0xa0,
 0x5e, 0x95, 0x32, 0x39, 0x40, 0xf7, 0xe2, 0xcf, 0x92, 0x45, 0x94, 0x65, 0x4c, 0x8a, 0xa5, 0x3e,
 0x31, 0x6b, 0x87, 0x59, 0x7e, 0x54, 0xc8, 0xe5, 0x4c, 0xbc, 0x59, 0x78, 0xbb, 0xe2, 0x70, 0x01,
 0xcb, 0xbe, 0xd6, 0x1e, 0xad, 0xe6, 0x75, 0xa0, 0xa7, 0x98, 0xe7, 0x15, 0xb8, 0x74, 0xc2, 0x8d,
 0x38, 0xfb, 0x6e, 0x4f, 0xfc, 0xa7, 0x94, 0x9e, 0xc7, 0xe6, 0x6a, 0x87, 0x33, 0xcf, 0xdf, 0x83,
 0xce, 0xff, 0x00, 0xf5, 0x4d, 0xbe, 0x07, 0xfe, 0x62, 0xbf, 0xef, 0xe0, 0xf2, 0x3c, 0x7a, 0xde,
 0x8f, 0x87, 0xe4, 0x9f, 0xa7, 0xeb, 0x0f, 0x56, 0x95, 0x32, 0x39, 0x43, 0x42, 0xf4, 0xa9, 0xe8,
 0x47, 0x28, 0x1d, 0x3c, 0x59, 0xf3, 0x68, 0xb2, 0x8c, 0xa9, 0x9c, 0x2e, 0xda, 0x43, 0xff, 0x00,
 0x08, 0x67, 0x3f, 0xa0, 0x57, 0xf9, 0x39, 0x1d, 0x92, 0x54, 0xce, 0x13, 0x6d, 0xa1, 0xc3, 0x63,
 0xb3, 0xb7, 0xf9, 0xbe, 0xbf, 0xc9, 0xc8, 0x64, 0xb7, 0xee, 0x4f, 0xd1, 0xb3, 0xc6, 0xb7, 0xfc,
 0xda, 0xfd, 0x63, 0xf5, 0x7c, 0xbe, 0x00, 0x38, 0xd7, 0xd5, 0xc3, 0xd8, 0xb7, 0x24, 0xb8, 0xec,
 0xa6, 0x29, 0xff, 0x00, 0x4e, 0x9f, 0xc9, 0xd3, 0x3c, 0x74, 0xf6, 0x7d, 0xc6, 0x47, 0x9b, 0x64,
 0x71, 0x4f, 0xfa, 0x7c, 0xfe, 0x4e, 0x99, 0xe9, 0xf8, 0x4c, 0xeb, 0x93, 0x1f, 0x49, 0x78, 0x9e,
 0x3f, 0x3a, 0xe1, 0xcf, 0xd6, 0x1d, 0xd5, 0xc4, 0xd5, 0xc4, 0xb1, 0x28, 0x1a, 0x38, 0x9d, 0x5c,
 0x4b, 0x87, 0x89, 0x78, 0x76, 0xf6, 0xea, 0x39, 0xed, 0xa5, 0x78, 0x3f, 0xf6, 0x74, 0xa9, 0xc5,
 0x7e, 0xaf, 0x1f, 0x9c, 0xea, 0x27, 0x69, 0xde, 0xaf, 0x15, 0xb7, 0x79, 0x87, 0x1f, 0x05, 0x2e,
 0x1e, 0x4a, 0x27, 0x56, 0x38, 0xae, 0x64, 0xef, 0x91, 0x7f, 0xac, 0xfe, 0xaf, 0xa4, 0x78, 0x7c,
 0x6b, 0x8b, 0x8f, 0xff, 0x00, 0x8c, 0x7e, 0x81, 0x36, 0x0b, 0x13, 0x5f, 0x05, 0x8b, 0xa5, 0x8b,
 0xc3, 0x4f, 0x92, 0xb5, 0x29, 0x29, 0xc2, 0x5c, 0x13, 0xe0, 0xd7, 0x53, 0xe0, 0xfa, 0x08, 0x41,
 0xaf, 0x13, 0x31, 0x3b, 0x86, 0xd4, 0xc4, 0x4c, 0x6a, 0x5d, 0x93, 0xec, 0xeb, 0x6a, 0xbc, 0x69,
 0xfe, 0x1e, 0x97, 0xd1, 0x1f, 0x67, 0x3b, 0x53, 0xe3, 0x4f, 0xf0, 0xf4, 0xbe, 0x89, 0xd6, 0xc1,
 0x9f, 0xd7, 0x39, 0x1f, 0x89, 0x3e, 0x72, 0xd6, 0xf5, 0x2e, 0x37, 0xe1, 0xd7, 0xca, 0x1d, 0x8f,
 0xec, 0xe3, 0x6a, 0x7c, 0x69, 0xfe, 0x1e, 0x97, 0xd1, 0x1f, 0x67, 0x1b, 0x51, 0xe3, 0x3f, 0xf0,
 0xf4, 0xfe, 0x89, 0xd7, 0x01, 0x3e, 0xb9, 0xc8, 0xfc, 0x49, 0xf3, 0x93, 0xd4, 0xb8, 0xdf, 0x87,
 0x5f, 0x28, 0x76, 0x27, 0xb6, 0xfb, 0x4f, 0xe3, 0x3f, 0xee, 0x29, 0xfd, 0x13, 0xae, 0x80, 0x62,
 0xc9, 0x9b, 0x26, 0x5d, 0x7a, 0x76, 0x99, 0xfa, 0xce, 0xd9, 0x71, 0xe1, 0xc7, 0x8b, 0x7e, 0x85,
 0x62, 0x37, 0xf2, 0x8d, 0x00, 0x03, 0x1b, 0x2b, 0xd2, 0xb7, 0x3f, 0x57, 0x9b, 0x2e, 0xc7, 0xd0,
 0xe3, 0xf7, 0x15, 0x63, 0x3f, 0xd6, 0x5c, 0x3f, 0xca, 0x77, 0x96, 0x8f, 0x3d, 0xdc, 0xd4, 0xbe,
 0xdf, 0x99, 0xc3, 0xc3, 0x1a, 0x6f, 0xda, 0x72, 0xed, 0x3d, 0x19, 0xa3, 0xb6, 0xf0, 0x9b, 0x6f,
 0x89, 0x4f, 0xeb, 0xfa, 0xcb, 0x88, 0xf1, 0x68, 0xf4, 0x79, 0x97, 0xfe, 0x9f, 0xa4, 0x21, 0x68,
 0xc3, 0x89, 0x2b, 0x89, 0xab, 0x47, 0xa7, 0xb7, 0x9d, 0xb4, 0x4e, 0x26, 0xad, 0x13, 0x34, 0x6a,
 0xd1, 0x3b, 0x5b, 0x68, 0x5c, 0x4c, 0x38, 0x92, 0xb8, 0x98, 0x71, 0x27, 0x69, 0xda, 0x16, 0x8d,
 0x5a, 0x26, 0x68, 0xd5, 0xc4, 0xb6, 0xd3, 0x12, 0x89, 0xc4, 0xd5, 0xc4, 0x99, 0xa3, 0x56, 0x89,
 0xda, 0xdb, 0x42, 0xd1, 0xa5, 0x47, 0x1a, 0x70, 0x95, 0x49, 0xc9, 0x46, 0x11, 0x5c, 0x65, 0x26,
 0xf8, 0x24, 0x89, 0xaa, 0x38, 0xc2, 0x12, 0x9c, 0xe4, 0xa3, 0x18, 0xae, 0x2d, 0xb7, 0xc1, 0x24,
 0x79, 0xa6, 0xd9, 0xed, 0x2c, 0xb3, 0x2a, 0x92, 0xc1, 0x60, 0xa4, 0xe3, 0x83, 0x8b, 0xe9, 0x92,
 0xe8, 0x75, 0x5f, 0x87, 0xd6, 0xd0, 0xd3, 0xe7, 0x73, 0xe9, 0xc3, 0xc7, 0xe9, 0x5b, 0xdf, 0xf0,
 0x8f, 0x9b, 0x73, 0x87, 0xc4, 0xbf, 0x2a, 0xfe, 0x8d, 0x7d, 0xdf, 0x19, 0x63, 0x6c, 0x36, 0x96,
 0x59, 0x8c, 0xe5, 0x83, 0xc1, 0x49, 0xc7, 0x06, 0x9f, 0xa6, 0x97, 0x53, 0xab, 0xfb, 0xb4, 0x3a,
 0xc0, 0x07, 0x09, 0xc9, 0xe4, 0xe4, 0xe4, 0xe4, 0x9c, 0x99, 0x27, 0xda, 0xec, 0x30, 0x60, 0xa6,
 0x0a, 0x45, 0x29, 0x1e, 0xc0, 0x02, 0xf6, 0x4b, 0x95, 0xe2, 0xb3, 0x6c, 0x62, 0xc3, 0xe1, 0xa3,
 0xd0, 0xba, 0x67, 0x37, 0xf7, 0x30, 0x5e, 0x16, 0x63, 0xc7, 0x8e, 0xd9, 0x2d, 0x15, 0xac, 0x6e,
 0x65, 0x92, 0xf7, 0xad, 0x2b, 0x36, 0xb4, 0xea, 0x21, 0xae, 0x51, 0x97, 0x62, 0x73, 0x3c, 0x64,
 0x70, 0xd8, 0x68, 0xf1, 0x6f, 0xa6, 0x52, 0x7d, 0x51, 0x5e, 0x16, 0x7a, 0x5e, 0x4f, 0x96, 0x61,
 0xf2, 0xbc, 0x1c, 0x70, 0xf4, 0x16, 0xb3, 0x9b, 0xeb, 0x9b, 0xf0, 0xb2, 0x5c, 0x9b, 0x2a, 0xc2,
 0xe5, 0x58, 0x35, 0x87, 0xc3, 0xc7, 0xa7, 0xae, 0x73, 0x7d, 0x73, 0x7e, 0x16, 0x5d, 0x71, 0x3b,
 0x8f, 0x0a, 0xf0, 0xba, 0xf0, 0xeb, 0xe9, 0xdb, 0xdb, 0x79, 0xfe, 0xdf, 0x94, 0x39, 0x6e, 0x77,
 0x88, 0x4f, 0x22, 0xde, 0x8d, 0x7f, 0x87, 0xf5, 0x42, 0xd1, 0xab, 0x44, 0xce, 0x26, 0xad, 0x1e,
 0xd6, 0xde, 0x7e, 0xd1, 0x34, 0x6a, 0xd1, 0x2b, 0x46, 0x1a, 0x27, 0x69, 0xda, 0x17, 0x13, 0x56,
 0x89, 0x9c, 0x4c, 0x34, 0x4e, 0xd6, 0xda, 0x16, 0x8d, 0x5a, 0x26, 0x71, 0x35, 0x68, 0xb4, 0x4a,
 0x76, 0x85, 0xa3, 0x0d, 0x12, 0xf0, 0x30, 0xe2, 0x4e, 0xd6, 0xda, 0x17, 0x13, 0x57, 0x12, 0x66,
 0x8c, 0x34, 0x5b, 0x69, 0xda, 0x06, 0x8c, 0x34, 0x4c, 0xd1, 0xab, 0x89, 0x3b, 0x4c, 0x4b, 0xd3,
 0x23, 0x53, 0x52, 0x58, 0xd4, 0xd4, 0xe3, 0xe3, 0x50, 0x96, 0x35, 0x0f, 0xcd, 0xbb, 0x6b, 0x45,
 0x97, 0xe3, 0x50, 0x96, 0x35, 0x0e, 0x3e, 0x35, 0x09, 0x63, 0x50, 0x9d, 0xad, 0x16, 0x72, 0x11,
 0xa8, 0x4b, 0x1a, 0x87, 0x1d, 0x1a, 0x84, 0xb1, 0xa9, 0xa9, 0x3b, 0x5e, 0x2c, 0xe4, 0x23, 0x50,
 0x96, 0x35, 0x35, 0x38, 0xf8, 0xd4, 0x25, 0x8d, 0x42, 0x76, 0xb4, 0x59, 0xc8, 0x46, 0xa1, 0x2c,
 0x2a, 0x6a, 0x71, 0xd1, 0xa9, 0xa9, 0x2c, 0x6a, 0x13, 0xb5, 0xe2, 0xce, 0x46, 0x15, 0x09, 0x63,
 0x53, 0x53, 0x8e, 0x8d, 0x42, 0x58, 0xd4, 0xd4, 0x9d, 0xaf, 0x16, 0x78, 0x4f, 0x9a, 0x56, 0x5c,
 0xdb, 0x75, 0x82, 0x7f, 0x9b, 0x29, 0xfc, 0xad, 0x53, 0xcb, 0xcf, 0x4c, 0xf3, 0x46, 0x4b, 0x9b,
 0x6d, 0xf0, 0x6f, 0xf3, 0x6c, 0x3e, 0x56, 0xa9, 0xe6, 0x67, 0x4f, 0xc3, 0xfb, 0x8a, 0xfd, 0x1d,
 0x37, 0x13, 0xee, 0x6a, 0x00, 0x0d, 0x96, 0xcb, 0xee, 0xd8, 0x55, 0x26, 0x85, 0x5d, 0x4e, 0x32,
 0x15, 0x75, 0x26, 0x85, 0x5d, 0x4e, 0x4b, 0x6e, 0x66, 0x2c, 0xe4, 0xe1, 0x54, 0x9a, 0x15, 0x75,
 0x38, 0xb8, 0x55, 0x26, 0x85, 0x5d, 0x4b, 0x6d, 0x78, 0xb3, 0x94, 0x85, 0x5d, 0x49, 0xa1, 0x57,
 0x53, 0x8b, 0x85, 0x52, 0x58, 0x55, 0xd4, 0x9d, 0xaf, 0x16, 0x72, 0xd0, 0xad, 0xa9, 0x34, 0x2b,
 0x6a, 0x71, 0x30, 0xaa, 0x4f, 0x0a, 0xba, 0x93, 0xb5, 0xe2, 0xce, 0x5a, 0x15, 0xb5, 0x27, 0x85,
 0x6d, 0x4e, 0x22, 0x15, 0x75, 0x27, 0x85, 0x6d, 0x4b, 0x6d, 0x92, 0x2c, 0xe5, 0xe9, 0xd6, 0xd4,
 0xe0, 0x37, 0xad, 0x5b, 0x8e, 0xea, 0xb6, 0xb9, 0x71, 0xeb, 0xc8, 0xf1, 0xbf, 0x21, 0x32, 0xf4,
 0x2b, 0x6a, 0x70, 0x3b, 0xd2, 0xab, 0xc7, 0x75, 0xfb, 0x56, 0xbc, 0x39, 0x2e, 0x33, 0xe4, 0x26,
 0x64, 0xc7, 0x3f, 0xbd, 0x0c, 0xb4, 0xb7, 0xb6, 0x1f, 0x00, 0x80, 0x0e, 0x8d, 0xea, 0x07, 0xda,
 0x9e, 0x60, 0xa9, 0x5a, 0xdd, 0x6e, 0x71, 0x3f, 0xc6, 0xce, 0xea, 0x2f, 0x6a, 0x85, 0x1e, 0xd3,
 0xe2, 0xb3, 0xec, 0xbf, 0x30, 0xed, 0x4b, 0x7b, 0xa8, 0xcc, 0xd7, 0x87, 0x3c, 0xaa, 0xff, 0x00,
 0xb8, 0xa0, 0x6a, 0xf3, 0x27, 0xfe, 0x52, 0x99, 0x27, 0x50, 0xfa, 0x62, 0x8e, 0x29, 0xf8, 0x4b,
 0xb4, 0x31, 0x8d, 0x7d, 0xf1, 0xd6, 0xa9, 0xe2, 0x35, 0x2c, 0xd2, 0xc4, 0x6a, 0x79, 0x31, 0x66,
 0x3a, 0xe4, 0x76, 0xba, 0x58, 0xc8, 0xc9, 0x70, 0x9a, 0x4c, 0x97, 0x92, 0x95, 0x55, 0xe9, 0x5a,
 0xf5, 0x8e, 0xb5, 0x4b, 0x12, 0xfc, 0x25, 0xca, 0x38, 0xb6, 0xbb, 0xe5, 0xe2, 0xf3, 0x0c, 0x9e,
 0x94, 0x5b, 0xde, 0xe4, 0x6b, 0x61, 0x34, 0x3e, 0x6a, 0xf3, 0x70, 0x6f, 0x16, 0xae, 0xc9, 0x6c,
 0x96, 0x1f, 0x63, 0xf2, 0x8a, 0xee, 0x96, 0x69, 0x9e, 0xc2, 0x4f, 0x11, 0x38, 0xbf, 0x4d, 0x47,
 0x08, 0xba, 0x25, 0xc3, 0xc0, 0xe6, 0xf8, 0xc7, 0x8f, 0x82, 0x33, 0xd0, 0xfa, 0x4a, 0x86, 0x39,
 0xf5, 0x37, 0xc5, 0x6a, 0x7e, 0x71, 0x79, 0xaf, 0xb6, 0x86, 0xa6, 0xd1, 0x79, 0xa0, 0x36, 0x8e,
 0xa3, 0x9b, 0x74, 0x30, 0x13, 0x86, 0x02, 0x84, 0x78, 0xfd, 0xc4, 0x69, 0x41, 0x29, 0x2f, 0xd7,
 0x73, 0x7e, 0xc9, 0xb9, 0xc6, 0x9f, 0x4e, 0xca, 0x4e, 0x0c, 0x73, 0x3b, 0x79, 0x18, 0x00, 0xf4,
 0x59, 0x83, 0xd6, 0xb7, 0x5d, 0xb8, 0x3d, 0xb5, 0xdb, 0x7c, 0x15, 0x1c, 0xd6, 0x71, 0xa5, 0x92,
 0xe5, 0x35, 0x92, 0x95, 0x3c, 0x4e, 0x2d, 0x3e, 0x7a, 0xb1, 0xfc, 0x68, 0x53, 0x5d, 0x2d, 0x78,
 0x1b, 0x71, 0x4f, 0xbc, 0xd9, 0x0f, 0x99, 0x63, 0x62, 0x30, 0x7b, 0x79, 0xbd, 0xfc, 0x0e, 0x5d,
 0x99, 0x52, 0x8d, 0x7c, 0xbf, 0x03, 0x46, 0x78, 0xfc, 0x55, 0x19, 0x2e, 0x2a, 0xac, 0x69, 0xb8,
 0xa8, 0xc5, 0xe8, 0xe7, 0x28, 0x71, 0x5d, 0xf5, 0xc5, 0x1f, 0xa0, 0xf5, 0x30, 0x71, 0x8c, 0x54,
 0x63, 0x05, 0x18, 0xa5, 0xc1, 0x24, 0xb8, 0x24, 0x8a, 0x5a, 0xf1, 0x13, 0xa7, 0x9f, 0xce, 0xe4,
 0x64, 0xc7, 0x1e, 0x8e, 0x3f, 0x7b, 0xe7, 0x0d, 0x99, 0xf3, 0x30, 0x6c, 0x2e, 0x5b, 0x18, 0xcf,
 0x39, 0xc5, 0x66, 0x59, 0xdd, 0x65, 0xf7, 0x4a, 0x55, 0x2c, 0x52, 0x7e, 0xb4, 0x61, 0xe9, 0x97,
 0xeb, 0x33, 0xd1, 0x72, 0x0d, 0xde, 0x6c, 0x56, 0xcf, 0xf2, 0xbc, 0x9f, 0x65, 0xf2, 0xbc, 0x2d,
 0x48, 0xf5, 0x55, 0x58, 0x78, 0xca, 0xa7, 0xeb, 0xcb, 0x8c, 0xbd, 0xf3, 0xbf, 0xd5, 0xc2, 0xb5,
 0xde, 0x2a, 0xd4, 0xa0, 0xd7, 0x78, 0xb5, 0x6f, 0x0e, 0x5f, 0x93, 0x7e, 0x46, 0x4f, 0xe3, 0xb4,
 0xcb, 0x89, 0x9d, 0x2d, 0x0f, 0x86, 0x7c, 0xd3, 0xfd, 0x1b, 0xf3, 0xda, 0x25, 0xe0, 0x78, 0x65,
 0xfe, 0x1a, 0x91, 0xf7, 0xac, 0xe9, 0x68, 0x7c, 0x01, 0xe6, 0x8b, 0xc5, 0x47, 0x17, 0xbe, 0xcd,
 0xa8, 0xab, 0x06, 0x9a, 0x8e, 0x2d, 0x52, 0xf6, 0x61, 0x08, 0xc1, 0xfb, 0xf1, 0x2f, 0x36, 0xdc,
 0x36, 0x7c, 0x03, 0x0f, 0xa1, 0xc9, 0xb5, 0xbf, 0xf6, 0xff, 0x00, 0xac, 0x3c, 0xfc, 0x00, 0x55,
 0xd7, 0xbd, 0xa3, 0xcc, 0x7d, 0x1e, 0x6d, 0xe5, 0xe6, 0x2b, 0xf3, 0x35, 0x5f, 0x96, 0xa2, 0x7d,
 0x51, 0x3a, 0x5a, 0x1f, 0x2e, 0x79, 0x8d, 0x23, 0xcd, 0xbc, 0xfc, 0xc9, 0x7e, 0x65, 0xab, 0xf2,
 0xf4, 0x0f, 0xac, 0xe7, 0x4b, 0x43, 0x6b, 0x0d, 0xb5, 0x57, 0xcd, 0xfe, 0xd4, 0x61, 0xf4, 0xf9,
 0xd3, 0x3f, 0x94, 0x38, 0x99, 0xd2, 0x21, 0x95, 0x23, 0x95, 0x9d, 0x2d, 0x08, 0x67, 0x4b, 0x43,
 0x3c, 0x5d, 0xca, 0xdf, 0x8f, 0xa7, 0xc1, 0x9b, 0xca, 0xe8, 0xde, 0x36, 0xd3, 0x2f, 0xce, 0xf8,
 0xaf, 0x96, 0x91, 0xd7, 0xce, 0xc5, 0xbc, 0xe5, 0xc3, 0x79, 0x5b, 0x50, 0xbc, 0x19, 0xc6, 0x2f,
 0xe5, 0xa6, 0x75, 0xd3, 0xcf, 0xb7, 0xbe, 0x5f, 0x6b, 0xe2, 0xfd, 0xc5, 0x3e, 0x91, 0xfa, 0x07,
 0xaa, 0xf9, 0x97, 0x97, 0x1d, 0xe3, 0x62, 0x17, 0xe6, 0xda, 0xbf, 0x1e, 0x99, 0xe5, 0x47, 0xac,
 0xf9, 0x95, 0xd7, 0x1d, 0xe4, 0xe2, 0x17, 0xe6, 0xca, 0xbf, 0x1e, 0x99, 0x93, 0x0f, 0xde, 0x43,
 0x47, 0xc7, 0x3f, 0xf4, 0xec, 0xdf, 0x49, 0x7d, 0x2b, 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x95, 0x32,
 0x39, 0x53, 0x3d, 0x88, 0xb3, 0xe3, 0xb1, 0x65, 0x19, 0x53, 0x23, 0x94, 0x0b, 0xd2, 0xa6, 0x47,
 0x28, 0x17, 0x8b, 0x32, 0x45, 0x9f, 0x09, 0x80, 0x0e, 0x7d, 0xf7, 0x30, 0xf6, 0x8f, 0x33, 0x14,
 0x79, 0xbe, 0xc8, 0x7f, 0xf4, 0xdf, 0xf5, 0x4f, 0x17, 0x3d, 0xb7, 0xcc, 0xb7, 0x1e, 0x65, 0xb4,
 0x7f, 0xfa, 0x5f, 0xfa, 0xa6, 0xd7, 0x0a, 0x75, 0x9e, 0xbf, 0xef, 0xe0, 0xf1, 0x3e, 0xd1, 0x4e,
 0xbc, 0x37, 0x27, 0xf4, 0xff, 0x00, 0xed, 0x0f, 0x60, 0x94, 0x08, 0xe5, 0x4c, 0xbd, 0x28, 0x11,
 0xca, 0x99, 0xd0, 0x45, 0x9f, 0x31, 0x8b, 0x28, 0xca, 0x99, 0xc1, 0xed, 0xcc, 0x38, 0x6c, 0x5e,
 0x78, 0xff, 0x00, 0x37, 0x62, 0x3e, 0x4e, 0x47, 0x66, 0x95, 0x33, 0x82, 0xdb, 0xc8, 0x70, 0xd8,
 0x8c, 0xf9, 0xfe, 0x6d, 0xc4, 0x7c, 0x9c, 0x85, 0xed, 0xfb, 0x92, 0xda, 0xe2, 0xdb, 0xfe, 0x75,
 0x3e, 0xb1, 0xfa, 0xbe, 0x4d, 0x00, 0x1c, 0xab, 0xeb, 0xe1, 0xed, 0xdb, 0x85, 0x8f, 0x36, 0xc7,
 0x62, 0xdf, 0xe7, 0x09, 0xfc, 0x9d, 0x33, 0xc4, 0x4f, 0x74, 0xf3, 0x3f, 0x47, 0x8e, 0xc6, 0x62,
 0xdf, 0xe7, 0x19, 0xfc, 0x9d, 0x33, 0xd1, 0xf0, 0xb9, 0xd7, 0x22, 0x3e, 0x8f, 0x0b, 0xed, 0x14,
 0xeb, 0x85, 0x3f, 0x58, 0x77, 0x89, 0x53, 0x23, 0x95, 0x32, 0xf4, 0xa9, 0x91, 0xca, 0x99, 0xd3,
 0x45, 0x9c, 0x0c, 0x5d, 0xf3, 0xfe, 0xf9, 0x28, 0x3a, 0x3b, 0x71, 0x5a, 0x4d, 0x70, 0xbb, 0x46,
 0x9c, 0xfd, 0xee, 0x5f, 0xf2, 0x9d, 0x34, 0xf5, 0x0d, 0xff, 0x00, 0xe0, 0x1d, 0x3c, 0xc7, 0x2c,
 0xcc, 0x52, 0xe8, 0xa9, 0x4a, 0x54, 0x64, 0xfc, 0x0e, 0x2f, 0x99, 0x7c, 0x67, 0xed, 0x1e, 0x5e,
 0x72, 0x7c, 0xea, 0xfa, 0x3c, 0x8b, 0xfd, 0x7f, 0x57, 0xd2, 0xbc, 0x27, 0x24, 0x64, 0xe1, 0xe3,
 0x98, 0xf9, 0x6b, 0xcb, 0xd8, 0x1c, 0x96, 0xcb, 0xe0, 0x28, 0x66, 0x7b, 0x41, 0x82, 0xcb, 0xf1,
 0x33, 0xa9, 0x0a, 0x55, 0xea, 0x72, 0x49, 0xc1, 0xa5, 0x25, 0xeb, 0x71, 0x4c, 0xe3, 0x4b, 0x99,
 0x26, 0x2f, 0xce, 0x19, 0xce, 0x0b, 0x1c, 0xf8, 0xf0, 0xa1, 0x5e, 0x15, 0x1e, 0xa9, 0x49, 0x36,
 0x6b, 0xe3, 0x98, 0x8b, 0xc7, 0xa5, 0xee, 0xdb, 0x77, 0x34, 0x5a, 0x71, 0xda, 0x2b, 0xef, 0xd4,
 0xe9, 0xea, 0xbe, 0x85, 0xd9, 0x07, 0xf2, 0xcc, 0xcf, 0xca, 0x43, 0xe8, 0x18, 0xf4, 0x2f, 0xc8,
 0x3f, 0x95, 0xe6, 0x7e, 0x52, 0x1f, 0x40, 0xef, 0xb1, 0xe1, 0x28, 0x46, 0x70, 0x6a, 0x51, 0x92,
 0xe2, 0x9a, 0xea, 0x68, 0xc3, 0x47, 0x61, 0x1c, 0x0e, 0x37, 0x64, 0x38, 0x0f, 0xda, 0xbc, 0xbf,
 0xc4, 0x97, 0x42, 0x7b, 0xb0, 0xc8, 0x7f, 0x95, 0xe6, 0x7e, 0x52, 0x1f, 0x40, 0xd5, 0xee, 0xc7,
 0x21, 0xfe, 0x57, 0x99, 0xf9, 0x48, 0x7d, 0x03, 0xbe, 0xb8, 0x98, 0x68, 0x9f, 0x50, 0xe3, 0x76,
 0x42, 0x7f, 0x6a, 0xf2, 0xff, 0x00, 0x12, 0x5d, 0x0f, 0xd0, 0xc7, 0x21, 0xfe, 0x57, 0x99, 0x79,
 0x48, 0x7d, 0x03, 0x57, 0xbb, 0x2c, 0x8b, 0xf9, 0x5e, 0x65, 0xe5, 0x21, 0xf4, 0x0e, 0xef, 0x8d,
 0xc4, 0x61, 0xf0, 0x78, 0x69, 0xe2, 0x71, 0x55, 0x61, 0x46, 0x8d, 0x35, 0xc6, 0x73, 0x93, 0xe0,
 0x91, 0x5f, 0x07, 0x99, 0xe5, 0x98, 0xde, 0x1e, 0x74, 0xcc, 0x30, 0xb8, 0x8e, 0x3d, 0xea, 0x75,
 0xa3, 0x27, 0xef, 0x32, 0x27, 0x85, 0xc4, 0x89, 0xd4, 0xd6, 0x36, 0xbc, 0x78, 0x8f, 0x36, 0x63,
 0xd2, 0x8b, 0xce, 0x9d, 0x43, 0xd0, 0xcf, 0x22, 0xfe, 0x57, 0x99, 0x79, 0x48, 0x7d, 0x03, 0x57,
 0xbb, 0x4c, 0x8f, 0xf9, 0x5e, 0x65, 0xe5, 0x21, 0xf4, 0x0e, 0xf6, 0xd1, 0xab, 0x89, 0x7f, 0xd9,
 0xfc, 0x5e, 0xc8, 0x47, 0xed, 0x4e, 0x5f, 0xe2, 0x4b, 0xae, 0xec, 0xce, 0xcb, 0x65, 0xfb, 0x3f,
 0x56, 0xbd, 0x4c, 0x1d, 0x6c, 0x55, 0x47, 0x5a, 0x2a, 0x32, 0xbb, 0x28, 0xb4, 0xb8, 0x78, 0x38,
 0x24, 0x73, 0x6d, 0x12, 0xb8, 0x98, 0x71, 0x36, 0xf1, 0x63, 0xa6, 0x2a, 0xfa, 0x34, 0x8d, 0x43,
 0x5b, 0x26, 0x6b, 0xe5, 0xb7, 0xa7, 0x79, 0xdc, 0xa1, 0x68, 0xd5, 0xa2, 0x66, 0x8d, 0x78, 0x19,
 0x76, 0xae, 0xd1, 0x34, 0x6a, 0xe2, 0x4c, 0xd1, 0xab, 0x89, 0x3b, 0x4e, 0xd0, 0xb4, 0x61, 0xa2,
 0x56, 0x8c, 0x72, 0x93, 0xb5, 0xb6, 0x85, 0xa3, 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x2d, 0xb4, 0xed,
 0x0b, 0x89, 0x86, 0x89, 0x9a, 0x3a, 0x36, 0xf1, 0xf6, 0x8b, 0xce, 0xd0, 0x96, 0x4f, 0x82, 0x9f,
 0x0a, 0xd3, 0x5f, 0x6f, 0x9c, 0x5f, 0xdc, 0x45, 0xfd, 0xef, 0xae, 0xfb, 0xfa, 0x7a, 0xe6, 0x0e,
 0x57, 0x2a, 0x9c, 0x6c, 0x73, 0x92, 0xed, 0x9e, 0x2f, 0x1e, 0xfc, 0x8c, 0x91, 0x8e, 0x8e, 0x23,
 0x6f, 0x36, 0x9b, 0xcf, 0xb5, 0x27, 0x96, 0x60, 0x2a, 0x7f, 0xdd, 0x60, 0xf8, 0x55, 0xa9, 0x17,
 0xfe, 0xb1, 0xf8, 0x17, 0xf3, 0x7e, 0x13, 0xa7, 0x80, 0x70, 0x9c, 0x9e, 0x4d, 0xf9, 0x39, 0x27,
 0x25, 0xdd, 0xbf, 0x1f, 0x8f, 0x4e, 0x3e, 0x38, 0xa5, 0x00, 0x0e, 0x4f, 0x67, 0x32, 0x6c, 0x4e,
 0x75, 0x8f, 0x58, 0x7a, 0x1e, 0x96, 0x9c, 0x7a, 0x6a, 0xd4, 0x6b, 0xa2, 0x0b, 0xb7, 0xc0, 0x8c,
 0x58, 0xf1, 0xdb, 0x25, 0xa2, 0x94, 0x8d, 0xcc, 0xb2, 0x64, 0xbd, 0x71, 0xd6, 0x6d, 0x69, 0xd4,
 0x43, 0x1b, 0x3f, 0x93, 0x62, 0xb3, 0x9c, 0x65, 0x9a, 0x0b, 0x96, 0x9c, 0x7a, 0x6a, 0x55, 0x6b,
 0xa2, 0x0b, 0xb7, 0x43, 0xd4, 0xb2, 0x9c, 0xb3, 0x0b, 0x95, 0xe0, 0xe3, 0x85, 0xc2, 0xd3, 0xe5,
 0x8a, 0xe9, 0x94, 0x9f, 0x5c, 0x9f, 0x85, 0xb2, 0x7c, 0xaf, 0x2e, 0xc2, 0xe5, 0x98, 0x28, 0x61,
 0x30, 0x94, 0xf9, 0x61, 0x1e, 0xb7, 0xdf, 0x93, 0xf0, 0xb7, 0xdf, 0x65, 0x96, 0x8e, 0xdf, 0xc3,
 0x3c, 0x36, 0x9c, 0x3a, 0xfa, 0x53, 0xed, 0xb4, 0xfc, 0x7f, 0xd2, 0x1c, 0x8f, 0x3b, 0xc4, 0x2d,
 0xc9, 0xb6, 0xa3, 0xd9, 0x58, 0xff, 0x00, 0x7e, 0xd4, 0x2d, 0x1a, 0xb4, 0x4c, 0xe2, 0x6a, 0xd1,
 0xeb, 0x6d, 0xa1, 0xb4, 0x4d, 0x1a, 0xb4, 0x4c, 0xd1, 0xab, 0x45, 0xb6, 0xb6, 0xd0, 0xb8, 0x98,
 0x68, 0x99, 0xa3, 0x56, 0x89, 0xda, 0x76, 0x85, 0xa3, 0x56, 0x89, 0x9a, 0x35, 0x71, 0x27, 0x69,
 0xda, 0x26, 0x8d, 0x5a, 0x26, 0x68, 0xd5, 0xa2, 0xdb, 0x5b, 0x68, 0x9c, 0x4d, 0x5c, 0x49, 0x5a,
 0x30, 0xe2, 0x4c, 0x4a, 0x76, 0x85, 0xc4, 0xc3, 0x44, 0xad, 0x1a, 0xb8, 0x93, 0xb5, 0xa2, 0x51,
 0x34, 0x6a, 0xd1, 0x33, 0x46, 0xad, 0x16, 0xda, 0x76, 0xed, 0xf1, 0xa8, 0x49, 0x1a, 0x85, 0x18,
 0xd4, 0x24, 0x8d, 0x43, 0xf3, 0x76, 0xda, 0x71, 0x65, 0xf8, 0xd4, 0x24, 0x8d, 0x42, 0x84, 0x6a,
 0x12, 0x46, 0xa1, 0x3b, 0x5e, 0x2c, 0xbf, 0x1a, 0x84, 0xb1, 0xa8, 0x50, 0x8d, 0x42, 0x48, 0xd4,
 0xd4, 0x9d, 0xad, 0x16, 0x72, 0x11, 0xa9, 0xa9, 0x24, 0x6a, 0x14, 0x23, 0x50, 0x92, 0x35, 0x35,
 0x27, 0x6b, 0x45, 0x9c, 0x84, 0x6a, 0x12, 0x46, 0xa1, 0x42, 0x35, 0x09, 0x23, 0x50, 0x9d, 0xaf,
 0x16, 0x72, 0x10, 0xa8, 0x4b, 0x1a, 0x87, 0x1f, 0x1a, 0x84, 0xb1, 0xa8, 0x4e, 0xd6, 0x8b, 0x3c,
 0x5f, 0xcd, 0x09, 0x2e, 0x6d, 0xb3, 0xc1, 0xbf, 0xcd, 0xd0, 0xf9, 0x4a, 0x87, 0x9c, 0x1e, 0x87,
 0xbf, 0xc9, 0x73, 0x6d, 0x86, 0x11, 0xfe, 0x6f, 0x87, 0xca, 0x54, 0x3c, 0xf0, 0xea, 0x78, 0x7f,
 0x71, 0x5f, 0xa3, 0xac, 0xe1, 0x7d, 0xc5, 0x7e, 0x80, 0x00, 0xd9, 0x6d, 0x3e, 0xd3, 0x85, 0x42,
 0x58, 0x55, 0x38, 0xe8, 0xd4, 0xd4, 0x96, 0x35, 0x0e, 0x3f, 0x6e, 0x4a, 0x2c, 0xe4, 0xa1, 0x54,
 0x96, 0x35, 0x75, 0x38, 0xd8, 0xd4, 0xd4, 0x96, 0x35, 0x4b, 0x6d, 0x68, 0xb3, 0x93, 0x85, 0x52,
 0x68, 0x55, 0x38, 0xc8, 0x55, 0x25, 0x85, 0x5d, 0x49, 0xda, 0xf1, 0x67, 0x27, 0x0a, 0xba, 0x93,
 0x42, 0xa9, 0xc6, 0x42, 0xa9, 0x2c, 0x2a, 0xea, 0x4e, 0xd7, 0x8b, 0x39, 0x48, 0x55, 0xd4, 0x9a,
 0x15, 0x75, 0x38, 0xb8, 0x55, 0x26, 0x85, 0x52, 0x76, 0xc9, 0x16, 0x72, 0xb0, 0xad, 0xa9, 0xc1,
 0x6f, 0x36, 0xaf, 0x1d, 0xd9, 0xed, 0x4a, 0xe3, 0xd7, 0x93, 0x62, 0xfe, 0x46, 0x65, 0xe8, 0x55,
 0xd4, 0xe1, 0x37, 0x93, 0x57, 0x8e, 0xee, 0x36, 0x99, 0x7e, 0x68, 0xc5, 0xfc, 0x8c, 0x8c, 0x98,
 0xe7, 0xf7, 0xa1, 0x97, 0x1d, 0xbf, 0x7a, 0x1f, 0x0e, 0x00, 0x0e, 0x9d, 0xee, 0x07, 0xd7, 0xfe,
 0x62, 0xba, 0x9c, 0x9b, 0xad, 0xcc, 0x57, 0xe7, 0xaa, 0xbf, 0x23, 0x40, 0xf9, 0x00, 0xfa, 0xd3,
 0xcc, 0x71, 0x53, 0x93, 0x76, 0x39, 0x82, 0xe3, 0xf8, 0x66, 0xaf, 0xc8, 0xd1, 0x34, 0xf9, 0xdf,
 0x74, 0xc1, 0xc8, 0x9d, 0x51, 0xf4, 0x15, 0x3a, 0xfa, 0x96, 0x69, 0xd7, 0xd4, 0xe1, 0x21, 0x5b,
 0x52, 0xc4, 0x2b, 0x1e, 0x36, 0xda, 0x71, 0x77, 0x37, 0x4e, 0xbe, 0xa5, 0x9a, 0x78, 0x8d, 0x4e,
 0x0a, 0x9d, 0x7d, 0x4b, 0x14, 0xeb, 0xea, 0x5a, 0x25, 0x92, 0x2e, 0xe7, 0xe9, 0x62, 0x75, 0x3f,
 0x35, 0x77, 0xdc, 0xa6, 0xb7, 0xc7, 0xb6, 0x6e, 0xa7, 0x1e, 0x2f, 0x3d, 0xc6, 0x4b, 0xa7, 0xc0,
 0xeb, 0x4d, 0xaf, 0x7b, 0x81, 0xfa, 0x29, 0x4e, 0xbe, 0xa7, 0xc2, 0x7e, 0x6b, 0x2c, 0x8e, 0xa6,
 0x4d, 0xbe, 0xac, 0xd7, 0x11, 0xc8, 0xe3, 0x43, 0x34, 0x85, 0x3c, 0x75, 0x17, 0xe1, 0xe6, 0x8f,
 0x2c, 0xff, 0x00, 0xe7, 0x8c, 0xfd, 0xe3, 0x7f, 0x83, 0x6f, 0xdf, 0x98, 0x6c, 0xe2, 0xbe, 0xe7,
 0x4f, 0x27, 0x00, 0x1e, 0xa3, 0x33, 0xdc, 0x7c, 0xc4, 0x1b, 0x43, 0x83, 0xc8, 0xb7, 0xf1, 0x83,
 0xc3, 0xe3, 0x6a, 0x46, 0x95, 0x3c, 0xe3, 0x07, 0x57, 0x2e, 0x84, 0xe4, 0xf8, 0x25, 0x52, 0x4e,
 0x13, 0x82, 0xff, 0x00, 0xcd, 0x2a, 0x6a, 0x2b, 0x59, 0x23, 0xf4, 0x26, 0xb6, 0x13, 0xaf, 0xa0,
 0xfc, 0x88, 0xc3, 0xd6, 0xab, 0x87, 0xaf, 0x4e, 0xbd, 0x0a, 0xb3, 0xa5, 0x5a, 0x9c, 0x94, 0xe9,
 0xce, 0x12, 0x6a, 0x51, 0x92, 0x7c, 0x53, 0x4d, 0x75, 0x34, 0xcf, 0xb6, 0x37, 0x13, 0xe6, 0xb4,
 0xc9, 0x71, 0x79, 0x56, 0x1b, 0x25, 0xde, 0x65, 0x49, 0xe0, 0x73, 0x1a, 0x31, 0x54, 0xd6, 0x69,
 0x1a, 0x4e, 0x74, 0x71, 0x1c, 0x3a, 0x14, 0xa6, 0xa2, 0x9b, 0x84, 0xfc, 0x3c, 0x13, 0x8b, 0xe9,
 0x7e, 0x97, 0xa8, 0xd5, 0xe4, 0x52, 0xdb, 0xf4, 0xaa, 0xa5, 0xf1, 0x56, 0xfe, 0xf7, 0xd2, 0x55,
 0xb0, 0x9a, 0x14, 0xeb, 0x61, 0x34, 0x38, 0xb8, 0x6f, 0x77, 0x74, 0xf5, 0xb0, 0xbe, 0x78, 0x5b,
 0xc4, 0xd9, 0x68, 0xc5, 0xae, 0x3c, 0x25, 0x9a, 0x52, 0x52, 0xfd, 0x57, 0x2e, 0x6f, 0x78, 0xf3,
 0x2d, 0xe5, 0xf9, 0xa9, 0x37, 0x67, 0xb3, 0xb8, 0x6a, 0xb4, 0xb6, 0x7e, 0xbd, 0x6d, 0xa8, 0xcc,
 0x52, 0x6a, 0x14, 0xf0, 0xb0, 0x74, 0xe8, 0x29, 0x7f, 0x3a, 0xac, 0xd7, 0x57, 0xf5, 0x54, 0x8c,
 0x58, 0xed, 0x79, 0xf6, 0x69, 0xa3, 0x97, 0x81, 0x13, 0xee, 0x76, 0xdd, 0xeb, 0x6d, 0x56, 0x55,
 0xb0, 0x1b, 0x19, 0x8e, 0xda, 0x3c, 0xd6, 0x71, 0x4a, 0x8c, 0x5c, 0x70, 0xf4, 0x5c, 0xb8, 0x4b,
 0x11, 0x59, 0xa7, 0xc9, 0x4e, 0x3a, 0xb7, 0xd7, 0xe0, 0x49, 0xbe, 0xf1, 0xf9, 0xb7, 0x9a, 0xe3,
 0xb1, 0x39, 0xa6, 0x69, 0x8b, 0xcc, 0xb1, 0xb5, 0x1d, 0x4c, 0x56, 0x2e, 0xb4, 0xeb, 0xd6, 0x9b,
 0xfb, 0xe9, 0xce, 0x4e, 0x52, 0x7e, 0xdb, 0x67, 0x6a, 0xde, 0xc6, 0xf2, 0xb6, 0xa3, 0x79, 0x79,
 0xf7, 0x75, 0x36, 0x87, 0x15, 0x1b, 0x74, 0xb8, 0xac, 0x2e, 0x0e, 0x8a, 0x71, 0xa1, 0x86, 0x8b,
 0xef, 0x46, 0x3e, 0x17, 0xdf, 0x93, 0xe2, 0xdf, 0x05, 0xd3, 0xc1, 0x24, 0xba, 0x61, 0xbb, 0x58,
 0x98, 0x8f, 0x6b, 0x2f, 0x13, 0x89, 0x5e, 0x3c, 0x4c, 0xfc, 0x64, 0x00, 0x16, 0x6e, 0x3d, 0xc3,
 0xcc, 0x5c, 0xd7, 0xa2, 0xb6, 0x3a, 0x3f, 0x8d, 0x93, 0x56, 0x4b, 0xca, 0xd1, 0x7f, 0x31, 0xf5,
 0xfc, 0xe9, 0x68, 0x7c, 0x69, 0xe6, 0x39, 0xc4, 0x2a, 0x5b, 0xea, 0xc3, 0x51, 0x6f, 0x83, 0xc4,
 0xe0, 0x71, 0x14, 0x96, 0xbc, 0x22, 0xa7, 0xfe, 0x43, 0xed, 0xa9, 0xd2, 0xd0, 0xb5, 0x6d, 0xa7,
 0x19, 0xe3, 0xd8, 0x3d, 0x2e, 0x4e, 0xff, 0x00, 0x28, 0x71, 0x33, 0xa5, 0xa1, 0x0c, 0xe9, 0x68,
 0x72, 0xd3, 0xa4, 0x41, 0x3a, 0x5a, 0x19, 0x62, 0xee, 0x72, 0xfc, 0x77, 0xe7, 0x96, 0xf4, 0xd7,
 0x0d, 0xe7, 0x6d, 0x52, 0xf0, 0x67, 0x58, 0xcf, 0x96, 0x99, 0xd6, 0xce, 0xcd, 0xbd, 0x75, 0xc3,
 0x7a, 0x5b, 0x58, 0xbc, 0x19, 0xde, 0x33, 0xe5, 0xe6, 0x75, 0x93, 0x0c, 0xfb, 0xdf, 0x50, 0xe3,
 0xc6, 0xb1, 0x57, 0xe9, 0x1f, 0xa0, 0x7a, 0xef, 0x99, 0x42, 0x3c, 0xdb, 0xcc, 0xc4, 0x2f, 0xcd,
 0x75, 0x7e, 0x3d, 0x33, 0xc8, 0x8f, 0x62, 0xf3, 0x22, 0xc7, 0x9b, 0x7a, 0x38, 0x95, 0xf9, 0xaa,
 0xaf, 0xca, 0x53, 0x2d, 0x8e, 0x75, 0x68, 0x68, 0xf8, 0xdc, 0x7a, 0x5e, 0x1f, 0x96, 0x3f, 0x29,
 0x7d, 0x43, 0x3a, 0x44, 0x52, 0xa6, 0x72, 0x73, 0xa3, 0xa1, 0x0c, 0xe9, 0x1e, 0x8c, 0x5d, 0xf1,
 0xcb, 0x62, 0x98, 0x71, 0xd2, 0xa6, 0x47, 0x2a, 0x65, 0xf9, 0xd2, 0xd0, 0x8a, 0x54, 0xf4, 0x32,
 0x45, 0x94, 0xdc, 0xc7, 0xbd, 0xf9, 0xfe, 0x00, 0x3c, 0x77, 0xde, 0x83, 0xdc, 0xbc, 0xca, 0x71,
 0xe6, 0x5b, 0x4b, 0xff, 0x00, 0xa5, 0xff, 0x00, 0xac, 0x78, 0x69, 0xee, 0xfe, 0x64, 0xc8, 0xf3,
 0x2d, 0xa6, 0xff, 0x00, 0xd2, 0x7f, 0xd6, 0x36, 0x38, 0xb3, 0xac, 0xb0, 0xf0, 0xbe, 0xd2, 0xce,
 0xbc, 0x33, 0x2f, 0xf4, 0xff, 0x00, 0xed, 0x0f, 0x6a, 0x95, 0x32, 0x39, 0x53, 0x2f, 0x4a, 0x99,
 0x1c, 0xa9, 0x9e, 0xd4, 0x59, 0xf2, 0xb8, 0xb2, 0x8c, 0xa9, 0x9c, 0x06, 0xdf, 0xc3, 0xff, 0x00,
 0x03, 0x67, 0xef, 0xf3, 0x66, 0x27, 0xe4, 0xa4, 0x76, 0x99, 0x43, 0x43, 0xaf, 0xef, 0x0a, 0x1c,
 0x36, 0x0f, 0x68, 0x7f, 0xfc, 0x5e, 0x27, 0xe4, 0xa4, 0x4d, 0xad, 0xfb, 0xb2, 0xda, 0xe2, 0xdb,
 0xfe, 0x75, 0x3e, 0xb1, 0xfa, 0xbe, 0x3c, 0x00, 0x1c, 0xe3, 0xec, 0xe1, 0xef, 0x5e, 0x67, 0x78,
 0xf1, 0xd8, 0x9c, 0x63, 0xfc, 0xe5, 0x3f, 0x93, 0xa4, 0x78, 0x29, 0xf4, 0x07, 0x99, 0xc2, 0x3c,
 0x76, 0x1f, 0x18, 0xff, 0x00, 0x39, 0x54, 0xf9, 0x2a, 0x46, 0xf7, 0x87, 0x4e, 0xb3, 0x39, 0xff,
 0x00, 0xb4, 0xb3, 0xae, 0x0c, 0xfd, 0x61, 0xe8, 0x12, 0x81, 0x1c, 0xa9, 0x97, 0xa5, 0x02, 0x39,
 0x53, 0x3a, 0x18, 0xb3, 0xe7, 0x91, 0x67, 0x41, 0xdf, 0x06, 0x4b, 0x2c, 0xd7, 0x62, 0xb1, 0x32,
 0xa5, 0x0e, 0x6a, 0xd8, 0x36, 0xb1, 0x30, 0xe1, 0xd7, 0xc2, 0x3c, 0x79, 0xbf, 0xe5, 0x6f, 0xda,
 0x47, 0xce, 0xe7, 0xd8, 0x35, 0x69, 0x46, 0x71, 0x70, 0x94, 0x54, 0xa2, 0xd7, 0x06, 0x9a, 0xe2,
 0x9a, 0x3e, 0x64, 0xde, 0x4e, 0xcd, 0x54, 0xd9, 0x8d, 0xa7, 0xaf, 0x84, 0x8c, 0x1f, 0x9d, 0x2a,
 0xb7, 0x57, 0x0b, 0x2e, 0xf3, 0x83, 0x7d, 0x5e, 0xba, 0xea, 0xf6, 0x9f, 0x7c, 0xf2, 0x3c, 0x53,
 0x16, 0xe6, 0x32, 0xc7, 0xd2, 0x5d, 0xa7, 0xd9, 0x7e, 0x74, 0x4d, 0x6d, 0xc6, 0xb4, 0xfb, 0x7d,
 0xf1, 0xfe, 0xae, 0xb2, 0x00, 0x3c, 0x77, 0x5e, 0xf6, 0xbd, 0xd1, 0xed, 0x2d, 0x2c, 0xd3, 0x28,
 0x86, 0x4f, 0x8a, 0xa8, 0x96, 0x3b, 0x09, 0x0e, 0x58, 0x29, 0x3e, 0x9a, 0x94, 0xd7, 0x53, 0x5a,
 0xae, 0xa7, 0xec, 0x33, 0xbc, 0x4a, 0x99, 0xf3, 0x0e, 0x0f, 0x13, 0x88, 0xc1, 0xe2, 0x69, 0xe2,
 0x70, 0xb5, 0xa7, 0x46, 0xb5, 0x39, 0x73, 0x42, 0x70, 0x7c, 0x1c, 0x59, 0xea, 0x1b, 0x37, 0xbd,
 0x78, 0xaa, 0x51, 0xa1, 0x9f, 0xe0, 0xe7, 0x29, 0xae, 0x8f, 0x3c, 0x61, 0xd2, 0xf4, 0xda, 0xb8,
 0xbe, 0x1e, 0xf3, 0xf6, 0x0e, 0x83, 0x83, 0xe2, 0x75, 0x8a, 0xc5, 0x32, 0xce, 0xa6, 0x3e, 0x2e,
 0x43, 0xc5, 0x7c, 0x13, 0x27, 0x52, 0x72, 0xf1, 0xe3, 0x71, 0x3e, 0xf8, 0xf9, 0x7d, 0x1e, 0x96,
 0xe0, 0x68, 0xe2, 0x75, 0xd5, 0xbc, 0x5d, 0x8f, 0x95, 0x3e, 0x67, 0x99, 0x4e, 0x2f, 0xf1, 0x5e,
 0x1a, 0xa7, 0x1f, 0x7a, 0x3c, 0x0e, 0xbd, 0xb4, 0x7b, 0xd2, 0xc1, 0x42, 0x8c, 0xa9, 0x64, 0x78,
 0x5a, 0x95, 0xab, 0x35, 0xc1, 0x56, 0xaf, 0x1e, 0x58, 0x47, 0x55, 0x1e, 0xb7, 0xec, 0xf0, 0x3d,
 0x2b, 0x73, 0xf8, 0xf4, 0x8d, 0xcd, 0xa3, 0xfa, 0x3c, 0x8c, 0x5e, 0x19, 0xcb, 0xc9, 0x6f, 0x46,
 0x31, 0xcc, 0x7d, 0x63, 0x5f, 0xaa, 0x3d, 0xf3, 0xe7, 0x50, 0xa5, 0x82, 0xa5, 0x91, 0xd1, 0x9a,
 0x75, 0x6b, 0x35, 0x52, 0xba, 0x4f, 0xee, 0x60, 0xbe, 0xe5, 0x3f, 0x5d, 0xf4, 0xfb, 0x1a, 0x9e,
 0x52, 0x4d, 0x8e, 0xc5, 0x62, 0x31, 0xb8, 0xba, 0xb8, 0xbc, 0x5d, 0x59, 0x56, 0xaf, 0x56, 0x5c,
 0xd3, 0x9c, 0x9f, 0x4b, 0x64, 0x27, 0x2d, 0xcb, 0xe4, 0xcf, 0x23, 0x2c, 0xde, 0x7f, 0xa3, 0xba,
 0xe0, 0x71, 0x23, 0x89, 0x82, 0x31, 0xc7, 0xbf, 0xe3, 0xf5, 0x5e, 0xc1, 0xe7, 0x19, 0xb6, 0x0f,
 0x87, 0x9d, 0x73, 0x2c, 0x5d, 0x14, 0xbb, 0xd0, 0xad, 0x24, 0xbd, 0xae, 0x3c, 0x0e, 0x6b, 0x07,
 0xb7, 0xbb, 0x4f, 0x87, 0xe0, 0x9e, 0x3a, 0x35, 0xe2, 0xbb, 0xd5, 0x69, 0x45, 0xfb, 0xe9, 0x27,
 0xef, 0x9d, 0x5c, 0xe6, 0xf6, 0x2b, 0x23, 0xa9, 0x9f, 0xe7, 0xd4, 0x70, 0x7c, 0xb2, 0xb1, 0x17,
 0xcf, 0x88, 0x92, 0xfb, 0xd8, 0x2e, 0xbf, 0x65, 0xf5, 0x7b, 0x23, 0x06, 0x5c, 0xfe, 0x94, 0x53,
 0x1d, 0xa7, 0x73, 0xf9, 0xa7, 0x93, 0x8b, 0x8f, 0x14, 0x9b, 0xe5, 0xac, 0x6a, 0x3f, 0x27, 0xb3,
 0x6c, 0xae, 0x2f, 0x1d, 0x98, 0x64, 0x18, 0x5c, 0x76, 0x63, 0x4e, 0x95, 0x3a, 0xf5, 0xe1, 0xcf,
 0xcb, 0x4e, 0x2d, 0x25, 0x16, 0xfd, 0x2f, 0x5b, 0x7d, 0x6b, 0x83, 0xf6, 0x4e, 0x49, 0xc4, 0x92,
 0x34, 0xe3, 0x08, 0x28, 0x42, 0x2a, 0x31, 0x8a, 0xe0, 0x92, 0x5d, 0x09, 0x06, 0x8e, 0xdb, 0x1c,
 0x4d, 0x6b, 0x11, 0x33, 0xb7, 0xcf, 0x72, 0x5e, 0x2d, 0x79, 0xb4, 0x46, 0xa2, 0x7e, 0x08, 0x5a,
 0x35, 0x68, 0x99, 0xa3, 0x57, 0x12, 0xfb, 0x57, 0x68, 0x9a, 0x35, 0x71, 0x26, 0x68, 0xd5, 0xc4,
 0xb6, 0xd6, 0xda, 0x26, 0x8d, 0x5c, 0x49, 0x5a, 0x30, 0xe2, 0x4e, 0xd3, 0xb4, 0x2d, 0x1a, 0xb4,
 0x4c, 0xe2, 0x6a, 0xd1, 0x6d, 0xad, 0xb7, 0x09, 0xb5, 0xb9, 0xb4, 0x32, 0x4c, 0x9a, 0xae, 0x31,
 0xf0, 0x75, 0x5f, 0xa4, 0xa3, 0x17, 0xdf, 0x9b, 0xea, 0xf6, 0xba, 0xfd, 0x83, 0xc5, 0x2b, 0xd5,
 0xa9, 0x5e, 0xb4, 0xeb, 0x56, 0x9b, 0x9d, 0x49, 0xc9, 0xca, 0x52, 0x7d, 0x6d, 0xbe, 0xb6, 0x76,
 0x9d, 0xe7, 0xe6, 0xaf, 0x1d, 0x9f, 0xcb, 0x07, 0x4e, 0x5c, 0x68, 0x60, 0xfd, 0x22, 0x4b, 0xa9,
 0xcd, 0xfd, 0xd3, 0xf9, 0xbd, 0x83, 0xa9, 0x9c, 0x6f, 0x8b, 0xf2, 0xe7, 0x3e, 0x69, 0xac, 0x7f,
 0x0d, 0x7d, 0x9f, 0xe5, 0xda, 0x78, 0x47, 0x12, 0x30, 0x60, 0x8b, 0x4f, 0xbe, 0xde, 0xdf, 0xe9,
 0xf0, 0x00, 0x07, 0x94, 0xf5, 0x9b, 0x52, 0x83, 0xa9, 0x56, 0x34, 0xd3, 0x8a, 0x72, 0x69, 0x27,
 0x29, 0x24, 0x97, 0xae, 0xdf, 0x52, 0x3d, 0x63, 0x67, 0x6a, 0x6c, 0xfe, 0x4d, 0x96, 0x43, 0x09,
 0x4b, 0x36, 0xcb, 0xdc, 0xfe, 0xea, 0xac, 0xfc, 0xf1, 0x0f, 0x4f, 0x2e, 0xfb, 0xeb, 0x3c, 0x94,
 0x1b, 0xdc, 0x1e, 0x6f, 0xaa, 0x5a, 0x6d, 0x15, 0xdc, 0xb4, 0xb9, 0xbc, 0x3f, 0x5a, 0xac, 0x56,
 0x6d, 0xa8, 0x7b, 0x53, 0xce, 0x72, 0x6f, 0x1b, 0x65, 0xfe, 0xe9, 0x87, 0x69, 0x87, 0x9c, 0xe4,
 0xde, 0x36, 0xc0, 0x7b, 0xa2, 0x1d, 0xa7, 0x8b, 0x03, 0xd4, 0xff, 0x00, 0x88, 0x72, 0xf6, 0x43,
 0xce, 0xfd, 0x85, 0x8f, 0xbe, 0x5e, 0xce, 0xf3, 0x9c, 0x9f, 0xc6, 0xd8, 0x0f, 0x74, 0x43, 0xb4,
 0xc3, 0xce, 0x32, 0x7f, 0x1a, 0xe0, 0x3d, 0xd1, 0x0e, 0xd3, 0xc6, 0x40, 0xff, 0x00, 0x88, 0xb2,
 0xf6, 0x42, 0x7f, 0x61, 0x63, 0xef, 0x97, 0xb2, 0x3c, 0xe3, 0x27, 0xf1, 0xae, 0x03, 0xdd, 0x10,
 0xed, 0x36, 0xa3, 0x99, 0xe5, 0xb5, 0xea, 0xc6, 0x95, 0x1c, 0xc7, 0x09, 0x56, 0xa4, 0xba, 0x23,
 0x08, 0x56, 0x8b, 0x6f, 0xd6, 0x49, 0x9e, 0x32, 0x73, 0x1b, 0x19, 0xff, 0x00, 0xd5, 0x18, 0x0f,
 0xed, 0x3e, 0x66, 0x65, 0xc3, 0xe3, 0xf9, 0x32, 0x64, 0xad, 0x26, 0x91, 0xed, 0x98, 0x85, 0x32,
 0xf8, 0x35, 0x31, 0xe3, 0xb5, 0xbd, 0x29, 0xf6, 0x43, 0xd5, 0xda, 0x30, 0xd1, 0x33, 0x89, 0xab,
 0x89, 0xd4, 0xed, 0xcf, 0x44, 0xa1, 0x68, 0xc3, 0x44, 0xad, 0x1a, 0xb4, 0x4e, 0xd6, 0xda, 0x26,
 0x8d, 0x5c, 0x49, 0x9a, 0x35, 0x68, 0x9d, 0xa7, 0x68, 0x5a, 0x30, 0xd1, 0x33, 0x46, 0xae, 0x25,
 0xb6, 0xb6, 0xd0, 0xb4, 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x44, 0xed, 0x3b, 0x44, 0xd1, 0xab, 0x89,
 0x33, 0x46, 0xad, 0x13, 0xb5, 0xb6, 0xe4, 0xa3, 0x50, 0x96, 0x35, 0x0a, 0x2a, 0x5c, 0x09, 0x23,
 0x50, 0xfc, 0xe1, 0xb6, 0x8c, 0x59, 0x7a, 0x35, 0x09, 0x23, 0x53, 0x52, 0x8c, 0x6a, 0x12, 0x46,
 0xa0, 0xda, 0xd1, 0x65, 0xe8, 0xd4, 0xd4, 0x96, 0x35, 0x35, 0x28, 0x46, 0xa1, 0x2c, 0x66, 0x5b,
 0x6b, 0x45, 0x97, 0xa3, 0x50, 0x92, 0x35, 0x0a, 0x11, 0x99, 0x2c, 0x6a, 0x0d, 0xad, 0x16, 0x5f,
 0x8d, 0x4d, 0x49, 0x23, 0x50, 0xa1, 0x1a, 0x84, 0xb1, 0xa8, 0x4e, 0xd7, 0x8b, 0x2f, 0xc6, 0xa1,
 0x24, 0x6a, 0x14, 0x23, 0x50, 0x92, 0x35, 0x09, 0xda, 0xd1, 0x67, 0x93, 0x6f, 0xd1, 0xf3, 0x6d,
 0x6e, 0x15, 0xff, 0x00, 0x40, 0x87, 0xca, 0x54, 0x3a, 0x01, 0xde, 0xb7, 0xd8, 0xf9, 0xb6, 0xab,
 0x0a, 0xff, 0x00, 0xa0, 0xc3, 0xe5, 0x2a, 0x1d, 0x14, 0xea, 0xf8, 0x5f, 0x71, 0x5f, 0xa3, 0xb1,
 0xe0, 0xff, 0x00, 0xe5, 0xe9, 0xf4, 0x00, 0x06, 0xd3, 0x6d, 0xf5, 0xdc, 0x6a, 0x6a, 0x4b, 0x0a,
 0x9a, 0x9c, 0x7c, 0x6a, 0x12, 0x46, 0xa6, 0xa7, 0x1b, 0xb7, 0x17, 0x16, 0x72, 0x31, 0xa8, 0x4b,
 0x1a, 0x87, 0x1d, 0x1a, 0x84, 0xb1, 0xa8, 0x4e, 0xd7, 0x8b, 0x39, 0x18, 0xd4, 0xd4, 0x96, 0x15,
 0x35, 0x38, 0xe8, 0xd4, 0x25, 0x8d, 0x42, 0x76, 0xb4, 0x59, 0xc9, 0x46, 0xa9, 0x2c, 0x2a, 0xea,
 0x71, 0xb1, 0xa8, 0x4b, 0x0a, 0x84, 0xed, 0x78, 0xb3, 0x93, 0x85, 0x52, 0x58, 0x55, 0xd4, 0xe3,
 0x23, 0x53, 0x52, 0x68, 0x55, 0x27, 0x6b, 0xc5, 0x9c, 0x9c, 0x2a, 0x9c, 0x2e, 0xf1, 0x6a, 0x71,
 0xdd, 0xde, 0xd2, 0x2e, 0x3d, 0x79, 0x4e, 0x2b, 0xe4, 0x64, 0x5c, 0x8d, 0x53, 0x88, 0xde, 0x0d,
 0x4e, 0x3b, 0xbf, 0xda, 0x25, 0xc7, 0xf0, 0x56, 0x2b, 0xe4, 0xa4, 0x64, 0xc7, 0x3f, 0xbf, 0x0c,
 0xb8, 0xed, 0xfb, 0xd0, 0xf8, 0xd0, 0x00, 0x75, 0x4e, 0x90, 0x3e, 0xaa, 0xf3, 0x21, 0x4f, 0x97,
 0x76, 0xd8, 0xf5, 0xf9, 0xde, 0xaf, 0xc8, 0xd1, 0x3e, 0x55, 0x3e, 0xa1, 0xf3, 0x26, 0xcf, 0x97,
 0x77, 0x58, 0xe5, 0xf9, 0xda, 0xa7, 0xc9, 0x51, 0x34, 0xb9, 0xff, 0x00, 0x72, 0xd6, 0xe5, 0xce,
 0xb1, 0xbd, 0xce, 0x15, 0xb5, 0x27, 0x85, 0x6d, 0x4e, 0x26, 0x15, 0x75, 0x26, 0x85, 0x5d, 0x4f,
 0x0f, 0x6f, 0x32, 0x2c, 0xe5, 0xe9, 0xd6, 0x27, 0xa7, 0x5b, 0x53, 0x88, 0x85, 0x5d, 0x49, 0xa1,
 0x58, 0xb6, 0xd9, 0x22, 0xee, 0x62, 0x9d, 0x6d, 0x4f, 0x27, 0xf3, 0x50, 0xee, 0xfe, 0xae, 0xdb,
 0xec, 0x64, 0x33, 0x1c, 0xae, 0x8b, 0xab, 0x9c, 0xe5, 0x1c, 0xd5, 0x68, 0xc2, 0x2b, 0xd3, 0x57,
 0xa4, 0xf8, 0x73, 0xd3, 0x5e, 0x17, 0xd0, 0xa4, 0xb5, 0x4d, 0x7d, 0xf1, 0xe8, 0xf0, 0xac, 0x4f,
 0x0a, 0xda, 0x99, 0x31, 0xe4, 0x9a, 0x5a, 0x2d, 0x0c, 0xb4, 0xc9, 0xe8, 0xce, 0xdf, 0x9b, 0x4d,
 0x34, 0xf8, 0x35, 0xc1, 0xa3, 0x07, 0xd5, 0xdb, 0xf5, 0xdc, 0x55, 0x3d, 0xa2, 0xc5, 0x57, 0xda,
 0x4d, 0x8d, 0x8d, 0x1c, 0x3e, 0x67, 0x51, 0xb9, 0xe2, 0x70, 0x32, 0x6a, 0x14, 0xf1, 0x32, 0xef,
 0xca, 0x0f, 0xaa, 0x33, 0x7d, 0xf4, 0xfa, 0x1f, 0x5f, 0x43, 0xe3, 0xc7, 0xe5, 0xec, 0xeb, 0x29,
 0xcc, 0xf2, 0x4c, 0xc2, 0xa6, 0x5f, 0x9b, 0xe0, 0x31, 0x38, 0x1c, 0x5d, 0x37, 0xe9, 0xa9, 0x57,
 0xa6, 0xe1, 0x25, 0xaf, 0x4f, 0x5a, 0xd7, 0xa8, 0xf7, 0x70, 0xe7, 0xa6, 0x58, 0xdc, 0x3d, 0x0a,
 0x64, 0x8b, 0xc7, 0xb1, 0x48, 0x00, 0x66, 0x5c, 0x00, 0xe4, 0xb6, 0x73, 0x20, 0xce, 0xb6, 0x8f,
 0x32, 0x86, 0x5b, 0x90, 0xe5, 0x78, 0xbc, 0xcb, 0x17, 0x3e, 0xaa, 0x58, 0x7a, 0x4e, 0x6d, 0x2f,
 0x0b, 0xe1, 0xd4, 0xb5, 0x7d, 0x02, 0x67, 0x43, 0x8d, 0x3b, 0x36, 0x67, 0xb0, 0x9b, 0x4f, 0x96,
 0xec, 0x0e, 0x03, 0x6e, 0x31, 0xf9, 0x65, 0x4c, 0x36, 0x49, 0x98, 0xe2, 0x9e, 0x17, 0x09, 0x5a,
 0xa7, 0x43, 0xab, 0x25, 0x17, 0x2e, 0x65, 0x1e, 0xbe, 0x56, 0xa3, 0x2e, 0x0f, 0xbf, 0xc1, 0xf0,
 0xea, 0x3e, 0x96, 0xdc, 0x5f, 0x99, 0x8b, 0x0d, 0x80, 0xc4, 0x61, 0xf3, 0xed, 0xe4, 0x3a, 0x38,
 0xba, 0xd0, 0x6a, 0x74, 0xb2, 0x7a, 0x72, 0x52, 0xa5, 0x17, 0xde, 0xbd, 0x25, 0xd1, 0x3f, 0xea,
 0xaf, 0x4b, 0xe1, 0x72, 0x5d, 0x07, 0xae, 0xf9, 0xa8, 0xf6, 0x72, 0x1b, 0x4d, 0xb8, 0x6c, 0xf3,
 0x2f, 0xc2, 0xd0, 0x8a, 0xab, 0x96, 0xd1, 0x8e, 0x3f, 0x09, 0x08, 0x47, 0x82, 0x85, 0x8e, 0x96,
 0xa2, 0x97, 0xff, 0x00, 0x6f, 0x9e, 0x29, 0x2f, 0x09, 0xa9, 0x6e, 0x5d, 0x7d, 0x38, 0xad, 0x51,
 0x16, 0x87, 0xe7, 0x30, 0x00, 0xdb, 0x4b, 0xbc, 0x6e, 0x13, 0x3a, 0x86, 0xcf, 0xef, 0x8f, 0x65,
 0xf3, 0x3a, 0xb3, 0x50, 0xa4, 0xb1, 0xf0, 0xa1, 0x56, 0x4f, 0xaa, 0x30, 0xaa, 0x9d, 0x29, 0x37,
 0xa2, 0x53, 0x6c, 0xfd, 0x1a, 0xab, 0x85, 0xd0, 0xfc, 0xae, 0x8b, 0x71, 0x92, 0x94, 0x5b, 0x4d,
 0x3e, 0x29, 0xae, 0xf1, 0xfa, 0x71, 0xb9, 0x0d, 0xa8, 0xa7, 0xb7, 0xdb, 0xaa, 0xc8, 0xf6, 0x91,
 0x54, 0x8c, 0xf1, 0x35, 0xb0, 0xea, 0x96, 0x31, 0x2e, 0xb8, 0xe2, 0x21, 0xe9, 0x6a, 0x71, 0x5d,
 0xee, 0x32, 0x4e, 0x4b, 0x49, 0x23, 0x16, 0x4b, 0x7a, 0x3a, 0x97, 0x97, 0xe2, 0x1c, 0x4e, 0xb6,
 0xac, 0xbf, 0x52, 0x83, 0x5d, 0xe2, 0x09, 0xd2, 0xd0, 0xec, 0x55, 0xb0, 0x9d, 0x7d, 0x05, 0x3a,
 0xd8, 0x4d, 0x05, 0x72, 0xb9, 0xfc, 0xbc, 0x29, 0x87, 0xe6, 0x86, 0xf7, 0x17, 0x0d, 0xeb, 0x6d,
 0x7a, 0xf0, 0x67, 0x98, 0xdf, 0x97, 0x99, 0xd5, 0xce, 0xd5, 0xbe, 0x15, 0xcb, 0xbd, 0xcd, 0xb1,
 0x8f, 0x83, 0x3e, 0xc7, 0x2f, 0xf1, 0x13, 0x3a, 0xa9, 0x95, 0xd8, 0x62, 0x8d, 0x63, 0xac, 0x7e,
 0x50, 0x1e, 0xd1, 0xe6, 0x3b, 0x8f, 0x36, 0xf5, 0x71, 0x2b, 0xf3, 0x4d, 0x6f, 0x94, 0xa4, 0x78,
 0xb9, 0xed, 0xbe, 0x63, 0x18, 0xf3, 0x6f, 0x6b, 0x14, 0xbf, 0x34, 0x56, 0xf9, 0x4a, 0x44, 0xd6,
 0x75, 0x2d, 0x4f, 0x14, 0x8f, 0x4b, 0x87, 0x92, 0x3f, 0x27, 0xd6, 0x93, 0xa3, 0xa1, 0x04, 0xe8,
 0xe8, 0x72, 0xd3, 0xa5, 0xa1, 0x0c, 0xe9, 0x68, 0x6c, 0xc5, 0xdf, 0x31, 0xc9, 0xc7, 0x71, 0x33,
 0xa3, 0xa1, 0x0c, 0xe9, 0x68, 0x72, 0xb3, 0xa5, 0xa1, 0x0c, 0xe9, 0x68, 0x64, 0x8b, 0xb4, 0xef,
 0xc7, 0x7e, 0x71, 0x00, 0x0d, 0x17, 0xda, 0x43, 0xdf, 0x3c, 0xc8, 0x91, 0xe6, 0xfb, 0x28, 0xff,
 0x00, 0xd2, 0x7f, 0xd6, 0x3c, 0x0c, 0xfa, 0x07, 0xcc, 0x79, 0x1e, 0x65, 0xb5, 0x3a, 0x79, 0xcf,
 0xfe, 0xb9, 0x9b, 0x8f, 0x3a, 0xc9, 0x0f, 0x03, 0xed, 0x3f, 0xfe, 0x97, 0x97, 0xff, 0x00, 0xc7,
 0xff, 0x00, 0xb4, 0x3d, 0xd2, 0x50, 0x23, 0x94, 0x0b, 0xd2, 0xa7, 0xa1, 0x1c, 0xa9, 0x9e, 0xa4,
 0x59, 0xf2, 0x58, 0xb2, 0x8c, 0xa9, 0x9d, 0x7b, 0x78, 0xb0, 0xe1, 0xb0, 0x1b, 0x44, 0xff, 0x00,
 0x35, 0x62, 0x7e, 0x4a, 0x47, 0x6b, 0x95, 0x33, 0xae, 0x6f, 0x1e, 0x1c, 0x37, 0x7b, 0xb4, 0x6f,
 0xf3, 0x56, 0x2b, 0xe4, 0xa4, 0x4d, 0xad, 0xfb, 0xb2, 0xda, 0xe2, 0x5b, 0xfe, 0x7d, 0x3e, 0xb1,
 0xfa, 0xbe, 0x2b, 0x00, 0x1e, 0x23, 0xed, 0xe1, 0xf4, 0x37, 0x99, 0xaa, 0x3c, 0x76, 0x13, 0x1a,
 0xff, 0x00, 0x39, 0xd4, 0xf9, 0x2a, 0x47, 0xcf, 0x27, 0xd1, 0xbe, 0x66, 0x38, 0xf1, 0xd8, 0x1c,
 0x77, 0xff, 0x00, 0x94, 0xa9, 0xf2, 0x54, 0x8d, 0xce, 0x0c, 0xeb, 0x2b, 0x9d, 0xfb, 0x51, 0x3a,
 0xe0, 0x4f, 0xd6, 0x1e, 0x8f, 0x2a, 0x64, 0x72, 0xa6, 0x5e, 0x95, 0x3d, 0x08, 0xe5, 0x4c, 0xf6,
 0xe2, 0xcf, 0x9b, 0x45, 0xd4, 0x65, 0x4c, 0xeb, 0x1b, 0xc1, 0xd9, 0x2c, 0x2e, 0xd5, 0xe4, 0x72,
 0xc1, 0x55, 0x6a, 0x96, 0x26, 0x9f, 0x19, 0xe1, 0xab, 0x70, 0xff, 0x00, 0x57, 0x3d, 0x7f, 0x9a,
 0xfa, 0x9a, 0xec, 0x47, 0x71, 0x94, 0x08, 0xa5, 0x4c, 0x9b, 0x6a, 0xf5, 0x9a, 0xdb, 0xdc, 0xcf,
 0x83, 0x91, 0x7c, 0x37, 0x8c, 0x94, 0x9d, 0x4c, 0x3e, 0x3b, 0xce, 0xf2, 0xac, 0x7e, 0x4b, 0x99,
 0xd6, 0xcb, 0xb3, 0x2c, 0x3c, 0xa8, 0x62, 0x29, 0x3e, 0x12, 0x8b, 0xea, 0x6b, 0xbc, 0xd3, 0xef,
 0xa7, 0xe1, 0x29, 0x1f, 0x57, 0xed, 0xa6, 0xc7, 0xe5, 0x1b, 0x55, 0x81, 0xb1, 0x98, 0xd1, 0x6a,
 0xac, 0x17, 0xda, 0x71, 0x14, 0xfa, 0x2a, 0x53, 0x7a, 0x3e, 0xfa, 0xd1, 0xf4, 0x1e, 0x11, 0xb5,
 0xfb, 0xb1, 0xda, 0x5c, 0x86, 0x73, 0xab, 0x47, 0x0f, 0x2c, 0xcf, 0x04, 0xba, 0x55, 0x6c, 0x34,
 0x5b, 0x92, 0x5f, 0xce, 0x87, 0x5a, 0xf6, 0x38, 0xad, 0x4f, 0x13, 0x91, 0xc2, 0xbe, 0x39, 0xdd,
 0x7d, 0xb0, 0xfa, 0x2f, 0x86, 0x78, 0xfe, 0x0e, 0x5d, 0x62, 0xb9, 0x27, 0xd1, 0xbf, 0xcb, 0xe1,
 0x3f, 0x4f, 0xf0, 0xe8, 0xe0, 0xcc, 0x93, 0x8b, 0x69, 0xa6, 0x9a, 0xe8, 0x69, 0xf7, 0x8c, 0x1a,
 0x4f, 0x7c, 0x00, 0x00, 0x00, 0xed, 0x5b, 0x2d, 0xb0, 0x7b, 0x41, 0x9f, 0x4a, 0x15, 0x23, 0x85,
 0x96, 0x0f, 0x08, 0xfa, 0x5e, 0x23, 0x11, 0x17, 0x14, 0xd7, 0xf3, 0x57, 0x5c, 0xbd, 0x8e, 0x8d,
 0x4b, 0xe3, 0xc7, 0x7c, 0x93, 0xaa, 0xc6, 0xe5, 0x8b, 0x36, 0x7c, 0x78, 0x2b, 0xe9, 0x64, 0xb6,
 0xa1, 0xd7, 0xb2, 0xdc, 0x0e, 0x2b, 0x32, 0xc6, 0xd2, 0xc1, 0x60, 0xa8, 0xca, 0xb5, 0x7a, 0xaf,
 0x84, 0x63, 0x15, 0xef, 0xe8, 0xb5, 0x3d, 0xdf, 0x62, 0x76, 0x6a, 0x8e, 0xcd, 0xe5, 0x2b, 0x0e,
 0x9c, 0x6a, 0x62, 0xaa, 0xf0, 0x96, 0x22, 0xaa, 0x5f, 0x75, 0x2f, 0x02, 0xd1, 0x77, 0xbd, 0xbe,
 0xf9, 0x7b, 0x64, 0x76, 0x47, 0x2c, 0xd9, 0xac, 0x2b, 0x86, 0x12, 0x0e, 0xae, 0x22, 0x6b, 0x85,
 0x5c, 0x44, 0xd7, 0xa7, 0x9e, 0x9a, 0x2d, 0x17, 0xbe, 0x73, 0x52, 0xa6, 0x74, 0x9e, 0x1f, 0xc1,
 0x8e, 0x3f, 0xef, 0xdf, 0xf8, 0xbf, 0x47, 0x15, 0xe2, 0xbe, 0x33, 0xeb, 0x73, 0xd3, 0xc7, 0xec,
 0xa7, 0xea, 0xa8, 0xd1, 0xab, 0x89, 0x66, 0x54, 0xc8, 0xdc, 0x0f, 0x5e, 0x25, 0xe2, 0xc5, 0x90,
 0x34, 0x6a, 0xd1, 0x33, 0x89, 0xab, 0x89, 0x3b, 0x5b, 0x68, 0x9c, 0x4d, 0x5a, 0x26, 0x71, 0x35,
 0x68, 0xb6, 0xd6, 0xda, 0x17, 0x13, 0x0d, 0x12, 0xb4, 0x61, 0xa2, 0x76, 0x98, 0x94, 0x2e, 0x25,
 0x3c, 0xe3, 0x15, 0x1c, 0xbf, 0x2a, 0xc5, 0x63, 0x65, 0xc3, 0x85, 0x0a, 0x52, 0x9f, 0xae, 0xd2,
 0xe8, 0x5e, 0xd9, 0xc8, 0x70, 0x3a, 0x96, 0xf6, 0x31, 0x0f, 0x0f, 0xb2, 0x15, 0x60, 0x9f, 0x07,
 0x5e, 0xac, 0x29, 0x7b, 0xfc, 0xdf, 0xe5, 0x31, 0x72, 0x32, 0xf4, 0xb1, 0x5a, 0xff, 0x00, 0x28,
 0x6c, 0xf1, 0x71, 0xf5, 0xb3, 0x56, 0x9f, 0x39, 0x87, 0x8d, 0xd5, 0xa9, 0x3a, 0xb5, 0x67, 0x56,
 0xa4, 0x9c, 0xa7, 0x39, 0x39, 0x49, 0xbe, 0xfb, 0x7d, 0x6c, 0xd4, 0x03, 0x82, 0x7d, 0x18, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x8d, 0x8a, 0xff, 0x00, 0xea, 0x9c, 0x07, 0xf6,
 0x9f, 0x33, 0x38, 0x73, 0x99, 0xd8, 0x8e, 0x9d, 0xaa, 0xcb, 0xff, 0x00, 0xb4, 0xf9, 0x99, 0xb1,
 0xc4, 0xfb, 0xfa, 0x7d, 0x63, 0xf5, 0x60, 0xe5, 0x7d, 0xcd, 0xfe, 0x93, 0xfa, 0x3d, 0x7d, 0xa3,
 0x56, 0x89, 0x9a, 0x35, 0x68, 0xfa, 0x26, 0xdc, 0x16, 0xd0, 0xb4, 0x61, 0xc4, 0x95, 0xa3, 0x0d,
 0x16, 0xda, 0x76, 0x85, 0xc4, 0xd5, 0xa2, 0x66, 0x8d, 0x5c, 0x49, 0xda, 0xd1, 0x28, 0x9a, 0x35,
 0x68, 0x99, 0xc4, 0xd5, 0xa2, 0xdb, 0x4e, 0xd0, 0xb4, 0x61, 0xa2, 0x56, 0x8c, 0x34, 0x4e, 0xd6,
 0xda, 0x17, 0x13, 0x57, 0x12, 0x66, 0x8d, 0x5a, 0x27, 0x69, 0xdb, 0xed, 0x9f, 0xf4, 0x7b, 0xdd,
 0x77, 0x89, 0xb1, 0x5e, 0xee, 0xab, 0xf4, 0x87, 0xfa, 0x3e, 0x6e, 0xbb, 0xc4, 0xd8, 0xaf, 0x77,
 0x55, 0xfa, 0x47, 0xaa, 0x73, 0xa1, 0xcc, 0x8f, 0x92, 0x7a, 0xa6, 0x0e, 0xc8, 0xf2, 0x76, 0x7e,
 0xa3, 0xc6, 0xfc, 0x38, 0xf2, 0x87, 0x96, 0x7f, 0xa3, 0xee, 0xeb, 0xfc, 0x4d, 0x8a, 0xf7, 0x75,
 0x5f, 0xa4, 0x65, 0x79, 0x9f, 0xf7, 0x60, 0xbf, 0x03, 0xe2, 0xbd, 0xdd, 0x57, 0xe9, 0x1e, 0xa5,
 0xcc, 0x8c, 0xf3, 0x21, 0xea, 0x98, 0x3b, 0x23, 0xc8, 0xf5, 0x1e, 0x37, 0xe1, 0xc7, 0x94, 0x3c,
 0xb5, 0x6e, 0x03, 0x76, 0x2b, 0xf0, 0x3e, 0x2b, 0xdd, 0xd5, 0x7e, 0x91, 0xb2, 0xdc, 0x16, 0xec,
 0x97, 0xe0, 0x7c, 0x57, 0xbb, 0xaa, 0xfd, 0x23, 0xd4, 0x39, 0x91, 0x8e, 0x74, 0x3d, 0x53, 0x07,
 0x64, 0x79, 0x1e, 0xa5, 0xc6, 0xfc, 0x38, 0xf2, 0x87, 0x98, 0xad, 0xc2, 0x6e, 0xcd, 0x7e, 0x08,
 0xc5, 0x7b, 0xba, 0xaf, 0xd2, 0x33, 0xe8, 0x0d, 0xbb, 0x5f, 0x14, 0x62, 0x7d, 0xdb, 0x57, 0xe9,
 0x1e, 0x9b, 0xcc, 0x8c, 0xf3, 0x21, 0xea, 0x98, 0x3b, 0x23, 0xc8, 0xf5, 0x2e, 0x3f, 0x64, 0x79,
 0x43, 0xcc, 0x96, 0xe2, 0x37, 0x6c, 0xbf, 0x04, 0x62, 0x7d, 0xdb, 0x57, 0xe9, 0x19, 0x5b, 0x8a,
 0xdd, 0xba, 0xfc, 0x13, 0x89, 0xf7, 0x6d, 0x5f, 0xa4, 0x7a, 0x5f, 0x32, 0x1c, 0xc8, 0x7a, 0xa6,
 0x0e, 0xc8, 0xf2, 0x4f, 0xa9, 0x71, 0xfb, 0x23, 0xca, 0x1e, 0x6c, 0xb7, 0x17, 0xbb, 0x85, 0xf8,
 0x27, 0x13, 0xee, 0xda, 0xbf, 0x48, 0xca, 0xdc, 0x6e, 0xee, 0x7c, 0x53, 0x89, 0xf7, 0x6d, 0x5f,
 0xa4, 0x7a, 0x4f, 0x32, 0x1c, 0xc8, 0x7a, 0xa6, 0x0e, 0xc8, 0xf2, 0x3d, 0x4f, 0x8f, 0xd9, 0x1e,
 0x4f, 0x04, 0xdb, 0x8d, 0xd3, 0x6c, 0x1e, 0x5f, 0x9b, 0x52, 0xa3, 0x47, 0x26, 0x9c, 0xa2, 0xe8,
 0x29, 0x3e, 0x7c, 0x5d, 0x56, 0xf8, 0xf3, 0x49, 0x7e, 0x36, 0x87, 0x04, 0xb7, 0x6b, 0xb1, 0x4b,
 0xf0, 0x2f, 0xf8, 0xaa, 0xdf, 0x4c, 0xf5, 0x5d, 0xe5, 0x49, 0x77, 0x76, 0x8f, 0xe8, 0xd1, 0xf8,
 0xd2, 0x3a, 0xbf, 0x32, 0x2d, 0x1c, 0x7c, 0x51, 0xfc, 0xb1, 0xe4, 0xbc, 0x71, 0xb0, 0xc7, 0xba,
 0x91, 0xe5, 0x0e, 0xa7, 0xe8, 0x6d, 0xb1, 0x7e, 0x26, 0xff, 0x00, 0x15, 0x5b, 0xe9, 0x8f, 0x43,
 0x8d, 0x8c, 0xf1, 0x37, 0xf8, 0xaa, 0xdf, 0x4c, 0xed, 0x9c, 0xc8, 0x73, 0x22, 0x7a, 0x18, 0xbb,
 0x63, 0xc9, 0x3e, 0xaf, 0x8b, 0xb6, 0x3c, 0x9d, 0xa1, 0x6e, 0x5f, 0x77, 0xeb, 0xf0, 0x5e, 0x23,
 0xdd, 0x75, 0x3b, 0x4d, 0x96, 0xe6, 0x76, 0x01, 0x7e, 0x0c, 0xc4, 0x7b, 0xae, 0xa7, 0x69, 0xe8,
 0x3c, 0xc8, 0xc7, 0x32, 0x2b, 0xea, 0xb8, 0x7b, 0x23, 0xc9, 0x4f, 0x54, 0xc1, 0xd9, 0x1e, 0x4e,
 0x80, 0xb7, 0x37, 0xb0, 0x4b, 0xf0, 0x66, 0x23, 0xdd, 0x75, 0x3b, 0x4c, 0xfa, 0x0e, 0xec, 0x1f,
 0x8b, 0x31, 0x1e, 0xeb, 0xa9, 0xda, 0x77, 0xee, 0x64, 0x39, 0x90, 0xf5, 0x5c, 0x3d, 0x91, 0xe4,
 0x7a, 0xae, 0x0e, 0xc8, 0xf2, 0x74, 0x35, 0xb9, 0xfd, 0x84, 0x5f, 0x83, 0x71, 0x1e, 0xeb, 0xa9,
 0xda, 0x65, 0x6e, 0x87, 0x61, 0x97, 0xe0, 0xda, 0xfe, 0xea, 0xa9, 0xda, 0x77, 0xbe, 0x64, 0x67,
 0x99, 0x0f, 0x55, 0xc3, 0xd9, 0x1e, 0x49, 0xf5, 0x5c, 0x3d, 0x91, 0xe4, 0xe8, 0xab, 0x74, 0x9b,
 0x0e, 0xbf, 0x07, 0x57, 0xf7, 0x55, 0x4e, 0xd3, 0x2b, 0x74, 0xdb, 0x10, 0xbf, 0x07, 0x57, 0xf7,
 0x55, 0x4e, 0xd3, 0xbc, 0xf3, 0x21, 0xcc, 0x87, 0xab, 0x61, 0xed, 0x8f, 0x23, 0xd5, 0xb0, 0xf6,
 0xc7, 0x93, 0xa3, 0xad, 0xd4, 0x6c, 0x52, 0xfc, 0x1d, 0x5f, 0xdd, 0x55, 0x3b, 0x4d, 0x96, 0xea,
 0xb6, 0x2d, 0x7e, 0x0f, 0xaf, 0xee, 0x99, 0xf6, 0x9d, 0xd7, 0x99, 0x0e, 0x64, 0x3d, 0x5b, 0x0f,
 0x6c, 0x79, 0x27, 0xd5, 0xb1, 0x76, 0xc7, 0x93, 0xa5, 0xad, 0xd6, 0xec, 0x62, 0xfc, 0x1f, 0x5f,
 0xdd, 0x33, 0xed, 0x28, 0xed, 0x2e, 0xea, 0xb6, 0x26, 0xbe, 0xcd, 0xe6, 0x74, 0x2b, 0x65, 0x95,
 0xaa, 0x52, 0xa9, 0x83, 0xab, 0x09, 0xc5, 0xe2, 0xaa, 0x2e, 0x68, 0xb8, 0x34, 0xd7, 0x15, 0x2e,
 0x3e, 0xd1, 0xe8, 0x5c, 0xc8, 0xa5, 0x9f, 0xc9, 0x77, 0x0b, 0x30, 0xfd, 0x1a, 0xa7, 0xc5, 0x64,
 0xc7, 0x1f, 0x14, 0x7f, 0x2c, 0x79, 0x11, 0xc7, 0xc5, 0x1f, 0xcb, 0x0f, 0x96, 0x3d, 0x01, 0xf7,
 0x51, 0xf9, 0x2b, 0xfb, 0x43, 0x15, 0xf5, 0x83, 0xd0, 0x1f, 0x75, 0x1f, 0x92, 0xbf, 0xb4, 0x31,
 0x5f, 0x58, 0x7a, 0x57, 0x32, 0x1c, 0xc8, 0xcc, 0xcc, 0xf3, 0x5f, 0x40, 0x7d, 0xd4, 0x7e, 0x4a,
 0xfe, 0xd0, 0xc5, 0x7d, 0x61, 0xea, 0xdb, 0xa0, 0xdd, 0x36, 0xc2, 0x65, 0x5b, 0x35, 0x88, 0xc3,
 0xe5, 0xb9, 0x3d, 0x4c, 0x2d, 0x19, 0x63, 0x25, 0x37, 0x08, 0xe2, 0xea, 0xcb, 0x8c, 0xb9, 0x20,
 0xb8, 0xf1, 0x94, 0x9b, 0xea, 0x48, 0xa7, 0xcc, 0x8f, 0x43, 0xdd, 0xac, 0x97, 0x70, 0xab, 0x7e,
 0x93, 0x2f, 0x8b, 0x12, 0xb6, 0xa5, 0x6f, 0x1a, 0xb4, 0x6d, 0x5b, 0x56, 0x2d, 0x1a, 0x98, 0x68,
 0xb7, 0x77, 0xb2, 0xab, 0xf8, 0x15, 0x5f, 0x74, 0x4f, 0xb4, 0xd9, 0x6e, 0xfb, 0x65, 0xd7, 0xf0,
 0x3a, 0xbe, 0x5e, 0x7d, 0xa7, 0x69, 0xe6, 0x46, 0x39, 0xd1, 0x8f, 0xd5, 0xf1, 0x76, 0xc7, 0x92,
 0x9d, 0x1c, 0x7d, 0xb0, 0xeb, 0x0b, 0x60, 0x76, 0x65, 0x7f, 0x03, 0xab, 0xe5, 0xe7, 0xda, 0x6c,
 0xb6, 0x0f, 0x66, 0x97, 0xf0, 0x4a, 0xbe, 0x5e, 0x5d, 0xa7, 0x66, 0xe6, 0x43, 0x99, 0x0f, 0x57,
 0xc5, 0xdb, 0x1e, 0x49, 0xe8, 0xe3, 0xf9, 0x43, 0xad, 0xad, 0x86, 0xd9, 0xc5, 0xfc, 0x12, 0xaf,
 0x96, 0x97, 0x69, 0xb2, 0xd8, 0x9d, 0x9e, 0x5d, 0x58, 0x5a, 0xbe, 0x5a, 0x5d, 0xa7, 0x61, 0xe6,
 0x47, 0x1b, 0xb4, 0x79, 0xbd, 0x3c, 0xa7, 0x2d, 0x9e, 0x21, 0xf0, 0x95, 0x59, 0x7a, 0x5a, 0x51,
 0x7f, 0x7d, 0x2e, 0xc5, 0xd6, 0x3d, 0x5f, 0x17, 0x6c, 0x79, 0x1d, 0x2a, 0x7c, 0x9d, 0x73, 0x68,
 0x32, 0xad, 0x94, 0xc9, 0xa9, 0xa5, 0x53, 0x0d, 0x56, 0xae, 0x22, 0x4b, 0x8c, 0x29, 0x46, 0xbc,
 0xb8, 0xbd, 0x5f, 0x4f, 0x42, 0x3c, 0xbf, 0x6e, 0xb6, 0x43, 0x66, 0x36, 0xd3, 0x0f, 0x0c, 0x2e,
 0x7f, 0x94, 0x47, 0x11, 0x86, 0xa5, 0x2e, 0x6a, 0x74, 0xa3, 0x88, 0xab, 0x0e, 0x57, 0xeb, 0xc6,
 0x49, 0xb3, 0x9f, 0xc5, 0x62, 0x6a, 0xe2, 0xb1, 0x13, 0xc4, 0x62, 0x2a, 0x3a, 0x95, 0x66, 0xf8,
 0xca, 0x4f, 0xbe, 0x47, 0xcc, 0x8b, 0x57, 0x0e, 0x3a, 0xce, 0xe2, 0xb0, 0x98, 0xa5, 0x63, 0xdb,
 0x10, 0xf3, 0x5f, 0x40, 0x7d, 0xd4, 0x7e, 0x4a, 0xfe, 0xd0, 0xc5, 0x7d, 0x60, 0xf4, 0x07, 0xdd,
 0x47, 0xe4, 0xaf, 0xed, 0x0c, 0x57, 0xd6, 0x1e, 0x95, 0xcc, 0x87, 0x32, 0x32, 0x2e, 0xf3, 0x5f,
 0x40, 0x7d, 0xd4, 0x7e, 0x4a, 0xfe, 0xd0, 0xc5, 0x7d, 0x61, 0xdf, 0x76, 0x0f, 0x24, 0xc9, 0x36,
 0x2b, 0x2f, 0x59, 0x6e, 0x43, 0x96, 0xc6, 0x86, 0x01, 0x4b, 0x99, 0xd0, 0x95, 0x6a, 0x93, 0xe9,
 0xfe, 0xb4, 0xa4, 0xdf, 0xbe, 0x5d, 0xe6, 0x43, 0x99, 0x15, 0xb5, 0x62, 0xd1, 0xa9, 0x84, 0x4c,
 0x44, 0xbd, 0x03, 0x67, 0xe7, 0xb3, 0xf9, 0xaa, 0x54, 0xe1, 0x4e, 0x74, 0x71, 0x3c, 0x3a, 0x68,
 0xce, 0xa3, 0xe2, 0xfd, 0x67, 0xdf, 0x2c, 0x6d, 0x46, 0x59, 0x96, 0x61, 0xb6, 0x7b, 0x1d, 0x3a,
 0x94, 0x65, 0x28, 0xca, 0x8b, 0xa7, 0xc1, 0xd4, 0x7d, 0x3c, 0xde, 0x97, 0xc3, 0xa9, 0xe7, 0x10,
 0xa9, 0x2a, 0x73, 0x8c, 0xe1, 0x27, 0x19, 0x45, 0xf1, 0x52, 0x4f, 0x83, 0x4c, 0xe6, 0xb3, 0x5d,
 0xa4, 0xc4, 0x66, 0x59, 0x25, 0x2c, 0x06, 0x21, 0x71, 0xab, 0x0a, 0x8a, 0x52, 0xa8, 0xbe, 0xfd,
 0x25, 0xd1, 0xc7, 0x5e, 0x92, 0x9d, 0x1c, 0x7d, 0xb0, 0x7a, 0x30, 0xf1, 0xaf, 0x40, 0x7d, 0xd4,
 0x7e, 0x4a, 0xfe, 0xd0, 0xc5, 0x7d, 0x60, 0xf4, 0x07, 0xdd, 0x47, 0xe4, 0xaf, 0xed, 0x0c, 0x57,
 0xd6, 0x1e, 0x95, 0xcc, 0x87, 0x32, 0x32, 0xa5, 0xe6, 0xbe, 0x80, 0xfb, 0xa8, 0xfc, 0x95, 0xfd,
 0xa1, 0x8a, 0xfa, 0xc3, 0xdf, 0x77, 0x3b, 0xbb, 0xdd, 0x9b, 0xd8, 0x3d, 0x8d, 0x86, 0x57, 0x90,
 0x65, 0xaf, 0x03, 0x43, 0x15, 0x59, 0xe3, 0x2a, 0xd3, 0xbf, 0x52, 0xa7, 0xdb, 0x25, 0x18, 0xae,
 0x3c, 0x67, 0x26, 0xd7, 0xa5, 0x8c, 0x57, 0x0d, 0x0e, 0xaf, 0x93, 0x61, 0xd6, 0x33, 0x35, 0xc2,
 0xe1, 0x5f, 0xdc, 0xd4, 0xaa, 0x94, 0xbd, 0x6e, 0x3d, 0x3e, 0xf7, 0x13, 0xd7, 0xd4, 0x92, 0x5c,
 0x12, 0xe0, 0x88, 0x98, 0x89, 0xf6, 0x48, 0x82, 0x58, 0x0c, 0x34, 0xba, 0xe9, 0xbf, 0x6d, 0x91,
 0xcb, 0x2b, 0xc1, 0x4b, 0xae, 0x93, 0xfd, 0x66, 0x5b, 0xe7, 0x46, 0x79, 0x91, 0x1e, 0x85, 0x7e,
 0x4a, 0x4e, 0x3a, 0x4f, 0xbe, 0x1f, 0x2f, 0xed, 0x86, 0xe4, 0xf7, 0x63, 0x98, 0xed, 0x76, 0x73,
 0x98, 0x63, 0x76, 0x66, 0xee, 0x27, 0x15, 0x8f, 0xaf, 0x5a, 0xb4, 0xfc, 0xfd, 0x89, 0x8f, 0x34,
 0xe5, 0x52, 0x4e, 0x4f, 0x82, 0xa8, 0x92, 0xe2, 0xdb, 0xe8, 0x4b, 0x81, 0xc5, 0x7a, 0x03, 0xee,
 0xa3, 0xf2, 0x57, 0xf6, 0x86, 0x2b, 0xeb, 0x0f, 0x57, 0xcf, 0xe4, 0xbb, 0xbb, 0x98, 0x7e, 0x95,
 0x53, 0xe3, 0x32, 0x97, 0x32, 0x2c, 0xbb, 0xcd, 0x7d, 0x01, 0xf7, 0x51, 0xf9, 0x2b, 0xfb, 0x43,
 0x15, 0xf5, 0x87, 0x77, 0xdc, 0xb6, 0xe8, 0xf7, 0x7d, 0xb3, 0xdb, 0x5d, 0x57, 0x1d, 0x93, 0x64,
 0x2f, 0x09, 0x89, 0x96, 0x0e, 0x74, 0xdc, 0xd6, 0x32, 0xbc, 0xfd, 0x2b, 0x94, 0x1b, 0x5c, 0x27,
 0x36, 0xbb, 0xcb, 0xbc, 0x72, 0x7c, 0xc8, 0xec, 0xbb, 0xb8, 0x92, 0xee, 0xfc, 0xff, 0x00, 0x47,
 0x97, 0xc3, 0x10, 0xad, 0xab, 0x5b, 0xc7, 0xa3, 0x68, 0xdc, 0x3b, 0x6b, 0xd9, 0x6c, 0x99, 0xf5,
 0xe1, 0xe7, 0xe5, 0x25, 0xda, 0x6a, 0xf6, 0x4f, 0x24, 0x7f, 0xc1, 0xa7, 0xe5, 0x65, 0xda, 0x73,
 0x7c, 0xc8, 0x73, 0x22, 0x76, 0xd6, 0xf5, 0x0e, 0x34, 0xff, 0x00, 0xd3, 0x8f, 0x28, 0x70, 0x4f,
 0x64, 0x72, 0x27, 0xd7, 0x86, 0x9f, 0x95, 0x97, 0x69, 0xab, 0xd8, 0xec, 0x85, 0xf5, 0xe1, 0x67,
 0xe5, 0x65, 0xda, 0x73, 0xfc, 0xc8, 0x73, 0x21, 0xe9, 0x4a, 0x3f, 0x67, 0x71, 0x27, 0xfe, 0x95,
 0x7c, 0xa1, 0xf2, 0x57, 0xa0, 0x3e, 0xea, 0x3f, 0x25, 0x7f, 0x68, 0x62, 0xbe, 0xb0, 0x7a, 0x03,
 0xee, 0xa3, 0xf2, 0x57, 0xf6, 0x86, 0x2b, 0xeb, 0x0f, 0x4a, 0xe6, 0x43, 0x99, 0x10, 0xdc, 0x79,
 0xaf, 0xa0, 0x3e, 0xea, 0x3f, 0x25, 0x7f, 0x68, 0x62, 0xbe, 0xb0, 0xf4, 0x7d, 0xc9, 0xee, 0x93,
 0x60, 0x72, 0x4e, 0xeb, 0xf7, 0x27, 0x24, 0x96, 0x12, 0xf5, 0x9b, 0xbc, 0x31, 0x75, 0xa7, 0xcd,
 0xcb, 0x73, 0x87, 0xdd, 0xcd, 0xf0, 0xeb, 0x7d, 0x5e, 0x13, 0x7e, 0x64, 0x77, 0x5d, 0xd7, 0x49,
 0x7a, 0xa3, 0xff, 0x00, 0x0b, 0xfc, 0xe4, 0xc4, 0xcc, 0x7b, 0x61, 0x8f, 0x2e, 0x1c, 0x79, 0xa9,
 0x34, 0xc9, 0x11, 0x31, 0x3f, 0x09, 0xf7, 0x2f, 0x3d, 0x80, 0xd9, 0x87, 0xfc, 0x0e, 0xaf, 0x97,
 0x9f, 0x69, 0x87, 0xbb, 0xed, 0x97, 0x7f, 0xc0, 0xaa, 0xf9, 0x79, 0xf6, 0x9d, 0xa7, 0x99, 0x18,
 0xe7, 0x45, 0xba, 0x97, 0xf9, 0xb4, 0xbf, 0x63, 0xf0, 0x3f, 0x06, 0xbf, 0xfe, 0xb0, 0xea, 0xaf,
 0x77, 0x9b, 0x2b, 0xfc, 0x8a, 0xaf, 0x97, 0x9f, 0x69, 0xc6, 0xed, 0x46, 0xed, 0x36, 0x3f, 0x13,
 0xb3, 0x59, 0xa6, 0x1f, 0x11, 0x97, 0x54, 0xa9, 0x46, 0xae, 0x0e, 0xb4, 0x2a, 0x41, 0xe2, 0x2a,
 0x2e, 0x68, 0xb8, 0x34, 0xd7, 0x14, 0xf8, 0xf5, 0x78, 0x0e, 0xfb, 0xcc, 0x8a, 0x39, 0xfc, 0x97,
 0x70, 0xb3, 0x0f, 0xd1, 0xaa, 0x7c, 0x56, 0x3a, 0xb7, 0xf9, 0xa6, 0xbe, 0x13, 0xc1, 0xac, 0xee,
 0x30, 0xd7, 0x7f, 0x48, 0x7c, 0xb1, 0xe8, 0x0f, 0xba, 0x8f, 0xc9, 0x5f, 0xda, 0x18, 0xaf, 0xac,
 0x1e, 0x80, 0xfb, 0xa8, 0xfc, 0x95, 0xfd, 0xa1, 0x8a, 0xfa, 0xc3, 0xd2, 0xb9, 0x90, 0xe6, 0x45,
 0x1e, 0x83, 0xcd, 0x7d, 0x01, 0xf7, 0x51, 0xf9, 0x2b, 0xfb, 0x43, 0x15, 0xf5, 0x87, 0xa9, 0x6e,
 0x8f, 0x74, 0x5b, 0x03, 0x96, 0xec, 0xde, 0x22, 0x86, 0x5f, 0x93, 0x54, 0xc3, 0x52, 0x96, 0x32,
 0x53, 0x70, 0x8e, 0x2e, 0xb4, 0xb8, 0xcb, 0x92, 0x0b, 0x8f, 0x19, 0x49, 0xbe, 0xa4, 0x8a, 0xfc,
 0xc8, 0xf4, 0x2d, 0xda, 0xc9, 0x2c, 0x8a, 0xbf, 0xe9, 0x52, 0xf8, 0xb1, 0x26, 0xb6, 0x9a, 0xce,
 0xe2, 0x58, 0xb3, 0x60, 0xc7, 0x9e, 0xbe, 0x86, 0x5a, 0xc5, 0xa3, 0xe5, 0x3e, 0xd5, 0x67, 0xbb,
 0x1d, 0x8f, 0x7f, 0xc0, 0x2b, 0x7b, 0xa2, 0x7d, 0xa6, 0x3d, 0x0b, 0xf6, 0x3b, 0xc5, 0xf5, 0xbd,
 0xd3, 0x3e, 0xd3, 0xb9, 0x73, 0x23, 0x3c, 0xc8, 0xc9, 0xd7, 0xc9, 0xdd, 0x2d, 0x4f, 0xd9, 0x3c,
 0x1f, 0xc1, 0xaf, 0x94, 0x3a, 0x5b, 0xdd, 0x6e, 0xc6, 0xbf, 0xc1, 0xf5, 0xbd, 0xd3, 0x3e, 0xd3,
 0x0f, 0x75, 0x9b, 0x18, 0xff, 0x00, 0x07, 0xd6, 0xf7, 0x4c, 0xfb, 0x4e, 0xe9, 0xcc, 0x88, 0x31,
 0xf8, 0xdc, 0x3e, 0x07, 0x09, 0x53, 0x15, 0x89, 0x9f, 0x25, 0x38, 0x2e, 0x2d, 0xf8, 0x74, 0x5a,
 0x8e, 0xbe, 0x5e, 0xe9, 0x4f, 0xec, 0xae, 0x17, 0xe0, 0xd7, 0xca, 0x1d, 0x37, 0x13, 0xbb, 0x0d,
 0x85, 0xa1, 0x46, 0x55, 0xab, 0xe0, 0xaa, 0x53, 0xa7, 0x15, 0xc6, 0x52, 0x96, 0x2a, 0x69, 0x2f,
 0x7c, 0xe9, 0xf9, 0xc6, 0xcf, 0xec, 0x3c, 0x64, 0xe9, 0xe5, 0x99, 0x3d, 0x5a, 0x9c, 0x3f, 0xda,
 0xd5, 0xc4, 0xd4, 0x49, 0xfa, 0xcb, 0x8f, 0x1f, 0x6c, 0xe5, 0x36, 0x8b, 0x3d, 0xc4, 0xe7, 0x18,
 0x97, 0x2a, 0x8d, 0xc3, 0x0f, 0x17, 0xf6, 0xba, 0x49, 0xf4, 0x2d, 0x5f, 0x85, 0x9c, 0x57, 0x32,
 0x27, 0xd6, 0x32, 0xf7, 0x4f, 0x99, 0xfb, 0x2f, 0x85, 0xf8, 0x55, 0xf2, 0x87, 0x46, 0xcf, 0xf7,
 0x45, 0xbb, 0xcc, 0xfb, 0x1b, 0xe7, 0xcc, 0xd7, 0x67, 0xbc, 0xf1, 0x5f, 0xab, 0x9b, 0xcf, 0x95,
 0xe1, 0xef, 0x46, 0x69, 0x1c, 0x77, 0xa0, 0x3e, 0xea, 0x3f, 0x25, 0x7f, 0x68, 0x62, 0xbe, 0xb0,
 0xf4, 0xae, 0x64, 0x39, 0x91, 0x8a, 0x66, 0x66, 0x77, 0x2d, 0xda, 0x52, 0xb4, 0xac, 0x56, 0xb1,
 0xa8, 0x87, 0x9a, 0xfa, 0x03, 0xee, 0xa3, 0xf2, 0x57, 0xf6, 0x86, 0x2b, 0xeb, 0x07, 0xa0, 0x3e,
 0xea, 0x3f, 0x25, 0x7f, 0x68, 0x62, 0xbe, 0xb0, 0xf4, 0xae, 0x64, 0x39, 0x91, 0x0b, 0x3c, 0xff,
 0x00, 0x2a, 0xdc, 0xbe, 0xed, 0x32, 0xbc, 0x6c, 0x31, 0x98, 0x1d, 0x9a, 0xb3, 0x5e, 0x1f, 0x73,
 0x2f, 0x3f, 0x62, 0x25, 0xc3, 0xd8, 0x75, 0x1a, 0x3b, 0xb6, 0x53, 0xb2, 0x9b, 0x0a, 0xe6, 0xa9,
 0xe6, 0x99, 0x25, 0x5e, 0x57, 0xfe, 0xd2, 0x8e, 0x2a, 0xa7, 0x47, 0xae, 0x9c, 0xbe, 0x02, 0xd7,
 0x32, 0x1c, 0xc8, 0xc9, 0x4c, 0xd9, 0x31, 0xc6, 0xab, 0x69, 0x86, 0xbe, 0x6e, 0x26, 0x0c, 0xd3,
 0xbc, 0x94, 0x89, 0x9f, 0xce, 0x1d, 0x9b, 0x0b, 0xba, 0x4d, 0xdd, 0xe2, 0xe8, 0x46, 0xbe, 0x1f,
 0x03, 0x56, 0xad, 0x29, 0x75, 0x4a, 0x38, 0xca, 0x9c, 0x3e, 0x12, 0x47, 0xb9, 0xad, 0x80, 0xf1,
 0x5d, 0x7f, 0x75, 0xd4, 0xed, 0x38, 0x7c, 0x83, 0x3a, 0xc5, 0x65, 0x18, 0xa5, 0x52, 0x8c, 0xb9,
 0xa9, 0x49, 0xfd, 0xb2, 0x93, 0x7d, 0x12, 0x5f, 0x33, 0xd4, 0xf5, 0x0c, 0xb7, 0x1f, 0x87, 0xcc,
 0x30, 0x70, 0xc5, 0x61, 0xa7, 0xcd, 0x4e, 0x6b, 0xd9, 0x4f, 0xbe, 0x9e, 0xa6, 0x4f, 0x5b, 0xcf,
 0xdf, 0x3e, 0x6c, 0x5f, 0xb3, 0x78, 0x9f, 0x85, 0x5f, 0x28, 0x74, 0x67, 0xb9, 0x8d, 0xdf, 0xf8,
 0xaf, 0x11, 0xee, 0xba, 0x9d, 0xa6, 0x1e, 0xe5, 0xb7, 0x7c, 0xff, 0x00, 0x05, 0x62, 0x3d, 0xd7,
 0x53, 0xb4, 0xf4, 0x3e, 0x64, 0x63, 0x99, 0x0f, 0x5b, 0xcf, 0xdf, 0x3e, 0x69, 0xfd, 0x9d, 0xc4,
 0xfc, 0x3a, 0xf9, 0x43, 0xce, 0xde, 0xe5, 0x37, 0x7b, 0xe2, 0xac, 0x47, 0xbb, 0x2a, 0x76, 0x8f,
 0x41, 0x3d, 0xde, 0x78, 0xab, 0x11, 0xee, 0xca, 0x9d, 0xa7, 0xa2, 0xf3, 0x23, 0x1c, 0xc8, 0x9f,
 0x5c, 0xe4, 0x77, 0xcf, 0x99, 0xfb, 0x3f, 0x8b, 0xf8, 0x75, 0xf2, 0x87, 0x9d, 0x7a, 0x09, 0x6e,
 0xf3, 0xc5, 0x58, 0x8f, 0x76, 0x54, 0xed, 0x1e, 0x82, 0x3b, 0xbb, 0xf1, 0x56, 0x23, 0xdd, 0x95,
 0x3b, 0x4f, 0x45, 0xe6, 0x43, 0x99, 0x0f, 0x5c, 0xe4, 0x77, 0xcf, 0x99, 0xfb, 0x3f, 0x8b, 0xf8,
 0x71, 0xe5, 0x0f, 0x39, 0xf4, 0x10, 0xdd, 0xdf, 0x8a, 0x71, 0x1e, 0xec, 0xa9, 0xda, 0x3d, 0x04,
 0x37, 0x77, 0xe2, 0x9c, 0x47, 0xbb, 0x2a, 0x76, 0x9e, 0x8f, 0xcc, 0x87, 0x32, 0x1e, 0xb9, 0xc8,
 0xef, 0x9f, 0x34, 0xfe, 0xcf, 0xe2, 0xfe, 0x1c, 0x79, 0x43, 0xcd, 0xfd, 0x03, 0xf7, 0x75, 0xe2,
 0x9c, 0x47, 0xbb, 0x2a, 0x76, 0x9d, 0x67, 0x78, 0xfb, 0x85, 0xdd, 0x9e, 0x23, 0x20, 0x8c, 0xeb,
 0xe4, 0x35, 0xab, 0xc6, 0x95, 0x68, 0xcb, 0x96, 0x58, 0xea, 0xe9, 0x2e, 0x29, 0xae, 0x3e, 0x96,
 0x6b, 0xc2, 0x7b, 0x6f, 0x32, 0x28, 0xe7, 0xf8, 0x75, 0x8e, 0xc9, 0xb1, 0x58, 0x64, 0xb8, 0xca,
 0x74, 0xdf, 0x2a, 0xfe, 0x72, 0xe9, 0x5e, 0xfa, 0x45, 0x6d, 0xca, 0xcd, 0x78, 0xf4, 0x6d, 0x79,
 0x98, 0xfa, 0xad, 0x4e, 0x1f, 0x1e, 0x96, 0x8b, 0x56, 0x91, 0x13, 0xf4, 0x7c, 0xb3, 0xe8, 0x0f,
 0xba, 0x8f, 0xc9, 0x5f, 0xda, 0x18, 0xaf, 0xac, 0x1e, 0x80, 0xfb, 0xa8, 0xfc, 0x95, 0xfd, 0xa1,
 0x8a, 0xfa, 0xc3, 0xd2, 0xb9, 0x90, 0xe6, 0x46, 0x06, 0xcb, 0xcd, 0x7d, 0x01, 0xf7, 0x51, 0xf9,
 0x2b, 0xfb, 0x43, 0x15, 0xf5, 0x83, 0xd0, 0x1f, 0x75, 0x1f, 0x92, 0xbf, 0xb4, 0x31, 0x5f, 0x58,
 0x7a, 0x57, 0x32, 0x1c, 0xc8, 0x0f, 0x35, 0xf4, 0x07, 0xdd, 0x47, 0xe4, 0xaf, 0xed, 0x0c, 0x57,
 0xd6, 0x0f, 0x40, 0x7d, 0xd4, 0x7e, 0x4a, 0xfe, 0xd0, 0xc5, 0x7d, 0x61, 0xe9, 0x5c, 0xc8, 0x73,
 0x20, 0x3c, 0xd7, 0xd0, 0x1f, 0x75, 0x1f, 0x92, 0xbf, 0xb4, 0x31, 0x5f, 0x58, 0x3d, 0x01, 0xf7,
 0x51, 0xf9, 0x2b, 0xfb, 0x43, 0x15, 0xf5, 0x87, 0xa5, 0x73, 0x21, 0xcc, 0x80, 0xf3, 0x5f, 0x40,
 0x7d, 0xd4, 0x7e, 0x4a, 0xfe, 0xd0, 0xc5, 0x7d, 0x60, 0xf4, 0x07, 0xdd, 0x47, 0xe4, 0xaf, 0xed,
 0x0c, 0x57, 0xd6, 0x1e, 0x95, 0xcc, 0x87, 0x32, 0x03, 0xcd, 0x7d, 0x01, 0xf7, 0x51, 0xf9, 0x2b,
 0xfb, 0x43, 0x15, 0xf5, 0x87, 0x2b, 0xb2, 0x5b, 0x86, 0xdd, 0x5f, 0xd9, 0x1e, 0x0b, 0x93, 0x66,
 0x25, 0x4e, 0x57, 0x3a, 0x25, 0x1c, 0xc3, 0x13, 0xc5, 0x74, 0x3f, 0x0d, 0x46, 0x8e, 0xeb, 0xcc,
 0x8e, 0x57, 0x64, 0x24, 0xbe, 0xc9, 0x30, 0x3f, 0xda, 0x7c, 0xcc, 0x98, 0x99, 0xac, 0xee, 0x11,
 0x31, 0x16, 0x8d, 0x4a, 0xc7, 0xa0, 0x2e, 0xed, 0x3c, 0x4f, 0x89, 0xf7, 0x6d, 0x5f, 0xa4, 0x63,
 0xd0, 0x13, 0x76, 0x7e, 0x27, 0xc4, 0xfb, 0xb6, 0xaf, 0xd2, 0x3d, 0x3f, 0x99, 0x18, 0xe7, 0x46,
 0xd7, 0xaf, 0x72, 0x7f, 0x12, 0x7c, 0xe5, 0xad, 0xea, 0x3c, 0x6f, 0xc3, 0x8f, 0x28, 0x79, 0x87,
 0xa0, 0x1e, 0xec, 0xfc, 0x4f, 0x89, 0xf7, 0x6d, 0x5f, 0xa4, 0x3d, 0x00, 0xf7, 0x65, 0xe2, 0x7c,
 0x4f, 0xbb, 0x6a, 0xfd, 0x23, 0xd3, 0xf9, 0x91, 0x9e, 0x64, 0x3d, 0x7f, 0x93, 0xf8, 0x93, 0xe7,
 0x27, 0xa9, 0x71, 0xfb, 0x23, 0xca, 0x1e, 0x5d, 0xe8, 0x05, 0xbb, 0x2f, 0x13, 0xe2, 0xbd, 0xdd,
 0x57, 0xe9, 0x0f, 0x40, 0x1d, 0xd9, 0x78, 0x9f, 0x15, 0xee, 0xea, 0xbf, 0x48, 0xf5, 0x0e, 0x64,
 0x39, 0x90, 0xf5, 0xfe, 0x57, 0xe2, 0x4f, 0x9c, 0xa7, 0xd4, 0xb8, 0xfd, 0x91, 0xe5, 0x0f, 0x2f,
 0xf4, 0x01, 0xdd, 0x8f, 0x89, 0xf1, 0x5e, 0xee, 0xab, 0xf4, 0x8c, 0x7a, 0x00, 0x6e, 0xc7, 0xc4,
 0xd8, 0xaf, 0x77, 0x55, 0xfa, 0x47, 0xa8, 0xf3, 0x23, 0x3c, 0xc8, 0x7a, 0xff, 0x00, 0x2b, 0xf1,
 0x27, 0xce, 0x4f, 0x52, 0xe3, 0xf6, 0x47, 0x94, 0x3c, 0xb7, 0xfd, 0x1f, 0xf7, 0x61, 0xe2, 0x6c,
 0x57, 0xbb, 0xaa, 0xfd, 0x23, 0x1f, 0xe8, 0xfd, 0xbb, 0x0f, 0x13, 0x62, 0xbd, 0xdd, 0x57, 0xe9,
 0x1e, 0xa5, 0xcc, 0x87, 0x32, 0x1e, 0xbf, 0xca, 0xfc, 0x49, 0xf3, 0x93, 0xd4, 0xf8, 0xfd, 0x91,
 0xe4, 0xf2, 0xdf, 0xf4, 0x7e, 0xdd, 0x7f, 0x89, 0xb1, 0x5e, 0xee, 0xab, 0xf4, 0x8c, 0x7f, 0xa3,
 0xee, 0xeb, 0xfc, 0x4d, 0x8a, 0xf7, 0x75, 0x5f, 0xa4, 0x7a, 0x9f, 0x32, 0x1c, 0xc8, 0x9f, 0xda,
 0x1c, 0xaf, 0xc4, 0x9f, 0x39, 0x3d, 0x4f, 0x8f, 0xd9, 0x1e, 0x4a, 0xb7, 0x05, 0xc2, 0xa5, 0xc1,
 0x73, 0x53, 0x4d, 0xb2, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c,
 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0xd4, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c,
 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x73, 0x51, 0x70, 0x0e, 0x93, 0xbc, 0x9a, 0x9c, 0x73, 0xda, 0x3f,
 0xa3, 0x47, 0xe3, 0x48, 0xeb, 0x1c, 0xe7, 0x3b, 0xbc, 0x7a, 0x9e, 0xae, 0x51, 0xfd, 0x1a, 0x3f,
 0x1a, 0x47, 0x59, 0xe7, 0x02, 0xcf, 0x38, 0xe7, 0x2b, 0x73, 0x8e, 0x70, 0x3d, 0xc6, 0xe0, 0xb8,
 0x53, 0xb9, 0xa9, 0x9b, 0x9a, 0x81, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x62, 0xe6, 0xa0, 0x5c, 0xb8,
 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb9, 0xa8, 0xb8, 0x54, 0xb8, 0x2e, 0x6a, 0x05, 0xbb, 0xa2,
 0xe6, 0xa5, 0x4b, 0x86, 0x2e, 0x01, 0x72, 0xe1, 0x4b, 0x3e, 0xa9, 0xea, 0x1e, 0x3f, 0xf4, 0x6a,
 0x9f, 0x15, 0x9b, 0x5c, 0xd4, 0xa5, 0x9e, 0xd4, 0xf5, 0x13, 0x1f, 0xfa, 0x35, 0x4f, 0x8a, 0xc0,
 0xf2, 0xfe, 0x71, 0xce, 0x56, 0xe7, 0x1c, 0xe0, 0x59, 0xe7, 0x3d, 0x07, 0x76, 0xf5, 0x38, 0x64,
 0x55, 0xbf, 0x49, 0x97, 0xc5, 0x89, 0xe6, 0xbc, 0xe7, 0xa0, 0x6e, 0xe6, 0xa7, 0x0c, 0x8e, 0xb7,
 0xe9, 0x32, 0xf8, 0xb1, 0x03, 0xb8, 0xdc, 0x17, 0x0a, 0x77, 0x0c, 0xdc, 0x02, 0xdd, 0xcd, 0x45,
 0xc2, 0xa5, 0xcd, 0x45, 0xcd, 0x40, 0xb7, 0x70, 0xf3, 0xbd, 0xe0, 0xe6, 0x12, 0xc4, 0x67, 0x5e,
 0x76, 0x52, 0xfb, 0x5e, 0x1a, 0x09, 0x70, 0xfe, 0x73, 0xe9, 0x6f, 0xe0, 0x5e, 0xc1, 0xde, 0x6e,
 0x1e, 0x51, 0xb4, 0x55, 0x9c, 0xf3, 0xdc, 0x74, 0x9b, 0xe3, 0xf6, 0xf9, 0xaf, 0x69, 0xf0, 0x02,
 0x1e, 0x71, 0xce, 0x56, 0xe7, 0x1c, 0xe0, 0x59, 0xe7, 0x3b, 0x0e, 0x43, 0xb3, 0x38, 0xbc, 0xca,
 0x94, 0x71, 0x15, 0xe6, 0xb0, 0xd8, 0x79, 0x74, 0xc5, 0xb5, 0xc6, 0x52, 0x5e, 0x14, 0xbc, 0x1a,
 0x9c, 0x56, 0xca, 0x60, 0xe1, 0x98, 0x67, 0x74, 0x68, 0xd5, 0x5c, 0x69, 0x47, 0x8d, 0x4a, 0x8b,
 0xc2, 0x97, 0x7b, 0xdb, 0xe0, 0x7a, 0x82, 0x9a, 0x4b, 0x82, 0xe8, 0x40, 0x70, 0x4b, 0x63, 0x32,
 0xce, 0x4e, 0x0f, 0x15, 0x8b, 0xe6, 0xf0, 0xf3, 0x47, 0x87, 0xb5, 0xc0, 0xe3, 0x33, 0x3d, 0x8d,
 0xc4, 0xd2, 0x8b, 0xa9, 0x81, 0xc4, 0x47, 0x11, 0xc3, 0xef, 0x26, 0xb9, 0x65, 0xec, 0x3e, 0xa7,
 0xef, 0x1d, 0xc6, 0xe6, 0xa2, 0xe6, 0xa0, 0x79, 0x2d, 0x78, 0xd5, 0xa1, 0x56, 0x54, 0xab, 0x53,
 0x95, 0x3a, 0x91, 0x7c, 0x25, 0x19, 0x2e, 0x0d, 0x1a, 0x73, 0x9e, 0x85, 0xb5, 0x59, 0x45, 0x2c,
 0xd3, 0x07, 0x29, 0xd3, 0x8a, 0x58, 0xba, 0x6b, 0x8d, 0x39, 0x2f, 0xbe, 0xfe, 0x6b, 0xd0, 0xf3,
 0x57, 0x2e, 0x0d, 0xa7, 0xc5, 0x34, 0x05, 0x8e, 0x71, 0xce, 0x56, 0xe7, 0x1c, 0xe0, 0x76, 0x7d,
 0x82, 0x4a, 0x7b, 0x49, 0x46, 0x4f, 0xef, 0x21, 0x39, 0x7b, 0xdc, 0x3e, 0x73, 0xd2, 0xae, 0x1e,
 0x65, 0xbb, 0xb9, 0x71, 0xcf, 0x66, 0xfc, 0x18, 0x79, 0x3f, 0x7e, 0x27, 0xa1, 0x5c, 0xd4, 0x0b,
 0x77, 0x05, 0xc2, 0xa5, 0xcd, 0x4c, 0x5c, 0x03, 0xcc, 0x33, 0xe9, 0xfa, 0xb9, 0x8f, 0xfd, 0x26,
 0xa7, 0xc6, 0x65, 0x2e, 0x72, 0x4c, 0xf6, 0x7e, 0xad, 0xe3, 0xff, 0x00, 0x49, 0xa9, 0xf1, 0x99,
 0x4b, 0x9c, 0x0b, 0x3c, 0xe7, 0x65, 0xdd, 0xcc, 0xfd, 0x5e, 0x9f, 0xe8, 0xf2, 0xf8, 0x62, 0x75,
 0x1e, 0x73, 0xb2, 0x6e, 0xee, 0xa7, 0xab, 0xd3, 0xfe, 0xc2, 0x5f, 0x0c, 0x40, 0xf4, 0xdb, 0x82,
 0xe6, 0xa5, 0x4b, 0x86, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x6a, 0x07, 0x91, 0x73,
 0x8e, 0x72, 0xb7, 0x38, 0xe7, 0x02, 0xcf, 0x39, 0xdd, 0x37, 0x61, 0x3e, 0x1d, 0xd1, 0xff, 0x00,
 0x85, 0xfe, 0x73, 0xa1, 0x73, 0x9d, 0xcf, 0x76, 0x75, 0x3f, 0xf9, 0x87, 0xfc, 0x3f, 0xf3, 0x81,
 0xdf, 0xae, 0x0b, 0x85, 0x4b, 0x82, 0xe6, 0xa0, 0x5b, 0xb9, 0xa9, 0x4b, 0x3e, 0xa9, 0xea, 0x1e,
 0x3d, 0x7f, 0x46, 0xa9, 0xf1, 0x59, 0xb5, 0xcd, 0x4a, 0x59, 0xed, 0x4f, 0x51, 0x31, 0xff, 0x00,
 0xa3, 0x54, 0xf8, 0xac, 0x0f, 0x2f, 0xe7, 0x1c, 0xe5, 0x6e, 0x71, 0xce, 0x05, 0x9e, 0x73, 0xd0,
 0x77, 0x6d, 0x53, 0xd4, 0x3a, 0xdf, 0xa4, 0xcb, 0xe2, 0xc4, 0xf3, 0x5e, 0x73, 0xd0, 0x37, 0x71,
 0x53, 0x86, 0x49, 0x5b, 0xf4, 0x99, 0x7c, 0x58, 0x81, 0xdc, 0x6e, 0x6a, 0x2e, 0x14, 0xee, 0x6a,
 0x2e, 0x01, 0x72, 0xe1, 0xe7, 0x5b, 0x75, 0x9d, 0x4b, 0x1d, 0x98, 0x3c, 0x1d, 0x29, 0x7f, 0xdd,
 0xf0, 0xef, 0x87, 0x43, 0xe8, 0x94, 0xfb, 0xef, 0xd8, 0xea, 0xf6, 0xce, 0xd1, 0xb4, 0x99, 0x93,
 0xcb, 0xf2, 0x6a, 0xf8, 0x88, 0xbe, 0x15, 0x39, 0x79, 0x69, 0xff, 0x00, 0x59, 0xf4, 0x2f, 0x6b,
 0xaf, 0xd8, 0x3c, 0xad, 0xcf, 0x8f, 0x4b, 0xe2, 0x05, 0x9e, 0x71, 0xce, 0x56, 0xe7, 0x1c, 0xe0,
 0x59, 0xe7, 0x39, 0xac, 0xa7, 0x67, 0x33, 0x3c, 0xc6, 0x0a, 0xac, 0x69, 0xc6, 0x85, 0x27, 0xd5,
 0x3a, 0xaf, 0x87, 0x1f, 0x59, 0x75, 0x96, 0xf6, 0x23, 0x25, 0xa7, 0x5e, 0x2b, 0x33, 0xc6, 0x41,
 0x4a, 0x09, 0xfd, 0xa6, 0x12, 0xea, 0x6d, 0x7d, 0xf3, 0x3b, 0xc5, 0xcd, 0x40, 0xea, 0x91, 0xd8,
 0x89, 0xf2, 0xf4, 0xe6, 0x71, 0x52, 0xf0, 0x2a, 0x3d, 0x1f, 0x18, 0xe3, 0x33, 0x5d, 0x97, 0xcc,
 0xb0, 0x34, 0xe5, 0x56, 0x9a, 0x86, 0x2a, 0x9c, 0x7a, 0x5b, 0xa7, 0xc7, 0x99, 0x2f, 0x5b, 0xb3,
 0x89, 0xdf, 0xae, 0x0b, 0x80, 0x79, 0x17, 0x38, 0xe7, 0x3b, 0x0e, 0xde, 0xe5, 0x90, 0xc3, 0x57,
 0x8e, 0x63, 0x87, 0x82, 0x8d, 0x3a, 0xcf, 0x85, 0x48, 0xae, 0xa5, 0x3f, 0x0f, 0xb3, 0xf3, 0x6a,
 0x75, 0x5e, 0x70, 0x2c, 0xf3, 0x9d, 0x87, 0x62, 0x33, 0xa7, 0x97, 0xe6, 0x4b, 0x0d, 0x56, 0x7c,
 0x30, 0xd8, 0x86, 0xa3, 0x2e, 0x2f, 0xa2, 0x32, 0xef, 0x3f, 0x99, 0xfe, 0xe3, 0xaa, 0xf3, 0x9b,
 0xd1, 0x8d, 0x5a, 0xb2, 0xe5, 0xa5, 0x4e, 0x75, 0x25, 0xe0, 0x8c, 0x5b, 0x60, 0x7b, 0x75, 0xc1,
 0x73, 0x53, 0x85, 0xc8, 0x31, 0x58, 0x8a, 0xf9, 0x46, 0x1e, 0x78, 0xaa, 0x75, 0x29, 0xd7, 0x51,
 0xe5, 0x9a, 0x9c, 0x5a, 0x6d, 0xae, 0x8e, 0x3d, 0x3e, 0x1e, 0xb2, 0xf5, 0xc0, 0x2e, 0x5c, 0x17,
 0x0a, 0x97, 0x0c, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0xa5, 0xcd, 0x45, 0xc0, 0x2d, 0xdc, 0xd4,
 0x5c, 0x29, 0xdc, 0xd4, 0xcd, 0xc0, 0x2d, 0xdc, 0x17, 0x35, 0x2a, 0x5c, 0xd4, 0x5c, 0x03, 0xce,
 0x36, 0xb7, 0x07, 0xdc, 0xfc, 0xf2, 0xbc, 0x23, 0x1e, 0x14, 0xaa, 0x3b, 0x94, 0xfd, 0x67, 0xde,
 0xf6, 0x1f, 0x14, 0x71, 0x3c, 0xe7, 0x7f, 0xdb, 0x5c, 0xbf, 0xba, 0x39, 0x5b, 0xab, 0x4a, 0x3c,
 0x71, 0x18, 0x7e, 0x33, 0x8f, 0x0e, 0xb9, 0x2e, 0xfa, 0xf9, 0xfd, 0x83, 0xcd, 0xf9, 0xc0, 0xb3,
 0xce, 0x39, 0xca, 0xdc, 0xe3, 0x9c, 0x0b, 0x3c, 0xe3, 0x9c, 0x82, 0x9c, 0xe1, 0x72, 0x37, 0x14,
 0x9c, 0x38, 0xfa, 0x65, 0x17, 0xc1, 0xf0, 0xd0, 0xef, 0x18, 0x4d, 0x96, 0xc9, 0x71, 0x58, 0x6a,
 0x78, 0x9a, 0x18, 0xac, 0x64, 0xa9, 0xd4, 0x8f, 0x34, 0x5f, 0x3c, 0x7e, 0x88, 0x1d, 0x3b, 0x9c,
 0x73, 0x9d, 0xdb, 0xec, 0x3b, 0x2a, 0xfe, 0x51, 0x8d, 0xfd, 0x78, 0xfd, 0x11, 0xf6, 0x1d, 0x95,
 0x7f, 0x28, 0xc6, 0xfe, 0xbc, 0x7e, 0x88, 0x1d, 0x27, 0x9c, 0x73, 0x9d, 0xdb, 0xec, 0x3b, 0x2a,
 0xfe, 0x51, 0x8d, 0xfd, 0x78, 0xfd, 0x11, 0xf6, 0x1b, 0x95, 0x7f, 0x28, 0xc6, 0xfe, 0xbc, 0x7e,
 0x88, 0x1d, 0x27, 0x9c, 0xe5, 0x76, 0x46, 0x7f, 0xf8, 0x93, 0x05, 0xfd, 0xa7, 0xcc, 0xce, 0xc3,
 0xf6, 0x1d, 0x95, 0x7f, 0x28, 0xc6, 0xfe, 0xbc, 0x7e, 0x89, 0x63, 0x2e, 0xd9, 0x8c, 0xbb, 0x03,
 0x8d, 0xa5, 0x8b, 0xa5, 0x5f, 0x15, 0x29, 0xd2, 0x7c, 0x52, 0x94, 0xa2, 0xd3, 0xff, 0x00, 0x94,
 0x0e, 0xd5, 0x73, 0x51, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x35, 0x17, 0x0a, 0x77, 0x0c,
 0xdc, 0xd4, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xc1, 0x70,
 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xc1, 0x70, 0x0a, 0x77,
 0x05, 0xcd, 0x4a, 0x77, 0x3a, 0x7a, 0xc5, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00,
 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0xd4,
 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x97, 0x35, 0x31, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a,
 0x77, 0x05, 0xc0, 0x3a, 0x76, 0xf1, 0x27, 0xea, 0xdd, 0x1f, 0xd1, 0xa3, 0xf1, 0xa4, 0x75, 0xae,
 0x73, 0x9b, 0xde, 0x15, 0x4f, 0x56, 0xa8, 0xfe, 0x8d, 0x1f, 0x8d, 0x23, 0xad, 0xf3, 0x81, 0x67,
 0x9c, 0x73, 0x95, 0xb9, 0xc7, 0x38, 0x1e, 0xd7, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b,
 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0xd4,
 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00,
 0xb9, 0x70, 0xa7, 0x9e, 0xd4, 0xf5, 0x13, 0x1d, 0xd3, 0xfc, 0x1a, 0xa7, 0xc5, 0x62, 0xe6, 0xa5,
 0x4c, 0xf2, 0xa7, 0xa8, 0xb8, 0xef, 0xd1, 0xea, 0x7c, 0x56, 0x07, 0x9a, 0x73, 0x8e, 0x72, 0xb7,
 0x38, 0xe7, 0x02, 0xcf, 0x39, 0xdf, 0xb7, 0x77, 0x53, 0xd4, 0x4a, 0xdf, 0xa4, 0xcb, 0xe2, 0xc4,
 0xf3, 0x8e, 0x73, 0xbd, 0xee, 0xf2, 0xa7, 0xa8, 0xf5, 0x97, 0x1f, 0xe1, 0x0f, 0xe2, 0xc4, 0x0e,
 0xe1, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0,
 0x2e, 0x5c, 0x3c, 0xbf, 0x6a, 0x22, 0xe8, 0xed, 0x06, 0x32, 0x2d, 0x75, 0xd4, 0x73, 0xfd, 0x6e,
 0x9f, 0x9c, 0xf4, 0x4b, 0x87, 0x4f, 0xde, 0x06, 0x0e, 0x4d, 0xd2, 0xcc, 0xa9, 0xa6, 0xd7, 0x0b,
 0x75, 0x78, 0x77, 0xbc, 0x0f, 0xe6, 0xf6, 0x80, 0xeb, 0x3c, 0xe3, 0x9c, 0xad, 0xcf, 0xa8, 0xe7,
 0x03, 0xb4, 0x6c, 0x1e, 0x2e, 0x14, 0x33, 0xe5, 0x19, 0xb4, 0xaf, 0x52, 0x95, 0x38, 0xb7, 0xe1,
 0xe2, 0x9f, 0xcc, 0x7a, 0x1d, 0xcd, 0x4f, 0x15, 0x85, 0x59, 0x42, 0x4a, 0x71, 0x93, 0x8c, 0xa2,
 0xf8, 0xa6, 0x9f, 0x4a, 0x67, 0x71, 0xc9, 0xf6, 0xca, 0x9d, 0xb8, 0xd2, 0xcc, 0xa1, 0x25, 0x25,
 0xd1, 0x76, 0x0b, 0x8a, 0x7e, 0xba, 0xec, 0x03, 0xbc, 0xdc, 0x17, 0x35, 0x38, 0x9c, 0x1e, 0x6d,
 0x80, 0xc5, 0xa5, 0xe7, 0x6c, 0x5d, 0x2a, 0x8d, 0xfd, 0xea, 0x97, 0xa6, 0xf6, 0xba, 0xcb, 0x57,
 0x00, 0xb9, 0x70, 0xf2, 0xdd, 0xa5, 0x8a, 0xa3, 0x9f, 0x63, 0x29, 0xc5, 0x70, 0x57, 0x5c, 0x92,
 0xf5, 0xfa, 0x7e, 0x73, 0xd1, 0xae, 0x1e, 0x6f, 0xb6, 0x33, 0xff, 0x00, 0xc4, 0x98, 0xbf, 0xfc,
 0x9f, 0x12, 0x20, 0x51, 0xe7, 0x1c, 0xe5, 0x6e, 0x71, 0xce, 0x07, 0x6e, 0xdd, 0xdc, 0xfd, 0x5b,
 0xad, 0xfa, 0x34, 0xbe, 0x34, 0x4e, 0xfb, 0x70, 0xf3, 0x8d, 0xde, 0xd4, 0xf5, 0x6a, 0xb7, 0xe8,
 0xf2, 0xf8, 0xd1, 0x3b, 0xdd, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xf3, 0x5c,
 0xf2, 0x7e, 0xad, 0xe3, 0xbf, 0x49, 0xa9, 0xf1, 0x99, 0x4f, 0x9c, 0xdf, 0x3c, 0x9f, 0xab, 0x58,
 0xef, 0xd2, 0x2a, 0x7c, 0x66, 0x53, 0xe7, 0x02, 0xcf, 0x39, 0xd8, 0xf7, 0x7b, 0x3f, 0x57, 0x27,
 0xfd, 0x84, 0xbe, 0x18, 0x9d, 0x4f, 0x9f, 0x53, 0xb1, 0x6e, 0xfe, 0x7e, 0xae, 0x4f, 0xfb, 0x09,
 0x7c, 0x31, 0x03, 0xd2, 0x6e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82,
 0xe0, 0x1e, 0x53, 0xce, 0x39, 0xca, 0xdc, 0xfa, 0x8e, 0x70, 0x2c, 0xf3, 0x9d, 0xc7, 0x76, 0xb3,
 0xff, 0x00, 0xe3, 0xff, 0x00, 0xe1, 0xff, 0x00, 0x98, 0xe8, 0xbc, 0xe7, 0x70, 0xdd, 0xbd, 0x4e,
 0x1e, 0x7f, 0xff, 0x00, 0x87, 0xfe, 0x60, 0x3b, 0xdd, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x05, 0xc0,
 0x2e, 0x5c, 0xd4, 0xa7, 0x9e, 0x54, 0xf5, 0x13, 0x1f, 0xfa, 0x35, 0x4f, 0x8a, 0xc5, 0xc2, 0xa6,
 0x77, 0x53, 0xd4, 0x5c, 0x77, 0x4f, 0xf0, 0x6a, 0x9f, 0x15, 0x81, 0xe6, 0x9c, 0xe3, 0x9c, 0xad,
 0xce, 0x39, 0xc0, 0xb3, 0xce, 0x77, 0xdd, 0xdd, 0xd4, 0xf5, 0x12, 0xb7, 0xe9, 0x32, 0xf8, 0xb1,
 0x3c, 0xe7, 0x9c, 0xef, 0x9b, 0xbd, 0xa9, 0xc3, 0x25, 0xad, 0xfa, 0x4c, 0xbe, 0x2c, 0x40, 0xed,
 0xf7, 0x05, 0xcd, 0x4a, 0x77, 0x35, 0x17, 0x35, 0x03, 0xad, 0xef, 0x1f, 0x19, 0xe9, 0x70, 0x98,
 0x44, 0xfa, 0x1b, 0x75, 0x24, 0xbd, 0xe5, 0xf3, 0x9d, 0x37, 0x9c, 0xe5, 0xf6, 0xf7, 0x11, 0xcf,
 0x9e, 0xf2, 0xf1, 0xe8, 0xa7, 0x4a, 0x31, 0xf8, 0x5f, 0xce, 0x75, 0xfe, 0x70, 0x2c, 0xf3, 0x92,
 0x61, 0xa3, 0x2a, 0xf8, 0x8a, 0x74, 0x61, 0xf7, 0x55, 0x26, 0xa0, 0xbd, 0x76, 0xf8, 0x14, 0xb9,
 0xcb, 0xfb, 0x3d, 0x56, 0x94, 0x33, 0xbc, 0x24, 0xeb, 0x4e, 0x30, 0x84, 0x6a, 0x29, 0x39, 0x49,
 0xf0, 0x4b, 0x87, 0x4f, 0x58, 0x1e, 0xb1, 0x86, 0x8d, 0x3c, 0x3e, 0x1e, 0x9d, 0x0a, 0x4b, 0x84,
 0x29, 0xc5, 0x46, 0x2b, 0x44, 0x49, 0x70, 0xe2, 0x3b, 0xb1, 0x96, 0x78, 0xcb, 0x07, 0xe5, 0xe3,
 0xda, 0x3b, 0xb1, 0x96, 0x78, 0xcb, 0x07, 0xe5, 0xe3, 0xda, 0x07, 0x2f, 0x73, 0x51, 0x73, 0x53,
 0x88, 0xee, 0xc6, 0x59, 0xe3, 0x2c, 0x1f, 0x97, 0x8f, 0x68, 0xee, 0xc6, 0x59, 0xe3, 0x2c, 0x1f,
 0x97, 0x8f, 0x68, 0x17, 0x73, 0x6c, 0x2d, 0x2c, 0xc7, 0x01, 0x53, 0x09, 0x59, 0xb8, 0xc6, 0x7c,
 0x3d, 0x32, 0xeb, 0x4d, 0x3e, 0x3c, 0x4e, 0x27, 0x0f, 0xb2, 0x99, 0x45, 0x3e, 0x17, 0x15, 0x7a,
 0xdf, 0xd7, 0xa9, 0xc3, 0xe0, 0xe0, 0x59, 0xee, 0xce, 0x59, 0xe3, 0x2c, 0x1f, 0x97, 0x8f, 0x68,
 0xee, 0xc6, 0x59, 0xe3, 0x2c, 0x1f, 0x97, 0x8f, 0x68, 0x16, 0x30, 0xf9, 0x4e, 0x53, 0x43, 0x85,
 0xbc, 0x06, 0x1f, 0x8a, 0xef, 0xca, 0x1c, 0xcf, 0xdb, 0x65, 0xe8, 0x4a, 0x30, 0x8f, 0x2c, 0x22,
 0xa2, 0x97, 0x52, 0x4b, 0x82, 0x38, 0x9e, 0xec, 0x65, 0x9e, 0x32, 0xc1, 0xf9, 0x78, 0xf6, 0x8e,
 0xec, 0x65, 0x9e, 0x32, 0xc1, 0xf9, 0x78, 0xf6, 0x81, 0xcb, 0xdc, 0x17, 0x0e, 0x37, 0x0d, 0x8f,
 0xc2, 0x62, 0x5b, 0x58, 0x7c, 0x55, 0x1a, 0xce, 0x3d, 0x2d, 0x53, 0xa8, 0xa5, 0xc3, 0xda, 0x26,
 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb9,
 0xa8, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a,
 0x8b, 0x9a, 0x81, 0x72, 0xe1, 0xd0, 0x76, 0xd3, 0x28, 0xf3, 0x9e, 0x25, 0xe3, 0xb0, 0xd0, 0xff,
 0x00, 0xbb, 0xd5, 0x97, 0xa6, 0x4b, 0xef, 0x25, 0xd8, 0xce, 0xe5, 0x70, 0xd3, 0x11, 0x1a, 0x75,
 0xe8, 0xce, 0x8d, 0x68, 0xa9, 0xd3, 0x9a, 0xe1, 0x28, 0xbe, 0xfa, 0x03, 0xcb, 0x39, 0xc7, 0x39,
 0x73, 0x68, 0xf2, 0xaa, 0xb9, 0x56, 0x2f, 0x87, 0x4c, 0xf0, 0xf3, 0x7f, 0x6b, 0x9f, 0xcc, 0xf5,
 0x38, 0xae, 0x70, 0x2c, 0xf3, 0x9c, 0xfe, 0xc9, 0x6d, 0x03, 0xcb, 0x2b, 0x79, 0xdf, 0x10, 0xdb,
 0xc2, 0x54, 0x7d, 0x3f, 0xfd, 0xb7, 0xe1, 0xf5, 0xbc, 0x27, 0x57, 0xe7, 0x1c, 0xe0, 0x7b, 0x4c,
 0x2b, 0x46, 0x70, 0x8c, 0xe1, 0x25, 0x28, 0xc9, 0x71, 0x4d, 0x3e, 0x29, 0xa3, 0x6b, 0x87, 0x9a,
 0x6c, 0xb6, 0xd1, 0xcf, 0x2e, 0x92, 0xc2, 0xe2, 0xa5, 0x29, 0xe1, 0x24, 0xfa, 0x1f, 0x5b, 0xa6,
 0xfc, 0x2b, 0x4d, 0x0e, 0xfd, 0x4e, 0xbc, 0x2a, 0x53, 0x8d, 0x4a, 0x73, 0x53, 0x84, 0x97, 0x18,
 0xc9, 0x3e, 0x29, 0xa0, 0x2e, 0xdc, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xcd, 0x45,
 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c,
 0xd4, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17,
 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xcd, 0x45, 0xcd, 0x40, 0xb9,
 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0a, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0, 0x2e,
 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x73,
 0x51, 0x74, 0xa7, 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02,
 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x3a, 0x8e, 0xf0, 0x27, 0xc7, 0x39, 0xa3, 0xd3,
 0xfc, 0x1e, 0x3f, 0x1a, 0x47, 0x5d, 0xe7, 0x39, 0x9d, 0xbe, 0x9f, 0xab, 0x14, 0xba, 0x7f, 0x83,
 0xaf, 0x8d, 0x23, 0xae, 0xf3, 0xea, 0x05, 0x9e, 0x7d, 0x47, 0x3e, 0xa5, 0x6e, 0x7d, 0x47, 0x3e,
 0xa0, 0x7b, 0x2d, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70,
 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00,
 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc2, 0x9e, 0x77, 0x53, 0xd4, 0x6c, 0x77,
 0xe8, 0xf5, 0x3e, 0x2b, 0x17, 0x0a, 0x99, 0xd5, 0x4f, 0x51, 0xf1, 0xbf, 0xa3, 0xd4, 0xf8, 0xac,
 0x0f, 0x3a, 0xe7, 0x1c, 0xfa, 0x95, 0xb9, 0xf5, 0x1c, 0xfa, 0x81, 0x67, 0x9c, 0xee, 0xdb, 0xbd,
 0xab, 0xea, 0x76, 0x22, 0x3c, 0x7a, 0xab, 0x71, 0xf7, 0x97, 0x61, 0xd0, 0x39, 0xf5, 0x3b, 0x7e,
 0xef, 0x6b, 0xfd, 0xaf, 0x19, 0x0e, 0x3d, 0x4e, 0x0f, 0xdb, 0xe3, 0xd8, 0x07, 0x76, 0xb8, 0x2e,
 0x14, 0xee, 0x6a, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x84, 0x78,
 0x85, 0x4e, 0xbd, 0x19, 0xd1, 0xad, 0x15, 0x3a, 0x73, 0x4e, 0x32, 0x4f, 0xbe, 0x8a, 0xf7, 0x05,
 0xc0, 0x3a, 0x36, 0xd0, 0x64, 0xd8, 0x8c, 0xb2, 0xab, 0x9c, 0x54, 0xaa, 0x61, 0x5b, 0xf4, 0xb3,
 0xf0, 0x68, 0xce, 0x23, 0x9c, 0xf5, 0x09, 0x4d, 0x4a, 0x2e, 0x32, 0x49, 0xa6, 0xb8, 0x34, 0xfa,
 0x99, 0xc0, 0x66, 0x5b, 0x35, 0x80, 0xc4, 0xb7, 0x3c, 0x3c, 0xa5, 0x85, 0x9b, 0xfc, 0x5e, 0x98,
 0xfb, 0x5d, 0x80, 0x74, 0xee, 0x71, 0xce, 0x72, 0x78, 0xcd, 0x9b, 0xcc, 0xe8, 0x71, 0x74, 0x94,
 0x31, 0x11, 0xf0, 0xc2, 0x5c, 0x1f, 0xb4, 0xce, 0x27, 0x11, 0x43, 0x15, 0x87, 0x7c, 0x31, 0x14,
 0x2a, 0xd2, 0xfe, 0xbc, 0x1a, 0x03, 0x7e, 0x7d, 0x4b, 0x98, 0x5c, 0xdf, 0x31, 0xc2, 0xf0, 0xb1,
 0x8d, 0xaf, 0x14, 0xbe, 0xf7, 0x9b, 0x8a, 0xf6, 0x9f, 0x41, 0xc5, 0x73, 0xea, 0x39, 0xf5, 0x03,
 0xb6, 0x60, 0xf6, 0xcb, 0x30, 0xa5, 0xc1, 0x62, 0x29, 0xd2, 0xc4, 0x47, 0xbe, 0xf8, 0x72, 0xcb,
 0xde, 0xe8, 0xf7, 0x8e, 0x27, 0x3b, 0xcc, 0x23, 0x98, 0x66, 0x95, 0x71, 0x91, 0x84, 0xa9, 0xaa,
 0x9c, 0xbe, 0x95, 0xbe, 0x3c, 0x38, 0x45, 0x2f, 0x98, 0xe2, 0x79, 0xf5, 0x1c, 0xe0, 0x59, 0xe7,
 0x1c, 0xe5, 0x6e, 0x7d, 0x47, 0x3e, 0xa0, 0x76, 0xbd, 0xdf, 0xcf, 0x86, 0x73, 0x5b, 0xf4, 0x79,
 0x7c, 0x68, 0x9d, 0xea, 0xe1, 0xe7, 0x9b, 0x03, 0x53, 0x86, 0x71, 0x57, 0xa7, 0xf8, 0x3c, 0xbe,
 0x34, 0x4e, 0xef, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xf3, 0xac, 0xee,
 0x7e, 0xac, 0xe3, 0xba, 0x7f, 0x84, 0x54, 0xf8, 0xcc, 0xa9, 0xcf, 0xa9, 0xb6, 0x75, 0x3f, 0x56,
 0x31, 0xbd, 0x3f, 0xc2, 0x2a, 0x7c, 0x66, 0x54, 0xe7, 0xd4, 0x0b, 0x3c, 0xe7, 0x60, 0xd8, 0x29,
 0xfa, 0xb7, 0x3f, 0xec, 0x25, 0xf0, 0xa3, 0xab, 0x73, 0xea, 0x73, 0xdb, 0x0d, 0x57, 0x97, 0x3c,
 0xe1, 0xc7, 0xae, 0x94, 0x97, 0xc0, 0x07, 0xa3, 0xdc, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9,
 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5d, 0x03, 0xcb, 0xf9, 0xc7, 0x3e, 0xa5, 0x6e, 0x7d, 0x47, 0x3e,
 0xa0, 0x59, 0xe7, 0xd4, 0xed, 0xdb, 0xb9, 0xa9, 0xc3, 0xcf, 0xeb, 0xfb, 0x3f, 0xf3, 0x1d, 0x23,
 0x9f, 0x53, 0xb5, 0x6e, 0xf6, 0xaf, 0x0a, 0xb8, 0xc8, 0xf1, 0xeb, 0x8c, 0x1f, 0xc3, 0xda, 0x07,
 0x7b, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa9, 0x4f, 0x3b, 0xa9, 0xea, 0x36, 0x3b,
 0xf4, 0x7a, 0x9f, 0x15, 0x8b, 0x85, 0x4c, 0xea, 0xa7, 0xa8, 0xf8, 0xdf, 0xd1, 0xea, 0x7c, 0x56,
 0x07, 0x9d, 0x73, 0x8e, 0x7d, 0x4a, 0xdc, 0xfa, 0x8e, 0x7d, 0x40, 0xb3, 0xce, 0x77, 0x9d, 0xdf,
 0xd4, 0xe1, 0x93, 0x56, 0xfd, 0x22, 0x5f, 0x16, 0x27, 0x9e, 0xf3, 0xea, 0x77, 0x8d, 0x81, 0xa9,
 0xea, 0x3d, 0x5e, 0x9f, 0xe1, 0x0f, 0xe2, 0xc4, 0x0e, 0xdb, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00,
 0xe8, 0xfb, 0x65, 0x53, 0x8e, 0xd1, 0xe2, 0x74, 0x50, 0xf8, 0x88, 0xe1, 0xf9, 0xce, 0x43, 0x6c,
 0xe5, 0xc3, 0x68, 0x2b, 0x3f, 0xc6, 0x8c, 0x5f, 0xfc, 0xa9, 0x7c, 0xc7, 0x0d, 0xcf, 0xa8, 0x16,
 0x79, 0xc7, 0x3e, 0xa5, 0x6e, 0x7d, 0x47, 0x3e, 0xa0, 0x59, 0xe7, 0xd4, 0x73, 0x95, 0xb9, 0xf5,
 0x33, 0xcf, 0xa8, 0x16, 0x39, 0xc7, 0x39, 0x5b, 0x9f, 0x51, 0xcf, 0xa8, 0x16, 0x79, 0xc7, 0x3e,
 0xa5, 0x6e, 0x7d, 0x47, 0x3e, 0xa0, 0x59, 0xe7, 0xd4, 0x73, 0x95, 0xb9, 0xf5, 0x1c, 0xfa, 0x81,
 0xdd, 0x37, 0x77, 0x2f, 0xb7, 0xe3, 0x25, 0xfc, 0xd8, 0x7c, 0x2c, 0xee, 0x37, 0x0e, 0x95, 0xbb,
 0xd7, 0xc2, 0x8e, 0x32, 0xa7, 0xe3, 0x4a, 0x31, 0xf6, 0xb8, 0xf6, 0x9d, 0xa6, 0xe0, 0x17, 0x2e,
 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0,
 0xb8, 0x53, 0xb9, 0xa8, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b,
 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x4b, 0x8f, 0xa1, 0x43, 0x1b, 0x85, 0x9e, 0x1b, 0x11, 0x0e, 0x68,
 0x4b, 0xdb, 0x4f, 0xc2, 0xb5, 0x3c, 0xe7, 0x3c, 0xcb, 0xab, 0xe5, 0x78, 0xa7, 0x4a, 0xa7, 0x19,
 0x53, 0x97, 0x4d, 0x3a, 0x89, 0x74, 0x49, 0x76, 0x9e, 0x83, 0x70, 0xaf, 0x98, 0x61, 0xe8, 0x63,
 0xb0, 0xb2, 0xc3, 0xe2, 0x23, 0xcd, 0x09, 0x77, 0xfb, 0xf1, 0x7e, 0x15, 0xa8, 0x1e, 0x6f, 0xce,
 0x39, 0xc9, 0xf3, 0xbc, 0xba, 0xbe, 0x59, 0x89, 0xb7, 0x57, 0xd3, 0x53, 0x97, 0xfa, 0xba, 0x89,
 0x74, 0x49, 0x76, 0x9c, 0x7f, 0x3e, 0xa0, 0x59, 0xe7, 0xd4, 0xe6, 0xf6, 0x6b, 0x68, 0x6a, 0xe5,
 0x95, 0x15, 0x0a, 0xce, 0x55, 0x30, 0x92, 0x7d, 0x2b, 0xbf, 0x0d, 0x57, 0x61, 0xd6, 0xf9, 0xf5,
 0x1c, 0xfa, 0x81, 0xec, 0x54, 0x31, 0x34, 0xeb, 0xd1, 0x8d, 0x5a, 0x33, 0x53, 0xa7, 0x25, 0xc6,
 0x32, 0x4f, 0xa1, 0xa3, 0x7b, 0x87, 0x99, 0x6c, 0xe6, 0x7d, 0x57, 0x2c, 0xad, 0x6e, 0xa3, 0x73,
 0xc2, 0xcd, 0xfa, 0x68, 0xfe, 0x2e, 0xa8, 0xef, 0xd4, 0x31, 0x34, 0xeb, 0x52, 0x8d, 0x6a, 0x33,
 0x53, 0xa7, 0x35, 0xc6, 0x32, 0x4f, 0xad, 0x01, 0x7e, 0xe0, 0xb8, 0x53, 0xb9, 0xa8, 0xb8, 0x05,
 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e,
 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb9, 0xa8, 0x17,
 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x54, 0xb9,
 0xa8, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x81,
 0xd4, 0xd4, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02,
 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x03, 0xaa, 0xed,
 0xe5, 0x4f, 0x55, 0xe9, 0x74, 0xff, 0x00, 0x07, 0x5f, 0x1a, 0x47, 0x5f, 0xe7, 0xd4, 0xe5, 0xb6,
 0xea, 0x7e, 0xab, 0xd2, 0xe9, 0xff, 0x00, 0x60, 0xbe, 0x34, 0x8e, 0x03, 0x9c, 0x0b, 0x3c, 0xfa,
 0x8e, 0x7d, 0x4a, 0xdc, 0xe3, 0x9f, 0x50, 0x2c, 0xf3, 0xea, 0x39, 0xf5, 0x2b, 0x73, 0x8e, 0x7d,
 0x40, 0xb3, 0xcf, 0xa8, 0xe7, 0xd4, 0xad, 0xce, 0x39, 0xc0, 0xb3, 0xcf, 0xa8, 0xe7, 0xd4, 0xad,
 0xce, 0x39, 0xf5, 0x02, 0xcf, 0x39, 0xd9, 0xf6, 0x02, 0x7f, 0xf7, 0x8c, 0x5f, 0x4f, 0xde, 0x47,
 0xe1, 0x67, 0x4f, 0xe7, 0xd4, 0xec, 0xdb, 0x05, 0x53, 0x85, 0x7c, 0x5f, 0xf5, 0x63, 0xf0, 0xb0,
 0x3b, 0xcd, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x2a, 0x67, 0x35, 0x3d, 0x48,
 0xc6, 0xf4, 0xff, 0x00, 0x07, 0x9f, 0xc5, 0x66, 0x2e, 0x6a, 0x55, 0xce, 0x2a, 0x7a, 0x91, 0x8c,
 0xfe, 0xc2, 0x7f, 0x15, 0x81, 0xe7, 0xfc, 0xe3, 0x9f, 0x52, 0xb7, 0x3e, 0xa3, 0x9f, 0x50, 0x2c,
 0xf3, 0xea, 0x76, 0x1d, 0x84, 0xc5, 0x28, 0x66, 0x75, 0x68, 0xb7, 0xc2, 0xed, 0x3e, 0x8d, 0x5a,
 0x7d, 0x9c, 0x4e, 0xab, 0xcf, 0xa9, 0x63, 0x2e, 0xc6, 0x4b, 0x07, 0x8d, 0xa3, 0x89, 0x87, 0x4b,
 0xa7, 0x2e, 0x3c, 0x3c, 0x2b, 0xbe, 0xbd, 0xa0, 0x3d, 0x5e, 0xe0, 0xb8, 0x50, 0xc3, 0xe2, 0xa9,
 0xd7, 0xa1, 0x0a, 0xd4, 0xa6, 0xa5, 0x09, 0xae, 0x31, 0x66, 0xf7, 0x00, 0xb9, 0x73, 0x51, 0x70,
 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x35, 0x31, 0x2a, 0xca, 0x2b, 0x8c,
 0xa4, 0x92, 0xf0, 0xb6, 0x05, 0xdb, 0x9a, 0x8b, 0x87, 0x0f, 0x5f, 0x39, 0xcb, 0xa8, 0x71, 0xb9,
 0x8d, 0xa3, 0xc5, 0x77, 0x94, 0xb8, 0xbf, 0x69, 0x14, 0x2b, 0xed, 0x5e, 0x5b, 0x4f, 0xfd, 0x5b,
 0xad, 0x57, 0xfa, 0xb0, 0xe0, 0xbd, 0xfe, 0x00, 0x76, 0x7b, 0x86, 0x39, 0xd3, 0x5c, 0x1f, 0x4a,
 0x3a, 0xae, 0x5d, 0xb5, 0x34, 0xf1, 0x79, 0x85, 0x3c, 0x37, 0x9d, 0xdd, 0x28, 0xd4, 0x7c, 0x14,
 0xdc, 0xf8, 0xf4, 0xf7, 0xba, 0x38, 0x1c, 0xfd, 0xc0, 0x31, 0x89, 0xcb, 0xf2, 0xec, 0x47, 0x1b,
 0xb8, 0x3a, 0x2d, 0xbe, 0xfa, 0x8f, 0x07, 0xed, 0xa3, 0x8c, 0xc5, 0x6c, 0xc6, 0x5f, 0x53, 0x8b,
 0xa3, 0x52, 0xad, 0x07, 0xe0, 0x52, 0xe6, 0x5e, 0xff, 0x00, 0x4f, 0xbe, 0x72, 0x97, 0x05, 0xc0,
 0x3a, 0xa6, 0x33, 0x66, 0x31, 0xf4, 0xb8, 0xcb, 0x0f, 0x52, 0x9e, 0x22, 0x3e, 0x0f, 0xb9, 0x97,
 0xb4, 0xfa, 0x3d, 0xf3, 0x83, 0xaf, 0x0a, 0xb4, 0x2a, 0xca, 0x95, 0x68, 0x4a, 0x9d, 0x48, 0xf5,
 0xc6, 0x4b, 0x83, 0x47, 0xa3, 0xdc, 0xd4, 0xf3, 0xfd, 0xa9, 0xac, 0xa7, 0x9f, 0x62, 0xa4, 0x9f,
 0x7e, 0x2b, 0xda, 0x8a, 0x40, 0x55, 0xe7, 0xd4, 0x73, 0x95, 0xb9, 0xf5, 0x1c, 0xfa, 0x81, 0xda,
 0x76, 0x0e, 0x7e, 0xab, 0xd5, 0xfd, 0x1d, 0xfc, 0x68, 0x9d, 0xda, 0xe1, 0xd0, 0x76, 0x16, 0x5e,
 0xa9, 0xd7, 0x97, 0x82, 0x8b, 0x5f, 0xf3, 0x23, 0xb9, 0x5c, 0xd4, 0x0b, 0x97, 0x0c, 0x5c, 0x2a,
 0x5c, 0x17, 0x00, 0xf3, 0xfc, 0xe6, 0x7e, 0xac, 0x63, 0x7a, 0x7f, 0x84, 0x54, 0xf8, 0xcc, 0xab,
 0xcf, 0xa9, 0x9c, 0xe2, 0x7e, 0xab, 0xe3, 0x3f, 0xb7, 0x9f, 0xc6, 0x65, 0x5e, 0x70, 0x2c, 0xf3,
 0xea, 0x72, 0xbb, 0x27, 0x88, 0xb5, 0x9f, 0xe1, 0xf8, 0xbe, 0x89, 0x73, 0x47, 0xdb, 0x4f, 0x87,
 0xbe, 0x70, 0x3c, 0xe4, 0x98, 0x6c, 0x44, 0xa8, 0x62, 0x29, 0xd7, 0x83, 0xf4, 0xd4, 0xe4, 0xa4,
 0xbd, 0x74, 0xc0, 0xf5, 0xbb, 0x82, 0xe1, 0xc7, 0x61, 0x31, 0x74, 0xf1, 0x38, 0x6a, 0x75, 0xe9,
 0x4b, 0x8c, 0x27, 0x1e, 0x28, 0x96, 0xe0, 0x17, 0x2e, 0x1a, 0xd4, 0xab, 0xc2, 0x9c, 0xa5, 0xe0,
 0x4d, 0x95, 0x6e, 0x6a, 0x56, 0xcd, 0x71, 0x2a, 0x8e, 0x59, 0x89, 0xaa, 0xdf, 0x0e, 0x5a, 0x52,
 0xe1, 0xeb, 0xf0, 0xe8, 0x03, 0xcf, 0xb9, 0xf5, 0x1c, 0xfa, 0x95, 0xb9, 0xc7, 0x38, 0x16, 0x79,
 0xf5, 0x3b, 0x06, 0xc2, 0xe2, 0x14, 0x33, 0x5a, 0x94, 0xdb, 0xfb, 0xba, 0x4f, 0x87, 0xae, 0x9a,
 0xfd, 0xe7, 0x56, 0xe7, 0x2d, 0x65, 0x58, 0xd7, 0x82, 0xcc, 0x68, 0xe2, 0x57, 0x54, 0x25, 0xe9,
 0x92, 0xef, 0xa7, 0xd0, 0xfd, 0xe0, 0x3d, 0x52, 0xe1, 0x9b, 0x9a, 0x94, 0xa9, 0xd7, 0x8d, 0x4a,
 0x71, 0x9c, 0x24, 0xa5, 0x19, 0x24, 0xe2, 0xd7, 0x7d, 0x19, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x52,
 0xcf, 0x6b, 0x70, 0xc9, 0xb1, 0x9d, 0x3f, 0xec, 0x64, 0xbd, 0xb4, 0x66, 0xe6, 0xa7, 0x15, 0xb5,
 0x78, 0x95, 0x4b, 0x22, 0xae, 0xb8, 0xf4, 0xcf, 0x84, 0x17, 0xb2, 0xfb, 0x38, 0x81, 0xd2, 0xb9,
 0xf5, 0x1c, 0xfa, 0x95, 0xb9, 0xc7, 0x3e, 0xa0, 0x59, 0xe7, 0xd4, 0xee, 0xdb, 0x07, 0x53, 0xd4,
 0x8a, 0xbd, 0x3f, 0xc2, 0x1f, 0xc5, 0x89, 0xd0, 0x39, 0xf5, 0x3b, 0xb6, 0xc4, 0x4b, 0x97, 0x27,
 0x93, 0xfc, 0x6a, 0xd2, 0x7e, 0xf2, 0x03, 0xb4, 0xdc, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x35, 0x03,
 0xab, 0x6d, 0xda, 0xe5, 0xcd, 0x29, 0x55, 0x5d, 0x53, 0xa4, 0x97, 0xb2, 0x9b, 0xed, 0x47, 0x5e,
 0xe7, 0xd4, 0xed, 0x5b, 0x71, 0x4a, 0xee, 0x5d, 0x4f, 0x10, 0x97, 0x17, 0x46, 0x7c, 0x1f, 0xac,
 0xff, 0x00, 0x7f, 0x03, 0xa6, 0x73, 0xea, 0x05, 0x9e, 0x7d, 0x4b, 0x79, 0x35, 0x65, 0x4f, 0x36,
 0xc2, 0x4d, 0xbe, 0x85, 0x5a, 0x3c, 0x7d, 0xb3, 0x8b, 0xe7, 0xd4, 0xca, 0xa8, 0xd3, 0x4d, 0x3e,
 0x0d, 0x75, 0x01, 0xeb, 0xd7, 0x35, 0x17, 0x0e, 0x27, 0x2a, 0xc7, 0xc7, 0x1d, 0x80, 0xa5, 0x88,
 0x8b, 0x5c, 0x65, 0x1f, 0x4c, 0xbc, 0x12, 0xef, 0xa2, 0xd5, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0xd4,
 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x35, 0xab, 0xaa, 0x74, 0x67, 0x51, 0xbe, 0x88, 0xc5, 0xbf, 0x69,
 0x1e, 0x59, 0xcf, 0xa9, 0xdd, 0x76, 0xab, 0x1e, 0xb0, 0xb9, 0x45, 0x58, 0xf3, 0x70, 0x9d, 0x65,
 0x6e, 0x2b, 0xd7, 0xeb, 0xf7, 0x8e, 0x83, 0xce, 0x05, 0x9e, 0x7d, 0x47, 0x3e, 0xa5, 0x6e, 0x73,
 0x2a, 0x4d, 0xbe, 0x0b, 0xa5, 0xbe, 0xf2, 0x03, 0xd0, 0x76, 0x22, 0x36, 0xf2, 0x5e, 0x77, 0xfe,
 0xd6, 0xa4, 0xa5, 0xec, 0x75, 0x7c, 0xc7, 0x3b, 0x73, 0x53, 0x8b, 0xcb, 0x29, 0xf9, 0xd7, 0x2f,
 0xa1, 0x87, 0xef, 0xc2, 0x09, 0x3f, 0x5f, 0xbf, 0xef, 0x96, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53,
 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b, 0x85, 0x3b,
 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb9, 0xa8, 0xb8, 0x53, 0xb9,
 0xa8, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x4b, 0x8e, 0xa1, 0x43, 0x1b,
 0x86, 0x96, 0x1f, 0x11, 0x05, 0x28, 0x4b, 0xdb, 0x4f, 0xc2, 0xb5, 0x3a, 0x06, 0x77, 0x96, 0xd7,
 0xcb, 0x31, 0x1c, 0x93, 0xf4, 0xf4, 0xa5, 0xfe, 0xae, 0xa7, 0x0e, 0x87, 0xa7, 0xae, 0x77, 0xab,
 0x84, 0x38, 0xca, 0x54, 0x71, 0x78, 0x79, 0xd0, 0xc4, 0x41, 0x4e, 0x12, 0xeb, 0xd3, 0x54, 0x07,
 0x9d, 0xf3, 0xea, 0x39, 0xf5, 0x27, 0xce, 0xf2, 0xea, 0xd9, 0x66, 0x27, 0x92, 0x6f, 0x9a, 0x94,
 0xbf, 0xd5, 0xcf, 0x87, 0x5a, 0xed, 0x38, 0xfe, 0x70, 0x2c, 0xf3, 0xea, 0x73, 0x5b, 0x31, 0x9e,
 0x4b, 0x2f, 0xae, 0xa8, 0x57, 0x93, 0x78, 0x59, 0xbe, 0x9f, 0xe6, 0x3f, 0x0a, 0xf9, 0xce, 0xb9,
 0xce, 0x39, 0xc0, 0xf5, 0xe8, 0xd5, 0x4d, 0x29, 0x26, 0x9a, 0x7d, 0x29, 0xae, 0xf9, 0x9b, 0x9a,
 0x9d, 0x37, 0x63, 0x73, 0x87, 0x38, 0x77, 0x3a, 0xbc, 0xfd, 0x34, 0x57, 0x1a, 0x4d, 0xf7, 0xd7,
 0x7e, 0x3e, 0xc1, 0xd9, 0xae, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xbb, 0x86,
 0x6e, 0x14, 0xee, 0x6a, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e,
 0x6a, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x9a,
 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0x4b, 0x86, 0x2e, 0x15, 0x2e, 0x0b, 0x80,
 0x5b, 0xb8, 0x66, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x18, 0xb8, 0x54, 0xb8, 0x2e, 0x01,
 0x72, 0xe1, 0x8b, 0x85, 0x4b, 0x9a, 0x8b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b,
 0xb8, 0x66, 0xe6, 0xa5, 0x3b, 0x82, 0xe0, 0x1d, 0x67, 0x6e, 0x27, 0xc7, 0x36, 0xa5, 0xfd, 0x82,
 0xf8, 0xd2, 0x38, 0x1e, 0x73, 0x94, 0xdb, 0x6a, 0x9c, 0x73, 0x5a, 0x5f, 0xd8, 0x2f, 0x8d, 0x23,
 0x82, 0xe7, 0x02, 0xcf, 0x38, 0xe7, 0x2b, 0x73, 0x8e, 0x70, 0x2c, 0xf3, 0x8e, 0x73, 0xbd, 0x79,
 0xcb, 0x2f, 0xfe, 0x43, 0x85, 0xf2, 0x51, 0xec, 0x1e, 0x72, 0xcb, 0xff, 0x00, 0x90, 0xe1, 0x7c,
 0x94, 0x7b, 0x00, 0xe8, 0xbc, 0xe3, 0x9c, 0xef, 0x5e, 0x72, 0xcb, 0xff, 0x00, 0x90, 0xe1, 0x7c,
 0x94, 0x7b, 0x07, 0x9c, 0xb2, 0xff, 0x00, 0xe4, 0x38, 0x5f, 0x23, 0x1e, 0xc0, 0x3a, 0x2f, 0x38,
 0xe7, 0x3b, 0xd7, 0x9c, 0xb2, 0xff, 0x00, 0xe4, 0x38, 0x5f, 0x25, 0x1e, 0xc1, 0xe7, 0x2c, 0xbf,
 0xf9, 0x0e, 0x17, 0xc9, 0x47, 0xb0, 0x0e, 0x8b, 0xce, 0x76, 0x4d, 0x84, 0xa9, 0xf6, 0xfc, 0x57,
 0xf5, 0x63, 0xf0, 0xb3, 0x96, 0xf3, 0x96, 0x5f, 0xfc, 0x87, 0x0b, 0xe4, 0xa3, 0xd8, 0x4b, 0x42,
 0x96, 0x1b, 0x0e, 0xdb, 0xa1, 0x42, 0x95, 0x26, 0xfa, 0xf9, 0x20, 0xa3, 0xc7, 0xda, 0x03, 0x90,
 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x56, 0xcd, 0xea, 0x7a, 0x93, 0x8c, 0xfe, 0xc2,
 0x7f, 0x15, 0x9a, 0xdc, 0x2a, 0xe6, 0xd5, 0x3d, 0x4a, 0xc5, 0xff, 0x00, 0x61, 0x3f, 0x8a, 0xc0,
 0xe8, 0xbc, 0xe3, 0x9c, 0xad, 0xce, 0x39, 0xc0, 0xb3, 0xce, 0x39, 0xca, 0xdc, 0xe4, 0x95, 0xe1,
 0x52, 0x8c, 0xa3, 0x1a, 0x91, 0xe1, 0xcd, 0x08, 0xce, 0x3a, 0xa6, 0xb8, 0xa0, 0x39, 0x8c, 0x9f,
 0x3c, 0xc5, 0x65, 0xbe, 0x92, 0x3c, 0x2a, 0xd1, 0x6f, 0x8b, 0xa7, 0x27, 0xd5, 0xeb, 0x3e, 0xf1,
 0xce, 0xc3, 0x6b, 0xb0, 0x6e, 0x3e, 0x9f, 0x0f, 0x88, 0x52, 0xf0, 0x2e, 0x0d, 0x7c, 0x27, 0x46,
 0xe7, 0x1c, 0xe0, 0x76, 0xdc, 0x76, 0xd6, 0xd5, 0x9c, 0x5c, 0x70, 0x74, 0x15, 0x3f, 0xe7, 0xcd,
 0xf1, 0x7e, 0xd7, 0x57, 0xc2, 0x5a, 0xd8, 0xec, 0xd2, 0xae, 0x21, 0xe2, 0x28, 0x62, 0x2a, 0xca,
 0xa5, 0x4e, 0x37, 0x13, 0x93, 0xe2, 0xfc, 0x0f, 0xe6, 0x3a, 0x47, 0x39, 0x7b, 0x22, 0xc6, 0xf9,
 0xd3, 0x35, 0xa1, 0x55, 0xbe, 0x11, 0x72, 0xe5, 0x97, 0xac, 0xfa, 0x3f, 0x78, 0x1e, 0x97, 0x70,
 0xe0, 0xb6, 0xd2, 0x93, 0xad, 0x96, 0x46, 0xbc, 0x7a, 0xe8, 0xcb, 0x8b, 0xf5, 0x9f, 0x43, 0xf9,
 0x8e, 0x46, 0xe6, 0xa6, 0x95, 0xb9, 0x2b, 0x51, 0x9d, 0x2a, 0x8b, 0x8c, 0x26, 0x9c, 0x64, 0xbc,
 0x29, 0x81, 0xe7, 0xdc, 0xe3, 0x9c, 0x66, 0x58, 0x79, 0xe0, 0xb1, 0x95, 0x30, 0xf3, 0xfb, 0xd7,
 0xe9, 0x5f, 0xe3, 0x2e, 0xf3, 0x2b, 0x73, 0x81, 0x6a, 0x35, 0x65, 0x19, 0x29, 0x45, 0xf0, 0x92,
 0x7c, 0x53, 0x5d, 0xe3, 0xbb, 0xe4, 0x59, 0xfd, 0x0c, 0x6d, 0x18, 0xd3, 0xaf, 0x52, 0x34, 0xf1,
 0x29, 0x70, 0x69, 0xbe, 0x0a, 0x5a, 0xae, 0xc3, 0xcf, 0xb9, 0xc7, 0x38, 0x1e, 0xb1, 0x70, 0x5c,
 0x3c, 0xba, 0x9e, 0x3f, 0x17, 0x49, 0x70, 0xa5, 0x8a, 0xaf, 0x05, 0xe0, 0x8d, 0x46, 0x84, 0xf3,
 0x0c, 0x65, 0x45, 0xc2, 0x78, 0xba, 0xf2, 0x5a, 0xd4, 0x6c, 0x0f, 0x43, 0xcd, 0x73, 0x9c, 0x2e,
 0x02, 0x8c, 0x9c, 0xea, 0x46, 0x55, 0x78, 0x7a, 0x5a, 0x69, 0xf4, 0xb7, 0xf3, 0x23, 0xa0, 0xd6,
 0xc4, 0x4e, 0xb5, 0x69, 0xd5, 0xa8, 0xf8, 0xce, 0x72, 0x72, 0x93, 0xd5, 0x94, 0xf9, 0xc7, 0x38,
 0x16, 0x79, 0xc7, 0x39, 0x5b, 0x9c, 0x73, 0x81, 0xdb, 0xf6, 0x13, 0xfd, 0x66, 0x2a, 0xaf, 0x81,
 0x46, 0x2b, 0xdf, 0xec, 0x3b, 0x4d, 0xc3, 0xae, 0xec, 0x95, 0x27, 0x87, 0xca, 0x94, 0xe4, 0xb8,
 0x4a, 0xb4, 0x9c, 0xfd, 0x8e, 0xf7, 0x6f, 0xb2, 0x72, 0xf7, 0x00, 0xb7, 0x73, 0x53, 0x37, 0x0a,
 0x77, 0x05, 0xc0, 0x3a, 0x2e, 0x6f, 0x3f, 0x55, 0xb1, 0x9f, 0xdb, 0xcf, 0xe3, 0x32, 0xaf, 0x39,
 0x9c, 0xda, 0x7e, 0xaa, 0xe2, 0xff, 0x00, 0xb7, 0x9f, 0xc6, 0x65, 0x5e, 0x70, 0x2c, 0xf3, 0x8e,
 0x72, 0xb7, 0x39, 0x2d, 0xaa, 0xbe, 0x74, 0x58, 0xa5, 0x1e, 0x34, 0xb9, 0xdc, 0x38, 0xae, 0xf3,
 0xe0, 0x9f, 0xce, 0x07, 0x37, 0x90, 0x67, 0xb5, 0x32, 0xd9, 0x3a, 0x55, 0x13, 0xa9, 0x87, 0x93,
 0xe2, 0xe2, 0xba, 0xe2, 0xfc, 0x2b, 0xb0, 0xed, 0xd8, 0x4c, 0xd7, 0x05, 0x8b, 0x8a, 0x74, 0x31,
 0x34, 0xe4, 0xdf, 0xde, 0xb7, 0xc2, 0x5e, 0xd3, 0x3c, 0xc7, 0x9c, 0x73, 0x81, 0xea, 0xd5, 0x31,
 0x34, 0xe9, 0xc7, 0x9a, 0xa5, 0x48, 0x42, 0x3e, 0x19, 0x4b, 0x82, 0x3a, 0xa6, 0xd4, 0xe7, 0xb4,
 0xf1, 0x54, 0xfc, 0xe5, 0x84, 0x9f, 0x35, 0x3e, 0x3c, 0x6a, 0x4f, 0xbd, 0x2e, 0x1d, 0x49, 0x68,
 0x75, 0x4e, 0x71, 0xce, 0x05, 0x9e, 0x71, 0xce, 0x56, 0xe7, 0x1c, 0xe0, 0x59, 0xe7, 0x1c, 0xe5,
 0x7a, 0x7c, 0xd3, 0x9c, 0x61, 0x04, 0xe5, 0x29, 0x3e, 0x09, 0x2e, 0xfb, 0x26, 0xc7, 0x61, 0xeb,
 0xe0, 0xb1, 0x0e, 0x85, 0x78, 0xf0, 0x92, 0xe9, 0x4d, 0x75, 0x35, 0xe1, 0x40, 0x73, 0xfb, 0x3d,
 0xb4, 0x32, 0xc1, 0x45, 0x61, 0xb1, 0x3c, 0x67, 0x87, 0xfb, 0xd6, 0xba, 0xe1, 0xda, 0x8e, 0xd7,
 0x85, 0xcc, 0x70, 0xb8, 0xa8, 0xa9, 0x50, 0xc4, 0x53, 0xa8, 0x9f, 0x79, 0x4b, 0xa7, 0xda, 0xeb,
 0x3c, 0xbb, 0x9c, 0x73, 0x81, 0xea, 0x78, 0x8c, 0x76, 0x1b, 0x0f, 0x17, 0x2a, 0xf5, 0xe9, 0xd3,
 0x4b, 0xf1, 0xa4, 0x74, 0xcd, 0xa4, 0xce, 0xbb, 0xa3, 0x56, 0x34, 0xa8, 0xf1, 0x58, 0x7a, 0x6f,
 0x8a, 0xe3, 0xd7, 0x27, 0xe1, 0x3a, 0xff, 0x00, 0x38, 0xe7, 0x02, 0xcf, 0x38, 0xe7, 0x2b, 0x73,
 0x8e, 0x70, 0x2c, 0xf3, 0x9d, 0xf3, 0x65, 0x93, 0xa5, 0x91, 0xd0, 0x4f, 0xa1, 0xcb, 0x8c, 0xbd,
 0xb6, 0xf8, 0x7b, 0xc7, 0x40, 0xc0, 0xd2, 0x9e, 0x2f, 0x17, 0x4f, 0x0f, 0x4f, 0xee, 0xa7, 0x2e,
 0x1c, 0x7c, 0x0b, 0xbe, 0xcf, 0x44, 0xa3, 0xcb, 0x46, 0x8c, 0x29, 0x43, 0xa2, 0x30, 0x8a, 0x8a,
 0xf5, 0x90, 0x17, 0xae, 0x0b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x4d, 0x8c, 0x84, 0x31, 0x58, 0x5a,
 0xb8, 0x7a, 0x9f, 0x73, 0x52, 0x2e, 0x2f, 0x4d, 0x4f, 0x39, 0xc4, 0xc2, 0xa6, 0x1f, 0x11, 0x52,
 0x85, 0x45, 0xc2, 0x70, 0x93, 0x8b, 0x3d, 0x02, 0xe1, 0xd7, 0xb6, 0xb7, 0x2f, 0x75, 0xe1, 0xe7,
 0xea, 0x11, 0xe3, 0x52, 0x0b, 0x85, 0x44, 0xbe, 0xfa, 0x3e, 0x1f, 0x60, 0x0e, 0xb9, 0xce, 0x39,
 0xca, 0xdc, 0xe3, 0x9c, 0x0e, 0x73, 0x20, 0xce, 0x6a, 0x65, 0x95, 0xda, 0x69, 0xce, 0x84, 0xdf,
 0xa7, 0x82, 0xef, 0x6a, 0xb5, 0x3b, 0xae, 0x0b, 0x30, 0xc3, 0x63, 0x29, 0xdc, 0xc3, 0xd6, 0x8c,
 0xd7, 0x7d, 0x27, 0xd2, 0xbd, 0x75, 0xde, 0x3c, 0xbb, 0x9c, 0xda, 0x15, 0x65, 0x09, 0x29, 0x42,
 0x4e, 0x32, 0x5d, 0x4d, 0x3e, 0x0c, 0x0f, 0x56, 0xb9, 0xa9, 0x53, 0x31, 0xcd, 0x70, 0x98, 0x0a,
 0x6e, 0x58, 0x8a, 0xa9, 0x4b, 0x87, 0x44, 0x17, 0x4c, 0x9f, 0xb0, 0x79, 0xdb, 0xcc, 0xb1, 0xce,
 0x3c, 0xaf, 0x19, 0x88, 0xe1, 0xe0, 0xba, 0xfb, 0x4a, 0xee, 0xa3, 0x93, 0x6e, 0x4f, 0x8b, 0x7d,
 0xf6, 0xc0, 0xe5, 0x73, 0x8c, 0xd2, 0xb6, 0x65, 0x8a, 0x75, 0xaa, 0x7a, 0x58, 0xae, 0x88, 0x41,
 0x3e, 0x88, 0xa2, 0x97, 0x39, 0x5b, 0x9c, 0x73, 0x81, 0x67, 0x9c, 0xe5, 0x76, 0x5b, 0x0c, 0xf1,
 0x79, 0xa4, 0x27, 0x25, 0xc6, 0x9d, 0x1f, 0x4f, 0x2f, 0x5f, 0xbc, 0xbd, 0xbf, 0x80, 0xe0, 0xe9,
 0x29, 0xd5, 0xa9, 0x1a, 0x74, 0xe2, 0xe5, 0x39, 0x3e, 0x09, 0x2e, 0xfb, 0x3b, 0xe6, 0x49, 0x83,
 0x8e, 0x5f, 0x81, 0x54, 0xb8, 0xa7, 0x52, 0x5e, 0x9a, 0xa4, 0x97, 0x7d, 0x81, 0xcd, 0xdc, 0x17,
 0x0a, 0x77, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x35, 0x29,
 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x73,
 0x51, 0x74, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc,
 0x17, 0x00, 0xb7, 0x70, 0xcd, 0xc2, 0x9d, 0xc1, 0x74, 0x09, 0x71, 0xd4, 0x68, 0xe3, 0x70, 0xd3,
 0xc3, 0xd7, 0x8f, 0x34, 0x25, 0xed, 0xa7, 0xe1, 0x47, 0x40, 0xcd, 0x70, 0x95, 0x72, 0xfc, 0x5c,
 0xa8, 0x55, 0xe9, 0x5d, 0x70, 0x97, 0x7a, 0x4b, 0xc2, 0x77, 0xab, 0x87, 0x19, 0xb4, 0x98, 0x55,
 0x8e, 0xcb, 0xa4, 0xe2, 0xbe, 0xdb, 0x4b, 0x8c, 0xe1, 0xaf, 0x85, 0x7b, 0x20, 0x74, 0xee, 0x71,
 0xce, 0x56, 0xe7, 0x1c, 0xe0, 0x5c, 0xc3, 0xe2, 0x27, 0x42, 0xbc, 0x2b, 0x52, 0x97, 0x2c, 0xe1,
 0x25, 0x28, 0xbd, 0x4f, 0x45, 0xcb, 0xf1, 0xb0, 0xc6, 0x60, 0xa9, 0x62, 0x61, 0xd5, 0x38, 0xf1,
 0x6b, 0xc0, 0xfb, 0xeb, 0xdb, 0x3c, 0xbb, 0x9c, 0xed, 0x3b, 0x11, 0x8d, 0x6e, 0x9d, 0x7c, 0x24,
 0x9f, 0xdc, 0xb5, 0x52, 0x3f, 0x03, 0xf9, 0x80, 0xed, 0xf7, 0x0c, 0xdc, 0x29, 0xdc, 0x17, 0x00,
 0xb7, 0x73, 0x51, 0x70, 0xa9, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xc0,
 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x35, 0x17, 0x00, 0xb9,
 0x73, 0x51, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xc0, 0x2a, 0x5c, 0x31, 0x70, 0xa9, 0x73, 0x51, 0x70,
 0x0b, 0x77, 0x05, 0xcd, 0x4a, 0x97, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0xc5, 0xcd, 0x4a, 0x97, 0x05,
 0xc0, 0x2d, 0xdc, 0xe8, 0x33, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xc0, 0x2d, 0xdc, 0x33, 0x70, 0xa7,
 0x73, 0x51, 0x73, 0x50, 0x2d, 0xdc, 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x35, 0x03, 0xae, 0x6d, 0x9c,
 0xf8, 0xe6, 0x94, 0xff, 0x00, 0xb0, 0x5f, 0x1a, 0x47, 0x07, 0xce, 0x72, 0x7b, 0x63, 0x3f, 0x54,
 0xe9, 0xff, 0x00, 0x62, 0xbe, 0x34, 0x8e, 0x13, 0x9c, 0x0b, 0x3c, 0xe6, 0x39, 0xca, 0xfc, 0xe3,
 0x9c, 0x0f, 0x52, 0xb8, 0x2e, 0x15, 0x1d, 0x4d, 0x45, 0xc0, 0x2e, 0x5c, 0xd4, 0xc5, 0xcd, 0x4a,
 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0xd4, 0xa9, 0x73, 0x51, 0x73, 0x50, 0x2d, 0xdc, 0x17,
 0x35, 0x2a, 0x5c, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x0c, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0xd4, 0x0b,
 0x77, 0x0a, 0xd9, 0xad, 0x4f, 0x52, 0xf1, 0x7f, 0xd8, 0x4f, 0xe2, 0xb3, 0x5b, 0x9a, 0x91, 0x62,
 0x95, 0xfc, 0x2d, 0x5a, 0x1c, 0xdc, 0xb7, 0x21, 0x28, 0x71, 0xe1, 0xc7, 0x87, 0x15, 0xc0, 0x0e,
 0x8b, 0xce, 0x39, 0xce, 0x6f, 0xec, 0x6b, 0xfa, 0x77, 0xf7, 0x5f, 0xbc, 0x7d, 0x8d, 0x7f, 0x4e,
 0xfe, 0xeb, 0xf7, 0x81, 0xc2, 0xf3, 0x9d, 0xb7, 0x17, 0x80, 0x59, 0x86, 0x43, 0x84, 0x70, 0xe0,
 0xab, 0xd3, 0xa1, 0x07, 0x07, 0xe1, 0xf4, 0xab, 0xa0, 0xe3, 0x3e, 0xc6, 0xbf, 0xa7, 0x7f, 0x75,
 0xfb, 0xce, 0x7f, 0x0a, 0xac, 0x61, 0x69, 0x50, 0xe6, 0xe6, 0xb7, 0x05, 0x0e, 0x3c, 0x38, 0x71,
 0xe0, 0xb8, 0x01, 0xd1, 0xe6, 0xe5, 0x09, 0x38, 0xc9, 0x38, 0xc9, 0x3e, 0x0d, 0x3e, 0xf3, 0x31,
 0xce, 0x76, 0xcc, 0xdb, 0x2b, 0xc3, 0x63, 0xdd, 0xce, 0x2e, 0x95, 0x6e, 0x1f, 0x77, 0x15, 0xd7,
 0xeb, 0xae, 0xf9, 0xc0, 0xd7, 0xc8, 0x73, 0x08, 0x37, 0x6d, 0x53, 0xaa, 0xbb, 0xcd, 0x4b, 0x87,
 0xc2, 0x05, 0x1e, 0x71, 0xce, 0x5b, 0x86, 0x49, 0x99, 0x49, 0xf4, 0xd1, 0x8c, 0x35, 0x75, 0x17,
 0xcc, 0xcb, 0xd8, 0x4d, 0x9d, 0x7c, 0x53, 0xc5, 0x62, 0x17, 0x0e, 0xfc, 0x69, 0xf6, 0xbe, 0xc0,
 0x3b, 0x26, 0x4b, 0x8d, 0xf3, 0xde, 0x59, 0x46, 0xb3, 0x97, 0x19, 0x72, 0xf2, 0xcb, 0xd7, 0x5d,
 0x0c, 0xb9, 0x70, 0xe3, 0xb0, 0x74, 0x68, 0x60, 0xe8, 0xd9, 0xc3, 0xc3, 0x92, 0x09, 0xf1, 0xeb,
 0xe3, 0xc5, 0xf8, 0x49, 0xae, 0x6a, 0x04, 0x59, 0xe6, 0x02, 0x9e, 0x63, 0x87, 0xe0, 0x9a, 0x8d,
 0x68, 0x2f, 0x49, 0x2f, 0x99, 0xe8, 0x74, 0xac, 0x4d, 0x3a, 0xb8, 0x6a, 0xd2, 0xa3, 0x5a, 0x0e,
 0x13, 0x8f, 0x5a, 0x67, 0x7a, 0xb9, 0xa9, 0x5f, 0x1b, 0x87, 0xc3, 0x63, 0x29, 0xf2, 0x62, 0x29,
 0xa9, 0xae, 0xf3, 0xef, 0xaf, 0x59, 0x81, 0xd2, 0x79, 0xc7, 0x39, 0xcc, 0xe2, 0xf6, 0x75, 0xf1,
 0x6f, 0x0b, 0x88, 0x5c, 0x3b, 0xd1, 0xa8, 0xbe, 0x75, 0xd8, 0x71, 0xd5, 0x72, 0x7c, 0xca, 0x9b,
 0xff, 0x00, 0xe1, 0xf9, 0xd7, 0x86, 0x32, 0x4c, 0x0a, 0xdc, 0xe6, 0x79, 0xcc, 0xcb, 0x03, 0x8f,
 0x8f, 0x5e, 0x0e, 0xbf, 0xb1, 0x06, 0xcc, 0x2c, 0x16, 0x39, 0xff, 0x00, 0x02, 0xc4, 0x79, 0x36,
 0x03, 0x9c, 0x73, 0x92, 0x43, 0x2d, 0xcc, 0x67, 0xd5, 0x84, 0xa8, 0xbd, 0x7e, 0x8f, 0x84, 0xb7,
 0x87, 0xc8, 0x31, 0xf5, 0x1f, 0xdb, 0x1d, 0x2a, 0x4b, 0x59, 0x71, 0x7e, 0xf0, 0x14, 0x39, 0xce,
 0x63, 0x20, 0xca, 0xa7, 0x8c, 0xa9, 0x1a, 0xf8, 0x88, 0xb8, 0xe1, 0xd3, 0xe3, 0xd3, 0xf7, 0xfe,
 0xb6, 0x9a, 0x97, 0xb2, 0xfc, 0x8f, 0x07, 0x87, 0x6a, 0x75, 0x9b, 0xc4, 0x4d, 0x7e, 0x32, 0xe1,
 0x1f, 0x68, 0xe6, 0x15, 0x4e, 0x0b, 0x82, 0x02, 0xda, 0x9a, 0x4b, 0x82, 0xe8, 0x4b, 0xa9, 0x19,
 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x07, 0x4a, 0xcd, 0x67,
 0xea, 0xa6, 0x2f, 0xfb, 0x79, 0xfc, 0x66, 0x56, 0xe7, 0x39, 0xfc, 0x56, 0x40, 0xab, 0xe2, 0xaa,
 0xd7, 0xf3, 0xef, 0x2d, 0xc9, 0xb9, 0xf0, 0xb5, 0xc7, 0x87, 0x17, 0xc7, 0xc2, 0x45, 0xf6, 0x35,
 0xfd, 0x3b, 0xfb, 0xaf, 0xde, 0x07, 0x0b, 0xce, 0x76, 0xbd, 0x92, 0x8d, 0x3a, 0xd9, 0x2d, 0x7a,
 0x35, 0x62, 0xa7, 0x09, 0x56, 0x69, 0xa7, 0xfd, 0x58, 0x9c, 0x77, 0xd8, 0xdf, 0xf4, 0xef, 0xee,
 0xbf, 0x79, 0xcb, 0x64, 0xd8, 0x4e, 0xe7, 0x61, 0x65, 0x42, 0xf5, 0xde, 0x69, 0xb9, 0xf1, 0xe5,
 0xe1, 0xde, 0x4b, 0xc3, 0xa0, 0x1c, 0x1e, 0x75, 0x94, 0xd6, 0xc0, 0xcd, 0xd4, 0xa6, 0x9d, 0x4c,
 0x3b, 0x7d, 0x12, 0xef, 0xc7, 0x47, 0xda, 0x71, 0x7c, 0xe7, 0x7e, 0x73, 0x4f, 0xa1, 0xf4, 0xa6,
 0x70, 0xf9, 0x86, 0x47, 0x83, 0xc4, 0x37, 0x3a, 0x2d, 0xe1, 0xe6, 0xff, 0x00, 0x15, 0x71, 0x8f,
 0xb5, 0xd8, 0x07, 0x59, 0xe7, 0x31, 0xce, 0x72, 0x15, 0xb2, 0x0c, 0x74, 0x1f, 0xda, 0xe5, 0x4a,
 0xaa, 0xef, 0x70, 0x97, 0x07, 0xef, 0x91, 0x2c, 0x97, 0x33, 0x6f, 0x87, 0x9d, 0xd7, 0xaf, 0x72,
 0x3d, 0xa0, 0x55, 0xe7, 0x1c, 0xc7, 0x25, 0x87, 0xd9, 0xec, 0x64, 0xda, 0xbd, 0x56, 0x95, 0x28,
 0xf7, 0xfa, 0x79, 0x9f, 0xfe, 0xfd, 0x93, 0x9a, 0xcb, 0x72, 0xac, 0x1e, 0x09, 0xaa, 0x89, 0x3a,
 0xb5, 0x57, 0xdf, 0xcf, 0xbd, 0xeb, 0x2e, 0xf0, 0x1a, 0x6c, 0xce, 0x56, 0xe8, 0x35, 0x8c, 0xc5,
 0x47, 0x85, 0x4e, 0x1f, 0x6b, 0x83, 0xfb, 0xdd, 0x5e, 0xa7, 0x29, 0x9b, 0x60, 0xa8, 0xe6, 0x38,
 0x7b, 0x75, 0x3d, 0x2c, 0xe3, 0xf7, 0x13, 0x5d, 0x71, 0x7d, 0x86, 0x6e, 0x0b, 0x9a, 0x81, 0xd2,
 0x71, 0xf8, 0x5c, 0x46, 0x06, 0xb5, 0xaa, 0xf0, 0xe1, 0xe0, 0x92, 0xea, 0x97, 0xac, 0x57, 0xe7,
 0x3b, 0xd6, 0x22, 0x14, 0x71, 0x14, 0xdd, 0x2a, 0xf4, 0xe3, 0x52, 0x0f, 0xad, 0x33, 0x82, 0xc6,
 0x6c, 0xf5, 0x39, 0x37, 0x2c, 0x25, 0x77, 0x0f, 0xe6, 0x4f, 0xa5, 0x7b, 0x60, 0x70, 0x5c, 0xe3,
 0x98, 0xb9, 0x53, 0x23, 0xcc, 0xa0, 0xfd, 0x2c, 0x29, 0xcf, 0x58, 0xcd, 0x7c, 0xfc, 0x0d, 0x63,
 0x92, 0x66, 0x6f, 0xae, 0x8c, 0x63, 0xeb, 0xd4, 0x5d, 0xa0, 0x55, 0xe7, 0x33, 0x4f, 0x9e, 0xa4,
 0xd4, 0x21, 0x17, 0x29, 0x49, 0xf0, 0x49, 0x74, 0xb6, 0x72, 0xb8, 0x6d, 0x9d, 0xac, 0xdf, 0x1c,
 0x46, 0x22, 0x10, 0x5e, 0x08, 0x71, 0x6f, 0xe6, 0x39, 0xcc, 0xbf, 0x03, 0x84, 0xc0, 0xaf, 0xb4,
 0x53, 0xf4, 0xfc, 0x38, 0x39, 0xcb, 0xa6, 0x4c, 0x06, 0xce, 0xe5, 0xab, 0x01, 0x49, 0xd6, 0xad,
 0xc1, 0xe2, 0x26, 0xba, 0x7f, 0x98, 0xbc, 0x07, 0x2f, 0x73, 0x52, 0xa5, 0xc1, 0x73, 0x50, 0x2e,
 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb7, 0x73, 0x51, 0x70, 0xa9, 0x73, 0xa7, 0xac, 0x5c,
 0x03, 0x85, 0xcf, 0xf2, 0x57, 0xcd, 0x2c, 0x56, 0x06, 0x3c, 0x78, 0xf4, 0xca, 0x92, 0xf8, 0x57,
 0x61, 0xd6, 0xdc, 0x9a, 0x7c, 0x1f, 0x43, 0x5d, 0x68, 0xef, 0xd7, 0x0a, 0x19, 0x8e, 0x5b, 0x83,
 0xc7, 0x71, 0x95, 0x48, 0x72, 0x54, 0xfc, 0x78, 0x74, 0x3f, 0x67, 0xc2, 0x07, 0x50, 0xe7, 0x1c,
 0xe7, 0x25, 0x8a, 0xd9, 0xfc, 0x5d, 0x36, 0xdd, 0x0a, 0x94, 0xeb, 0x47, 0xbc, 0x9b, 0xe5, 0x7d,
 0x9e, 0xf9, 0x46, 0xa6, 0x5b, 0x98, 0xc1, 0xf0, 0x96, 0x12, 0xab, 0xfe, 0xaa, 0xe3, 0xf0, 0x01,
 0x1f, 0x38, 0xe7, 0x32, 0xb0, 0x58, 0xf6, 0xfa, 0x30, 0x78, 0x8f, 0x26, 0xc9, 0xa8, 0xe5, 0x19,
 0x95, 0x46, 0xb8, 0x61, 0xdc, 0x57, 0x86, 0x52, 0x48, 0x0a, 0xfc, 0xe4, 0xb8, 0x7a, 0x75, 0xb1,
 0x15, 0x55, 0x2a, 0x34, 0xe5, 0x39, 0xbe, 0xf2, 0x39, 0x5c, 0x26, 0xce, 0xbe, 0x2a, 0x58, 0xbc,
 0x42, 0xe1, 0xf8, 0xb4, 0xfb, 0x5f, 0x61, 0xcf, 0x60, 0xe8, 0x61, 0xf0, 0x94, 0xf9, 0x30, 0xf4,
 0xa3, 0x05, 0xdf, 0x6b, 0xad, 0xfa, 0xec, 0x08, 0xf2, 0x1c, 0xae, 0x9e, 0x5f, 0x1b, 0xb5, 0x1a,
 0x9e, 0x22, 0x4b, 0xaf, 0xbd, 0x1d, 0x17, 0x69, 0xcb, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdd,
 0xcd, 0x45, 0xcd, 0x4a, 0x97, 0x05, 0xcd, 0x40, 0xb7, 0x73, 0x51, 0x70, 0xa9, 0x70, 0x5c, 0x02,
 0xdd, 0xc1, 0x70, 0xa9, 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0xd4, 0x5c,
 0x02, 0xdd, 0xc1, 0x73, 0x52, 0xa5, 0xc1, 0x73, 0x50, 0x2d, 0xdc, 0x17, 0x35, 0x3c, 0xf3, 0x17,
 0x99, 0xe6, 0x2a, 0xbd, 0x4a, 0x72, 0xc6, 0x57, 0x5c, 0xb2, 0x71, 0xe8, 0x9b, 0x5d, 0x4f, 0x42,
 0xa4, 0xf1, 0x55, 0xea, 0x7d, 0xdd, 0x6a, 0x93, 0xf5, 0xe4, 0xd8, 0x1e, 0x97, 0x53, 0x15, 0x4a,
 0x9f, 0xdd, 0xd5, 0x84, 0x3d, 0x79, 0x24, 0x62, 0x8e, 0x32, 0x85, 0x77, 0x25, 0x46, 0xbd, 0x3a,
 0x8e, 0x3f, 0x75, 0xc9, 0x24, 0xf8, 0x7b, 0x47, 0x98, 0xf3, 0x9d, 0x83, 0x62, 0xeb, 0x25, 0x5f,
 0x13, 0x4f, 0x8f, 0x4c, 0xa3, 0x17, 0xed, 0x3f, 0xde, 0x07, 0x72, 0xb9, 0xa8, 0xb8, 0x54, 0xb8,
 0x2e, 0x6a, 0x05, 0xbb, 0x9a, 0x8b, 0x85, 0x4b, 0x82, 0xe0, 0x1d, 0x2f, 0x36, 0x82, 0xc3, 0xe6,
 0x58, 0x8a, 0x51, 0xe8, 0x4a, 0x6f, 0x87, 0xac, 0xfa, 0x51, 0x57, 0x9c, 0x9f, 0x68, 0xaa, 0x29,
 0x67, 0x58, 0x86, 0xbc, 0x29, 0x7b, 0xc8, 0xe3, 0xf9, 0xc0, 0xb3, 0xce, 0x72, 0xbb, 0x29, 0x5d,
 0xd3, 0xce, 0x69, 0xae, 0x3c, 0x14, 0xe3, 0x28, 0xbf, 0x6b, 0x8f, 0xcc, 0x70, 0x3c, 0xe5, 0xfd,
 0x9f, 0x9f, 0xab, 0x38, 0x6e, 0x1f, 0x8c, 0xfe, 0x06, 0x07, 0xa1, 0xdc, 0xd4, 0xcd, 0xcd, 0x4a,
 0x77, 0x05, 0xcd, 0x40, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x17, 0x35, 0x02, 0xdd, 0xc1, 0x70, 0xa9,
 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0x31, 0x70, 0xa9, 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0x17,
 0x35, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xdb, 0xa8, 0x2e, 0x15, 0x2e, 0x6a, 0x2e, 0x01, 0x4e, 0xe0,
 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa2, 0xe1,
 0x52, 0xe1, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x15, 0x2e, 0x6a, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54,
 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x6a, 0x07, 0x01, 0xb5, 0xf3, 0xf5, 0x4e,
 0x9f, 0xf6, 0x2b, 0xe3, 0x48, 0xe1, 0x79, 0xce, 0x43, 0x6b, 0x6a, 0x71, 0xcc, 0xa9, 0xff, 0x00,
 0x62, 0xbe, 0x19, 0x1c, 0x3f, 0x38, 0x16, 0x39, 0xc7, 0x39, 0x5f, 0x9c, 0x73, 0x81, 0xe9, 0x97,
 0x05, 0xc3, 0xaa, 0x7d, 0x94, 0x7f, 0x42, 0xfe, 0xf7, 0xf7, 0x0f, 0xb2, 0x8f, 0xe8, 0x5f, 0xde,
 0xfe, 0xe0, 0x3b, 0x5d, 0xcd, 0x45, 0xcd, 0x4e, 0xa9, 0xf6, 0x51, 0xfd, 0x0b, 0xfb, 0xdf, 0xdc,
 0x3e, 0xca, 0x3f, 0xa1, 0x7f, 0x7b, 0xfb, 0x80, 0xed, 0x77, 0x05, 0xc3, 0xaa, 0x7d, 0x94, 0x7f,
 0x42, 0xfe, 0xf7, 0xf7, 0x0f, 0xb2, 0x8f, 0xe8, 0x5f, 0xde, 0xfe, 0xe0, 0x3b, 0x5d, 0xc1, 0x70,
 0xea, 0x9f, 0x65, 0x1f, 0xd0, 0xbf, 0xbd, 0xfd, 0xc3, 0xec, 0xa3, 0xfa, 0x17, 0xf7, 0xbf, 0xb8,
 0x0e, 0xd7, 0x70, 0x5c, 0x3a, 0xe6, 0x5b, 0x9f, 0xf9, 0xf3, 0x19, 0x0c, 0x3f, 0x9d, 0xad, 0xf3,
 0x71, 0xf4, 0xd7, 0x38, 0xf0, 0xe0, 0xb8, 0xf8, 0x0e, 0x5e, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x4b,
 0x9a, 0x8b, 0xa0, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b,
 0x80, 0x5b, 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x66, 0xe6, 0xa0, 0x5b, 0xb8, 0x2e, 0x14, 0xee, 0x19,
 0xb8, 0x05, 0xbb, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0xa2, 0xe0,
 0x16, 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x6a, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01,
 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa2, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb,
 0x82, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe6, 0xa0, 0x5b, 0xb8,
 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8,
 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5,
 0x4b, 0x82, 0xe6, 0xa0, 0x5b, 0xb8, 0x2e, 0x6a, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0xbb, 0x82, 0xe6,
 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x9a, 0x8b, 0x9a, 0x81, 0x6e, 0xe0, 0xb8,
 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8,
 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb9, 0xa9, 0x52, 0xe0, 0xb8,
 0x05, 0xbb, 0x82, 0xe1, 0x52, 0xe0, 0xb9, 0xa8, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16,
 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b,
 0x85, 0x4b, 0x86, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe1,
 0x52, 0xe6, 0xa2, 0xe0, 0x16, 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x18, 0xb9, 0xa8, 0x17, 0x2e, 0x0b,
 0x85, 0x4b, 0x82, 0xe0, 0x1d, 0x5b, 0x68, 0x61, 0x67, 0x36, 0xac, 0xbb, 0xd3, 0x7c, 0xeb, 0xd9,
 0xfd, 0xfc, 0x4e, 0x3f, 0x9c, 0xe7, 0x76, 0xb2, 0x8d, 0xca, 0x14, 0xf1, 0x51, 0x5c, 0x5d, 0x3f,
 0x4b, 0x2f, 0x59, 0xfe, 0xff, 0x00, 0x84, 0xeb, 0x5c, 0xe0, 0x58, 0xe7, 0x2f, 0x64, 0x78, 0xe5,
 0x83, 0xcc, 0x69, 0xd5, 0x93, 0xe1, 0x07, 0xe9, 0x66, 0xf4, 0x7f, 0xfb, 0x47, 0x13, 0xce, 0x39,
 0xc0, 0xf4, 0xc5, 0x55, 0x35, 0xc5, 0x3e, 0x29, 0x8b, 0x87, 0x49, 0xca, 0xb3, 0xea, 0xd8, 0x48,
 0x2a, 0x35, 0xa2, 0xea, 0xd2, 0x5d, 0x5d, 0x3d, 0x31, 0xf5, 0x8e, 0x62, 0x9e, 0xd0, 0x65, 0xf2,
 0x5c, 0x65, 0x52, 0x70, 0xd2, 0x50, 0x7f, 0x30, 0x1c, 0xf5, 0xc2, 0x3c, 0x4e, 0x2a, 0x18, 0x7a,
 0x13, 0xad, 0x52, 0x5c, 0x21, 0x05, 0xc5, 0x9c, 0x1d, 0x6d, 0xa2, 0xc0, 0xc2, 0x3c, 0x60, 0xea,
 0x55, 0x7e, 0x05, 0x1e, 0x1f, 0x09, 0xc0, 0xe6, 0x99, 0xb5, 0x7c, 0x7b, 0x51, 0x97, 0xa4, 0xa4,
 0x9f, 0x15, 0x04, 0xfe, 0x1f, 0x08, 0x1a, 0xe2, 0x31, 0x12, 0xaf, 0x88, 0xa9, 0x5a, 0x5f, 0x75,
 0x39, 0x39, 0x3f, 0x64, 0x8f, 0x9c, 0xaf, 0xce, 0x39, 0xc0, 0xb1, 0xce, 0x72, 0xbb, 0x2c, 0x9c,
 0xf3, 0x68, 0x4b, 0xbd, 0x4e, 0x32, 0x93, 0xf6, 0xb8, 0x7c, 0xe7, 0x05, 0xce, 0x76, 0x7d, 0x94,
 0xa3, 0x6b, 0x0b, 0x3c, 0x4c, 0x97, 0x4d, 0x57, 0xc2, 0x3e, 0xb2, 0xfd, 0xe0, 0x76, 0x5b, 0x82,
 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0xa2, 0xe0, 0x16, 0xee, 0x0b, 0x85,
 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x9a, 0x8b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e,
 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x53, 0xb8, 0x2e, 0x6a, 0x54, 0xb8, 0x2e,
 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb9, 0xa9, 0x8b, 0x80, 0x5c, 0xb9, 0xa8, 0xb8, 0x53, 0xb9, 0xa8,
 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x52,
 0xe6, 0xa6, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe6, 0xa5, 0x3b, 0x9a, 0x99, 0xb9, 0xa8, 0x1c, 0x26,
 0xd5, 0xd4, 0xf5, 0x46, 0x9f, 0x4f, 0xfb, 0x25, 0xf0, 0xb3, 0x87, 0xe7, 0xd4, 0xbd, 0xb5, 0x35,
 0x3d, 0x50, 0x87, 0x4f, 0xfb, 0x25, 0xf0, 0xb3, 0x89, 0xe7, 0xd4, 0x0b, 0x1c, 0xfa, 0x8e, 0x7d,
 0x4a, 0xfc, 0xfa, 0x8e, 0x7d, 0x40, 0xb1, 0xcf, 0xa8, 0xe7, 0xd4, 0xaf, 0xce, 0x39, 0xf5, 0x02,
 0xc7, 0x38, 0xe7, 0x2b, 0xf3, 0xea, 0x39, 0xf5, 0x02, 0xc7, 0x3e, 0xa3, 0x9f, 0x52, 0xbf, 0x3e,
 0xa3, 0x9f, 0x50, 0x2c, 0x73, 0xea, 0x39, 0xf5, 0x2b, 0xf3, 0x8e, 0x7d, 0x40, 0xe6, 0x76, 0x76,
 0x7e, 0xab, 0xd1, 0xe9, 0xef, 0x4b, 0xe2, 0xb3, 0xb6, 0xdc, 0x3a, 0x46, 0xcf, 0xd4, 0xf5, 0x5a,
 0x8f, 0xad, 0x2f, 0x81, 0x9d, 0xae, 0xe6, 0xa0, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x52, 0xe0, 0xb9,
 0xa8, 0x16, 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x14, 0xee, 0x19, 0xb9,
 0xa8, 0x16, 0xee, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e,
 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe1, 0x9b, 0x9a, 0x81, 0x6e, 0xe6, 0xa2, 0xe6, 0xa5, 0x3b,
 0x86, 0x6e, 0x6a, 0x05, 0xbb, 0x82, 0xe1, 0x52, 0xe6, 0xa6, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53,
 0xb9, 0xa9, 0x9b, 0x80, 0x5b, 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x66, 0xe0, 0x16, 0xee, 0x0b, 0x85,
 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x54, 0xb8, 0x62, 0xe6, 0xa0, 0x5c, 0xb9, 0xa8,
 0xb8, 0x54, 0xb8, 0x62, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e,
 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x6a, 0x54, 0xb8, 0x62, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e,
 0x14, 0xee, 0x19, 0xb8, 0x05, 0xbb, 0x82, 0xe1, 0x4d, 0xd4, 0x33, 0x73, 0x50, 0x2d, 0xdc, 0x17,
 0x0a, 0x77, 0x0c, 0xdc, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x73, 0x53, 0x17, 0x00, 0xb9, 0x70, 0x5c,
 0x29, 0xdc, 0x33, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0x17, 0x0a,
 0x77, 0x0c, 0xdc, 0x02, 0xdd, 0xcd, 0x45, 0xc2, 0x9d, 0xc3, 0x37, 0x00, 0xb7, 0x70, 0x5c, 0xd4,
 0xa9, 0x70, 0xc5, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70,
 0xa7, 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0x2a, 0x5c, 0x31, 0x70, 0x0b, 0x97, 0x05,
 0xc2, 0xa5, 0xc3, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05,
 0xcd, 0x4a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa9, 0x73, 0x53, 0x17, 0x00, 0xb9,
 0x70, 0x5c, 0x2a, 0x5c, 0xd4, 0x5c, 0x02, 0xdd, 0xcd, 0x45, 0xc2, 0xa5, 0xc3, 0x17, 0x00, 0xb9,
 0x73, 0x51, 0x70, 0xa7, 0x73, 0x53, 0x37, 0x35, 0x02, 0xcd, 0x57, 0x1a, 0x94, 0xe5, 0x4e, 0x69,
 0x4a, 0x32, 0x5c, 0x1a, 0x3a, 0x76, 0x67, 0x86, 0xa9, 0x82, 0xc4, 0xba, 0x72, 0xe2, 0xe0, 0xfa,
 0x61, 0x2f, 0x0a, 0x3b, 0x3d, 0xcd, 0x48, 0xb1, 0x74, 0xa8, 0xe2, 0xa8, 0xba, 0x55, 0xa3, 0xc6,
 0x2f, 0xdb, 0x4f, 0xc2, 0x80, 0xea, 0x5c, 0xfa, 0x8e, 0x7d, 0x4b, 0x19, 0x8e, 0x5b, 0x88, 0xc2,
 0xb7, 0x28, 0x71, 0xab, 0x4b, 0xf1, 0x92, 0xe9, 0x5e, 0xba, 0x38, 0xfe, 0x7d, 0x40, 0xb1, 0xcf,
 0xa8, 0xe7, 0xd4, 0xaf, 0xcf, 0xa8, 0xe7, 0xd4, 0x0b, 0x1c, 0xfa, 0x8e, 0x7d, 0x4a, 0xfc, 0xfa,
 0x8e, 0x70, 0x2c, 0xf3, 0xea, 0x63, 0x9f, 0x52, 0xbf, 0x3e, 0xa7, 0x21, 0x97, 0x65, 0xd5, 0xf1,
 0x6d, 0x4a, 0x5c, 0x69, 0xd1, 0xfc, 0x66, 0xba, 0x5f, 0xac, 0x04, 0xb9, 0x4e, 0x12, 0x78, 0xec,
 0x42, 0x8f, 0x4a, 0xa5, 0x1e, 0x99, 0xcb, 0xc0, 0xbc, 0x1e, 0xb9, 0xdc, 0x21, 0x28, 0xc2, 0x11,
 0x84, 0x12, 0x51, 0x8a, 0xe0, 0x92, 0xef, 0x22, 0x86, 0x16, 0x14, 0xb0, 0xd4, 0x55, 0x2a, 0x31,
 0xe5, 0x8a, 0xf7, 0xf5, 0x24, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x15, 0x2e, 0x18, 0xb8, 0x05,
 0xcb, 0x9a, 0x8b, 0x85, 0x4b, 0x86, 0x2e, 0x6a, 0x05, 0xcb, 0x9a, 0x8b, 0x9a, 0x94, 0xee, 0x6a,
 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa8, 0xb8, 0x53,
 0xb9, 0xa9, 0x9b, 0x80, 0x5b, 0xb8, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x52, 0xe6, 0xa2, 0xe1,
 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14,
 0xee, 0x6a, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85,
 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x15, 0x73, 0x8c, 0x0d, 0x7c, 0x6e,
 0x2a, 0x35, 0x69, 0x4e, 0x9a, 0x4a, 0x0a, 0x3e, 0x99, 0xbf, 0x0b, 0xd3, 0x52, 0x97, 0x71, 0xb1,
 0x7f, 0xc6, 0xd0, 0xfd, 0x67, 0xd8, 0x72, 0xf7, 0x05, 0xc0, 0x38, 0x8e, 0xe3, 0x62, 0xff, 0x00,
 0x8d, 0xa1, 0xfa, 0xcf, 0xb0, 0x77, 0x17, 0x17, 0xfc, 0x6d, 0x0f, 0x6d, 0xf6, 0x1c, 0xbd, 0xc1,
 0x70, 0x0e, 0x23, 0xb8, 0xd8, 0xbf, 0xe3, 0x68, 0x7e, 0xb3, 0xec, 0x1d, 0xc5, 0xc5, 0xff, 0x00,
 0x1b, 0x43, 0xf5, 0x9f, 0x61, 0xcb, 0xdc, 0x17, 0x00, 0xe2, 0x3b, 0x8d, 0x8b, 0xfe, 0x36, 0x87,
 0xeb, 0x3e, 0xc1, 0xdc, 0x6c, 0x5f, 0xf1, 0xb4, 0x3f, 0x59, 0xf6, 0x1c, 0xbd, 0xc1, 0x70, 0x0e,
 0x23, 0xb8, 0xd8, 0xbf, 0xe3, 0x68, 0x7e, 0xb3, 0xec, 0x1d, 0xc6, 0xc5, 0xff, 0x00, 0x1b, 0x43,
 0xf5, 0x9f, 0x61, 0xcb, 0xdc, 0x17, 0x00, 0xe2, 0x3b, 0x8d, 0x8b, 0xfe, 0x36, 0x87, 0xeb, 0x3e,
 0xc1, 0xdc, 0x6c, 0x5f, 0xf1, 0xb4, 0x3d, 0xb7, 0xd8, 0x72, 0xf7, 0x05, 0xcd, 0x40, 0xa3, 0x96,
 0x65, 0xb8, 0x8c, 0x2e, 0x36, 0x15, 0xea, 0x54, 0xa4, 0xe3, 0x1e, 0x3c, 0x54, 0x5b, 0xe3, 0xd2,
 0xb8, 0x78, 0x0e, 0x6a, 0xe1, 0x52, 0xe1, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80,
 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72,
 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e,
 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb,
 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b,
 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x85, 0x3b,
 0xa2, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e,
 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xee,
 0x0b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe6, 0xa5, 0x3b,
 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb8, 0x53, 0xb8,
 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe6,
 0xa5, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8,
 0x53, 0xb8, 0x66, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14,
 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x9a,
 0x94, 0xee, 0x0b, 0xba, 0x81, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x0b,
 0x9a, 0x94, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82,
 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xd5, 0x41, 0x70, 0x0b, 0x97, 0x05,
 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x35,
 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0xa9, 0x8a, 0xc0, 0xe0, 0xf1, 0x0d, 0xb9, 0xd2, 0x51, 0x93,
 0xfb, 0xe8, 0xf4, 0x33, 0x17, 0x05, 0xc0, 0x28, 0x55, 0xc9, 0x23, 0xd7, 0x4b, 0x12, 0xd2, 0xf0,
 0x4a, 0x3c, 0x48, 0x25, 0x92, 0xe2, 0x7e, 0xf6, 0xb5, 0x27, 0xeb, 0xf1, 0xec, 0x39, 0x6b, 0x82,
 0xe0, 0x1c, 0x4c, 0x72, 0x5c, 0x4f, 0x7e, 0xb5, 0x15, 0xeb, 0x37, 0xd8, 0x4d, 0x4b, 0x24, 0x5c,
 0x7e, 0xdb, 0x89, 0x7e, 0xb4, 0x62, 0x72, 0x17, 0x35, 0x17, 0x00, 0x61, 0xb0, 0x18, 0x3c, 0x3b,
 0x52, 0x8d, 0x3e, 0x79, 0x7e, 0x34, 0xfa, 0x4b, 0x97, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02, 0xe5,
 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c,
 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51,
 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2,
 0x9d, 0xc1, 0x70, 0x0a, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77,
 0x35, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a,
 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52,
 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x35, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45,
 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c,
 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x2a, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb9, 0xa8, 0xb8,
 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x81, 0xd4, 0x02, 0xe5, 0xcd, 0x45,
 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02, 0xe5, 0xc1,
 0x70, 0xa7, 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70,
 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29,
 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x73, 0x51,
 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5,
 0xc1, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0x02,
 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b,
 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c,
 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c,
 0xd4, 0xa7, 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70,
 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9,
 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xcd, 0x45, 0xcd,
 0x40, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xcd, 0x45,
 0xc0, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1,
 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17,
 0x00, 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x73,
 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b,
 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xc1, 0x73,
 0x50, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xcd,
 0x45, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17,
 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2a, 0x5c, 0xd4, 0xc5, 0xc2, 0xa5,
 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0xc5, 0xc2, 0xa5,
 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2d, 0xdc, 0x33, 0x73, 0x52, 0x9d,
 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x4c, 0x5c,
 0x2a, 0x5c, 0x17, 0x00, 0xb9, 0x70, 0xc5, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a,
 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0xc5, 0xc2, 0xa5,
 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0xc5, 0xc2, 0xa5,
 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7,
 0x73, 0x51, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb7, 0x70, 0xcd, 0xcd,
 0x4a, 0x77, 0x05, 0xc0, 0x2d, 0xdc, 0x33, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x77, 0x35, 0x33,
 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x31, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xe5, 0xcd,
 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0xd4,
 0xc5, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x31, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1,
 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0xd4,
 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xdd, 0xc1, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x97, 0x35,
 0x31, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2d, 0xdc,
 0x33, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73,
 0x52, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0x31, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45,
 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x73, 0x53,
 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb7, 0x70, 0xcd,
 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x31, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70,
 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0x17, 0x35,
 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x73,
 0x51, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9,
 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xdd, 0xc3, 0x37, 0x35, 0x29, 0xdc, 0x17, 0x35, 0x02,
 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e,
 0x5c, 0xd4, 0xc5, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x0c, 0xdc, 0x29, 0xdc, 0x17, 0x00, 0xb9,
 0x73, 0x53, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x33, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5,
 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x45, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x97, 0x35,
 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb7, 0x70, 0x5c,
 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xa5, 0xc1, 0x70, 0xa7,
 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x0c, 0x5c, 0x2a, 0x5c,
 0x17, 0x00, 0xb9, 0x70, 0xc5, 0xcd, 0x4a, 0x97, 0x35, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x73, 0x52,
 0x9d, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xcd, 0x45, 0xc0, 0x2d, 0xdc, 0x33, 0x73, 0x52,
 0x9d, 0xcd, 0x45, 0xcd, 0x40, 0xb7, 0x70, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70,
 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc3, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77,
 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0xcd, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x77, 0x0c, 0xdc, 0xd4, 0xa7,
 0x70, 0x5c, 0x02, 0xe5, 0xc3, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0xcd, 0xc2, 0x9d,
 0xc1, 0x70, 0x0b, 0x77, 0x35, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0xd4, 0xa9,
 0x70, 0x5c, 0x02, 0xdd, 0xc3, 0x37, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x73, 0x53, 0x17, 0x0a,
 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0xcd, 0xcd, 0x4a,
 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9,
 0x70, 0x5c, 0x02, 0xdd, 0xc3, 0x37, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45, 0xcd,
 0x4a, 0x77, 0x35, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0xd4,
 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x45, 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0xc5,
 0xc2, 0xa5, 0xc1, 0x73, 0x50, 0x2d, 0xdc, 0x33, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc3, 0x17,
 0x0a, 0x97, 0x05, 0xcd, 0x40, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x4c,
 0xdc, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xcd, 0x4c, 0x5c, 0x2a, 0x5c, 0xd4, 0x5c, 0x02, 0xdd,
 0xc3, 0x37, 0x0a, 0x77, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0xcd, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2d,
 0xdc, 0xd4, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdd,
 0xc3, 0x37, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb7, 0x73, 0x53, 0x37, 0x0a, 0x77, 0x05, 0xc0, 0x2d,
 0xdc, 0xd4, 0x5c, 0x2a, 0x5c, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5,
 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x77, 0x35, 0x33, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b,
 0x77, 0x05, 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c,
 0xd4, 0x5c, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0xd4, 0x0b, 0x77,
 0x0c, 0xdc, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e,
 0x5c, 0xd4, 0xc5, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2, 0xa5, 0xc1, 0x70, 0x0b, 0x77,
 0x35, 0x33, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x77, 0x35, 0x33, 0x73, 0x52, 0x9d, 0xcd, 0x45,
 0xc0, 0x2d, 0xdc, 0x33, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc3, 0x17, 0x0a, 0x97, 0x05, 0xcd,
 0x40, 0xb7, 0x73, 0x51, 0x73, 0x52, 0xa5, 0xcd, 0x45, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x35,
 0x17, 0x35, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x73, 0x51, 0x73, 0x50, 0x2d, 0xdc, 0xd4, 0x5c, 0xd4,
 0xa9, 0x70, 0x5c, 0x02, 0x9d, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0xd4, 0x0b, 0x77, 0x05, 0xcd, 0x4a,
 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0xd4, 0xa9, 0x73, 0x51, 0x70, 0x0b, 0x77, 0x05, 0xcd,
 0x4a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x45,
 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0x2a, 0x5c, 0x17, 0x35, 0x02, 0xdd, 0xc1,
 0x73, 0x52, 0xa5, 0xc1, 0x73, 0x50, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17,
 0x35, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x73, 0x51, 0x73, 0x52, 0xa5, 0xcd, 0x45, 0xc0, 0x2d, 0xdc,
 0xd4, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1,
 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xcd, 0x45, 0xcd, 0x4a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17,
 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0xd4,
 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x35, 0x17, 0x35,
 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x73, 0x51, 0x70, 0xa9, 0x73, 0x51, 0x70, 0x0b, 0x77, 0x05, 0xcd,
 0x4a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0xd4, 0xa9, 0x70, 0x5c, 0x02, 0xdb, 0xa9, 0xa8,
 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa2, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a,
 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa2, 0xe6, 0xa5, 0x4b, 0x9a, 0x8b, 0x9a, 0x81,
 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa2, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb,
 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b,
 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x6a, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8,
 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa2, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x9a,
 0x95, 0x2e, 0x0b, 0x80, 0x5b, 0xb9, 0xa8, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe6, 0xa2, 0xe6,
 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x6a,
 0x54, 0xba, 0x2e, 0x01, 0x6e, 0xe0, 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x9a,
 0x94, 0xee, 0x19, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x9a, 0x8b, 0x80, 0x5b, 0xb8, 0x2e,
 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x6a, 0x54,
 0xb9, 0xa8, 0xb9, 0xa8, 0x16, 0xee, 0x6a, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5c, 0xb9, 0xa9, 0x8b,
 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b, 0xb9, 0xa8, 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82,
 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b, 0xb9, 0xa8,
 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a,
 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x9a, 0x81, 0x6e, 0xe6, 0xa2,
 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b, 0xb9, 0xa8,
 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x9a, 0x95, 0x2e, 0x6a, 0x2e, 0x01, 0x6e,
 0xe0, 0xb9, 0xa9, 0x52, 0xe0, 0xb8, 0x05, 0x3b, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82,
 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85,
 0x4b, 0x9a, 0x8b, 0x80, 0x5b, 0xb8, 0x2e, 0x14, 0xee, 0x6a, 0x66, 0xe0, 0x16, 0xee, 0x6a, 0x2e,
 0x15, 0x2e, 0x6a, 0x2e, 0x6a, 0x05, 0xbb, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe1,
 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x9a, 0x8b, 0x80, 0x5b, 0xb9, 0xa8, 0xb8,
 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb8, 0x2e, 0x01, 0x6e, 0xe0, 0xb9, 0xa9, 0x52,
 0xe6, 0xa2, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x86, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x54, 0xb9,
 0xa8, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x9a,
 0x8b, 0x80, 0x5b, 0xb8, 0x2e, 0x14, 0xee, 0x19, 0xb9, 0xa8, 0x16, 0xee, 0x0b, 0x9a, 0x94, 0xee,
 0x19, 0xb8, 0x05, 0xbb, 0x82, 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x82, 0xe6, 0xa5, 0x4b, 0x82,
 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x85, 0x4b, 0x82, 0xe0, 0x16,
 0xee, 0x0b, 0x9a, 0x95, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8,
 0x2e, 0x15, 0x2e, 0x6a, 0x2e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb9, 0xa8, 0xb8, 0x05, 0xbb, 0x82,
 0xe1, 0x52, 0xe0, 0xb8, 0x05, 0xbb, 0x9a, 0x8b, 0x85, 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x0b, 0x9a,
 0x95, 0x2e, 0x07, 0x53, 0x50, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c,
 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x73, 0x51, 0x73, 0x52, 0xa5, 0xc1, 0x70, 0x0b, 0x77, 0x05, 0xc2,
 0x9d, 0xcd, 0x4c, 0xdc, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x73, 0x51, 0x70, 0x0b, 0x77, 0x35, 0x17,
 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a,
 0x5c, 0xd4, 0x5c, 0xd4, 0x0b, 0x77, 0x35, 0x17, 0x0a, 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x35,
 0x2a, 0x5c, 0x17, 0x35, 0x02, 0xdd, 0xc1, 0x70, 0xa9, 0x73, 0x53, 0x17, 0x35, 0x02, 0xe5, 0xc1,
 0x70, 0xa7, 0x70, 0xcd, 0xc0, 0x2d, 0xdc, 0xd4, 0x5c, 0x2a, 0x5c, 0x31, 0x70, 0x0b, 0x97, 0x35,
 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x97, 0x35, 0x17, 0x00, 0xb7, 0x70, 0x5c,
 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0x2a, 0x5c, 0x31, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a,
 0x97, 0x05, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x97, 0x35, 0x17, 0x35, 0x02, 0xdd, 0xc1, 0x70, 0xa7,
 0x70, 0xcd, 0xcd, 0x40, 0xb7, 0x73, 0x51, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9,
 0x73, 0x53, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x70, 0xa9, 0x70, 0x5c, 0x02, 0xdd, 0xc1, 0x70, 0xa9,
 0x70, 0x3a, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x0b, 0x80, 0x5b, 0xb8, 0x2e, 0x15, 0x2e, 0x74,
 0x8b, 0x80, 0x5b, 0xb9, 0xa8, 0xb8, 0x54, 0xb8, 0x2e, 0x6a, 0x05, 0xbb, 0x82, 0xe1, 0x4e, 0xe6,
 0xa6, 0x6e, 0x01, 0x6e, 0xe0, 0xb8, 0x54, 0xb9, 0xa9, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x15, 0x2e,
 0x6a, 0x62, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x95, 0x2e, 0x6a, 0x62, 0xe6, 0xa0, 0x54, 0xb9, 0xa8,
 0xb8, 0x53, 0xb9, 0xa8, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1,
 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94,
 0xee, 0x6a, 0x66, 0xe0, 0x16, 0xee, 0x0b, 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x14,
 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a, 0x8b, 0x85,
 0x4b, 0x82, 0xe0, 0x16, 0xee, 0x6a, 0x2e, 0x6a, 0x54, 0xb8, 0x62, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e,
 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe6,
 0xa5, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x0b, 0x9a, 0x94, 0xee, 0x6a, 0x66, 0xe0, 0x16, 0xee, 0x0b,
 0x9a, 0x94, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe6, 0xa2, 0xe6, 0xa5, 0x4b, 0x9a, 0x98, 0xb9, 0xa8,
 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01,
 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x52, 0xe6, 0xa6, 0x2e, 0x6a,
 0x05, 0xcb, 0x82, 0xe6, 0xa5, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x6a, 0x53, 0xb8, 0x2e,
 0x01, 0x71, 0x54, 0x17, 0x35, 0x2a, 0x5c, 0x17, 0x00, 0xb7, 0x70, 0x5c, 0xd4, 0xa7, 0x73, 0x51,
 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d,
 0xc3, 0x37, 0x35, 0x02, 0xdd, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a,
 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa9,
 0x70, 0xc5, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2,
 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x35, 0x29, 0xdc, 0xd4, 0xcd, 0xcd, 0x40, 0xb7, 0x73,
 0x51, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05,
 0xc2, 0xa5, 0xc3, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73,
 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a,
 0x77, 0x35, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2,
 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29,
 0xdc, 0x17, 0x00, 0xb9, 0x73, 0x51, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0xa5,
 0xcd, 0x4c, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xcd, 0x4a,
 0x97, 0x0c, 0x5c, 0x02, 0xe5, 0xcd, 0x45, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0xd4, 0x5c,
 0xd4, 0xa7, 0x70, 0xcd, 0xc0, 0x2d, 0xdc, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a,
 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x33, 0x73, 0x50, 0x2d, 0xdc, 0x17, 0x0a,
 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x73, 0x51, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17,
 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70,
 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a,
 0x77, 0x35, 0x33, 0x70, 0x0a, 0x77, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x70, 0x5c,
 0x29, 0xdc, 0xd4, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17,
 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x35, 0x02, 0xe5, 0xcd, 0x45,
 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x70, 0x5d,
 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xcd, 0x40, 0xb9, 0x70,
 0x5c, 0xd4, 0xa7, 0x73, 0x51, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c,
 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xc1,
 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2,
 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x73, 0xa0, 0x5c,
 0xd4, 0xa9, 0x70, 0xc5, 0xc0, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c,
 0x29, 0xdc, 0xd4, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xcd,
 0x4a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05,
 0xc2, 0x9d, 0xc1, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0xa5, 0xcd, 0x4c, 0x5c, 0xd4, 0x0b, 0x97, 0x05,
 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0x5c,
 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7,
 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0xa5, 0xc3, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7,
 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e, 0x5c, 0x17, 0x0a, 0x77,
 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17,
 0x00, 0xb9, 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xc1, 0x70,
 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00,
 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0x5c, 0xd4, 0x0b,
 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x35, 0x02,
 0xe5, 0xc1, 0x73, 0x52, 0x9d, 0xcd, 0x45, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x35,
 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x73, 0x51, 0x70, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xcd, 0x45, 0xc0,
 0x2e, 0x5c, 0x17, 0x35, 0x29, 0xdc, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xb9,
 0x70, 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xc2, 0x9d, 0xc1, 0x73, 0x50, 0x2e,
 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x33, 0x73, 0x50, 0x2d, 0xdc, 0x17, 0x0a, 0x77, 0x05, 0xc0, 0x2e,
 0x5c, 0x17, 0x0a, 0x77, 0x35, 0x17, 0x00, 0xb9, 0x70, 0x5c, 0x29, 0xdd, 0x17, 0x00, 0xb9, 0x70,
 0x5c, 0xd4, 0xa7, 0x70, 0x5c, 0x02, 0xe5, 0xc1, 0x70, 0xa7, 0x70, 0xcd, 0xc0, 0x2d, 0xdc, 0x17,
 0x0a, 0x77, 0x05, 0xc0, 0x2e, 0x5c, 0xd4, 0x5c, 0x29, 0xdc, 0x17, 0x00, 0xa9, 0x70, 0x5c, 0xd4,
 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x35, 0x17, 0x0a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70, 0x5c,
 0xd4, 0xa7, 0x70, 0x5c, 0xd4, 0x0b, 0x97, 0x05, 0xcd, 0x4a, 0x77, 0x05, 0xcd, 0x40, 0xb9, 0x70,
 0x2a, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb9, 0xa8, 0xb9, 0xa8, 0x17,
 0x2e, 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8,
 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x9a,
 0x8b, 0x9a, 0x94, 0xee, 0x6a, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17,
 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x01, 0x72,
 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e,
 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb,
 0x9a, 0x8b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05,
 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e,
 0x0b, 0x85, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb9, 0xa8,
 0xb9, 0xa9, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x72,
 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0, 0xb8,
 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x0b, 0x9a,
 0x94, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe6, 0xa2, 0xe1,
 0x4e, 0xe6, 0xa2, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x82,
 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72, 0xe0,
 0xb8, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x6a,
 0x2e, 0x6a, 0x53, 0xb8, 0x2e, 0x6a, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe6, 0xa2, 0xe0, 0x17, 0x2e,
 0x0b, 0x9a, 0x94, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe6,
 0xa2, 0xe6, 0xa5, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb9, 0xa8, 0xb8, 0x53, 0xb8, 0x2e, 0x01, 0x72,
 0xe0, 0xb9, 0xa9, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x82, 0xe1, 0x4e, 0xe0, 0xb8, 0x05, 0xcb, 0x9a,
 0x8b, 0x85, 0x3b, 0x82, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe6,
 0xa2, 0xe6, 0xa5, 0x3b, 0x9a, 0x8b, 0x80, 0x5c, 0xb9, 0xa8, 0xb9, 0xa9, 0x4e, 0xe6, 0xa2, 0xe0,
 0x17, 0x2e, 0x0b, 0x85, 0x3b, 0x82, 0xe6, 0xa0, 0x5c, 0xb8, 0x2e, 0x14, 0xee, 0x0b, 0x9a, 0x81,
 0x72, 0xe6, 0xa2, 0xe1, 0x4e, 0xe0, 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x6a, 0x53, 0xb8, 0x2e,
 0x6a, 0x05, 0xbb, 0x86, 0x6e, 0x14, 0xee, 0x0b, 0x9a, 0x81, 0x72, 0xe0, 0xb8, 0x53, 0xb9, 0xa8,
 0xb9, 0xa8, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x6a, 0x2e, 0x01, 0x72, 0xe0, 0xb9, 0xa9, 0x4e,
 0xe6, 0xa2, 0xe0, 0x17, 0x2e, 0x6a, 0x2e, 0x14, 0xee, 0x0b, 0x80, 0x5c, 0xb8, 0x2e, 0x14, 0xee,
 0x6a, 0x2e, 0x01, 0x53, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf,
 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68,
 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8e,
 0x76, 0x68, 0x00, 0xdf, 0x9d, 0x8b, 0x8c, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbd,
 0xc6, 0x39, 0xd9, 0xa0, 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0, 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0,
 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0, 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0, 0x03, 0x7b, 0x8c, 0x5c,
 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9,
 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80,
 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7,
 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9, 0xd8, 0xe7, 0x66, 0x80, 0x0d, 0xf9,
 0xd8, 0xb8, 0xcd, 0x00, 0x1b, 0xf3, 0xb1, 0xce, 0xcd, 0x00, 0x1b, 0xf3, 0xb1, 0xce, 0xcd, 0x00,
 0x1b, 0xf3, 0xb1, 0xce, 0xcd, 0x00, 0x1b, 0xdc, 0x63, 0x9d, 0x9a, 0x00, 0x37, 0xe7, 0x62, 0xe3,
 0x34, 0x00, 0x6f, 0xce, 0xc5, 0xc6, 0x68, 0x00, 0xdf, 0x9d, 0x8e, 0x76, 0x68, 0x00, 0xdf, 0x9d,
 0x8b, 0x8c, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbd, 0xc6, 0x39, 0xd9, 0xa0, 0x03,
 0x7e, 0x76, 0x39, 0xd9, 0xa0, 0x03, 0x7e, 0x76, 0x2e, 0x33, 0x40, 0x06, 0xfc, 0xec, 0x73, 0xb3,
 0x40, 0x06, 0xf7, 0x18, 0xe7, 0x66, 0x80, 0x0d, 0xee, 0x31, 0xce, 0xcd, 0x00, 0x1b, 0xf3, 0xb1,
 0x71, 0x9a, 0x00, 0x37, 0xb8, 0xc7, 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f,
 0xce, 0xc7, 0x3b, 0x34, 0x00, 0x6f, 0xce, 0xc5, 0xc6, 0x68, 0x00, 0xdf, 0x9d, 0x8b, 0x8c, 0xd0,
 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c,
 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbf, 0x3b, 0x1c, 0xec, 0xd0, 0x01, 0xbd,
 0xc6, 0x39, 0xd9, 0xa0, 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0, 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0,
 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0, 0x03, 0x7e, 0x76, 0x39, 0xd9, 0xa0, 0x03, 0x7e, 0x76, 0x2e,
 0x33, 0x40, 0x06, 0xfc, 0xec, 0x5c, 0x66, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37,
 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0xc7, 0xd5, 0xa7, 0x74,
 0x31, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b,
 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f,
 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33,
 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90,
 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37,
 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33,
 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07,
 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37,
 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07,
 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07,
 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47,
 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1,
 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef,
 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84,
 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1,
 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69,
 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84,
 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1,
 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23,
 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9,
 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63,
 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23,
 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0,
 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63,
 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0,
 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0,
 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74,
 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f,
 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e,
 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8,
 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f,
 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56,
 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8,
 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b,
 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72,
 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a,
 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66,
 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72,
 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb,
 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66,
 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd,
 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb,
 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7,
 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35,
 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02,
 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c,
 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35,
 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75,
 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c,
 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75,
 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77,
 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79,
 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16,
 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7,
 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b,
 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16,
 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d,
 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b,
 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f,
 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33,
 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90,
 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37,
 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33,
 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07,
 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37,
 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07,
 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07,
 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47,
 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1,
 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef,
 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84,
 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1,
 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69,
 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84,
 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1,
 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23,
 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9,
 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63,
 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23,
 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0,
 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63,
 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0,
 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0,
 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74,
 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f,
 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e,
 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8,
 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f,
 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56,
 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8,
 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b,
 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72,
 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a,
 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66,
 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72,
 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb,
 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7, 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66,
 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd,
 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02, 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb,
 0x07, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x07, 0x56, 0x9d, 0xd0, 0x75, 0xb1, 0xf7,
 0x47, 0x9a, 0x90, 0x2e, 0xf7, 0x23, 0x35, 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x77, 0x23, 0x35,
 0xf1, 0x66, 0x37, 0xc8, 0x4b, 0xb0, 0x75, 0x69, 0xdd, 0x07, 0x5b, 0x1f, 0x74, 0x79, 0xa9, 0x02,
 0xef, 0x72, 0x33, 0x5f, 0x16, 0x63, 0x7c, 0x84, 0xbb, 0x0c, 0xf7, 0x23, 0x36, 0xf1, 0x5e, 0x37,
 0xdc, 0xf2, 0xec, 0x1d, 0x5a, 0x77, 0x41, 0xd6, 0xc7, 0xdd, 0x1e, 0x6a, 0x20, 0xbd, 0xdc, 0x7c,
 0xdf, 0xc5, 0x58, 0xef, 0x73, 0xcf, 0xb0, 0xcf, 0x71, 0xb3, 0x8f, 0x15, 0x63, 0xbd, 0xcf, 0x3e,
 0xc1, 0xd5, 0xa7, 0x74, 0x27, 0xad, 0x8f, 0xba, 0x3c, 0xdf, 0xff, 0xd9};

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/CMakeLists.txt
================
check_include_files(linux/videodev2.h HAVE_LINUX_VIDEODEV2_H)

MJPG_STREAMER_PLUGIN_OPTION(input_uvc "Video 4 Linux input plugin"
                            ONLYIF HAVE_LINUX_VIDEODEV2_H)

if (PLUGIN_INPUT_UVC)
    
    add_definitions(-DLINUX -D_GNU_SOURCE)
    
    find_library(V4L2_LIB v4l2)
    find_library(JPEG_LIB jpeg)
    
    if (V4L2_LIB)
        add_definitions(-DUSE_LIBV4L2)
    endif (V4L2_LIB)
    
    if (NOT JPEG_LIB)
        add_definitions(-DNO_LIBJPEG)
    endif (NOT JPEG_LIB)

    MJPG_STREAMER_PLUGIN_COMPILE(input_uvc dynctrl.c
                                           input_uvc.c
                                           jpeg_utils.c
                                           v4l2uvc.c)

    if (V4L2_LIB)
        target_link_libraries(input_uvc ${V4L2_LIB})
    endif (V4L2_LIB)

    if (JPEG_LIB)
        target_link_libraries(input_uvc ${JPEG_LIB})
    endif (JPEG_LIB)

endif()

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/dynctrl.c
================
/*******************************************************************************#
#           guvcview              http://guvcview.berlios.de                    #
#                                                                               #
#           Paulo Assis <pj.assis@gmail.com>                                    #
#                                                                               #
# This program is free software; you can redistribute it and/or modify          #
# it under the terms of the GNU General Public License as published by          #
# the Free Software Foundation; either version 2 of the License, or             #
# (at your option) any later version.                                           #
#                                                                               #
# This program is distributed in the hope that it will be useful,               #
# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
# GNU General Public License for more details.                                  #
#                                                                               #
# You should have received a copy of the GNU General Public License             #
# along with this program; if not, write to the Free Software                   #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
#                                                                               #
********************************************************************************/


#include <sys/ioctl.h>
#include <sys/time.h>
#include <getopt.h>
#include <errno.h>
#include <pthread.h>
#include <stdio.h>

#include <linux/videodev2.h>

#include "../../utils.h"
#include "dynctrl.h"

/* some Logitech webcams have pan/tilt/focus controls */
#define LENGTH_OF_XU_CTR (6)
#define LENGTH_OF_XU_MAP (10)

static struct uvc_xu_control_info xu_ctrls[] = {
    {
        .entity   = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector = XU_MOTORCONTROL_PANTILT_RELATIVE,
        .index    = 0,
        .size     = 4,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_DEF | UVC_CONTROL_AUTO_UPDATE
    },
    {
        .entity   = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector = XU_MOTORCONTROL_PANTILT_RESET,
        .index    = 1,
        .size     = 1,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | UVC_CONTROL_GET_DEF | UVC_CONTROL_AUTO_UPDATE
    },
    {
        .entity   = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector = XU_MOTORCONTROL_FOCUS,
        .index    = 2,
        .size     = 6,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_DEF | UVC_CONTROL_AUTO_UPDATE
    },
    {
        .entity   = UVC_GUID_LOGITECH_VIDEO_PIPE,
        .selector = XU_COLOR_PROCESSING_DISABLE,
        .index    = 4,
        .size     = 1,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | UVC_CONTROL_GET_DEF | UVC_CONTROL_AUTO_UPDATE
    },
    {
        .entity   = UVC_GUID_LOGITECH_VIDEO_PIPE,
        .selector = XU_RAW_DATA_BITS_PER_PIXEL,
        .index    = 7,
        .size     = 1,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | UVC_CONTROL_GET_DEF | UVC_CONTROL_AUTO_UPDATE
    },
    {
        .entity   = UVC_GUID_LOGITECH_USER_HW_CONTROL,
        .selector = XU_HW_CONTROL_LED1,
        .index    = 0,
        .size     = 3,
        .flags    = UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR | UVC_CONTROL_GET_MIN | UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | UVC_CONTROL_GET_DEF | UVC_CONTROL_AUTO_UPDATE
    },

};

/* mapping for Pan/Tilt/Focus */
static struct uvc_xu_control_mapping xu_mappings[] = {
    {
        .id        = V4L2_CID_PAN_RELATIVE,
        .name      = "Pan (relative)",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_PANTILT_RELATIVE,
        .size      = 16,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_SIGNED
    },
    {
        .id        = V4L2_CID_TILT_RELATIVE,
        .name      = "Tilt (relative)",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_PANTILT_RELATIVE,
        .size      = 16,
        .offset    = 16,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_SIGNED
    },
    {
        .id        = V4L2_CID_PAN_RESET,
        .name      = "Pan Reset",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_PANTILT_RESET,
        .size      = 1,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_BUTTON,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },
    {
        .id        = V4L2_CID_TILT_RESET,
        .name      = "Tilt Reset",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_PANTILT_RESET,
        .size      = 1,
        .offset    = 1,
        .v4l2_type = V4L2_CTRL_TYPE_BUTTON,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },
    {
        .id        = V4L2_CID_PANTILT_RESET_LOGITECH,
        .name      = "Pan/tilt Reset",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_PANTILT_RESET,
        .size      = 8,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_BUTTON,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },
    {
        .id        = V4L2_CID_FOCUS_LOGITECH,
        .name      = "Focus (absolute)",
        .entity    = UVC_GUID_LOGITECH_MOTOR_CONTROL,
        .selector  = XU_MOTORCONTROL_FOCUS,
        .size      = 8,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },
    {
        .id        = V4L2_CID_LED1_MODE_LOGITECH,
        .name      = "LED1 Mode",
        .entity    = UVC_GUID_LOGITECH_USER_HW_CONTROL,
        .selector  = XU_HW_CONTROL_LED1,
        .size      = 8,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },
    {
        .id        = V4L2_CID_LED1_FREQUENCY_LOGITECH,
        .name      = "LED1 Frequency",
        .entity    = UVC_GUID_LOGITECH_USER_HW_CONTROL,
        .selector  = XU_HW_CONTROL_LED1,
        .size      = 8,
        .offset    = 16,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },
    {
        .id        = V4L2_CID_DISABLE_PROCESSING_LOGITECH,
        .name      = "Disable video processing",
        .entity    = UVC_GUID_LOGITECH_VIDEO_PIPE,
        .selector  = XU_COLOR_PROCESSING_DISABLE,
        .size      = 8,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_BOOLEAN,
        .data_type = UVC_CTRL_DATA_TYPE_BOOLEAN
    },
    {
        .id        = V4L2_CID_RAW_BITS_PER_PIXEL_LOGITECH,
        .name      = "Raw bits per pixel",
        .entity    = UVC_GUID_LOGITECH_VIDEO_PIPE,
        .selector  = XU_RAW_DATA_BITS_PER_PIXEL,
        .size      = 8,
        .offset    = 0,
        .v4l2_type = V4L2_CTRL_TYPE_INTEGER,
        .data_type = UVC_CTRL_DATA_TYPE_UNSIGNED
    },

};

int initDynCtrls(int fd)
{
    int i = 0;
    int err = 0;
    /* try to add all controls listed above */
    for(i = 0; i < LENGTH_OF_XU_CTR; i++) {
        if((err = xioctl(fd, UVCIOC_CTRL_ADD, &xu_ctrls[i])) < 0) {
            if(errno == EEXIST)
                fprintf(stderr,"Control exists\n");
            else if (errno != 0)
                fprintf(stderr, "UVCIOC_CTRL_ADD - Error at %s: %s (%d)\n", xu_mappings[i].name, strerror(errno), errno);
        }
    }

    /* after adding the controls, add the mapping now */
    for(i = 0; i < LENGTH_OF_XU_MAP; i++) {
        if((err = xioctl(fd, UVCIOC_CTRL_MAP, &xu_mappings[i])) < 0) {
            if(errno == EEXIST)
                fprintf(stderr,"Mapping exists\n");
            else if (errno != 0)
                fprintf(stderr, "UVCIOC_CTRL_MAP - Error at %s: %s (%d)\n", xu_mappings[i].name, strerror(errno), errno);
        }
    }
    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/dynctrl.h
================
/*******************************************************************************#
#           guvcview              http://guvcview.berlios.de                    #
#                                                                               #
#           Paulo Assis <pj.assis@gmail.com>                                    #
#                                                                               #
# This program is free software; you can redistribute it and/or modify          #
# it under the terms of the GNU General Public License as published by          #
# the Free Software Foundation; either version 2 of the License, or             #
# (at your option) any later version.                                           #
#                                                                               #
# This program is distributed in the hope that it will be useful,               #
# but WITHOUT ANY WARRANTY; without even the implied warranty of                #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 #
# GNU General Public License for more details.                                  #
#                                                                               #
# You should have received a copy of the GNU General Public License             #
# along with this program; if not, write to the Free Software                   #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA     #
#                                                                               #
********************************************************************************/

#ifndef V4L2_DYNA_CTRLS_H
#define V4L2_DYNA_CTRLS_H

#include <linux/videodev2.h>
#include "v4l2uvc.h"
/*
 * Dynamic controls
 */

#define UVC_CTRL_DATA_TYPE_RAW      0
#define UVC_CTRL_DATA_TYPE_SIGNED   1
#define UVC_CTRL_DATA_TYPE_UNSIGNED 2
#define UVC_CTRL_DATA_TYPE_BOOLEAN  3
#define UVC_CTRL_DATA_TYPE_ENUM     4
#define UVC_CTRL_DATA_TYPE_BITMASK  5

#define V4L2_CID_BASE_EXTCTR                0x0A046D01
#define V4L2_CID_BASE_LOGITECH              V4L2_CID_BASE_EXTCTR
//#define V4L2_CID_PAN_RELATIVE_LOGITECH        V4L2_CID_BASE_LOGITECH
//#define V4L2_CID_TILT_RELATIVE_LOGITECH       V4L2_CID_BASE_LOGITECH+1
#define V4L2_CID_PANTILT_RESET_LOGITECH         V4L2_CID_BASE_LOGITECH+2

/*this should realy be replaced by V4L2_CID_FOCUS_ABSOLUTE in libwebcam*/
#define V4L2_CID_FOCUS_LOGITECH             V4L2_CID_BASE_LOGITECH+3
#define V4L2_CID_LED1_MODE_LOGITECH         V4L2_CID_BASE_LOGITECH+4
#define V4L2_CID_LED1_FREQUENCY_LOGITECH        V4L2_CID_BASE_LOGITECH+5
#define V4L2_CID_DISABLE_PROCESSING_LOGITECH        V4L2_CID_BASE_LOGITECH+0x70
#define V4L2_CID_RAW_BITS_PER_PIXEL_LOGITECH        V4L2_CID_BASE_LOGITECH+0x71
#define V4L2_CID_LAST_EXTCTR                V4L2_CID_RAW_BITS_PER_PIXEL_LOGITECH

#define UVC_GUID_LOGITECH_VIDEO_PIPE        {0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x50}
#define UVC_GUID_LOGITECH_MOTOR_CONTROL     {0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x56}
#define UVC_GUID_LOGITECH_USER_HW_CONTROL   {0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x1f}

#define XU_HW_CONTROL_LED1          1
#define XU_MOTORCONTROL_PANTILT_RELATIVE    1
#define XU_MOTORCONTROL_PANTILT_RESET       2
#define XU_MOTORCONTROL_FOCUS           3
#define XU_COLOR_PROCESSING_DISABLE     5
#define XU_RAW_DATA_BITS_PER_PIXEL      8

#define UVC_CONTROL_SET_CUR (1 << 0)
#define UVC_CONTROL_GET_CUR (1 << 1)
#define UVC_CONTROL_GET_MIN (1 << 2)
#define UVC_CONTROL_GET_MAX (1 << 3)
#define UVC_CONTROL_GET_RES (1 << 4)
#define UVC_CONTROL_GET_DEF (1 << 5)
/* Control should be saved at suspend and restored at resume. */
#define UVC_CONTROL_RESTORE (1 << 6)
/* Control can be updated by the camera. */
#define UVC_CONTROL_AUTO_UPDATE (1 << 7)

#define UVC_CONTROL_GET_RANGE   (UVC_CONTROL_GET_CUR | UVC_CONTROL_GET_MIN | \
                                 UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | \
                                 UVC_CONTROL_GET_DEF)

struct uvc_xu_control_info {
    __u8 entity[16];
    __u8 index;
    __u8 selector;
    __u16 size;
    __u32 flags;
};

struct uvc_xu_control_mapping {
    __u32 id;
    __u8 name[32];
    __u8 entity[16];
    __u8 selector;

    __u8 size;
    __u8 offset;
    enum v4l2_ctrl_type v4l2_type;
    __u32 data_type;
};

struct uvc_xu_control {
    __u8 unit;
    __u8 selector;
    __u16 size;
    __u8 *data;
};

#define UVCIOC_CTRL_ADD     _IOW('U', 1, struct uvc_xu_control_info)
#define UVCIOC_CTRL_MAP     _IOWR('U', 2, struct uvc_xu_control_mapping)
#define UVCIOC_CTRL_GET     _IOWR('U', 3, struct uvc_xu_control)
#define UVCIOC_CTRL_SET     _IOW('U', 4, struct uvc_xu_control)

int initDynCtrls(int fd);

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/huffman.h
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

const static unsigned char dht_data[] = {
    0xff, 0xc4, 0x01, 0xa2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
    0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x01, 0x00, 0x03,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05,
    0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01, 0x02, 0x03, 0x00, 0x04,
    0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22,
    0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15,
    0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17,
    0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95,
    0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
    0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2,
    0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5,
    0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
    0xfa, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05,
    0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
    0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22,
    0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33,
    0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25,
    0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94,
    0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
    0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
    0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
};

#if 0
static unsigned char dht_data[] = {
    0xff, 0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
    0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x10, 0x00, 0x02,
    0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00,
    0x01, 0x7d, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11,
    0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71,
    0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42,
    0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09,
    0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26,
    0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77,
    0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92,
    0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a,
    0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
    0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,
    0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4,
    0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,
    0xf7, 0xf8, 0xf9, 0xfa, 0xff, 0xc4, 0x00, 0x1f,
    0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
    0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0xff, 0xc4, 0x00,
    0xb5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04,
    0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01,
    0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06,
    0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14,
    0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33,
    0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25,
    0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28,
    0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46,
    0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94,
    0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
    0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
    0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
    0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
};

#define JPG_HUFFMAN_TABLE_LENGTH 0x1A0

const unsigned char JPEGHuffmanTable[JPG_HUFFMAN_TABLE_LENGTH]
= {
    0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0A, 0x0B, 0x01, 0x00, 0x03,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10,
    0x00, 0x02, 0x01, 0x03, 0x03,
    0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D,
    0x01, 0x02, 0x03, 0x00, 0x04,
    0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
    0x22, 0x71, 0x14, 0x32, 0x81,
    0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0,
    0x24, 0x33, 0x62, 0x72, 0x82,
    0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
    0x29, 0x2A, 0x34, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
    0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
    0x6A, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
    0x8A, 0x92, 0x93, 0x94, 0x95,
    0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
    0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5,
    0xC6, 0xC7, 0xC8, 0xC9, 0xCA,
    0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
    0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
    0xF9, 0xFA, 0x11, 0x00, 0x02,
    0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00,
    0x01, 0x02, 0x77, 0x00, 0x01,
    0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51,
    0x07, 0x61, 0x71, 0x13, 0x22,
    0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23,
    0x33, 0x52, 0xF0, 0x15, 0x62,
    0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18,
    0x19, 0x1A, 0x26, 0x27, 0x28,
    0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
    0x46, 0x47, 0x48, 0x49, 0x4A,
    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65,
    0x66, 0x67, 0x68, 0x69, 0x6A,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84,
    0x85, 0x86, 0x87, 0x88, 0x89,
    0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2,
    0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9,
    0xBA, 0xC2, 0xC3, 0xC4, 0xC5,
    0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xE2, 0xE3,
    0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5,
    0xF6, 0xF7, 0xF8, 0xF9, 0xFA
};
#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/input_uvc.c
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <syslog.h>

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "../../utils.h"
#include "v4l2uvc.h" // this header will includes the ../../mjpg_streamer.h

#ifndef NO_LIBJPEG
    #include "jpeg_utils.h"
    #include "huffman.h"
#endif

#include "dynctrl.h"

//#include "uvcvideo.h"

#define INPUT_PLUGIN_NAME "UVC webcam grabber"

static const struct {
    const char *string;
    const v4l2_std_id vstd;
} norms[] = {
    { "UNKNOWN", V4L2_STD_UNKNOWN },
    { "PAL", V4L2_STD_PAL },
    { "NTSC", V4L2_STD_NTSC },
    { "SECAM", V4L2_STD_SECAM }
};

/* private functions and variables to this plugin */
static globals *pglobal;
static unsigned int minimum_size = 0;
static int dynctrls = 1;
static unsigned int every = 1;
static int wantTimestamp = 0;
static struct timeval timestamp;
static int softfps = -1;
static unsigned int timeout = 5;
static unsigned int dv_timings = 0;

static const struct {
  const char * k;
  const int v;
} exposures[] = {
  { "auto", V4L2_EXPOSURE_AUTO },
  { "shutter-priority", V4L2_EXPOSURE_SHUTTER_PRIORITY },
  { "aperature-priority", V4L2_EXPOSURE_APERTURE_PRIORITY }
};

static const struct {
  const char * k;
  const int v;
} power_line[] = {
  { "disabled", V4L2_CID_POWER_LINE_FREQUENCY_DISABLED },
  { "50hz", V4L2_CID_POWER_LINE_FREQUENCY_50HZ },
  { "60hz", V4L2_CID_POWER_LINE_FREQUENCY_60HZ },
  { "auto", V4L2_CID_POWER_LINE_FREQUENCY_AUTO }
};

void *cam_thread(void *);
void cam_cleanup(void *);
void help(void);
int input_cmd(int plugin, unsigned int control, unsigned int group, int value, char *value_string);

const char *get_name_by_tvnorm(v4l2_std_id vstd) {
	int i;
	for (i=0;i<sizeof(norms)/sizeof(norms[0]);i++) {
		if (vstd == norms[i].vstd) {
			return norms[i].string;
		}
	}
	return norms[0].string;
}

static context_settings * init_settings() {
    context_settings *settings;
    
    settings = calloc(1, sizeof(context_settings));
    if (settings == NULL) {
        IPRINT("error allocating context");
        exit(EXIT_FAILURE);
    }
    
    settings->quality = 80;
    return settings;
}


/*** plugin interface functions ***/
/******************************************************************************
Description.: This function initializes the plugin. It parses the commandline-
              parameter and stores the default and parsed values in the
              appropriate variables.
Input Value.: param contains among others the command-line string
Return Value: 0 if everything is fine
              1 if "--help" was triggered, in this case the calling programm
              should stop running and leave.
******************************************************************************/
int input_init(input_parameter *param, int id)
{
    char *dev = "/dev/video0", *s;
    int width = 640, height = 480, fps = -1, format = V4L2_PIX_FMT_MJPEG, i;
    v4l2_std_id tvnorm = V4L2_STD_UNKNOWN;
    context *pctx;
    context_settings *settings;
    
    pctx = calloc(1, sizeof(context));
    if (pctx == NULL) {
        IPRINT("error allocating context");
        exit(EXIT_FAILURE);
    }
    
    settings = pctx->init_settings = init_settings();
    pglobal = param->global;
    pglobal->in[id].context = pctx;

    /* initialize the mutes variable */
    if(pthread_mutex_init(&pctx->controls_mutex, NULL) != 0) {
        IPRINT("could not initialize mutex variable\n");
        exit(EXIT_FAILURE);
    }

    param->argv[0] = INPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    /* parse the parameters */
    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"d", required_argument, 0, 0},
            {"device", required_argument, 0, 0},
            {"r", required_argument, 0, 0},
            {"resolution", required_argument, 0, 0},
            {"f", required_argument, 0, 0},
            {"fps", required_argument, 0, 0},
            {"y", no_argument, 0, 0},
            {"yuv", no_argument, 0, 0},
            {"u", no_argument, 0, 0},
            {"uyvy", no_argument, 0, 0},
            {"q", required_argument, 0, 0},
            {"quality", required_argument, 0, 0},
            {"m", required_argument, 0, 0},
            {"minimum_size", required_argument, 0, 0},
            {"n", no_argument, 0, 0},
            {"no_dynctrl", no_argument, 0, 0},
            {"l", required_argument, 0, 0},
            {"led", required_argument, 0, 0},
            {"fourcc", required_argument, 0, 0},
            {"t", required_argument, 0, 0 },
            {"tvnorm", required_argument, 0, 0 },
            {"e", required_argument, 0, 0},
            {"every_frame", required_argument, 0, 0},
            {"sh", required_argument, 0, 0},
            {"co", required_argument, 0, 0},
            {"br", required_argument, 0, 0},
            {"sa", required_argument, 0, 0},
            {"wb", required_argument, 0, 0},
            {"ex", required_argument, 0, 0},
            {"bk", required_argument, 0, 0},
            {"rot", required_argument, 0, 0},
            {"hf", required_argument, 0, 0},
            {"vf", required_argument, 0, 0},
            {"pl", required_argument, 0, 0},
            {"gain", required_argument, 0, 0},
            {"cagc", required_argument, 0, 0},
            {"cb", required_argument, 0, 0},
            {"timestamp", no_argument, 0, 0},
            {"softfps", required_argument, 0, 0},
            {"timeout", required_argument, 0, 0},
            {"dv_timings", no_argument, 0, 0},
            {0, 0, 0, 0}
        };

        /* parsing all parameters according to the list above is sufficent */
        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        /* dispatch the given options */
        switch(option_index) {
        /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

        /* d, device */
        case 2:
        case 3:
            DBG("case 2,3\n");
            dev = realpath(optarg, NULL);
            break;

        /* r, resolution */
        case 4:
        case 5:
            DBG("case 4,5\n");
            parse_resolution_opt(optarg, &width, &height);
            break;

        /* f, fps */
        case 6:
        case 7:
            DBG("case 6,7\n");
            fps = atoi(optarg);
            break;

        /* y, yuv */
        #ifndef NO_LIBJPEG
        case 8:
        case 9:
            DBG("case 8,9\n");
            format = V4L2_PIX_FMT_YUYV;
            break;
        #endif
	/* u, uyvy */
        #ifndef NO_LIBJPEG
        case 10:
        case 11:
            DBG("case 10,11\n");
            format = V4L2_PIX_FMT_UYVY;
            break;
        #endif
        /* q, quality */
        #ifndef NO_LIBJPEG
        case 12:
        OPTION_INT(13, quality)
            settings->quality = MIN(MAX(settings->quality, 0), 100);
            break;
        #endif
        /* m, minimum_size */
        case 14:
        case 15:
            DBG("case 14,15\n");
            minimum_size = MAX(atoi(optarg), 0);
            break;

        /* n, no_dynctrl */
        case 16:
        case 17:
            DBG("case 16,17\n");
            dynctrls = 0;
            break;

            /* l, led */
        case 18:
        case 19:/*
        DBG("case 18,19\n");
        if ( strcmp("on", optarg) == 0 ) {
          led = IN_CMD_LED_ON;
        } else if ( strcmp("off", optarg) == 0 ) {
          led = IN_CMD_LED_OFF;
        } else if ( strcmp("auto", optarg) == 0 ) {
          led = IN_CMD_LED_AUTO;
        } else if ( strcmp("blink", optarg) == 0 ) {
          led = IN_CMD_LED_BLINK;
        }*/
            break;
        /* fourcc */
        #ifndef NO_LIBJPEG
        case 20:
            DBG("case 20\n");
            if (strcmp(optarg, "RGB24") == 0) {
                format = V4L2_PIX_FMT_RGB24;
            } else if (strcmp(optarg, "RGBP") == 0) {
                format = V4L2_PIX_FMT_RGB565;
            } else {
              fprintf(stderr," i: FOURCC codec '%s' not supported\n", optarg);
            }
            break;
        #endif
        /* t, tvnorm */
        case 21:
        case 22:
            DBG("case 21,22\n");
            if (strcasecmp("pal",optarg) == 0 ) {
	             tvnorm = V4L2_STD_PAL;
            } else if ( strcasecmp("ntsc",optarg) == 0 ) {
	             tvnorm = V4L2_STD_NTSC;
            } else if ( strcasecmp("secam",optarg) == 0 ) {
	             tvnorm = V4L2_STD_SECAM;
            }
            break;
        case 23:
        /* e, every */
        case 24:
            DBG("case 24\n");
            every = MAX(atoi(optarg), 1);
            break;

        /* options */
        OPTION_INT(25, sh)
            break;
        OPTION_INT(26, co)
            break;
        OPTION_INT_AUTO(27, br)
            break;
        OPTION_INT(28, sa)
            break;
        OPTION_INT_AUTO(29, wb)
            break;
        OPTION_MULTI_OR_INT(30, ex_auto, V4L2_EXPOSURE_MANUAL, ex, exposures)
            break;
        OPTION_INT(31, bk)
            break;
        OPTION_INT(32, rot)
            break;
        OPTION_BOOL(33, hf)
            break;
        OPTION_BOOL(34, vf)
            break;
        OPTION_MULTI(35, pl, power_line)
            break;
        OPTION_INT_AUTO(36, gain)
            break;
        OPTION_INT_AUTO(37, cagc)
            break;
        OPTION_INT_AUTO(38, cb)
            break;
        case 39:
            wantTimestamp = 1;
            break;
       case 40:
           softfps = atoi(optarg);
           break;
        case 41:
            DBG("case 41\n");
            timeout = MAX(atoi(optarg), 1);
            break;
        case 42:
            DBG("case 42\n");
            dv_timings = 1;
            break;
       default:
           DBG("default case\n");
           help();
           return 1;
      }
    }
    DBG("input id: %d\n", id);
    pctx->id = id;
    pctx->pglobal = param->global;

    /* allocate webcam datastructure */
    pctx->videoIn = calloc(1, sizeof(struct vdIn));
    if(pctx->videoIn == NULL) {
        IPRINT("not enough memory for videoIn\n");
        exit(EXIT_FAILURE);
    }
    
    /* display the parsed values */
    IPRINT("Using V4L2 device.: %s\n", dev);
    IPRINT("Desired Resolution: %i x %i\n", width, height);
    IPRINT("Frames Per Second.: %i\n", fps);
    char *fmtString = NULL;
    switch (format) {
        case V4L2_PIX_FMT_MJPEG:
            // Fall-through intentional
        case V4L2_PIX_FMT_JPEG:
            fmtString = "JPEG";
            break;
        #ifndef NO_LIBJPG
            case V4L2_PIX_FMT_YUYV:
                fmtString = "YUYV";
                break;
            case V4L2_PIX_FMT_UYVY:
                fmtString = "UYVY";
                break;
            case V4L2_PIX_FMT_RGB24:
                fmtString = "RGB24";
		break;
            case V4L2_PIX_FMT_RGB565:
                fmtString = "RGB565";
                break;
        #endif
        default:
            fmtString = "Unknown format";
    }

    IPRINT("Format............: %s\n", fmtString);
    #ifndef NO_LIBJPEG
        if(format != V4L2_PIX_FMT_MJPEG && format != V4L2_PIX_FMT_JPEG)
            IPRINT("JPEG Quality......: %d\n", settings->quality);
    #endif

    if (tvnorm != V4L2_STD_UNKNOWN) {
        IPRINT("TV-Norm...........: %s\n", get_name_by_tvnorm(tvnorm));
    } else {
        IPRINT("TV-Norm...........: DEFAULT\n");
    }

    DBG("vdIn pn: %d\n", id);
    /* open video device and prepare data structure */
    pctx->videoIn->dv_timings = dv_timings;
    if(init_videoIn(pctx->videoIn, dev, width, height, fps, format, 1, pctx->pglobal, id, tvnorm) < 0) {
        IPRINT("init_VideoIn failed\n");
        closelog();
        exit(EXIT_FAILURE);
    }

    if (softfps > 0) {
        IPRINT("Framedrop FPS.....: %d\n", softfps);
    }

    /*
     * recent linux-uvc driver (revision > ~#125) requires to use dynctrls
     * for pan/tilt/focus/...
     * dynctrls must get initialized
     */
    if(dynctrls)
        initDynCtrls(pctx->videoIn->fd);
    
    enumerateControls(pctx->videoIn, pctx->pglobal, id); // enumerate V4L2 controls after UVC extended mapping
    
    return 0;
}

/******************************************************************************
Description.: Stops the execution of worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int input_stop(int id)
{
    input * in = &pglobal->in[id];
    context *pctx = (context*)in->context;
    
    DBG("will cancel camera thread #%02d\n", id);
    pthread_cancel(pctx->threadID);
    return 0;
}

/******************************************************************************
Description.: spins of a worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int input_run(int id)
{
    input * in = &pglobal->in[id];
    context *pctx = (context*)in->context;
    
    in->buf = malloc(pctx->videoIn->framesizeIn);
    if(in->buf == NULL) {
        fprintf(stderr, "could not allocate memory\n");
        exit(EXIT_FAILURE);
    }

    DBG("launching camera thread #%02d\n", id);
    /* create thread and pass context to thread function */
    pthread_create(&(pctx->threadID), NULL, cam_thread, in);
    pthread_detach(pctx->threadID);
    return 0;
}

/*** private functions for this plugin below ***/
/******************************************************************************
Description.: print a help message to stderr
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    int i;

    fprintf(stderr, " ---------------------------------------------------------------\n" \
    " Help for input plugin..: "INPUT_PLUGIN_NAME"\n" \
    " ---------------------------------------------------------------\n" \
    " The following parameters can be passed to this plugin:\n\n" \
    " [-d | --device ].......: video device to open (your camera)\n" \
    " [-r | --resolution ]...: the resolution of the video device,\n" \
    "                          can be one of the following strings:\n" \
    "                          ");
    
    resolutions_help("                          ");

    fprintf(stderr,
    " [-f | --fps ]..........: frames per second\n" \
    "                          (camera may coerce to different value)\n" \
    " [-q | --quality ] .....: set quality of JPEG encoding\n" \
    " [-m | --minimum_size ].: drop frames smaller then this limit, useful\n" \
    "                          if the webcam produces small-sized garbage frames\n" \
    "                          may happen under low light conditions\n" \
    " [-e | --every_frame ]..: drop all frames except numbered\n" \
    " [-n | --no_dynctrl ]...: do not initalize dynctrls of Linux-UVC driver\n" \
    " [-l | --led ]..........: switch the LED \"on\", \"off\", let it \"blink\" or leave\n" \
    "                          it up to the driver using the value \"auto\"\n" \
    " [-t | --tvnorm ] ......: set TV-Norm pal, ntsc or secam\n" \
    " [-u | --uyvy ] ........: Use UYVY format, default: MJPEG (uses more cpu power)\n" \
    " [-y | --yuv  ] ........: Use YUV format, default: MJPEG (uses more cpu power)\n" \
    " [-fourcc ] ............: Use FOURCC codec 'argopt', \n" \
    "                          currently supported codecs are: RGB24, RGBP \n" \
    " [-timestamp ]..........: Populate frame timestamp with system time\n" \
    " [-softfps] ............: Drop frames to try and achieve this fps\n" \
    "                          set your camera to its maximum fps to avoid stuttering\n" \
    " [-timeout] ............: Timeout for device querying (seconds)\n" \
    " [-dv_timings] .........: Enable DV timings queriyng and events processing\n" \
    " ---------------------------------------------------------------\n");

    fprintf(stderr, "\n"\
    " Optional parameters (may not be supported by all cameras):\n\n"\
    " [-br ].................: Set image brightness (auto or integer)\n"\
    " [-co ].................: Set image contrast (integer)\n"\
    " [-sh ].................: Set image sharpness (integer)\n"\
    " [-sa ].................: Set image saturation (integer)\n"\
    " [-cb ].................: Set color balance (auto or integer)\n"\
    " [-wb ].................: Set white balance (auto or integer)\n"\
    " [-ex ].................: Set exposure (auto, shutter-priority, aperature-priority, or integer)\n"\
    " [-bk ].................: Set backlight compensation (integer)\n"\
    " [-rot ]................: Set image rotation (0-359)\n"\
    " [-hf ].................: Set horizontal flip (true/false)\n"\
    " [-vf ].................: Set vertical flip (true/false)\n"\
    " [-pl ].................: Set power line filter (disabled, 50hz, 60hz, auto)\n"\
    " [-gain ]...............: Set gain (auto or integer)\n"\
    " [-cagc ]...............: Set chroma gain control (auto or integer)\n"\
    " ---------------------------------------------------------------\n\n"\
    );
}

/******************************************************************************
Description.: this thread worker grabs a frame and copies it to the global buffer
Input Value.: unused
Return Value: unused, always NULL
******************************************************************************/
void *cam_thread(void *arg)
{
    input * in = (input*)arg;
    context *pcontext = (context*)in->context;
    context_settings *settings = pcontext->init_settings;
    
    unsigned int every_count = 0;
    int quality = settings->quality;
    
    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(cam_cleanup, in);
    
    #define V4L_OPT_SET(vid, var, desc) \
      if (input_cmd(pcontext->id, vid, IN_CMD_V4L2, settings->var, NULL) != 0) {\
          fprintf(stderr, "Failed to set " desc "\n"); \
      } else { \
          printf(" i: %-18s: %d\n", desc, settings->var); \
      }
    
    #define V4L_INT_OPT(vid, var, desc) \
      if (settings->var##_set) { \
          V4L_OPT_SET(vid, var, desc) \
      }
    
    /* V4L options */
    V4L_INT_OPT(V4L2_CID_SHARPNESS, sh, "sharpness")
    V4L_INT_OPT(V4L2_CID_CONTRAST, co, "contrast")
    V4L_INT_OPT(V4L2_CID_SATURATION, sa, "saturation")
    V4L_INT_OPT(V4L2_CID_BACKLIGHT_COMPENSATION, bk, "backlight compensation")
    V4L_INT_OPT(V4L2_CID_ROTATE, rot, "rotation")
    V4L_INT_OPT(V4L2_CID_HFLIP, hf, "hflip")
    V4L_INT_OPT(V4L2_CID_VFLIP, vf, "vflip")
    V4L_INT_OPT(V4L2_CID_VFLIP, pl, "power line filter")
    
    if (settings->br_set) {
        V4L_OPT_SET(V4L2_CID_AUTOBRIGHTNESS, br_auto, "auto brightness mode")
        
        if (settings->br_auto == 0) {
            V4L_OPT_SET(V4L2_CID_BRIGHTNESS, br, "brightness")
        }
    }
    
    if (settings->wb_set) {
        V4L_OPT_SET(V4L2_CID_AUTO_WHITE_BALANCE, wb_auto, "auto white balance mode")
        
        if (settings->wb_auto == 0) {
            V4L_OPT_SET(V4L2_CID_WHITE_BALANCE_TEMPERATURE, wb, "white balance temperature")
        }
    }
    
    if (settings->ex_set) {
        V4L_OPT_SET(V4L2_CID_EXPOSURE_AUTO, ex_auto, "exposure mode")
        if (settings->ex_auto == V4L2_EXPOSURE_MANUAL) {
            V4L_OPT_SET(V4L2_CID_EXPOSURE_ABSOLUTE, ex, "absolute exposure")
        }
    }
    
    if (settings->gain_set) {
        V4L_OPT_SET(V4L2_CID_AUTOGAIN, gain_auto, "auto gain mode")
        
        if (settings->gain_auto == 0) {
            V4L_OPT_SET(V4L2_CID_GAIN, gain, "gain")
        }
    }
    
    if (settings->cagc_set) {
        V4L_OPT_SET(V4L2_CID_AUTO_WHITE_BALANCE, cagc_auto, "chroma gain mode")
        
        if (settings->cagc_auto == 0) {
            V4L_OPT_SET(V4L2_CID_WHITE_BALANCE_TEMPERATURE, cagc, "chroma gain")
        }
    }
    
    if (settings->cb_set) {
        V4L_OPT_SET(V4L2_CID_HUE_AUTO, cb_auto, "color balance mode")
        
        if (settings->cb_auto == 0) {
            V4L_OPT_SET(V4L2_CID_HUE, cagc, "color balance")
        }
    }
    
    free(settings);
    settings = NULL;
    pcontext->init_settings = NULL;

    if (softfps > 0) {
        pcontext->videoIn->soft_framedrop = 1;
        pcontext->videoIn->frame_period_time = 1000/softfps;
    }

    if (video_enable(pcontext->videoIn)) {
        IPRINT("Can\'t enable video in first time\n");
        goto endloop;
    }

    while(!pglobal->stop) {
        while(pcontext->videoIn->streamingState == STREAMING_PAUSED) {
            usleep(1); // maybe not the best way so FIXME
        }

        fd_set rd_fds; // for capture
        fd_set ex_fds; // for capture
        fd_set wr_fds; // for output

        FD_ZERO(&rd_fds);
        FD_SET(pcontext->videoIn->fd, &rd_fds);

        FD_ZERO(&ex_fds);
        FD_SET(pcontext->videoIn->fd, &ex_fds);

        FD_ZERO(&wr_fds);
        FD_SET(pcontext->videoIn->fd, &wr_fds);

        struct timeval tv;
        tv.tv_sec = timeout;
        tv.tv_usec = 0;

        int sel = select(pcontext->videoIn->fd + 1, &rd_fds, &wr_fds, &ex_fds, &tv);
        DBG("select() = %d\n", sel);

        if (sel < 0) {
            if (errno == EINTR) {
                continue;
            }
            perror("select() error");
            goto endloop;
        } else if (sel == 0) {
            IPRINT("select() timeout\n");
            if (dv_timings) {
                if (setResolution(pcontext->videoIn, pcontext->videoIn->width, pcontext->videoIn->height) < 0) {
                    goto endloop;
                }
                continue;
            } else {
                goto endloop;
            }
        }

        if (FD_ISSET(pcontext->videoIn->fd, &rd_fds)) {
            DBG("Grabbing a frame...\n");
            /* grab a frame */
            if(uvcGrab(pcontext->videoIn) < 0) {
                IPRINT("Error grabbing frames\n");
                goto endloop;
            }

            if ( every_count < every - 1 ) {
                DBG("dropping %d frame for every=%d\n", every_count + 1, every);
                ++every_count;
                goto other_select_handlers;
            } else {
                every_count = 0;
            }

            //DBG("received frame of size: %d from plugin: %d\n", pcontext->videoIn->tmpbytesused, pcontext->id);

            /*
             * Workaround for broken, corrupted frames:
             * Under low light conditions corrupted frames may get captured.
             * The good thing is such frames are quite small compared to the regular pictures.
             * For example a VGA (640x480) webcam picture is normally >= 8kByte large,
             * corrupted frames are smaller.
             */
            if(pcontext->videoIn->tmpbytesused < minimum_size) {
                DBG("dropping too small frame, assuming it as broken\n");
                goto other_select_handlers;
            }

            // Overwrite timestamp (e.g. where camera is providing 0 values)
            // Do it here so that this timestamp can be used in frameskipping
            if(wantTimestamp)
            {
                gettimeofday(&timestamp, NULL);
                pcontext->videoIn->tmptimestamp = timestamp;
            }

            // use software frame dropping on low fps
            if (pcontext->videoIn->soft_framedrop == 1) {
                unsigned long last = pglobal->in[pcontext->id].timestamp.tv_sec * 1000 +
                                    (pglobal->in[pcontext->id].timestamp.tv_usec/1000); // convert to ms
                unsigned long current = pcontext->videoIn->tmptimestamp.tv_sec * 1000 +
                                        pcontext->videoIn->tmptimestamp.tv_usec/1000; // convert to ms

                // if the requested time did not esplashed skip the frame
                if ((current - last) < pcontext->videoIn->frame_period_time) {
                    DBG("Last frame taken %d ms ago so drop it\n", (current - last));
                    goto other_select_handlers;
                }
                DBG("Lagg: %ld\n", (current - last) - pcontext->videoIn->frame_period_time);
            }

            /* copy JPG picture to global buffer */
            pthread_mutex_lock(&pglobal->in[pcontext->id].db);

            /*
             * If capturing in YUV mode convert to JPEG now.
             * This compression requires many CPU cycles, so try to avoid YUV format.
             * Getting JPEGs straight from the webcam, is one of the major advantages of
             * Linux-UVC compatible devices.
             */
            #ifndef NO_LIBJPEG
            if ((pcontext->videoIn->formatIn == V4L2_PIX_FMT_YUYV) ||
            (pcontext->videoIn->formatIn == V4L2_PIX_FMT_UYVY) ||
            (pcontext->videoIn->formatIn == V4L2_PIX_FMT_RGB24) ||
            (pcontext->videoIn->formatIn == V4L2_PIX_FMT_RGB565) ) {
                DBG("compressing frame from input: %d\n", (int)pcontext->id);
                pglobal->in[pcontext->id].size = compress_image_to_jpeg(pcontext->videoIn, pglobal->in[pcontext->id].buf, pcontext->videoIn->framesizeIn, quality);
                /* copy this frame's timestamp to user space */
                pglobal->in[pcontext->id].timestamp = pcontext->videoIn->tmptimestamp;
            } else {
            #endif
                DBG("copying frame from input: %d\n", (int)pcontext->id);
                pglobal->in[pcontext->id].size = memcpy_picture(pglobal->in[pcontext->id].buf, pcontext->videoIn->tmpbuffer, pcontext->videoIn->tmpbytesused);
                /* copy this frame's timestamp to user space */
                pglobal->in[pcontext->id].timestamp = pcontext->videoIn->tmptimestamp;
            #ifndef NO_LIBJPEG
            }
            #endif

#if 0
            /* motion detection can be done just by comparing the picture size, but it is not very accurate!! */
            if((prev_size - global->size)*(prev_size - global->size) > 4 * 1024 * 1024) {
                DBG("motion detected (delta: %d kB)\n", (prev_size - global->size) / 1024);
            }
            prev_size = global->size;
#endif

            /* signal fresh_frame */
            pthread_cond_broadcast(&pglobal->in[pcontext->id].db_update);
            pthread_mutex_unlock(&pglobal->in[pcontext->id].db);
        }

other_select_handlers:

        if (dv_timings) {
            if (FD_ISSET(pcontext->videoIn->fd, &wr_fds)) {
                IPRINT("Writing?!\n");
            }

            if (FD_ISSET(pcontext->videoIn->fd, &ex_fds)) {
                IPRINT("FD exception\n");
                if (video_handle_event(pcontext->videoIn) < 0) {
                    goto endloop;
                }
            }
        }
    }

endloop:

    DBG("leaving input thread, calling cleanup function now\n");
    pthread_cleanup_pop(1);

    return NULL;
}

/******************************************************************************
Description.:
Input Value.:
Return Value:
******************************************************************************/
void cam_cleanup(void *arg)
{
    input * in = (input*)arg;
    context *pctx = (context*)in->context;
    
    IPRINT("cleaning up resources allocated by input thread\n");

    if (pctx->videoIn != NULL) {
        close_v4l2(pctx->videoIn);
        free(pctx->videoIn->tmpbuffer);
        free(pctx->videoIn);
        pctx->videoIn = NULL;
    }
    
    free(in->buf);
    in->buf = NULL;
    in->size = 0;
}

/******************************************************************************
Description.: process commands, allows to set v4l2 controls
Input Value.: * control specifies the selected v4l2 control's id
                see struct v4l2_queryctr in the videodev2.h
              * value is used for control that make use of a parameter.
Return Value: depends in the command, for most cases 0 means no errors and
              -1 signals an error. This is just rule of thumb, not more!
******************************************************************************/
int input_cmd(int plugin_number, unsigned int control_id, unsigned int group, int value, char *value_string)
{
    input * in = &pglobal->in[plugin_number];
    context *pctx = (context*)in->context;
    
    int ret = -1;
    int i = 0;
    DBG("Requested cmd (id: %d) for the %d plugin. Group: %d value: %d\n", control_id, plugin_number, group, value);
    switch(group) {
    case IN_CMD_GENERIC: {
            int i;
            for (i = 0; i<in->parametercount; i++) {
                if ((in->in_parameters[i].ctrl.id == control_id) &&
                    (in->in_parameters[i].group == IN_CMD_GENERIC)){
                    DBG("Generic control found (id: %d): %s\n", control_id, in->in_parameters[i].ctrl.name);
                    DBG("New %s value: %d\n", in->in_parameters[i].ctrl.name, value);
                    return 0;
                }
            }
            DBG("Requested generic control (%d) did not found\n", control_id);
            return -1;
        } break;
    case IN_CMD_V4L2: {
            ret = v4l2SetControl(pctx->videoIn, control_id, value, plugin_number, pglobal);
            if(ret == 0) {
                in->in_parameters[i].value = value;
            } else {
                DBG("v4l2SetControl failed: %d\n", ret);
            }
            return ret;
        } break;
    case IN_CMD_RESOLUTION: {
        // the value points to the current formats nth resolution
        if(value > (in->in_formats[in->currentFormat].resolutionCount - 1)) {
            DBG("The value is out of range");
            return -1;
        }
        int height = in->in_formats[in->currentFormat].supportedResolutions[value].height;
        int width = in->in_formats[in->currentFormat].supportedResolutions[value].width;
        ret = setResolution(pctx->videoIn, width, height);
        if(ret == 0) {
            in->in_formats[in->currentFormat].currentResolution = value;
        }
        return ret;
    } break;
    case IN_CMD_JPEG_QUALITY:
        if((value >= 0) && (value < 101)) {
            in->jpegcomp.quality = value;
            if(IOCTL_VIDEO(pctx->videoIn->fd, VIDIOC_S_JPEGCOMP, &in->jpegcomp) != EINVAL) {
                DBG("JPEG quality is set to %d\n", value);
                ret = 0;
            } else {
                DBG("Setting the JPEG quality is not supported\n");
            }
        } else {
            DBG("Quality is out of range\n");
        }
        break;
    }
    return ret;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/jpeg_utils.c
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
#   Orginally Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard       #
#   Modifications Copyright (C) 2006  Gabriel A. Devenyi                       #
#   Modifications Copyright (C) 2007  Tom Stöveken                             #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <stdio.h>
#include <jpeglib.h>
#include <stdlib.h>

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "v4l2uvc.h"

#define OUTPUT_BUF_SIZE  4096

typedef struct {
    struct jpeg_destination_mgr pub; /* public fields */

    JOCTET * buffer;    /* start of buffer */

    unsigned char *outbuffer;
    int outbuffer_size;
    unsigned char *outbuffer_cursor;
    int *written;

} mjpg_destination_mgr;

typedef mjpg_destination_mgr * mjpg_dest_ptr;

/******************************************************************************
Description.:
Input Value.:
Return Value:
******************************************************************************/
METHODDEF(void) init_destination(j_compress_ptr cinfo)
{
    mjpg_dest_ptr dest = (mjpg_dest_ptr) cinfo->dest;

    /* Allocate the output buffer --- it will be released when done with image */
    dest->buffer = (JOCTET *)(*cinfo->mem->alloc_small)((j_common_ptr) cinfo, JPOOL_IMAGE, OUTPUT_BUF_SIZE * sizeof(JOCTET));

    *(dest->written) = 0;

    dest->pub.next_output_byte = dest->buffer;
    dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
}

/******************************************************************************
Description.: called whenever local jpeg buffer fills up
Input Value.:
Return Value:
******************************************************************************/
METHODDEF(boolean) empty_output_buffer(j_compress_ptr cinfo)
{
    mjpg_dest_ptr dest = (mjpg_dest_ptr) cinfo->dest;

    memcpy(dest->outbuffer_cursor, dest->buffer, OUTPUT_BUF_SIZE);
    dest->outbuffer_cursor += OUTPUT_BUF_SIZE;
    *(dest->written) += OUTPUT_BUF_SIZE;

    dest->pub.next_output_byte = dest->buffer;
    dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;

    return TRUE;
}

/******************************************************************************
Description.: called by jpeg_finish_compress after all data has been written.
              Usually needs to flush buffer.
Input Value.:
Return Value:
******************************************************************************/
METHODDEF(void) term_destination(j_compress_ptr cinfo)
{
    mjpg_dest_ptr dest = (mjpg_dest_ptr) cinfo->dest;
    size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;

    /* Write any data remaining in the buffer */
    memcpy(dest->outbuffer_cursor, dest->buffer, datacount);
    dest->outbuffer_cursor += datacount;
    *(dest->written) += datacount;
}

/******************************************************************************
Description.: Prepare for output to a stdio stream.
Input Value.: buffer is the already allocated buffer memory that will hold
              the compressed picture. "size" is the size in bytes.
Return Value: -
******************************************************************************/
GLOBAL(void) dest_buffer(j_compress_ptr cinfo, unsigned char *buffer, int size, int *written)
{
    mjpg_dest_ptr dest;

    if(cinfo->dest == NULL) {
        cinfo->dest = (struct jpeg_destination_mgr *)(*cinfo->mem->alloc_small)((j_common_ptr) cinfo, JPOOL_PERMANENT, sizeof(mjpg_destination_mgr));
    }

    dest = (mjpg_dest_ptr) cinfo->dest;
    dest->pub.init_destination = init_destination;
    dest->pub.empty_output_buffer = empty_output_buffer;
    dest->pub.term_destination = term_destination;
    dest->outbuffer = buffer;
    dest->outbuffer_size = size;
    dest->outbuffer_cursor = buffer;
    dest->written = written;
}

/******************************************************************************
Description.: yuv2jpeg function is based on compress_yuyv_to_jpeg written by
              Gabriel A. Devenyi.
              modified to support other formats like RGB5:6:5 by Miklós Márton
              It uses the destination manager implemented above to compress
              YUYV data to JPEG. Most other implementations use the
              "jpeg_stdio_dest" from libjpeg, which can not store compressed
              pictures to memory instead of a file.
Input Value.: video structure from v4l2uvc.c/h, destination buffer and buffersize
              the buffer must be large enough, no error/size checking is done!
Return Value: the buffer will contain the compressed data
******************************************************************************/
int compress_image_to_jpeg(struct vdIn *vd, unsigned char *buffer, int size, int quality)
{
    struct jpeg_compress_struct cinfo;
    struct jpeg_error_mgr jerr;
    JSAMPROW row_pointer[1];
    unsigned char *line_buffer, *yuyv;
    int z;
    static int written;

    line_buffer = calloc(vd->width * 3, 1);
    yuyv = vd->framebuffer;

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);
    /* jpeg_stdio_dest (&cinfo, file); */
    dest_buffer(&cinfo, buffer, size, &written);

    cinfo.image_width = vd->width;
    cinfo.image_height = vd->height;
    cinfo.input_components = 3;
    cinfo.in_color_space = JCS_RGB;

    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, quality, TRUE);

    jpeg_start_compress(&cinfo, TRUE);

    z = 0;
    if (vd->formatIn == V4L2_PIX_FMT_YUYV) {
        while(cinfo.next_scanline < vd->height) {
            int x;
            unsigned char *ptr = line_buffer;


            for(x = 0; x < vd->width; x++) {
                int r, g, b;
                int y, u, v;

                if(!z)
                    y = yuyv[0] << 8;
                else
                    y = yuyv[2] << 8;
                u = yuyv[1] - 128;
                v = yuyv[3] - 128;

                r = (y + (359 * v)) >> 8;
                g = (y - (88 * u) - (183 * v)) >> 8;
                b = (y + (454 * u)) >> 8;

                *(ptr++) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
                *(ptr++) = (g > 255) ? 255 : ((g < 0) ? 0 : g);
                *(ptr++) = (b > 255) ? 255 : ((b < 0) ? 0 : b);

                if(z++) {
                    z = 0;
                    yuyv += 4;
                }
            }

            row_pointer[0] = line_buffer;
            jpeg_write_scanlines(&cinfo, row_pointer, 1);
        }
    } else if (vd->formatIn == V4L2_PIX_FMT_RGB24) {
        while(cinfo.next_scanline < vd->height) {
            int x;
            unsigned char *ptr = line_buffer;

            for(x = 0; x < vd->width; x++) {
                *(ptr++) = yuyv[0];
                *(ptr++) = yuyv[1];
                *(ptr++) = yuyv[2];
                yuyv += 3;
            }

            row_pointer[0] = line_buffer;
            jpeg_write_scanlines(&cinfo, row_pointer, 1);
        }
    } else if (vd->formatIn == V4L2_PIX_FMT_RGB565) {
        while(cinfo.next_scanline < vd->height) {
            int x;
            unsigned char *ptr = line_buffer;

            for(x = 0; x < vd->width; x++) {
                /*
                unsigned int tb = ((unsigned char)raw[i+1] << 8) + (unsigned char)raw[i];
                r =  ((unsigned char)(raw[i+1]) & 248);
                g = (unsigned char)(( tb & 2016) >> 3);
                b =  ((unsigned char)raw[i] & 31) * 8;
                */
                unsigned int twoByte = (yuyv[1] << 8) + yuyv[0];
                *(ptr++) = (yuyv[1] & 248);
                *(ptr++) = (unsigned char)((twoByte & 2016) >> 3);
                *(ptr++) = ((yuyv[0] & 31) * 8);
                yuyv += 2;
            }

            row_pointer[0] = line_buffer;
            jpeg_write_scanlines(&cinfo, row_pointer, 1);
        }
    }  else if (vd->formatIn == V4L2_PIX_FMT_UYVY) {
        while(cinfo.next_scanline < vd->height) {
            int x;
            unsigned char *ptr = line_buffer;


            for(x = 0; x < vd->width; x++) {
                int r, g, b;
                int y, u, v;

                if(!z)
                    y = yuyv[1] << 8;
                else
                    y = yuyv[3] << 8;
                u = yuyv[0] - 128;
                v = yuyv[2] - 128;

                r = (y + (359 * v)) >> 8;
                g = (y - (88 * u) - (183 * v)) >> 8;
                b = (y + (454 * u)) >> 8;

                *(ptr++) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
                *(ptr++) = (g > 255) ? 255 : ((g < 0) ? 0 : g);
                *(ptr++) = (b > 255) ? 255 : ((b < 0) ? 0 : b);

                if(z++) {
                    z = 0;
                    yuyv += 4;
                }
            }

            row_pointer[0] = line_buffer;
            jpeg_write_scanlines(&cinfo, row_pointer, 1);
        }
    }
    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);

    free(line_buffer);

    return (written);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/jpeg_utils.h
================
int compress_image_to_jpeg(struct vdIn *vd, unsigned char *buffer, int size, int quality);

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/README.md
================
mjpg-streamer input plugin: input_uvc
=====================================

This plugin provides JPEG data from V4L/V4L2 compatible webcams.

Usage
=====

    mjpg_streamer -i 'input_uvc.so [options]'
    
```
---------------------------------------------------------------
Help for input plugin..: UVC webcam grabber
---------------------------------------------------------------
The following parameters can be passed to this plugin:

[-d | --device ].......: video device to open (your camera)
[-r | --resolution ]...: the resolution of the video device,
                         can be one of the following strings:
                         QSIF QCIF CGA QVGA CIF VGA 
                         SVGA XGA SXGA 
                         or a custom value like the following
                         example: 640x480
[-f | --fps ]..........: frames per second
                         (activates YUYV format, disables MJPEG)
[-m | --minimum_size ].: drop frames smaller then this limit, useful
                         if the webcam produces small-sized garbage frames
                         may happen under low light conditions
[-e | --every_frame ]..: drop all frames except numbered
[-n | --no_dynctrl ]...: do not initalize dynctrls of Linux-UVC driver
[-l | --led ]..........: switch the LED "on", "off", let it "blink" or leave
                         it up to the driver using the value "auto"
---------------------------------------------------------------

[-t | --tvnorm ] ......: set TV-Norm pal, ntsc or secam
---------------------------------------------------------------

Optional parameters (may not be supported by all cameras):

[-br ].................: Set image brightness (auto or integer)
[-co ].................: Set image contrast (integer)
[-sh ].................: Set image sharpness (integer)
[-sa ].................: Set image saturation (integer)
[-cb ].................: Set color balance (auto or integer)
[-wb ].................: Set white balance (auto or integer)
[-ex ].................: Set exposure (auto, shutter-priority, aperature-priority, or integer)
[-bk ].................: Set backlight compensation (integer)
[-rot ]................: Set image rotation (0-359)
[-hf ].................: Set horizontal flip (true/false)
[-vf ].................: Set vertical flip (true/false)
[-pl ].................: Set power line filter (disabled, 50hz, 60hz, auto)
[-gain ]...............: Set gain (auto or integer)
[-cagc ]...............: Set chroma gain control (auto or integer)
---------------------------------------------------------------
```

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/uvc_compat.h
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#ifndef _UVC_COMPAT_H
#define _UVC_COMPAT_H

#include <linux/version.h>
#ifndef __KERNEL__
#ifndef __user
#define __user
#endif
#endif

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
/*
 * Extended control API
 */
struct v4l2_ext_control {
    __u32 id;
    __u32 reserved2[2];
    union {
        __s32 value;
        __s64 value64;
        void *reserved;
    };
} __attribute__((packed));

struct v4l2_ext_controls {
    __u32 ctrl_class;
    __u32 count;
    __u32 error_idx;
    __u32 reserved[2];
    struct v4l2_ext_control *controls;
};

/* Values for ctrl_class field */
#define V4L2_CTRL_CLASS_USER        0x00980000  /* Old-style 'user' controls */
#define V4L2_CTRL_CLASS_MPEG        0x00990000  /* MPEG-compression controls */

#define V4L2_CTRL_ID_MASK       (0x0fffffff)
#define V4L2_CTRL_ID2CLASS(id)      ((id) & 0x0fff0000UL)
#define V4L2_CTRL_DRIVER_PRIV(id)   (((id) & 0xffff) >= 0x1000)
/* Control flags */
#define V4L2_CTRL_FLAG_READ_ONLY    0x0004
#define V4L2_CTRL_FLAG_UPDATE       0x0008
#define V4L2_CTRL_FLAG_INACTIVE     0x0010
#define V4L2_CTRL_FLAG_SLIDER       0x0020

/* Query flags, to be ORed with the control ID */
#define V4L2_CTRL_FLAG_NEXT_CTRL    0x80000000

/* User-class control IDs defined by V4L2 */
#undef  V4L2_CID_BASE
#define V4L2_CID_BASE           (V4L2_CTRL_CLASS_USER | 0x900)
#define V4L2_CID_USER_BASE      V4L2_CID_BASE
#define V4L2_CID_USER_CLASS     (V4L2_CTRL_CLASS_USER | 1)

#define VIDIOC_G_EXT_CTRLS      _IOWR ('V', 71, struct v4l2_ext_controls)
#define VIDIOC_S_EXT_CTRLS      _IOWR ('V', 72, struct v4l2_ext_controls)
#define VIDIOC_TRY_EXT_CTRLS        _IOWR ('V', 73, struct v4l2_ext_controls)

#endif

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
/*
 * Frame size and frame rate enumeration
 *
 * Included in Linux 2.6.19
 */
enum v4l2_frmsizetypes {
    V4L2_FRMSIZE_TYPE_DISCRETE  = 1,
    V4L2_FRMSIZE_TYPE_CONTINUOUS    = 2,
    V4L2_FRMSIZE_TYPE_STEPWISE  = 3
};

struct v4l2_frmsize_discrete {
    __u32           width;      /* Frame width [pixel] */
    __u32           height;     /* Frame height [pixel] */
};

struct v4l2_frmsize_stepwise {
    __u32           min_width;  /* Minimum frame width [pixel] */
    __u32           max_width;  /* Maximum frame width [pixel] */
    __u32           step_width; /* Frame width step size [pixel] */
    __u32           min_height; /* Minimum frame height [pixel] */
    __u32           max_height; /* Maximum frame height [pixel] */
    __u32           step_height;    /* Frame height step size [pixel] */
};

struct v4l2_frmsizeenum {
    __u32           index;      /* Frame size number */
    __u32           pixel_format;   /* Pixel format */
    __u32           type;       /* Frame size type the device supports. */

    union {                 /* Frame size */
        struct v4l2_frmsize_discrete    discrete;
        struct v4l2_frmsize_stepwise    stepwise;
    };

    __u32   reserved[2];            /* Reserved space for future use */
};

enum v4l2_frmivaltypes {
    V4L2_FRMIVAL_TYPE_DISCRETE  = 1,
    V4L2_FRMIVAL_TYPE_CONTINUOUS    = 2,
    V4L2_FRMIVAL_TYPE_STEPWISE  = 3
};

struct v4l2_frmival_stepwise {
    struct v4l2_fract   min;        /* Minimum frame interval [s] */
    struct v4l2_fract   max;        /* Maximum frame interval [s] */
    struct v4l2_fract   step;       /* Frame interval step size [s] */
};

struct v4l2_frmivalenum {
    __u32           index;      /* Frame format index */
    __u32           pixel_format;   /* Pixel format */
    __u32           width;      /* Frame width */
    __u32           height;     /* Frame height */
    __u32           type;       /* Frame interval type the device supports. */

    union {                 /* Frame interval */
        struct v4l2_fract       discrete;
        struct v4l2_frmival_stepwise    stepwise;
    };

    __u32   reserved[2];            /* Reserved space for future use */
};

#define VIDIOC_ENUM_FRAMESIZES      _IOWR ('V', 74, struct v4l2_frmsizeenum)
#define VIDIOC_ENUM_FRAMEINTERVALS  _IOWR ('V', 75, struct v4l2_frmivalenum)
#endif


#endif /* _UVC_COMPAT_H */

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/uvcvideo.h
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#ifndef _USB_VIDEO_H_
#define _USB_VIDEO_H_

#include <linux/kernel.h>
#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#ifdef USE_LIBV4L2
#include <libv4l2.h>
#define IOCTL_VIDEO(fd, req, value) v4l2_ioctl(fd, req, value)
#define OPEN_VIDEO(fd, flags) v4l2_open(fd, flags)
#define CLOSE_VIDEO(fd) v4l2_close(fd)
#else
#define IOCTL_VIDEO(fd, req, value) ioctl(fd, req, value)
#define OPEN_VIDEO(fd, flags) open(fd, flags)
#define CLOSE_VIDEO(fd) close(fd)
#endif

/* Compatibility */
#include "uvc_compat.h"

/*
 * Private V4L2 control identifiers.
 */

/*
 * Dynamic controls
 */
/* Data types for UVC control data */
enum uvc_control_data_type {
    UVC_CTRL_DATA_TYPE_RAW = 0,
    UVC_CTRL_DATA_TYPE_SIGNED,
    UVC_CTRL_DATA_TYPE_UNSIGNED,
    UVC_CTRL_DATA_TYPE_BOOLEAN,
    UVC_CTRL_DATA_TYPE_ENUM,
    UVC_CTRL_DATA_TYPE_BITMASK,
};

#define UVC_CONTROL_SET_CUR (1 << 0)
#define UVC_CONTROL_GET_CUR (1 << 1)
#define UVC_CONTROL_GET_MIN (1 << 2)
#define UVC_CONTROL_GET_MAX (1 << 3)
#define UVC_CONTROL_GET_RES (1 << 4)
#define UVC_CONTROL_GET_DEF (1 << 5)
/* Control should be saved at suspend and restored at resume. */
#define UVC_CONTROL_RESTORE (1 << 6)

#define UVC_CONTROL_GET_RANGE   (UVC_CONTROL_GET_CUR | UVC_CONTROL_GET_MIN | \
                                 UVC_CONTROL_GET_MAX | UVC_CONTROL_GET_RES | \
                                 UVC_CONTROL_GET_DEF)

struct uvc_xu_control_info {
    __u8 entity[16];
    __u8 index;
    __u8 selector;
    __u16 size;
    __u32 flags;
};

struct uvc_xu_control_mapping {
    __u32 id;
    __u8 name[32];
    __u8 entity[16];
    __u8 selector;

    __u8 size;
    __u8 offset;
    enum v4l2_ctrl_type v4l2_type;
    enum uvc_control_data_type data_type;
};

struct uvc_xu_control {
    __u8 unit;
    __u8 selector;
    __u16 size;
    __u8 __user *data;
};

#define UVCIOC_CTRL_ADD     _IOW  ('U', 1, struct uvc_xu_control_info)
#define UVCIOC_CTRL_MAP     _IOWR ('U', 2, struct uvc_xu_control_mapping)
#define UVCIOC_CTRL_GET     _IOWR ('U', 3, struct uvc_xu_control)
#define UVCIOC_CTRL_SET     _IOW  ('U', 4, struct uvc_xu_control)



#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/v4l2uvc.c
================
/*******************************************************************************
# Linux-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <stdlib.h>
#include <errno.h>
#include "v4l2uvc.h"
#include "huffman.h"
#include "dynctrl.h"

static int debug = 0;

/* fcc2s - convert pixelformat to string
* (Obtained from vtl-utils: v4l2-ctl.cpp)
* args:
* fmsString - char* to hold string
* size - size of allocated memory for string
* pixelformat - v4l2 pixel format identidifier
*/
void fcc2s(char* fmtString, unsigned int size, unsigned int pixelformat)
{
  if ( size < 8 )
  {
    fmtString[0] = '\0';
    return;
  }
  

  fmtString[0] = pixelformat & 0x7f;
  fmtString[1] = (pixelformat >>  8 ) & 0x7f;
  fmtString[2] = (pixelformat >>  16 ) & 0x7f;
  fmtString[3] = (pixelformat >> 24 ) & 0x7f;
  if (pixelformat & (1 << 31))
  {
    fmtString[4] = '-';
    fmtString[5] = 'B';
    fmtString[6] = 'E';
    fmtString[7] = '\0';
  }
  else
  {
    fmtString[4] = '\0';
  }
  return;
}

/* ioctl with a number of retries in the case of failure
* args:
* fd - device descriptor
* IOCTL_X - ioctl reference
* arg - pointer to ioctl data
* returns - ioctl result
*/
int xioctl(int fd, int IOCTL_X, void *arg)
{
    int ret = 0;
    int tries = IOCTL_RETRY;
    do {
        ret = IOCTL_VIDEO(fd, IOCTL_X, arg);
    } while(ret && tries-- &&
            ((errno == EINTR) || (errno == EAGAIN) || (errno == ETIMEDOUT)));

    if(ret && (tries <= 0)) fprintf(stderr, "ioctl (%i) retried %i times - giving up: %s)\n", IOCTL_X, IOCTL_RETRY, strerror(errno));

    return (ret);
}

static int init_v4l2(struct vdIn *vd);
static int init_framebuffer(struct vdIn *vd);
static void free_framebuffer(struct vdIn *vd);

int init_videoIn(struct vdIn *vd, char *device, int width,
                 int height, int fps, int format, int grabmethod, globals *pglobal, int id, v4l2_std_id vstd)
{
    if(vd == NULL || device == NULL)
        return -1;
    if(width == 0 || height == 0)
        return -1;
    if(grabmethod < 0 || grabmethod > 1)
        grabmethod = 1;     //mmap by default;
    vd->videodevice = NULL;
    vd->status = NULL;
    vd->pictName = NULL;
    vd->videodevice = (char *) calloc(1, 16 * sizeof(char));
    vd->status = (char *) calloc(1, 100 * sizeof(char));
    vd->pictName = (char *) calloc(1, 80 * sizeof(char));
    snprintf(vd->videodevice, (16 - 1), "%s", device);
    vd->toggleAvi = 0;
    vd->getPict = 0;
    vd->signalquit = 1;
    vd->width = width;
    vd->height = height;
    vd->fps = fps;
    vd->formatIn = format;
	vd->vstd = vstd;
    vd->grabmethod = grabmethod;
    vd->soft_framedrop = 0;

    if(init_v4l2(vd) < 0) {
        goto error;
    }

    // getting the name of the input source
    struct v4l2_input in_struct;
    memset(&in_struct, 0, sizeof(struct v4l2_input));
    in_struct.index = 0;
    if (xioctl(vd->fd, VIDIOC_ENUMINPUT,  &in_struct) == 0) {
        int nameLength = strlen((char*)&in_struct.name);
        pglobal->in[id].name = malloc((1+nameLength)*sizeof(char));
        sprintf(pglobal->in[id].name, "%s", in_struct.name);
        DBG("Input name: %s\n", in_struct.name);
    } else {
        DBG("VIDIOC_ENUMINPUT failed\n");
    }

    // enumerating formats

    struct v4l2_format currentFormat;
    memset(&currentFormat, 0, sizeof(struct v4l2_format));
    currentFormat.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (xioctl(vd->fd, VIDIOC_G_FMT, &currentFormat) == 0) {
        DBG("Current size: %dx%d\n",
             currentFormat.fmt.pix.width,
             currentFormat.fmt.pix.height);
    }

    pglobal->in[id].in_formats = NULL;
    for(pglobal->in[id].formatCount = 0; 1; pglobal->in[id].formatCount++) {
        struct v4l2_fmtdesc fmtdesc;
        memset(&fmtdesc, 0, sizeof(struct v4l2_fmtdesc));
        fmtdesc.index = pglobal->in[id].formatCount;
        fmtdesc.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        if(xioctl(vd->fd, VIDIOC_ENUM_FMT, &fmtdesc) < 0) {
            break;
        }

        if (pglobal->in[id].in_formats == NULL) {
            pglobal->in[id].in_formats = (input_format*)calloc(1, sizeof(input_format));
        } else {
            pglobal->in[id].in_formats = (input_format*)realloc(pglobal->in[id].in_formats, (pglobal->in[id].formatCount + 1) * sizeof(input_format));
        }

        if (pglobal->in[id].in_formats == NULL) {
            LOG("Calloc/realloc failed: %s\n", strerror(errno));
            return -1;
        }

        memcpy(&pglobal->in[id].in_formats[pglobal->in[id].formatCount], &fmtdesc, sizeof(struct v4l2_fmtdesc));

        if(fmtdesc.pixelformat == format)
            pglobal->in[id].currentFormat = pglobal->in[id].formatCount;

        DBG("Supported format: %s\n", fmtdesc.description);
        struct v4l2_frmsizeenum fsenum;
        memset(&fsenum, 0, sizeof(struct v4l2_frmsizeenum));
        fsenum.pixel_format = fmtdesc.pixelformat;
        int j = 0;
        pglobal->in[id].in_formats[pglobal->in[id].formatCount].supportedResolutions = NULL;
        pglobal->in[id].in_formats[pglobal->in[id].formatCount].resolutionCount = 0;
        pglobal->in[id].in_formats[pglobal->in[id].formatCount].currentResolution = -1;
        while(1) {
            fsenum.index = j;
            j++;
            if(xioctl(vd->fd, VIDIOC_ENUM_FRAMESIZES, &fsenum) == 0) {
                pglobal->in[id].in_formats[pglobal->in[id].formatCount].resolutionCount++;

                if (pglobal->in[id].in_formats[pglobal->in[id].formatCount].supportedResolutions == NULL) {
                    pglobal->in[id].in_formats[pglobal->in[id].formatCount].supportedResolutions = (input_resolution*)
                            calloc(1, sizeof(input_resolution));
                } else {
                    pglobal->in[id].in_formats[pglobal->in[id].formatCount].supportedResolutions = (input_resolution*)
                            realloc(pglobal->in[id].in_formats[pglobal->in[id].formatCount].supportedResolutions, j * sizeof(input_resolution));
                }

                if (pglobal->in[id].in_formats[pglobal->in[id].formatCount].supportedResolutions == NULL) {
                    LOG("Calloc/realloc failed\n");
                    return -1;
                }

                pglobal->in[id].in_formats[pglobal->in[id].formatCount].supportedResolutions[j-1].width = fsenum.discrete.width;
                pglobal->in[id].in_formats[pglobal->in[id].formatCount].supportedResolutions[j-1].height = fsenum.discrete.height;
                if(format == fmtdesc.pixelformat) {
                    pglobal->in[id].in_formats[pglobal->in[id].formatCount].currentResolution = (j - 1);
                    DBG("\tSupported size with the current format: %dx%d\n", fsenum.discrete.width, fsenum.discrete.height);
                } else {
                    DBG("\tSupported size: %dx%d\n", fsenum.discrete.width, fsenum.discrete.height);
                }
            } else {
                break;
            }
        }
    }

    if (init_framebuffer(vd) < 0) {
        goto error;
    }

    return 0;
error:
    free_framebuffer(vd);
    free(pglobal->in[id].in_parameters);
    free(vd->videodevice);
    free(vd->status);
    free(vd->pictName);
    CLOSE_VIDEO(vd->fd);
    return -1;
}

static int init_framebuffer(struct vdIn *vd) {
    /* alloc a temp buffer to reconstruct the pict */
    vd->framesizeIn = (vd->width * vd->height << 1);
    switch (vd->formatIn) {
        case V4L2_PIX_FMT_JPEG:
            // Fall-through intentional
        case V4L2_PIX_FMT_MJPEG: // in JPG mode the frame size is varies at every frame, so we allocate a bit bigger buffer
            vd->tmpbuffer = (unsigned char *) calloc(1, (size_t) vd->framesizeIn);
            if(!vd->tmpbuffer)
                return -1;
            vd->framebuffer =
                (unsigned char *) calloc(1, (size_t) vd->width * (vd->height + 8) * 2);
            break;
        case V4L2_PIX_FMT_RGB24:
            vd->framesizeIn = (vd->width * vd->height) * 3;
            vd->framebuffer =
                (unsigned char *) calloc(1, (size_t) vd->framesizeIn);
            break;
        case V4L2_PIX_FMT_RGB565: // buffer allocation for non varies on frame size formats
        case V4L2_PIX_FMT_YUYV:
        case V4L2_PIX_FMT_UYVY:
            vd->framebuffer =
                (unsigned char *) calloc(1, (size_t) vd->framesizeIn);
            break;
        default:
            fprintf(stderr, "Unknown vd->formatIn\n");
            return -1;
    }
    return -!vd->framebuffer;
}

static void free_framebuffer(struct vdIn *vd) {
    if (vd->tmpbuffer) {
        free(vd->tmpbuffer);
    }
    vd->tmpbuffer = NULL;
    free(vd->framebuffer);
    vd->framebuffer = NULL;
}

static int init_v4l2(struct vdIn *vd)
{
    int i;
    int ret = 0;
    if((vd->fd = OPEN_VIDEO(vd->videodevice, O_RDWR)) == -1) {
        perror("ERROR opening V4L interface");
        DBG("errno: %d", errno);
        return -1;
    }

    memset(&vd->cap, 0, sizeof(struct v4l2_capability));
    ret = xioctl(vd->fd, VIDIOC_QUERYCAP, &vd->cap);
    if(ret < 0) {
        fprintf(stderr, "Error opening device %s: unable to query device.\n", vd->videodevice);
        goto fatal;
    }

    if((vd->cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) == 0) {
        fprintf(stderr, "Error opening device %s: video capture not supported.\n",
                vd->videodevice);
        goto fatal;;
    }

    if(vd->grabmethod) {
        if(!(vd->cap.capabilities & V4L2_CAP_STREAMING)) {
            fprintf(stderr, "%s does not support streaming i/o\n", vd->videodevice);
            goto fatal;
        }
    } else {
        if(!(vd->cap.capabilities & V4L2_CAP_READWRITE)) {
            fprintf(stderr, "%s does not support read i/o\n", vd->videodevice);
            goto fatal;
        }
    }

    if (vd->vstd != V4L2_STD_UNKNOWN) {
        if (ioctl(vd->fd, VIDIOC_S_STD, &vd->vstd) == -1) {
            fprintf(stderr, "Can't set video standard: %s\n",strerror(errno));
            goto fatal;
        }
    }

    if (vd->dv_timings) {
        if (video_set_dv_timings(vd)) {
            goto fatal;
        }

        struct v4l2_event_subscription sub;
        memset(&sub, 0, sizeof(sub));
        sub.type = V4L2_EVENT_SOURCE_CHANGE;
        if (ioctl(vd->fd, VIDIOC_SUBSCRIBE_EVENT, &sub) < 0) {
            IPRINT("Can\'t subscribe to V4L2_EVENT_SOURCE_CHANGE: %s\n", strerror(errno));
        }
    }

    /*
     * set format in
     */
    memset(&vd->fmt, 0, sizeof(struct v4l2_format));
    vd->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    vd->fmt.fmt.pix.width = vd->width;
    vd->fmt.fmt.pix.height = vd->height;
    vd->fmt.fmt.pix.pixelformat = vd->formatIn;
    vd->fmt.fmt.pix.field = V4L2_FIELD_ANY;
    ret = xioctl(vd->fd, VIDIOC_S_FMT, &vd->fmt);
    if(ret < 0) {
        fprintf(stderr, "Unable to set format: %d res: %dx%d\n", vd->formatIn, vd->width, vd->height);
        goto fatal;
    }

    /* 
     * Check reoslution 
     */
    if((vd->fmt.fmt.pix.width != vd->width) ||
            (vd->fmt.fmt.pix.height != vd->height)) {
       fprintf(stderr, " i: The specified resolution is unavailable, using: width %d height %d instead \n", vd->fmt.fmt.pix.width, vd->fmt.fmt.pix.height);
        vd->width = vd->fmt.fmt.pix.width;
        vd->height = vd->fmt.fmt.pix.height;
    }
    /*
     * Check format
     */
    if(vd->formatIn != vd->fmt.fmt.pix.pixelformat) {
      char fmtStringRequested[8];
      char fmtStringObtained[8];
      fcc2s(fmtStringObtained,8,vd->fmt.fmt.pix.pixelformat);
      fcc2s(fmtStringRequested,8,vd->formatIn);
      fprintf(stderr, " i: Could not obtain the requested pixelformat: %s , driver gave us: %s\n",fmtStringRequested,fmtStringObtained);
      fprintf(stderr, "    ... will try to handle this by checking against supported formats. \n");

      switch(vd->fmt.fmt.pix.pixelformat){
      case V4L2_PIX_FMT_JPEG:
	// Fall-through intentional
      case V4L2_PIX_FMT_MJPEG:
	fprintf(stderr, "    ... Falling back to the faster MJPG mode (consider changing cmd line options).\n");
	vd->formatIn = vd->fmt.fmt.pix.pixelformat;
	break;
      case V4L2_PIX_FMT_YUYV:
	fprintf(stderr, "    ... Falling back to YUV mode (consider using -yuv option). Note that this requires much more CPU power\n");
	vd->formatIn = vd->fmt.fmt.pix.pixelformat;
        break;
      case V4L2_PIX_FMT_UYVY:
	fprintf(stderr, "    ... Falling back to UYVY mode (consider using -uyvy option). Note that this requires much more CPU power\n");
	vd->formatIn = vd->fmt.fmt.pix.pixelformat;
        break;
      case V4L2_PIX_FMT_RGB24:
	fprintf(stderr, "    ... Falling back to RGB24 mode (consider using -fourcc RGB24 option). Note that this requires much more CPU power\n");
	vd->formatIn = vd->fmt.fmt.pix.pixelformat;
	break;
      case V4L2_PIX_FMT_RGB565:
	fprintf(stderr, "    ... Falling back to RGB565 mode (consider using -fourcc RGBP option). Note that this requires much more CPU power\n");
	vd->formatIn = vd->fmt.fmt.pix.pixelformat;
	break;
      default:
	goto fatal;
	break;
      }
    }
 
    /*
     * set framerate
     */

    if (vd->fps != -1) {
        struct v4l2_streamparm *setfps;
        setfps = (struct v4l2_streamparm *) calloc(1, sizeof(struct v4l2_streamparm));
        memset(setfps, 0, sizeof(struct v4l2_streamparm));
        setfps->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

        /*
        * first query streaming parameters to determine that the FPS selection is supported
        */
        ret = xioctl(vd->fd, VIDIOC_G_PARM, setfps);
        if (ret == 0) {
            if (setfps->parm.capture.capability & V4L2_CAP_TIMEPERFRAME) {
                memset(setfps, 0, sizeof(struct v4l2_streamparm));
                setfps->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                setfps->parm.capture.timeperframe.numerator = 1;
                setfps->parm.capture.timeperframe.denominator = vd->fps==-1?255:vd->fps; // if no default fps set set it to maximum

                ret = xioctl(vd->fd, VIDIOC_S_PARM, setfps);
                if (ret) {
                    perror("Unable to set the FPS\n");
                } else {
                    if (vd->fps != setfps->parm.capture.timeperframe.denominator) {
                        IPRINT("FPS coerced ......: from %d to %d\n", vd->fps, setfps->parm.capture.timeperframe.denominator);
                    }
                }
            } else {
                perror("Setting FPS on the capture device is not supported, fallback to software framedropping\n");
                vd->soft_framedrop = 1;
                vd->frame_period_time = 1000/vd->fps; // calcualate frame period time in ms
                IPRINT("Frame period time ......: %ld ms\n", vd->frame_period_time);
            }
        } else {
            perror("Unable to query that the FPS change is supported\n");
        }
    }

    /*
     * request buffers
     */
    memset(&vd->rb, 0, sizeof(struct v4l2_requestbuffers));
    vd->rb.count = NB_BUFFER;
    vd->rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    vd->rb.memory = V4L2_MEMORY_MMAP;

    ret = xioctl(vd->fd, VIDIOC_REQBUFS, &vd->rb);
    if(ret < 0) {
        perror("Unable to allocate buffers");
        goto fatal;
    }

    /*
     * map the buffers
     */
    for(i = 0; i < NB_BUFFER; i++) {
        memset(&vd->buf, 0, sizeof(struct v4l2_buffer));
        vd->buf.index = i;
        vd->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        vd->buf.memory = V4L2_MEMORY_MMAP;
        ret = xioctl(vd->fd, VIDIOC_QUERYBUF, &vd->buf);
        if(ret < 0) {
            perror("Unable to query buffer");
            goto fatal;
        }

        if(debug)
            fprintf(stderr, "length: %u offset: %u\n", vd->buf.length, vd->buf.m.offset);

        vd->mem[i] = mmap(0 /* start anywhere */ ,
                          vd->buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, vd->fd,
                          vd->buf.m.offset);
        if(vd->mem[i] == MAP_FAILED) {
            perror("Unable to map buffer");
            goto fatal;
        }
        if(debug)
            fprintf(stderr, "Buffer mapped at address %p.\n", vd->mem[i]);
    }

    /*
     * Queue the buffers.
     */
    for(i = 0; i < NB_BUFFER; ++i) {
        memset(&vd->buf, 0, sizeof(struct v4l2_buffer));
        vd->buf.index = i;
        vd->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        vd->buf.memory = V4L2_MEMORY_MMAP;
        ret = xioctl(vd->fd, VIDIOC_QBUF, &vd->buf);
        if(ret < 0) {
            perror("Unable to queue buffer");
            goto fatal;;
        }
    }
    return 0;
fatal:
    fprintf(stderr, "Init v4L2 failed !! exit fatal\n");
    return -1;

}

int video_enable(struct vdIn *vd)
{
    int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    int ret;

    ret = xioctl(vd->fd, VIDIOC_STREAMON, &type);
    if(ret < 0) {
        perror("Unable to start capture");
        return ret;
    }
    vd->streamingState = STREAMING_ON;
    return 0;
}

static int video_disable(struct vdIn *vd, streaming_state disabledState)
{
    int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    int ret;
    DBG("STopping capture\n");
    ret = xioctl(vd->fd, VIDIOC_STREAMOFF, &type);
    if(ret != 0) {
        perror("Unable to stop capture");
        return ret;
    }
    DBG("STopping capture done\n");
    vd->streamingState = disabledState;
    return 0;
}

int video_set_dv_timings(struct vdIn *vd)
{
    struct v4l2_dv_timings timings;
    v4l2_std_id std;

    memset(&timings, 0, sizeof(timings));
    if (xioctl(vd->fd, VIDIOC_QUERY_DV_TIMINGS, &timings) >= 0) {
        IPRINT("QUERY_DV_TIMINGS returned %ux%u pixclk %llu\n", timings.bt.width, timings.bt.height, timings.bt.pixelclock);
        // Can read DV timings, so set them.
        if (xioctl(vd->fd, VIDIOC_S_DV_TIMINGS, &timings) < 0) {
            perror("Failed to set DV timings");
            return -1;
        } else {
            vd->width = timings.bt.width;
            vd->height = timings.bt.height;
        }
    } else {
        memset(&std, 0, sizeof(std));
        if (xioctl(vd->fd, VIDIOC_QUERYSTD, &std) >= 0) {
            // Can read standard, so set it.
            if (xioctl(vd->fd, VIDIOC_S_STD, &std) < 0) {
                perror("Failed to set standard");
                return -1;
            }
        }
    }
    return 0;
}

int video_handle_event(struct vdIn *vd)
{
    struct v4l2_event ev;
    if (!ioctl(vd->fd, VIDIOC_DQEVENT, &ev)) {
        switch (ev.type) {
            case V4L2_EVENT_SOURCE_CHANGE:
                IPRINT("V4L2_EVENT_SOURCE_CHANGE: Source changed\n");
                if (setResolution(vd, vd->width, vd->height) < 0) {
                    return -1;
                }
                break;
            case V4L2_EVENT_EOS:
                IPRINT("V4L2_EVENT_EOS\n");
                break;
        }
    }
    return 0;
}

/******************************************************************************
Description.:
Input Value.:
Return Value:
******************************************************************************/
int is_huffman(unsigned char *buf)
{
    unsigned char *ptbuf;
    int i = 0;
    ptbuf = buf;
    while(((ptbuf[0] << 8) | ptbuf[1]) != 0xffda) {
        if(i++ > 2048)
            return 0;
        if(((ptbuf[0] << 8) | ptbuf[1]) == 0xffc4)
            return 1;
        ptbuf++;
    }
    return 0;
}

/******************************************************************************
Description.:
Input Value.:
Return Value:
******************************************************************************/
int memcpy_picture(unsigned char *out, unsigned char *buf, int size)
{
    unsigned char *ptdeb, *ptlimit, *ptcur = buf;
    int sizein, pos = 0;

    if(!is_huffman(buf)) {
        ptdeb = ptcur = buf;
        ptlimit = buf + size;
        while((((ptcur[0] << 8) | ptcur[1]) != 0xffc0) && (ptcur < ptlimit))
            ptcur++;
        if(ptcur >= ptlimit)
            return pos;
        sizein = ptcur - ptdeb;

        memcpy(out + pos, buf, sizein); pos += sizein;
        memcpy(out + pos, dht_data, sizeof(dht_data)); pos += sizeof(dht_data);
        memcpy(out + pos, ptcur, size - sizein); pos += size - sizein;
    } else {
        memcpy(out + pos, ptcur, size); pos += size;
    }
    return pos;
}

int uvcGrab(struct vdIn *vd)
{
#define HEADERFRAME1 0xaf
    int ret;

    if(vd->streamingState == STREAMING_OFF) {
        if(video_enable(vd))
            goto err;
    }
    memset(&vd->buf, 0, sizeof(struct v4l2_buffer));
    vd->buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    vd->buf.memory = V4L2_MEMORY_MMAP;

    ret = xioctl(vd->fd, VIDIOC_DQBUF, &vd->buf);
    if(ret < 0) {
        perror("Unable to dequeue buffer");
        goto err;
    }

    switch(vd->formatIn) {
    case V4L2_PIX_FMT_JPEG:
        // Fall-through intentional
    case V4L2_PIX_FMT_MJPEG:
        if(vd->buf.bytesused <= HEADERFRAME1) {
            /* Prevent crash
             * on empty image */
            fprintf(stderr, "Ignoring empty buffer ...\n");
            break;
        }

        /* memcpy(vd->tmpbuffer, vd->mem[vd->buf.index], vd->buf.bytesused);

        memcpy (vd->tmpbuffer, vd->mem[vd->buf.index], HEADERFRAME1);
        memcpy (vd->tmpbuffer + HEADERFRAME1, dht_data, sizeof(dht_data));
        memcpy (vd->tmpbuffer + HEADERFRAME1 + sizeof(dht_data), vd->mem[vd->buf.index] + HEADERFRAME1, (vd->buf.bytesused - HEADERFRAME1));
        */

        memcpy(vd->tmpbuffer, vd->mem[vd->buf.index], vd->buf.bytesused);
        vd->tmpbytesused = vd->buf.bytesused;
        vd->tmptimestamp = vd->buf.timestamp;

        if(debug) {
            fprintf(stderr, "bytes in used %d \n", vd->buf.bytesused);
        }
        break;
    case V4L2_PIX_FMT_RGB24:
    case V4L2_PIX_FMT_RGB565:
    case V4L2_PIX_FMT_YUYV:
    case V4L2_PIX_FMT_UYVY:
        if(vd->buf.bytesused > vd->framesizeIn) {
            memcpy(vd->framebuffer, vd->mem[vd->buf.index], (size_t) vd->framesizeIn);
        } else {
            memcpy(vd->framebuffer, vd->mem[vd->buf.index], (size_t) vd->buf.bytesused);
        }
        vd->tmpbytesused = vd->buf.bytesused;
        vd->tmptimestamp = vd->buf.timestamp;
        break;
    default:
        goto err;
        break;
    }

    ret = xioctl(vd->fd, VIDIOC_QBUF, &vd->buf);
    if(ret < 0) {
        perror("Unable to requeue buffer");
        goto err;
    }

    return 0;

err:
    vd->signalquit = 0;
    return -1;
}

int close_v4l2(struct vdIn *vd)
{
    if(vd->streamingState == STREAMING_ON)
        video_disable(vd, STREAMING_OFF);
    free_framebuffer(vd);
    free(vd->videodevice);
    free(vd->status);
    free(vd->pictName);
    vd->videodevice = NULL;
    vd->status = NULL;
    vd->pictName = NULL;

    return 0;
}

/* return >= 0 ok otherwhise -1 */
static int isv4l2Control(struct vdIn *vd, int control, struct v4l2_queryctrl *queryctrl)
{
    int err = 0;

    queryctrl->id = control;
    if((err = xioctl(vd->fd, VIDIOC_QUERYCTRL, queryctrl)) < 0) {
        //fprintf(stderr, "ioctl querycontrol error %d \n",errno);
        return -1;
    }

    if(queryctrl->flags & V4L2_CTRL_FLAG_DISABLED) {
        //fprintf(stderr, "control %s disabled \n", (char *) queryctrl->name);
        return -1;
    }

    if(queryctrl->type & V4L2_CTRL_TYPE_BOOLEAN) {
        return 1;
    }

    if(queryctrl->type & V4L2_CTRL_TYPE_INTEGER) {
        return 0;
    }

    fprintf(stderr, "contol %s unsupported  \n", (char *) queryctrl->name);
    return -1;
}

int v4l2GetControl(struct vdIn *vd, int control)
{
    struct v4l2_queryctrl queryctrl;
    struct v4l2_control control_s;
    int err;

    if((err = isv4l2Control(vd, control, &queryctrl)) < 0) {
        return -1;
    }

    control_s.id = control;
    if((err = xioctl(vd->fd, VIDIOC_G_CTRL, &control_s)) < 0) {
        return -1;
    }

    return control_s.value;
}

int v4l2SetControl(struct vdIn *vd, int control_id, int value, int plugin_number, globals *pglobal)
{
    struct v4l2_control control_s;
    int min, max;
    int ret = 0;
    int err;
    int i;
    int got = -1;
    DBG("Looking for the 0x%08x V4L2 control\n", control_id);
    for (i = 0; i<pglobal->in[plugin_number].parametercount; i++) {
        if (pglobal->in[plugin_number].in_parameters[i].ctrl.id == control_id) {
            got = 0;
            break;
        }
    }

    if (got == 0) { // we have found the control with the specified id
        DBG("V4L2 ctrl 0x%08x found\n", control_id);
        if (pglobal->in[plugin_number].in_parameters[i].class_id == V4L2_CTRL_CLASS_USER) {
            DBG("Control type: USER\n");
            min = pglobal->in[plugin_number].in_parameters[i].ctrl.minimum;
            max = pglobal->in[plugin_number].in_parameters[i].ctrl.maximum;

            if((value >= min) && (value <= max)) {
                control_s.id = control_id;
                control_s.value = value;
                if((err = xioctl(vd->fd, VIDIOC_S_CTRL, &control_s)) < 0) {
                    DBG("VIDIOC_S_CTRL failed\n");
                    return -1;
                } else {
                    DBG("V4L2 ctrl 0x%08x new value: %d\n", control_id, value);
                    pglobal->in[plugin_number].in_parameters[i].value = value;
                }
            } else {
                LOG("Value (%d) out of range (%d .. %d)\n", value, min, max);
            }
            return 0;
        } else { // not user class controls
            DBG("Control type: EXTENDED\n");
            struct v4l2_ext_controls ext_ctrls = {0};
            struct v4l2_ext_control ext_ctrl = {0};
            ext_ctrl.id = pglobal->in[plugin_number].in_parameters[i].ctrl.id;

            switch(pglobal->in[plugin_number].in_parameters[i].ctrl.type) {
#ifdef V4L2_CTRL_TYPE_STRING
                case V4L2_CTRL_TYPE_STRING:
                    //string gets set on VIDIOC_G_EXT_CTRLS
                    //add the maximum size to value
                    ext_ctrl.size = value;
                    DBG("STRING extended controls are currently broken\n");
                    //ext_ctrl.string = control->string; // FIXMEE
                    break;
#endif
                case V4L2_CTRL_TYPE_INTEGER64:
                    ext_ctrl.value64 = value;
                    break;
                default:
                    ext_ctrl.value = value;
                    break;
            }

            ext_ctrls.count = 1;
            ext_ctrls.controls = &ext_ctrl;
            ret = xioctl(vd->fd, VIDIOC_S_EXT_CTRLS, &ext_ctrls);
            if(ret) {
                LOG("control id: 0x%08x failed to set value (error %i)\n", ext_ctrl.id, ret);
                return -1;
            } else {
                DBG("control id: 0x%08x new value: %d\n", ext_ctrl.id, ext_ctrl.value);
            }
            return 0;
        }
    } else {
        LOG("Invalid V4L2_set_control request for the id: 0x%08x. Control cannot be found in the list\n", control_id);
        return -1;
    }
}

int v4l2ResetControl(struct vdIn *vd, int control)
{
    struct v4l2_control control_s;
    struct v4l2_queryctrl queryctrl;
    int val_def;
    int err;

    if(isv4l2Control(vd, control, &queryctrl) < 0)
        return -1;

    val_def = queryctrl.default_value;
    control_s.id = control;
    control_s.value = val_def;

    if((err = xioctl(vd->fd, VIDIOC_S_CTRL, &control_s)) < 0) {
        return -1;
    }

    return 0;
}

void control_readed(struct vdIn *vd, struct v4l2_queryctrl *ctrl, globals *pglobal, int id)
{
    struct v4l2_control c;
    memset(&c, 0, sizeof(struct v4l2_control));
    c.id = ctrl->id;

    if (pglobal->in[id].in_parameters == NULL) {
        pglobal->in[id].in_parameters = (control*)calloc(1, sizeof(control));
    } else {
        pglobal->in[id].in_parameters =
        (control*)realloc(pglobal->in[id].in_parameters,(pglobal->in[id].parametercount + 1) * sizeof(control));
    }

    if (pglobal->in[id].in_parameters == NULL) {
        DBG("Calloc failed\n");
        return;
    }

    memcpy(&pglobal->in[id].in_parameters[pglobal->in[id].parametercount].ctrl, ctrl, sizeof(struct v4l2_queryctrl));
    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].group = IN_CMD_V4L2;
    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = c.value;
    if(ctrl->type == V4L2_CTRL_TYPE_MENU) {
        pglobal->in[id].in_parameters[pglobal->in[id].parametercount].menuitems =
            (struct v4l2_querymenu*)malloc((ctrl->maximum + 1) * sizeof(struct v4l2_querymenu));
        int i;
        for(i = ctrl->minimum; i <= ctrl->maximum; i++) {
            struct v4l2_querymenu qm;
            memset(&qm, 0 , sizeof(struct v4l2_querymenu));
            qm.id = ctrl->id;
            qm.index = i;
            if(xioctl(vd->fd, VIDIOC_QUERYMENU, &qm) == 0) {
                memcpy(&pglobal->in[id].in_parameters[pglobal->in[id].parametercount].menuitems[i], &qm, sizeof(struct v4l2_querymenu));
                DBG("Menu item %d: %s\n", qm.index, qm.name);
            } else {
                DBG("Unable to get menu item for %s, index=%d\n", ctrl->name, qm.index);
            }
        }
    } else {
        pglobal->in[id].in_parameters[pglobal->in[id].parametercount].menuitems = NULL;
    }

    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = 0;
    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].class_id = (ctrl->id & 0xFFFF0000);
#ifndef V4L2_CTRL_FLAG_NEXT_CTRL
    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].class_id = V4L2_CTRL_CLASS_USER;
#endif

    int ret = -1;
    if (pglobal->in[id].in_parameters[pglobal->in[id].parametercount].class_id == V4L2_CTRL_CLASS_USER) {
        DBG("V4L2 parameter found: %s value %d Class: USER \n", ctrl->name, c.value);
        ret = xioctl(vd->fd, VIDIOC_G_CTRL, &c);
        if(ret == 0) {
            pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = c.value;
        } else {
            DBG("Unable to get the value of %s retcode: %d  %s\n", ctrl->name, ret, strerror(errno));
        }
    } else {
        DBG("V4L2 parameter found: %s value %d Class: EXTENDED \n", ctrl->name, c.value);
        struct v4l2_ext_controls ext_ctrls = {0};
        struct v4l2_ext_control ext_ctrl = {0};
        ext_ctrl.id = ctrl->id;
#ifdef V4L2_CTRL_TYPE_STRING
        ext_ctrl.size = 0;
        if(ctrl.type == V4L2_CTRL_TYPE_STRING) {
            ext_ctrl.size = ctrl->maximum + 1;
            // FIXMEEEEext_ctrl.string = control->string;
        }
#endif
        ext_ctrls.count = 1;
        ext_ctrls.controls = &ext_ctrl;
        ret = xioctl(vd->fd, VIDIOC_G_EXT_CTRLS, &ext_ctrls);
        if(ret) {
            switch (ext_ctrl.id) {
                case V4L2_CID_PAN_RESET:
                    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = 1;
                    DBG("Setting PAN reset value to 1\n");
                    break;
                case V4L2_CID_TILT_RESET:
                    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = 1;
                    DBG("Setting the Tilt reset value to 2\n");
                    break;
                case V4L2_CID_PANTILT_RESET_LOGITECH:
                    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = 3;
                    DBG("Setting the PAN/TILT reset value to 3\n");
                    break;
                default:
                    DBG("control id: 0x%08x failed to get value (error %i)\n", ext_ctrl.id, ret);
            }
        } else {
            switch(ctrl->type)
            {
#ifdef V4L2_CTRL_TYPE_STRING
                case V4L2_CTRL_TYPE_STRING:
                    //string gets set on VIDIOC_G_EXT_CTRLS
                    //add the maximum size to value
                    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = ext_ctrl.size;
                    break;
#endif
                case V4L2_CTRL_TYPE_INTEGER64:
                    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = ext_ctrl.value64;
                    break;
                default:
                    pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = ext_ctrl.value;
                    break;
            }
        }
    }

    pglobal->in[id].parametercount++;
}

/*  It should set the capture resolution
    Cheated from the openCV cap_libv4l.cpp the method is the following:
    Turn off the stream (video_disable)
    Unmap buffers
    Close the filedescriptor
    Initialize the camera again with the new resolution
*/
int setResolution(struct vdIn *vd, int width, int height)
{
    vd->streamingState = STREAMING_PAUSED;
    if (video_disable(vd, STREAMING_PAUSED) < 0) {
        IPRINT("Unable to disable streaming\n");
        return -1;
    }

    DBG("Unmap buffers\n");
    int i;
    for (i = 0; i < NB_BUFFER; i++) {
        munmap(vd->mem[i], vd->buf.length);
    }

    if (CLOSE_VIDEO(vd->fd) == 0) {
        DBG("Device closed successfully\n");
    }

    vd->width = width;
    vd->height = height;
    if (init_v4l2(vd) < 0) {
        return -1;
    }

    free_framebuffer(vd);
    if (init_framebuffer(vd) < 0) {
        IPRINT("Can\'t reallocate framebuffer\n");
        return -1;
    }

    DBG("Resolution changed to %dx%d , enabling the video...\n", width, height);
    if (video_enable(vd) < 0) {
        IPRINT("Can\'t RE-enable the video after setResolution(%dx%d)", width, height);
        return -1;
    }

    return 0;
}

/*
 *
 * Enumarates all V4L2 controls using various methods.
 * It places them to the
 *
 */

void enumerateControls(struct vdIn *vd, globals *pglobal, int id)
{
    // enumerating v4l2 controls
    struct v4l2_queryctrl ctrl;
    memset(&ctrl, 0, sizeof(struct v4l2_queryctrl));
    pglobal->in[id].parametercount = 0;
    pglobal->in[id].in_parameters = malloc(0 * sizeof(control));
    /* Enumerate the v4l2 controls
     Try the extended control API first */
#ifdef V4L2_CTRL_FLAG_NEXT_CTRL
    DBG("V4L2 API's V4L2_CTRL_FLAG_NEXT_CTRL is supported\n");
    ctrl.id = V4L2_CTRL_FLAG_NEXT_CTRL;
    if(0 == IOCTL_VIDEO(vd->fd, VIDIOC_QUERYCTRL, &ctrl)) {
        do {
            control_readed(vd, &ctrl, pglobal, id);
            ctrl.id |= V4L2_CTRL_FLAG_NEXT_CTRL;
        } while(0 == IOCTL_VIDEO(vd->fd, VIDIOC_QUERYCTRL, &ctrl));
        // note: use simple ioctl or v4l2_ioctl instead of the xioctl
    } else
#endif
    {
        DBG("V4L2 API's V4L2_CTRL_FLAG_NEXT_CTRL is NOT supported\n");
        /* Fall back on the standard API */
        /* Check all the standard controls */
        int i;
        for(i = V4L2_CID_BASE; i < V4L2_CID_LASTP1; i++) {
            ctrl.id = i;
            if(IOCTL_VIDEO(vd->fd, VIDIOC_QUERYCTRL, &ctrl) == 0) {
                control_readed(vd, &ctrl, pglobal, id);
            }
        }

        /* Check any custom controls */
        for(i = V4L2_CID_PRIVATE_BASE; ; i++) {
            ctrl.id = i;
            if(IOCTL_VIDEO(vd->fd, VIDIOC_QUERYCTRL, &ctrl) == 0) {
                control_readed(vd, &ctrl, pglobal, id);
            } else {
                break;
            }
        }
    }

    memset(&pglobal->in[id].jpegcomp, 0, sizeof(struct v4l2_jpegcompression));
    if(xioctl(vd->fd, VIDIOC_G_JPEGCOMP, &pglobal->in[id].jpegcomp) != EINVAL) {
        DBG("JPEG compression details:\n");
        DBG("Quality: %d\n", pglobal->in[id].jpegcomp.quality);
        DBG("APPn: %d\n", pglobal->in[id].jpegcomp.APPn);
        DBG("APP length: %d\n", pglobal->in[id].jpegcomp.APP_len);
        DBG("APP data: %s\n", pglobal->in[id].jpegcomp.APP_data);
        DBG("COM length: %d\n", pglobal->in[id].jpegcomp.COM_len);
        DBG("COM data: %s\n", pglobal->in[id].jpegcomp.COM_data);
        struct v4l2_queryctrl ctrl_jpeg;
        ctrl_jpeg.id = 1;
        sprintf((char*)&ctrl_jpeg.name, "JPEG quality");
        ctrl_jpeg.minimum = 0;
        ctrl_jpeg.maximum = 100;
        ctrl_jpeg.step = 1;
        ctrl_jpeg.default_value = 50;
        ctrl_jpeg.flags = 0;
        ctrl_jpeg.type = V4L2_CTRL_TYPE_INTEGER;
        if (pglobal->in[id].in_parameters == NULL) {
            pglobal->in[id].in_parameters = (control*)calloc(1, sizeof(control));
        } else {
            pglobal->in[id].in_parameters = (control*)realloc(pglobal->in[id].in_parameters,(pglobal->in[id].parametercount + 1) * sizeof(control));
        }

        if (pglobal->in[id].in_parameters == NULL) {
            DBG("Calloc/realloc failed\n");
            return;
        }

        memcpy(&pglobal->in[id].in_parameters[pglobal->in[id].parametercount].ctrl, &ctrl_jpeg, sizeof(struct v4l2_queryctrl));
        pglobal->in[id].in_parameters[pglobal->in[id].parametercount].group = IN_CMD_JPEG_QUALITY;
        pglobal->in[id].in_parameters[pglobal->in[id].parametercount].value = pglobal->in[id].jpegcomp.quality;
        pglobal->in[id].parametercount++;
    } else {
        DBG("Modifying the setting of the JPEG compression is not supported\n");
        pglobal->in[id].jpegcomp.quality = -1;
    }
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input_uvc/v4l2uvc.h
================
/*******************************************************************************
# Linuc-UVC streaming input-plugin for MJPG-streamer                           #
#                                                                              #
# This package work with the Logitech UVC based webcams with the mjpeg feature #
#                                                                              #
# Copyright (C) 2005 2006 Laurent Pinchart &&  Michel Xhaard                   #
#                    2007 Lucas van Staden                                     #
#                    2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#ifndef V4L2_UVC_H
#define V4L2_UVC_H


#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/select.h>

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "../../mjpg_streamer.h"
#define NB_BUFFER 4


#define IOCTL_RETRY 4

/* ioctl with a number of retries in the case of I/O failure
* args:
* fd - device descriptor
* IOCTL_X - ioctl reference
* arg - pointer to ioctl data
* returns - ioctl result
*/
int xioctl(int fd, int IOCTL_X, void *arg);

#ifdef USE_LIBV4L2
#include <libv4l2.h>
#define IOCTL_VIDEO(fd, req, value) v4l2_ioctl(fd, req, value)
#define OPEN_VIDEO(fd, flags) v4l2_open(fd, flags)
#define CLOSE_VIDEO(fd) v4l2_close(fd)
#else
#define IOCTL_VIDEO(fd, req, value) ioctl(fd, req, value)
#define OPEN_VIDEO(fd, flags) open(fd, flags)
#define CLOSE_VIDEO(fd) close(fd)
#endif

typedef enum _streaming_state streaming_state;
enum _streaming_state {
    STREAMING_OFF = 0,
    STREAMING_ON = 1,
    STREAMING_PAUSED = 2,
};

struct vdIn {
    int fd;
    char *videodevice;
    char *status;
    char *pictName;
    struct v4l2_capability cap;
    struct v4l2_format fmt;
    struct v4l2_buffer buf;
    struct v4l2_requestbuffers rb;
    void *mem[NB_BUFFER];
    unsigned char *tmpbuffer;
    unsigned char *framebuffer;
    streaming_state streamingState;
    int grabmethod;
    int width;
    int height;
    int fps;
    int formatIn;
    int formatOut;
    int framesizeIn;
    int signalquit;
    int toggleAvi;
    int getPict;
    int rawFrameCapture;
    /* raw frame capture */
    unsigned int fileCounter;
    /* raw frame stream capture */
    unsigned int rfsFramesWritten;
    unsigned int rfsBytesWritten;
    /* raw stream capture */
    FILE *captureFile;
    unsigned int framesWritten;
    unsigned int bytesWritten;
    int framecount;
    int recordstart;
    int recordtime;
    uint32_t tmpbytesused;
    struct timeval tmptimestamp;
    v4l2_std_id vstd;
    unsigned long frame_period_time; // in ms
    unsigned char soft_framedrop;
    unsigned int dv_timings;
};

/* optional initial settings */
typedef struct {
    int quality_set, quality,
        sh_set, sh,
        co_set, co,
        br_set, br_auto, br,
        sa_set, sa,
        wb_set, wb_auto, wb,
        ex_set, ex_auto, ex,
        bk_set, bk,
        rot_set, rot,
        hf_set, hf,
        vf_set, vf,
        pl_set, pl,
        gain_set, gain_auto, gain,
        cagc_set, cagc_auto, cagc,
        cb_set, cb_auto, cb;
} context_settings;

/* context of each camera thread */
typedef struct {
    int id;
    globals *pglobal;
    pthread_t threadID;
    pthread_mutex_t controls_mutex;
    struct vdIn *videoIn;
    context_settings *init_settings;
} context;

int init_videoIn(struct vdIn *vd, char *device, int width, int height, int fps, int format, int grabmethod, globals *pglobal, int id, v4l2_std_id vstd);
void enumerateControls(struct vdIn *vd, globals *pglobal, int id);
void control_readed(struct vdIn *vd, struct v4l2_queryctrl *ctrl, globals *pglobal, int id);
int setResolution(struct vdIn *vd, int width, int height);

int memcpy_picture(unsigned char *out, unsigned char *buf, int size);
int uvcGrab(struct vdIn *vd);
int close_v4l2(struct vdIn *vd);

int video_enable(struct vdIn *vd);
int video_set_dv_timings(struct vdIn *vd);
int video_handle_event(struct vdIn *vd);

int v4l2GetControl(struct vdIn *vd, int control);
int v4l2SetControl(struct vdIn *vd, int control, int value, int plugin_number, globals *pglobal);
int v4l2UpControl(struct vdIn *vd, int control);
int v4l2DownControl(struct vdIn *vd, int control);
int v4l2ToggleControl(struct vdIn *vd, int control);
int v4l2ResetControl(struct vdIn *vd, int control);

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_autofocus/Makefile
================
###############################################################
#
# Purpose: Makefile for "M-JPEG Streamer"
# Author.: Tom Stoeveken (TST)
# Version: 0.3
# License: GPL
#
###############################################################

CC = gcc

OTHER_HEADERS = ../../mjpg_streamer.h ../../utils.h ../output.h ../input.h

#CFLAGS += -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC
CFLAGS += -DDEBUG -O2 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC
LFLAGS += -lpthread -ldl

all: output_autofocus.so

clean:
	rm -f *.a *.o core *~ *.so *.lo

output_autofocus.so: $(OTHER_HEADERS) output_autofocus.c processJPEG_onlyCenter.lo
	$(CC) $(CFLAGS) -lm -o $@ output_autofocus.c processJPEG_onlyCenter.lo

processJPEG_onlyCenter.lo: $(OTHER_HEADERS) processJPEG_onlyCenter.h
	$(CC) -c $(CFLAGS) -o $@ processJPEG_onlyCenter.c

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_autofocus/output_autofocus.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "../../utils.h"
#include "../../mjpg_streamer.h"

#include "processJPEG_onlyCenter.h"

#define OUTPUT_PLUGIN_NAME "autofocus output plugin"

static pthread_t worker;
static globals *pglobal;
static int fd, delay;
static unsigned char *frame = NULL;
static int input_number;

/******************************************************************************
Description.: print a help message
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
            " Help for output plugin..: "OUTPUT_PLUGIN_NAME"\n" \
            " ---------------------------------------------------------------\n" \
            " The following parameters can be passed to this plugin:\n\n" \
            " [-d | --delay ].........: delay after saving pictures in ms\n" \
            " ---------------------------------------------------------------\n");
}

/******************************************************************************
Description.: clean up allocated resources
Input Value.: unused argument
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
    OPRINT("cleaning up resources allocated by worker thread\n");

    free(frame);
    close(fd);
}



/******************************************************************************
Description.: this is the main worker thread
              it loops forever, grabs a fresh frame and calculates focus
Input Value.:
Return Value:
******************************************************************************/
void *worker_thread(void *arg)
{
    int frame_size = 0;
    double sv = -1.0, max_sv = 100.0, delta = 500;
    int focus = 255, step = 10, max_focus = 100, search_focus = 1;

    if((frame = malloc(256 * 1024)) == NULL) {
        OPRINT("not enough memory for worker thread\n");
        exit(EXIT_FAILURE);
    }

    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, NULL);

    while(!pglobal->stop) {
        DBG("waiting for fresh frame\n");
        pthread_mutex_lock(&pglobal->in[input_number].db);
        pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

        /* read buffer */
        frame_size = pglobal->in[input_number].size;
        memcpy(frame, pglobal->in[input_number].buf, frame_size);

        pthread_mutex_unlock(&pglobal->in[input_number].db);

        /* process frame */
        sv = getFrameSharpnessValue(frame, frame_size);
        DBG("sharpness is: %f\n", sv);

        if(search_focus || (ABS(sv - max_sv) > delta)) {
            DBG("adjusting focus: %d\n", focus);

            /* entered because focus changed */
            if(!search_focus) {
                DBG("starting to search for focus\n");
                max_focus    = 255;
                focus        = 255;
                max_sv       = -1.0;
                search_focus = 1;
            }

            if(focus <= 0) {
                focus = max_focus;
                DBG("max focus found at: %d\n", max_focus);
                search_focus = 0;
            }

            if(search_focus) {
                if(sv > max_sv) {
                    /* sharpness is better then max now */
                    DBG("found better focus at: %d\n", focus);
                    max_focus = focus;
                    max_sv = sv;
                }

                focus = MIN(MAX(focus - step, 0), 255);
                DBG("decrement focus now to: %d\n", focus);
                //focus = pglobal->in.cmd(IN_CMD_FOCUS_SET, focus);
            }
        }

        if((delay > 0) && !search_focus) {
            usleep(1000 * delay);
        }
    }

    pthread_cleanup_pop(1);

    return NULL;
}

/*** plugin interface functions ***/
/******************************************************************************
Description.: this function is called first, in order to initialise
              this plugin and pass a parameter string
Input Value.: parameters
Return Value: 0 if everything is ok, non-zero otherwise
******************************************************************************/
int output_init(output_parameter *param)
{
    int i;

    delay = 10000;

    param->argv[0] = OUTPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"d", required_argument, 0, 0},
            {"delay", required_argument, 0, 0},
            {"i", required_argument, 0, 0},
            {"input", required_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

            /* d, delay */
        case 2:
        case 3:
            DBG("case 2,3\n");
            delay = atoi(optarg);
            break;
            /* i input */
        case 4:
        case 5:
            input_number = atoi(optarg);
            break;
        }
    }

    pglobal = param->global;

    OPRINT("delay.............: %d\n", delay);
    return 0;
}

/******************************************************************************
Description.: calling this function stops the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_stop(int id)
{
    DBG("will cancel worker thread\n");
    pthread_cancel(worker);
    return 0;
}

/******************************************************************************
Description.: calling this function creates and starts the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_run(int id)
{
    DBG("launching worker thread\n");
    pthread_create(&worker, 0, worker_thread, NULL);
    pthread_detach(worker);
    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_autofocus/processJPEG_onlyCenter.c
================
/*******************************************************************************
#   processJPEG_onlyCenter: sharpness estimates via JPEG AC coefficients       #
# Based on partial JPEG decompress on the camera JPEG images                   #
#                                                                              #
#   Copyright (C) 2007 Alexander K. Seewald <alex@seewald.at>                  #
#   Many helpful suggestions and improvements due to Richard Atterer           #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; either version 2 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <stdio.h>
#include <assert.h>
#include <malloc.h>
#include <math.h>
#include <stdlib.h>

#include "processJPEG_onlyCenter.h"

double getFrameSharpnessValue(unsigned char *data, int len)
{
    int Gpos = 0;
    char c; unsigned short int cnt; int i;
    int cnt2 = 0;
    unsigned char uc;
    assert(sizeof(cnt) == 2);
    assert(sizeof(int) == 4);
    unsigned char *buffer;
    double sumAC[64];
    double sumSqrAC[64];

    int width = -1; int height = -1;
    int huffman_DCY = -1; int huffman_ACY = -1;
    int quant_Y = -1;
    int scaleH_Y = 0; int scaleV_Y = 0;

    unsigned char dht_lookup_bitlen[4][162];
    unsigned int dht_lookup_bits[4][162];
    unsigned int dht_lookup_mask[4][162];
    unsigned char dht_lookup_code[4][162];
    unsigned char dht_lookup_size[4];

    float *QT[4] = { NULL, NULL, NULL, NULL };

    unsigned int mask[17] = { 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff };

    char fgetc_(void) {
        return data[Gpos++];
    }

    while(!(Gpos >= len)) {
        c = fgetc_();
        while(c != '\xff') {
            c = fgetc_();
        }
        c = fgetc_();
        if(c == '\xd8' || c == '\xe0' || c == '\x00') {
            continue;
        } else if(c == '\xdb') { // read in quantization table
            c = fgetc_(); cnt = (unsigned char)(c) * 256;
            c = fgetc_(); cnt += (unsigned char)(c);
            assert(cnt == 67);
            uc = fgetc_(); if((uc >> 4) != 0) {
                fprintf(stderr, "16bit quantization table not supported\n");
                exit(-1);
            }
            int tab = uc & 0x0f;
            QT[tab] = (float *)malloc(64 * sizeof(float));
            unsigned char hc = 0; int j;
            for(j = 0; j < 64; j++) {
                uc = fgetc_(); QT[tab][j] = (float)uc;
                hc ^= uc;
            }
        } else if(c == '\xc4') { // read in huffmann table
            // 0 and 2 are DC tables (0-15), 1 and 3 are AC tables (0-255)
            c = fgetc_(); cnt = (unsigned char)(c) * 256;
            c = fgetc_(); cnt += (unsigned char)(c);
            buffer = data + Gpos; Gpos += cnt - 2;

            // parse huffman table...
            int pos = 0; unsigned short int tab = 0;
            do {
                uc = buffer[pos]; pos++;
                tab = (uc >> 4) + (uc & 0x0f) * 2;
                tab = (uc & 0x0f) * 2 + (uc >> 4);
                int pos2 = pos + 16;
                unsigned char DhtCodesLen[16];
                int i_len; int table_ind = 0;
                int code_val = 0; int ind_code;
                for(i_len = 1; i_len <= 16; i_len++) {
                    DhtCodesLen[i_len-1] = (unsigned char)(buffer[pos+i_len-1]);
                    for(ind_code = 0; ind_code < DhtCodesLen[i_len-1]; ind_code++) {
                        dht_lookup_code[tab][table_ind] = buffer[pos2++];
                        dht_lookup_bits[tab][table_ind] = (code_val << (32 - i_len));
                        dht_lookup_mask[tab][table_ind] = ((1 << (i_len)) - 1) << (32 - i_len);
                        dht_lookup_bitlen[tab][table_ind] = i_len;

                        table_ind++; code_val++;
                    }
                    code_val <<= 1;
                }
                dht_lookup_size[tab] = table_ind;
                pos = pos2;
            } while(pos < cnt - 2);
        } else if(c == '\xda') { // start frame, followed by entropy-coded data
            c = fgetc_(); assert(c == '\x00');
            c = fgetc_(); assert(c == '\x0c'); // length: 12
            c = fgetc_(); assert(c == '\x03'); // three components
            for(i = 0; i < 3; i++) {
                int comp_id;
                c = fgetc_(); comp_id = c;
                c = fgetc_();
                if(comp_id == 1) { // Y
                    huffman_DCY = (unsigned)(c) >> 4;
                    huffman_ACY = (unsigned)(c) & 0x0f;
                }
            }
            // Y: 0/0, Cb & Cr: 1/1
            c = fgetc_(); c = fgetc_(); c = fgetc_(); // skip three bytes

            int data; uc = fgetc_(); int bitlen = 16; int bits_used = 0;
            data = uc << 24; uc = fgetc_(); data |= uc << 16;

            // read one XC coefficient from any table via huffmann code
            int readXC(int tab) {
                while(bitlen < 16) {
                    uc = fgetc_();
                    data = data | (uc << (24 - bitlen));
                    bitlen += 8;
                    if(((char)uc) == '\xff') {
                        uc = fgetc_();
                        if(((char)uc) == '\x00') {
                            uc = fgetc_();
                        }
                        data = data | (uc << (24 - bitlen));
                        bitlen += 8;
                    }
                }
                int ind = 0; int done = 0; int res = -1;
                while(done == 0) {
                    if((data & dht_lookup_mask[tab][ind]) == dht_lookup_bits[tab][ind]) {
                        res = dht_lookup_code[tab][ind];
                        bits_used = dht_lookup_bitlen[tab][ind];
                        done = 1;
                    }
                    ind++;

                    if(ind >= dht_lookup_size[tab]) {
                        /*fprintf(stderr,"Code not found in huffmann table.\n");*/ return -1;
                    }
                }
                data = data << bits_used; bitlen -= bits_used;
                while(bitlen < 16) {
                    uc = fgetc_();
                    data = data | (uc << (24 - bitlen));
                    bitlen += 8;
                    if(((char)uc) == '\xff') {
                        uc = fgetc_();
                        if(((char)uc) == '\x00') {
                            uc = fgetc_();
                        }
                        data = data | (uc << (24 - bitlen));
                        bitlen += 8;
                    }
                }
                return res;
            }

            int readTable(int tabDC, int tabAC, int * lastDC, int * table) {
                int j;
                for(j = 0; j < 64; j++) {
                    table[j] = 0;
                }
                int size_val = readXC(tabDC); if(size_val < 0) {
                    return -1;
                }
                int DC = (data >> (32 - size_val)) & mask[size_val]; data <<= size_val; bitlen -= size_val; // true value is next size_val bits
                DC = HUFF_EXTEND(DC, size_val); DC += *lastDC; *lastDC = DC;
                table[0] = DC;
                j = 0; int EOB = 0;
                while(j < 63 && (EOB == 0)) {
                    int comb = readXC(tabAC); if(comb < 0) {
                        return -1;
                    }
                    int val = comb & 0x0f;
                    int repeat = comb >> 4;
                    if(val == 0) {
                        if(repeat == 0x0f) {
                            j += 16;
                        } else {
                            EOB = 1;
                        }
                    } else {
                        j += repeat;
                        DC = (data >> (32 - val)) & mask[val]; data <<= val; bitlen -= val;
                        DC = HUFF_EXTEND(DC, val); table[j+1] = DC; j++;
                    }
                }
                if(j <= 63) {
                    return 0;
                } else {
                    /*fprintf(stderr,"ERROR: too many AC entries: %d\n",j);*/ return -1;
                }
            }

            cnt = ((int)(width / 8 / scaleH_Y + 0.5)) * ((int)(height / 8 / scaleV_Y + 0.5));

            int ctx = (int)(width / 8 + 0.5); int cty = (int)(height / 8 + 0.5);
            ctx /= 2; cty /= 2; int rad = ctx / 2; if(cty < ctx) {
                rad = cty / 2;
            }
            rad = rad * rad;
            int xp = 0; int yp = 0;

            int lastDCY = 0; int lastDCCr = 0; int lastDCCb = 0;
            int j; for(j = 0; j < 64; j++) {
                sumAC[j] = 0.0;
                sumSqrAC[j] = 0.0;
            }
            for(i = 0; i < cnt; i++) {
                int table[128];

                if(readTable(huffman_DCY, huffman_ACY + 1, &lastDCY, table) < 0) {
                    goto err;
                }

                // weight by distance to center (gaussian?)
                double xp_ = xp - ctx; double yp_ = yp - ctx;
                double weight = exp(-(xp_ * xp_) / rad - (yp_ * yp_) / rad);
                for(j = 0; j < 64; j++) {
                    double x = (table[j] * QT[0][j]) * (table[j] * QT[0][j]) * weight;
                    sumAC[j] += x;
                    sumSqrAC[j] += x * x;
                }
                cnt2++;
                xp++;
                if(readTable(huffman_DCY, huffman_ACY + 1, &lastDCY, table) < 0) {
                    goto err;
                }
                xp_ = xp - ctx; yp_ = yp - ctx;
                weight = exp(-(xp_ * xp_) / rad - (yp_ * yp_) / rad);
                for(j = 0; j < 64; j++) {
                    double x = (table[j] * QT[0][j]) * (table[j] * QT[0][j]) * weight;
                    sumAC[j] += x;
                    sumSqrAC[j] += x * x;
                }
                cnt2++;

                // ignore  C components
                if(readTable(2, 3, &lastDCCr, table) < 0) {
                    goto err;
                }
                if(readTable(2, 3, &lastDCCb, table) < 0) {
                    goto err;
                }

                xp++; if(xp == (int)(width / 8 + 0.5)) {
                    xp = 0;
                    yp++;
                }
            }
        } else if(c == '\xd9') { // end of file
        } else if(c == '\xc0') { // start of frame
            c = fgetc_(); cnt = (unsigned char)(c) * 256;
            c = fgetc_(); cnt += (unsigned char)(c);

            uc = fgetc_();
            c = fgetc_(); cnt = (unsigned char)(c) * 256;
            c = fgetc_(); cnt += (unsigned char)(c);
            height = cnt;
            c = fgetc_(); cnt = (unsigned char)(c) * 256;
            c = fgetc_(); cnt += (unsigned char)(c);
            width = cnt;
            uc = fgetc_();
            assert((int)uc == 3);

            int j;
            for(j = 0; j < uc; j++) {
                c = fgetc_(); int id = (unsigned)c;
                c = fgetc_();
                if(c != '\x11') {
                    if(id == 1) {
                        scaleH_Y = ((unsigned)c) >> 4;
                        scaleV_Y = ((unsigned)c) & 0x0f;
                    } else {
                        fprintf(stderr, "Sampling > 1 not supported for non-Y channels.\n");
                        exit(-2);
                    }
                }
                c = fgetc_();
                if(id == 1) {
                    quant_Y = (unsigned)c;
                }
            }
        } else {
        }
    }
    int j; int lenCurSeq = 2; int lenPrevTotal = 1; int valCurSeq = 1;
    double sum = 0.0;
    for(j = 0; j < 4; j++) {
        free(QT[j]);
    }
    for(j = 1; j < 21; j++) {
        if(j >= lenPrevTotal + lenCurSeq) {
            lenCurSeq++;
            lenPrevTotal = j;
            valCurSeq++;
        }
        sumAC[j] /= (double)(cnt2);
        sum += (double)valCurSeq * sumAC[j];
    }
    return sum;

err:
    return -1.0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_autofocus/processJPEG_onlyCenter.h
================
#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))

// haven't done restart markers, but these don't seem to appear
double getFrameSharpnessValue(unsigned char *data, int len);

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_file/examples/change_filename.sh
================
#!/bin/bash

################################################################################
#
# If you do not like the default filename it can be changed easily
#
# The ringbuffer feature will not work if the filename is changed!
#
################################################################################

mv "$1" "/tmp/picture.jpg"

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_file/examples/ftp_upload.sh
================
#!/bin/bash

################################################################################
#
# Upload image using FTP and the tool wput
#
################################################################################

# Configuration ################################################################
USERNAME="username"
PASSWORD="password"
SERVER="server.com"

# if the filename should be constant, just define it here as well
# if subfolders do not exists, wput will create them automatically
SERVERPATH="/path/to/file.jpg"

################################################################################
# check if required tool exists
RES="$(which wput)"
if [ $? -ne 0 ]; then
  echo "please install the tool wput"
  exit 1
fi

# upload it now
RES="$(wput --reupload "$1" "ftp://${USERNAME}:${PASSWORD}@${SERVER}${SERVERPATH}")"

# check if it went alright
if [ $? -ne 0 ]; then
  echo "wput failed, dumping output..."
  echo "$RES"
  exit 1
fi

exit 0

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_file/examples/show_filename.sh
================
#!/bin/bash

################################################################################
# This example just displays the filename of the just created file
#
#
################################################################################

# the last created filename is passed by two different variables
echo "Just stored the file ${MJPG_FILE}, which equals ${1}"

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_file/CMakeLists.txt
================
MJPG_STREAMER_PLUGIN_OPTION(output_file "File output plugin")
MJPG_STREAMER_PLUGIN_COMPILE(output_file output_file.c)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_file/output_file.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>
#include <dirent.h>

#include "output_file.h"

#include "../../utils.h"
#include "../../mjpg_streamer.h"

#define OUTPUT_PLUGIN_NAME "FILE output plugin"

static pthread_t worker;
static globals *pglobal;
static int fd, delay, ringbuffer_size = -1, ringbuffer_exceed = 0, max_frame_size;
static char *folder = "/tmp";
static unsigned char *frame = NULL;
static char *command = NULL;
static int input_number = 0;
static char *mjpgFileName = NULL;
static char *linkFileName = NULL;

/******************************************************************************
Description.: print a help message
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
            " Help for output plugin..: "OUTPUT_PLUGIN_NAME"\n" \
            " ---------------------------------------------------------------\n" \
            " The following parameters can be passed to this plugin:\n\n" \
            " [-f | --folder ]........: folder to save pictures\n" \
            " [-m | --mjpeg ].........: save the frames to an mjpg file \n" \
            " [-l | --link ]..........: link the last picture in ringbuffer as this fixed named file\n" \
            " [-d | --delay ].........: delay after saving pictures in ms\n" \
            " [-i | --input ].........: read frames from the specified input plugin\n" \
            " The following arguments are takes effect only if the current mode is not MJPG\n" \
            " [-s | --size ]..........: size of ring buffer (max number of pictures to hold)\n" \
            " [-e | --exceed ]........: allow ringbuffer to exceed limit by this amount\n" \
            " [-c | --command ].......: execute command after saving picture\n"\
            " ---------------------------------------------------------------\n");
}

/******************************************************************************
Description.: clean up allocated resources
Input Value.: unused argument
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if (mjpgFileName != NULL) {
        close(fd);
    }

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
    OPRINT("cleaning up resources allocated by worker thread\n");

    if(frame != NULL) {
        free(frame);
    }
    close(fd);
}

/******************************************************************************
Description.: compares a directory entry with a pattern
Input Value.: directory entry
Return Value: 0 if string do not match, 1 if they match
******************************************************************************/
int check_for_filename(const struct dirent *entry)
{
    int rc;

    int year, month, day, hour, minute, second;
    unsigned long long number;

    /*
     * try to scan the string using scanf
     * I would like to use a define for this format string later...
     */
    rc = sscanf(entry->d_name, "%d_%d_%d_%d_%d_%d_picture_%09llu.jpg", &year, \
                &month, \
                &day, \
                &hour, \
                &minute, \
                &second, \
                &number);

    DBG("%s, rc is %d (%d, %d, %d, %d, %d, %d, %llu)\n", entry->d_name, \
        rc, \
        year, \
        month, \
        day, \
        hour, \
        minute, \
        second, \
        number);

    /* if scanf could find all values, it matches our filenames */
    if(rc != 7) return 0;

    return 1;
}

/******************************************************************************
Description.: delete oldest files, just keep "size" most recent files
              This funtion MAY delete the wrong files if the time is not valid
Input Value.: how many files to keep
Return Value: -
******************************************************************************/
void maintain_ringbuffer(int size)
{
    struct dirent **namelist;
    int n, i;
    char buffer[1<<16];

    /* do nothing if ringbuffer is not set or wrong value is set */
    if(size < 0) return;

    /* get a sorted list of directory items */
    n = scandir(folder, &namelist, check_for_filename, alphasort);
    if(n < 0) {
        perror("scandir");
        return;
    }

    DBG("found %d directory entries\n", n);

    /* delete the first (thus oldest) number of files */
    for(i = 0; i < (n - size); i++) {

        /* put together the folder name and the directory item */
        snprintf(buffer, sizeof(buffer), "%s/%s", folder, namelist[i]->d_name);

        DBG("delete: %s\n", buffer);

        /* mark item for deletion */
        if(unlink(buffer) == -1) {
            perror("could not delete file");
        }

        /* free allocated memory for name */
        free(namelist[i]);
    }

    /* keep the rest, but we still have to free every result */
    for(i = MAX(n - size, 0); i < n; i++) {
        DBG("keep: %s\n", namelist[i]->d_name);
        free(namelist[i]);
    }

    /* free last just allocated resources */
    free(namelist);
}

/******************************************************************************
Description.: this is the main worker thread
              it loops forever, grabs a fresh frame and stores it to file
Input Value.:
Return Value:
******************************************************************************/
void *worker_thread(void *arg)
{
    int ok = 1, frame_size = 0, rc = 0;
    char buffer1[1024] = {0}, buffer2[1024] = {0};
    unsigned long long counter = 0;
    time_t t;
    struct tm *now;
    unsigned char *tmp_framebuffer = NULL;

    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, NULL);

    while(ok >= 0 && !pglobal->stop) {
        DBG("waiting for fresh frame\n");

        pthread_mutex_lock(&pglobal->in[input_number].db);
        pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

        /* read buffer */
        frame_size = pglobal->in[input_number].size;

        /* check if buffer for frame is large enough, increase it if necessary */
        if(frame_size > max_frame_size) {
            DBG("increasing buffer size to %d\n", frame_size);

            max_frame_size = frame_size + (1 << 16);
            if((tmp_framebuffer = realloc(frame, max_frame_size)) == NULL) {
                pthread_mutex_unlock(&pglobal->in[input_number].db);
                LOG("not enough memory\n");
                return NULL;
            }

            frame = tmp_framebuffer;
        }

        /* copy frame to our local buffer now */
        memcpy(frame, pglobal->in[input_number].buf, frame_size);

        /* allow others to access the global buffer again */
        pthread_mutex_unlock(&pglobal->in[input_number].db);

        if (mjpgFileName == NULL) { // single files with ringbuffer mode
            /* prepare filename */
            memset(buffer1, 0, sizeof(buffer1));
            memset(buffer2, 0, sizeof(buffer2));

            /* get current time */
            t = time(NULL);
            now = localtime(&t);
            if(now == NULL) {
                perror("localtime");
                return NULL;
            }

            /* prepare string, add time and date values */
            if(strftime(buffer1, sizeof(buffer1), "%%s/%Y_%m_%d_%H_%M_%S_picture_%%09llu.jpg", now) == 0) {
                OPRINT("strftime returned 0\n");
                free(frame); frame = NULL;
                return NULL;
            }

            /* finish filename by adding the foldername and a counter value */
            snprintf(buffer2, sizeof(buffer2), buffer1, folder, counter);

            counter++;

            DBG("writing file: %s\n", buffer2);

            /* open file for write */
            if((fd = open(buffer2, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
                OPRINT("could not open the file %s\n", buffer2);
                return NULL;
            }

            /* save picture to file */
            if(write(fd, frame, frame_size) < 0) {
                OPRINT("could not write to file %s\n", buffer2);
                perror("write()");
                close(fd);
                return NULL;
            }

            close(fd);

            /* link the picture as fixed name file */
            if (linkFileName) {
                snprintf(buffer1, sizeof(buffer1), "%s/%s", folder, linkFileName);
                unlink(buffer1);
                (void) link(buffer2, buffer1);
            }

            /* call the command if user specified one, pass current filename as argument */
            if(command != NULL) {
                memset(buffer1, 0, sizeof(buffer1));

                /* buffer2 still contains the filename, pass it to the command as parameter */
                snprintf(buffer1, sizeof(buffer1), "%s \"%s\"", command, buffer2);
                DBG("calling command %s", buffer1);

                /* in addition provide the filename as environment variable */
                if((rc = setenv("MJPG_FILE", buffer2, 1)) != 0) {
                    LOG("setenv failed (return value %d)\n", rc);
                }

                /* execute the command now */
                if((rc = system(buffer1)) != 0) {
                    LOG("command failed (return value %d)\n", rc);
                }
            }

            /*
             * maintain ringbuffer
             * do not maintain ringbuffer for each picture, this saves resources since
             * each run of the maintainance function involves sorting/malloc/free operations
             */
            if(ringbuffer_exceed <= 0) {
                /* keep ringbuffer excactly at specified siOUTPUT_PLUGIN_NAMEze */
                maintain_ringbuffer(ringbuffer_size);
            } else if(counter == 1 || counter % (ringbuffer_exceed + 1) == 0) {
                DBG("counter: %llu, will clean-up now\n", counter);
                maintain_ringbuffer(ringbuffer_size);
            }
        } else { // recording to MJPG file
            /* save picture to file */
            if(write(fd, frame, frame_size) < 0) {
                OPRINT("could not write to file %s\n", buffer2);
                perror("write()");
                close(fd);
                return NULL;
            }
        }

        /* if specified, wait now */
        if(delay > 0) {
            usleep(1000 * delay);
        }
    }

    /* cleanup now */
    pthread_cleanup_pop(1);

    return NULL;
}

/*** plugin interface functions ***/
/******************************************************************************
Description.: this function is called first, in order to initialize
              this plugin and pass a parameter string
Input Value.: parameters
Return Value: 0 if everything is OK, non-zero otherwise
******************************************************************************/
int output_init(output_parameter *param, int id)
{
	int i;
    delay = 0;
    pglobal = param->global;
    pglobal->out[id].name = malloc((1+strlen(OUTPUT_PLUGIN_NAME))*sizeof(char));
    sprintf(pglobal->out[id].name, "%s", OUTPUT_PLUGIN_NAME);
    DBG("OUT plugin %d name: %s\n", id, pglobal->out[id].name);

    param->argv[0] = OUTPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0},
            {"help", no_argument, 0, 0},
            {"f", required_argument, 0, 0},
            {"folder", required_argument, 0, 0},
            {"d", required_argument, 0, 0},
            {"delay", required_argument, 0, 0},
            {"s", required_argument, 0, 0},
            {"size", required_argument, 0, 0},
            {"e", required_argument, 0, 0},
            {"exceed", required_argument, 0, 0},
            {"i", required_argument, 0, 0},
            {"input", required_argument, 0, 0},
            {"m", required_argument, 0, 0},
            {"mjpeg", required_argument, 0, 0},
            {"l", required_argument, 0, 0},
            {"link", required_argument, 0, 0},
            {"c", required_argument, 0, 0},
            {"command", required_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

            /* f, folder */
        case 2:
        case 3:
            DBG("case 2,3\n");
            folder = malloc(strlen(optarg) + 1);
            strcpy(folder, optarg);
            if(folder[strlen(folder)-1] == '/')
                folder[strlen(folder)-1] = '\0';
            break;

            /* d, delay */
        case 4:
        case 5:
            DBG("case 4,5\n");
            delay = atoi(optarg);
            break;

            /* s, size */
        case 6:
        case 7:
            DBG("case 6,7\n");
            ringbuffer_size = atoi(optarg);
            break;

            /* e, exceed */
        case 8:
        case 9:
            DBG("case 8,9\n");
            ringbuffer_exceed = atoi(optarg);
            break;
            /* i, input*/
        case 10:
        case 11:
            DBG("case 12,13\n");
            input_number = atoi(optarg);
            break;
            /* m mjpeg */
        case 12:
        case 13:
            DBG("case 12,13\n");
            mjpgFileName = strdup(optarg);
            break;
            /* l link */
        case 14:
        case 15:
            DBG("case 14,15\n");
            linkFileName = strdup(optarg);
            break;
            /* c command */
        case 16:
        case 17:
            DBG("case 16,17\n");
            command = strdup(optarg);
            break;
        }
    }

    if(!(input_number < pglobal->incnt)) {
        OPRINT("ERROR: the %d input_plugin number is too much only %d plugins loaded\n", input_number, param->global->incnt);
        return 1;
    }

    OPRINT("output folder.....: %s\n", folder);
    OPRINT("input plugin.....: %d: %s\n", input_number, pglobal->in[input_number].plugin);
    OPRINT("delay after save..: %d\n", delay);
    if  (mjpgFileName == NULL) {
        if(ringbuffer_size > 0) {
            OPRINT("ringbuffer size...: %d to %d\n", ringbuffer_size, ringbuffer_size + ringbuffer_exceed);
        } else {
            OPRINT("ringbuffer size...: %s\n", "no ringbuffer");
        }
    } else {
        char *fnBuffer = malloc(strlen(mjpgFileName) + strlen(folder) + 3);
        sprintf(fnBuffer, "%s/%s", folder, mjpgFileName);

        OPRINT("output file.......: %s\n", fnBuffer);
        if((fd = open(fnBuffer, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
            OPRINT("could not open the file %s\n", fnBuffer);
            free(fnBuffer);
            return 1;
        }
        free(fnBuffer);
    }

    param->global->out[id].parametercount = 2;

    param->global->out[id].out_parameters = (control*) calloc(2, sizeof(control));

    control take_ctrl;
	take_ctrl.group = IN_CMD_GENERIC;
	take_ctrl.menuitems = NULL;
	take_ctrl.value = 1;
	take_ctrl.class_id = 0;

	take_ctrl.ctrl.id = OUT_FILE_CMD_TAKE;
	take_ctrl.ctrl.type = V4L2_CTRL_TYPE_BUTTON;
	strcpy((char*) take_ctrl.ctrl.name, "Take snapshot");
	take_ctrl.ctrl.minimum = 0;
	take_ctrl.ctrl.maximum = 1;
	take_ctrl.ctrl.step = 1;
	take_ctrl.ctrl.default_value = 0;

	param->global->out[id].out_parameters[0] = take_ctrl;

    control filename_ctrl;
	filename_ctrl.group = IN_CMD_GENERIC;
	filename_ctrl.menuitems = NULL;
	filename_ctrl.value = 1;
	filename_ctrl.class_id = 0;

	filename_ctrl.ctrl.id = OUT_FILE_CMD_FILENAME;
	filename_ctrl.ctrl.type = V4L2_CTRL_TYPE_STRING;
	strcpy((char*) filename_ctrl.ctrl.name, "Filename");
	filename_ctrl.ctrl.minimum = 0;
	filename_ctrl.ctrl.maximum = 32;
	filename_ctrl.ctrl.step = 1;
	filename_ctrl.ctrl.default_value = 0;

	param->global->out[id].out_parameters[1] = filename_ctrl;


    return 0;
}

/******************************************************************************
Description.: calling this function stops the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_stop(int id)
{
    DBG("will cancel worker thread\n");
    pthread_cancel(worker);
    return 0;
}

/******************************************************************************
Description.: calling this function creates and starts the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_run(int id)
{
    DBG("launching worker thread\n");
    pthread_create(&worker, 0, worker_thread, NULL);
    pthread_detach(worker);
    return 0;
}

int output_cmd(int plugin_id, unsigned int control_id, unsigned int group, int value, char *valueStr)
{
    int i = 0;
    DBG("command (%d, value: %d) for group %d triggered for plugin instance #%02d\n", control_id, value, group, plugin_id);
    switch(group) {
		case IN_CMD_GENERIC:
			for(i = 0; i < pglobal->out[plugin_id].parametercount; i++) {
				if((pglobal->out[plugin_id].out_parameters[i].ctrl.id == control_id) && (pglobal->out[plugin_id].out_parameters[i].group == IN_CMD_GENERIC)) {
					DBG("Generic control found (id: %d): %s\n", control_id, pglobal->out[plugin_id].out_parameters[i].ctrl.name);
					switch(control_id) {
                            case OUT_FILE_CMD_TAKE: {
                                if (valueStr != NULL) {
                                    int frame_size = 0;
                                    unsigned char *tmp_framebuffer = NULL;

                                    if(pthread_mutex_lock(&pglobal->in[input_number].db)) {
                                        DBG("Unable to lock mutex\n");
                                        return -1;
                                    }
                                    /* read buffer */
                                    frame_size = pglobal->in[input_number].size;

                                    /* check if buffer for frame is large enough, increase it if necessary */
                                    if(frame_size > max_frame_size) {
                                        DBG("increasing buffer size to %d\n", frame_size);

                                        max_frame_size = frame_size + (1 << 16);
                                        if((tmp_framebuffer = realloc(frame, max_frame_size)) == NULL) {
                                            pthread_mutex_unlock(&pglobal->in[input_number].db);
                                            LOG("not enough memory\n");
                                            return -1;
                                        }

                                        frame = tmp_framebuffer;
                                    }

                                    /* copy frame to our local buffer now */
                                    memcpy(frame, pglobal->in[input_number].buf, frame_size);

                                    /* allow others to access the global buffer again */
                                    pthread_mutex_unlock(&pglobal->in[input_number].db);

                                    DBG("writing file: %s\n", valueStr);

                                    int fd;
                                    /* open file for write */
                                    if((fd = open(valueStr, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
                                        OPRINT("could not open the file %s\n", valueStr);
                                        return -1;
                                    }

                                    /* save picture to file */
                                    if(write(fd, frame, frame_size) < 0) {
                                        OPRINT("could not write to file %s\n", valueStr);
                                        perror("write()");
                                        close(fd);
                                        return -1;
                                    }

                                    close(fd);
                                } else {
                                    DBG("No filename specified\n");
                                    return -1;
                                }
                            } break;
                            case OUT_FILE_CMD_FILENAME: {
                                DBG("Not yet implemented\n");
                                return -1;
                            } break;
                            default: {
                                DBG("Unknown command\n");
                                return -1;
                            } break;
					}
					DBG("Ctrl %s new value: %d\n", pglobal->out[plugin_id].out_parameters[i].ctrl.name, value);
					return 0;
				}
			}
			DBG("Requested generic control (%d) did not found\n", control_id);
			return -1;
			break;
	}
    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_file/output_file.h
================
#ifndef OUTPUT_FILE_H
#define OUTPUT_FILE_H

#define OUT_FILE_CMD_TAKE           1
#define OUT_FILE_CMD_FILENAME       2

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_http/CMakeLists.txt
================
add_feature_option(ENABLE_HTTP_MANAGEMENT "Enable experimental HTTP management option" OFF)

if (ENABLE_HTTP_MANAGEMENT)
    add_definitions(-DMANAGMENT)
endif (ENABLE_HTTP_MANAGEMENT)

add_definitions(-D_GNU_SOURCE)

MJPG_STREAMER_PLUGIN_OPTION(output_http "HTTP server output plugin")
MJPG_STREAMER_PLUGIN_COMPILE(output_http httpd.c output_http.c)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_http/httpd.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 busybox-project (base64 function)                    #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <string.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netdb.h>
#include <errno.h>
#include <limits.h>

#include <linux/version.h>
#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "../../mjpg_streamer.h"
#include "../../utils.h"

#include "httpd.h"

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
#define V4L2_CTRL_TYPE_STRING_SUPPORTED
#endif

#include "../output_file/output_file.h"


static globals *pglobal;
extern context servers[MAX_OUTPUT_PLUGINS];
int piggy_fine = 2; // FIXME make it command line parameter

/******************************************************************************
Description.: initializes the iobuffer structure properly
Input Value.: pointer to already allocated iobuffer
Return Value: iobuf
******************************************************************************/
void init_iobuffer(iobuffer *iobuf)
{
    memset(iobuf->buffer, 0, sizeof(iobuf->buffer));
    iobuf->level = 0;
}

/******************************************************************************
Description.: initializes the request structure properly
Input Value.: pointer to already allocated req
Return Value: req
******************************************************************************/
void init_request(request *req)
{
    req->type        = A_UNKNOWN;
    req->parameter   = NULL;
    req->client      = NULL;
    req->credentials = NULL;
}

/******************************************************************************
Description.: If strings were assigned to the different members free them
              This will fail if strings are static, so always use strdup().
Input Value.: req: pointer to request structure
Return Value: -
******************************************************************************/
void free_request(request *req)
{
    if(req->parameter != NULL) free(req->parameter);
    if(req->client != NULL) free(req->client);
    if(req->credentials != NULL) free(req->credentials);
    if(req->query_string != NULL) free(req->query_string);
}

/******************************************************************************
Description.: read with timeout, implemented without using signals
              tries to read len bytes and returns if enough bytes were read
              or the timeout was triggered. In case of timeout the return
              value may differ from the requested bytes "len".
Input Value.: * fd.....: fildescriptor to read from
              * iobuf..: iobuffer that allows to use this functions from multiple
                         threads because the complete context is the iobuffer.
              * buffer.: The buffer to store values at, will be set to zero
                         before storing values.
              * len....: the length of buffer
              * timeout: seconds to wait for an answer
Return Value: * buffer.: will become filled with bytes read
              * iobuf..: May get altered to save the context for future calls.
              * func().: bytes copied to buffer or -1 in case of error
******************************************************************************/
int _read(int fd, iobuffer *iobuf, void *buffer, size_t len, int timeout)
{
    int copied = 0, rc, i;
    fd_set fds;
    struct timeval tv;

    memset(buffer, 0, len);

    while((copied < len)) {
        i = MIN(iobuf->level, len - copied);
        memcpy(buffer + copied, iobuf->buffer + IO_BUFFER - iobuf->level, i);

        iobuf->level -= i;
        copied += i;
        if(copied >= len)
            return copied;

        /* select will return in case of timeout or new data arrived */
        tv.tv_sec = timeout;
        tv.tv_usec = 0;
        FD_ZERO(&fds);
        FD_SET(fd, &fds);
        if((rc = select(fd + 1, &fds, NULL, NULL, &tv)) <= 0) {
            if(rc < 0)
                exit(EXIT_FAILURE);

            /* this must be a timeout */
            return copied;
        }

        init_iobuffer(iobuf);

        /*
         * there should be at least one byte, because select signalled it.
         * But: It may happen (very seldomly), that the socket gets closed remotly between
         * the select() and the following read. That is the reason for not relying
         * on reading at least one byte.
         */
        if((iobuf->level = read(fd, &iobuf->buffer, IO_BUFFER)) <= 0) {
            /* an error occured */
            return -1;
        }

        /* align data to the end of the buffer if less than IO_BUFFER bytes were read */
        memmove(iobuf->buffer + (IO_BUFFER - iobuf->level), iobuf->buffer, iobuf->level);
    }

    return 0;
}

/******************************************************************************
Description.: Read a single line from the provided fildescriptor.
              This funtion will return under two conditions:
              * line end was reached
              * timeout occured
Input Value.: * fd.....: fildescriptor to read from
              * iobuf..: iobuffer that allows to use this functions from multiple
                         threads because the complete context is the iobuffer.
              * buffer.: The buffer to store values at, will be set to zero
                         before storing values.
              * len....: the length of buffer
              * timeout: seconds to wait for an answer
Return Value: * buffer.: will become filled with bytes read
              * iobuf..: May get altered to save the context for future calls.
              * func().: bytes copied to buffer or -1 in case of error
******************************************************************************/
/* read just a single line or timeout */
int _readline(int fd, iobuffer *iobuf, void *buffer, size_t len, int timeout)
{
    char c = '\0', *out = buffer;
    int i;

    memset(buffer, 0, len);

    for(i = 0; i < len && c != '\n'; i++) {
        if(_read(fd, iobuf, &c, 1, timeout) <= 0) {
            /* timeout or error occured */
            return -1;
        }
        *out++ = c;
    }

    return i;
}

/******************************************************************************
Description.: Decodes the data and stores the result to the same buffer.
              The buffer will be large enough, because base64 requires more
              space then plain text.
Hints.......: taken from busybox, but it is GPL code
Input Value.: base64 encoded data
Return Value: plain decoded data
******************************************************************************/
void decodeBase64(char *data)
{
    const unsigned char *in = (const unsigned char *)data;
    /* The decoded size will be at most 3/4 the size of the encoded */
    unsigned ch = 0;
    int i = 0;

    while(*in) {
        int t = *in++;

        if(t >= '0' && t <= '9')
            t = t - '0' + 52;
        else if(t >= 'A' && t <= 'Z')
            t = t - 'A';
        else if(t >= 'a' && t <= 'z')
            t = t - 'a' + 26;
        else if(t == '+')
            t = 62;
        else if(t == '/')
            t = 63;
        else if(t == '=')
            t = 0;
        else
            continue;

        ch = (ch << 6) | t;
        i++;
        if(i == 4) {
            *data++ = (char)(ch >> 16);
            *data++ = (char)(ch >> 8);
            *data++ = (char) ch;
            i = 0;
        }
    }
    *data = '\0';
}

/******************************************************************************
Description.: convert a hexadecimal ASCII character to integer
Input Value.: ASCII character
Return Value: corresponding value between 0 and 15, or -1 in case of error
******************************************************************************/
int hex_char_to_int(char in)
{
    if(in >= '0' && in <= '9')
        return in - '0';

    if(in >= 'a' && in <= 'f')
        return (in - 'a') + 10;

    if(in >= 'A' && in <= 'F')
        return (in - 'A') + 10;

    return -1;
}

/******************************************************************************
Description.: replace %XX with the character code it represents, URI
Input Value.: string to unescape
Return Value: 0 if everything is ok, -1 in case of error
******************************************************************************/
int unescape(char *string)
{
    char *source = string, *destination = string;
    int src, dst, length = strlen(string), rc;

    /* iterate over the string */
    for(dst = 0, src = 0; src < length; src++) {

        /* is it an escape character? */
        if(source[src] != '%') {
            /* no, so just go to the next character */
            destination[dst] = source[src];
            dst++;
            continue;
        }

        /* yes, it is an escaped character */

        /* check if there are enough characters */
        if(src + 2 > length) {
            return -1;
            break;
        }

        /* perform replacement of %## with the corresponding character */
        if((rc = hex_char_to_int(source[src+1])) == -1) return -1;
        destination[dst] = rc * 16;
        if((rc = hex_char_to_int(source[src+2])) == -1) return -1;
        destination[dst] += rc;

        /* advance pointers, here is the reason why the resulting string is shorter */
        dst++; src += 2;
    }

    /* ensure the string is properly finished with a null-character */
    destination[dst] = '\0';

    return 0;
}

#ifdef MANAGMENT

/******************************************************************************
Description.: Adds a new client information struct to the ino list.
Input Value.: Client IP address as a string
Return Value: Returns with the newly added info or with a pointer to the existing item
******************************************************************************/
client_info *add_client(char *address)
{
    unsigned int i = 0;
    int name_length = strlen(address) + 1;

    pthread_mutex_lock(&client_infos.mutex);

    for (; i<client_infos.client_count; i++) {
        if (strcmp(client_infos.infos[i]->address, address) == 0) {
            pthread_mutex_unlock(&client_infos.mutex);
            return client_infos.infos[i];
        }
    }

    client_info *current_client_info = malloc(sizeof(client_info));
    if (current_client_info == NULL) {
        fprintf(stderr, "could not allocate memory\n");
        pthread_mutex_unlock(&client_infos.mutex);
        return NULL;
    }

    current_client_info->address = malloc(name_length * sizeof(char));
    if (current_client_info->address == NULL) {
        fprintf(stderr, "could not allocate memory\n");
        pthread_mutex_unlock(&client_infos.mutex);
        return NULL;
    }

    strcpy(current_client_info->address, address);
    memset(&(current_client_info->last_take_time), 0, sizeof(struct timeval)); // set last time to zero

    client_infos.infos = realloc(client_infos.infos, (client_infos.client_count + 1) * sizeof(client_info*));
    client_infos.infos[client_infos.client_count] = current_client_info;
    client_infos.client_count += 1;

    pthread_mutex_unlock(&client_infos.mutex);
    return current_client_info;
}

/******************************************************************************
Description.: Looks in the client_infos for the current ip address.
Input Value.: Client IP address as a string
Return Value: If a frame was served to it within the specified interval it returns 1
              If not it returns with 0
******************************************************************************/
int check_client_status(client_info *client)
{
    unsigned int i = 0;
    pthread_mutex_lock(&client_infos.mutex);
    for (; i<client_infos.client_count; i++) {
        if (client_infos.infos[i] == client) {
            long msec;
            struct timeval tim;
            gettimeofday(&tim, NULL);
            msec  =(tim.tv_sec - client_infos.infos[i]->last_take_time.tv_sec)*1000;
            msec +=(tim.tv_usec - client_infos.infos[i]->last_take_time.tv_usec)/1000;
            DBG("diff: %ld\n", msec);
            if ((msec < 1000) && (msec > 0)) { // FIXME make it parameter
                DBG("CHEATER\n");
                pthread_mutex_unlock(&client_infos.mutex);
                return 1;
            } else {
                pthread_mutex_unlock(&client_infos.mutex);
                return 0;
            }
        }
    }
    DBG("Client not found in the client list! How did it happend?? This is a BUG\n");
    pthread_mutex_unlock(&client_infos.mutex);
    return 0;
}

void update_client_timestamp(client_info *client)
{
    struct timeval tim;
    pthread_mutex_lock(&client_infos.mutex);
    gettimeofday(&tim, NULL);
    memcpy(&client->last_take_time, &tim, sizeof(struct timeval));
    pthread_mutex_unlock(&client_infos.mutex);
}
#endif

/******************************************************************************
Description.: Send a complete HTTP response and a single JPG-frame.
Input Value.: fildescriptor fd to send the answer to
Return Value: -
******************************************************************************/
void send_snapshot(cfd *context_fd, int input_number)
{
    unsigned char *frame = NULL;
    int frame_size = 0;
    char buffer[BUFFER_SIZE] = {0};
    struct timeval timestamp;

    /* wait for a fresh frame */
    pthread_mutex_lock(&pglobal->in[input_number].db);
    pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

    /* read buffer */
    frame_size = pglobal->in[input_number].size;

    /* allocate a buffer for this single frame */
    if((frame = malloc(frame_size + 1)) == NULL) {
        free(frame);
        pthread_mutex_unlock(&pglobal->in[input_number].db);
        send_error(context_fd->fd, 500, "not enough memory");
        return;
    }
    /* copy v4l2_buffer timeval to user space */
    timestamp = pglobal->in[input_number].timestamp;

    memcpy(frame, pglobal->in[input_number].buf, frame_size);
    DBG("got frame (size: %d kB)\n", frame_size / 1024);

    pthread_mutex_unlock(&pglobal->in[input_number].db);

    #ifdef MANAGMENT
    update_client_timestamp(context_fd->client);
    #endif

    /* write the response */
    sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
            "Access-Control-Allow-Origin: *\r\n" \
            STD_HEADER \
            "Content-type: image/jpeg\r\n" \
            "X-Timestamp: %d.%06d\r\n" \
            "\r\n", (int) timestamp.tv_sec, (int) timestamp.tv_usec);

    /* send header and image now */
    if (write(context_fd->fd, buffer, strlen(buffer)) < 0 ||
        write(context_fd->fd, frame, frame_size) < 0) {
        free(frame);
        return;
    }

    free(frame);
}

/******************************************************************************
Description.: Send a complete HTTP response and a stream of JPG-frames.
Input Value.: fildescriptor fd to send the answer to
Return Value: -
******************************************************************************/
void send_stream(cfd *context_fd, int input_number)
{
    unsigned char *frame = NULL, *tmp = NULL;
    int frame_size = 0, max_frame_size = 0;
    char buffer[BUFFER_SIZE] = {0};
    struct timeval timestamp;

    DBG("preparing header\n");
    sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
            "Access-Control-Allow-Origin: *\r\n" \
            STD_HEADER \
            "Content-Type: multipart/x-mixed-replace;boundary=" BOUNDARY "\r\n" \
            "\r\n" \
            "--" BOUNDARY "\r\n");

    if(write(context_fd->fd, buffer, strlen(buffer)) < 0) {
        free(frame);
        return;
    }

    DBG("Headers send, sending stream now\n");

    while(!pglobal->stop) {

        /* wait for fresh frames */
        pthread_mutex_lock(&pglobal->in[input_number].db);
        pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

        /* read buffer */
        frame_size = pglobal->in[input_number].size;

        /* check if framebuffer is large enough, increase it if necessary */
        if(frame_size > max_frame_size) {
            DBG("increasing buffer size to %d\n", frame_size);

            max_frame_size = frame_size + TEN_K;
            if((tmp = realloc(frame, max_frame_size)) == NULL) {
                free(frame);
                pthread_mutex_unlock(&pglobal->in[input_number].db);
                send_error(context_fd->fd, 500, "not enough memory");
                return;
            }

            frame = tmp;
        }

        /* copy v4l2_buffer timeval to user space */
        timestamp = pglobal->in[input_number].timestamp;

        memcpy(frame, pglobal->in[input_number].buf, frame_size);
        DBG("got frame (size: %d kB)\n", frame_size / 1024);

        pthread_mutex_unlock(&pglobal->in[input_number].db);

        #ifdef MANAGMENT
        update_client_timestamp(context_fd->client);
        #endif

        /*
         * print the individual mimetype and the length
         * sending the content-length fixes random stream disruption observed
         * with firefox
         */
        sprintf(buffer, "Content-Type: image/jpeg\r\n" \
                "Content-Length: %d\r\n" \
                "X-Timestamp: %d.%06d\r\n" \
                "\r\n", frame_size, (int)timestamp.tv_sec, (int)timestamp.tv_usec);
        DBG("sending intemdiate header\n");
        if(write(context_fd->fd, buffer, strlen(buffer)) < 0) break;

        DBG("sending frame\n");
        if(write(context_fd->fd, frame, frame_size) < 0) break;

        DBG("sending boundary\n");
        sprintf(buffer, "\r\n--" BOUNDARY "\r\n");
        if(write(context_fd->fd, buffer, strlen(buffer)) < 0) break;
    }

    free(frame);
}

#ifdef WXP_COMPAT
/******************************************************************************
Description.: Sends a mjpg stream in the same format as the WebcamXP does
Input Value.: fildescriptor fd to send the answer to
Return Value: -
******************************************************************************/
void send_stream_wxp(cfd *context_fd, int input_number)
{
    unsigned char *frame = NULL, *tmp = NULL;
    int frame_size = 0, max_frame_size = 0;
    char buffer[BUFFER_SIZE] = {0};
    struct timeval timestamp;

    DBG("preparing header\n");

    time_t curDate, expiresDate;
    curDate = time(NULL);
    expiresDate = curDate - 1380; // teh expires date is before the current date with 23 minute (1380) sec

    char curDateBuffer[80];
    char expDateBuffer[80];

    strftime(curDateBuffer, 80, "%a, %d %b %Y %H:%M:%S %Z", localtime(&curDate));
    strftime(expDateBuffer, 80, "%a, %d %b %Y %H:%M:%S %Z", localtime(&expiresDate));
    sprintf(buffer, "HTTP/1.1 200 OK\r\n" \
                    "Connection: keep-alive\r\n" \
                    "Content-Type: multipart/x-mixed-replace; boundary=--myboundary\r\n" \
                    "Content-Length: 9999999\r\n" \
                    "Cache-control: no-cache, must revalidate\r\n" \
                    "Date: %s\r\n" \
                    "Expires: %s\r\n" \
                    "Pragma: no-cache\r\n" \
                    "Server: webcamXP\r\n"
                    "\r\n",
                    curDateBuffer,
                    expDateBuffer);

    if(write(context_fd->fd, buffer, strlen(buffer)) < 0) {
        free(frame);
        return;
    }

    DBG("Headers send, sending stream now\n");

    while(!pglobal->stop) {

        /* wait for fresh frames */
        pthread_mutex_lock(&pglobal->in[input_number].db);
        pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

        /* read buffer */
        frame_size = pglobal->in[input_number].size;

        /* check if framebuffer is large enough, increase it if necessary */
        if(frame_size > max_frame_size) {
            DBG("increasing buffer size to %d\n", frame_size);

            max_frame_size = frame_size + TEN_K;
            if((tmp = realloc(frame, max_frame_size)) == NULL) {
                free(frame);
                pthread_mutex_unlock(&pglobal->in[input_number].db);
                send_error(context_fd->fd, 500, "not enough memory");
                return;
            }

            frame = tmp;
        }

        /* copy v4l2_buffer timeval to user space */
        timestamp = pglobal->in[input_number].timestamp;

        #ifdef MANAGMENT
        update_client_timestamp(context_fd->client);
        #endif

        memcpy(frame, pglobal->in[input_number].buf, frame_size);
        DBG("got frame (size: %d kB)\n", frame_size / 1024);

        pthread_mutex_unlock(&pglobal->in[input_number].db);

        memset(buffer, 0, 50*sizeof(char));
        sprintf(buffer, "mjpeg %07d12345", frame_size);
        DBG("sending intemdiate header\n");
        if(write(context_fd->fd, buffer, 50) < 0) break;

        DBG("sending frame\n");
        if(write(context_fd->fd, frame, frame_size) < 0) break;
    }

    free(frame);
}
#endif

/******************************************************************************
Description.: Send error messages and headers.
Input Value.: * fd.....: is the filedescriptor to send the message to
              * which..: HTTP error code, most popular is 404
              * message: append this string to the displayed response
Return Value: -
******************************************************************************/
void send_error(int fd, int which, char *message)
{
    char buffer[BUFFER_SIZE] = {0};

    if(which == 401) {
        sprintf(buffer, "HTTP/1.0 401 Unauthorized\r\n" \
                "Content-type: text/plain\r\n" \
                STD_HEADER \
                "WWW-Authenticate: Basic realm=\"MJPG-Streamer\"\r\n" \
                "\r\n" \
                "401: Not Authenticated!\r\n" \
                "%s", message);
    } else if(which == 404) {
        sprintf(buffer, "HTTP/1.0 404 Not Found\r\n" \
                "Content-type: text/plain\r\n" \
                STD_HEADER \
                "\r\n" \
                "404: Not Found!\r\n" \
                "%s", message);
    } else if(which == 500) {
        sprintf(buffer, "HTTP/1.0 500 Internal Server Error\r\n" \
                "Content-type: text/plain\r\n" \
                STD_HEADER \
                "\r\n" \
                "500: Internal Server Error!\r\n" \
                "%s", message);
    } else if(which == 400) {
        sprintf(buffer, "HTTP/1.0 400 Bad Request\r\n" \
                "Content-type: text/plain\r\n" \
                STD_HEADER \
                "\r\n" \
                "400: Not Found!\r\n" \
                "%s", message);
    } else if (which == 403) {
        sprintf(buffer, "HTTP/1.0 403 Forbidden\r\n" \
                "Content-type: text/plain\r\n" \
                STD_HEADER \
                "\r\n" \
                "403: Forbidden!\r\n" \
                "%s", message);
    } else {
        sprintf(buffer, "HTTP/1.0 501 Not Implemented\r\n" \
                "Content-type: text/plain\r\n" \
                STD_HEADER \
                "\r\n" \
                "501: Not Implemented!\r\n" \
                "%s", message);
    }

    if(write(fd, buffer, strlen(buffer)) < 0) {
        DBG("write failed, done anyway\n");
    }
}

/******************************************************************************
Description.: Send HTTP header and copy the content of a file. To keep things
              simple, just a single folder gets searched for the file. Just
              files with known extension and supported mimetype get served.
              If no parameter was given, the file "index.html" will be copied.
Input Value.: * fd.......: filedescriptor to send data to
              * id.......: specifies which server-context is the right one
              * parameter: string that consists of the filename
Return Value: -
******************************************************************************/
void send_file(int id, int fd, char *parameter)
{
    char buffer[BUFFER_SIZE] = {0};
    char *extension, *mimetype = NULL;
    int i, lfd;
    config conf = servers[id].conf;

    /* in case no parameter was given */
    if(parameter == NULL || strlen(parameter) == 0)
        parameter = "index.html";

    /* find file-extension */
    char * pch;
    pch = strchr(parameter, '.');
    int lastDot = 0;
    while(pch != NULL) {
        lastDot = pch - parameter;
        pch = strchr(pch + 1, '.');
    }

    if(lastDot == 0) {
        send_error(fd, 400, "No file extension found");
        return;
    } else {
        extension = parameter + lastDot;
        DBG("%s EXTENSION: %s\n", parameter, extension);
    }

    /* determine mime-type */
    for(i = 0; i < LENGTH_OF(mimetypes); i++) {
        if(strcmp(mimetypes[i].dot_extension, extension) == 0) {
            mimetype = (char *)mimetypes[i].mimetype;
            break;
        }
    }

    /* in case of unknown mimetype or extension leave */
    if(mimetype == NULL) {
        send_error(fd, 404, "MIME-TYPE not known");
        return;
    }

    /* now filename, mimetype and extension are known */
    DBG("trying to serve file \"%s\", extension: \"%s\" mime: \"%s\"\n", parameter, extension, mimetype);

    /* build the absolute path to the file */
    strncat(buffer, conf.www_folder, sizeof(buffer) - 1);
    strncat(buffer, parameter, sizeof(buffer) - strlen(buffer) - 1);

    /* try to open that file */
    if((lfd = open(buffer, O_RDONLY)) < 0) {
        DBG("file %s not accessible\n", buffer);
        send_error(fd, 404, "Could not open file");
        return;
    }
    DBG("opened file: %s\n", buffer);

    /* prepare HTTP header */
    sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
            "Content-type: %s\r\n" \
            STD_HEADER \
            "\r\n", mimetype);
    i = strlen(buffer);

    /* first transmit HTTP-header, afterwards transmit content of file */
    do {
        if(write(fd, buffer, i) < 0) {
            close(lfd);
            return;
        }
    } while((i = read(lfd, buffer, sizeof(buffer))) > 0);

    /* close file, job done */
    close(lfd);
}

/******************************************************************************
Description.: Executes the specified CGI file if exists
Input Value.: * fd...........: filedescriptor to send data to
              * id...........: specifies which server-context is the right one
              * parameter....: the requested file name
              * query_string.: query parameters
Return Value: -
******************************************************************************/
void execute_cgi(int id, int fd, char *parameter, char *query_string)
{
    int lfd = 0, i;
    int buffer_length = 0;
    char *buffer = NULL;
    char fn_buffer[BUFFER_SIZE] = {0};
    FILE *f = NULL;
    config conf = servers[id].conf;

    /* build the absolute path to the file */
    strncat(fn_buffer, conf.www_folder, sizeof(fn_buffer) - 1);
    strncat(fn_buffer, parameter, sizeof(fn_buffer) - strlen(fn_buffer) - 1);

    if((lfd = open(fn_buffer, O_RDONLY)) < 0) {
        DBG("file %s not accessible\n", fn_buffer);
        send_error(fd, 404, "Could not open file");
        return;
    }

    char *enviroment =
        "SERVER_SOFTWARE=\"mjpg-streamer\" "
        //"SERVER_NAME=\"%s\" "
        "SERVER_PROTOCOL=\"HTTP/1.1\" "
        "SERVER_PORT=\"%d\" "  // OK
        "GATEWAY_INTERFACE=\"CGI/1.1\" "
        "REQUEST_METHOD=\"GET\" "
        "SCRIPT_NAME=\"%s\" " // OK
        "QUERY_STRING=\"%s\" " //OK
        //"REMOTE_ADDR=\"%s\" "
        //"REMOTE_PORT=\"%d\" "
        "%s"; // OK

    buffer_length = 3;
    buffer_length = strlen(fn_buffer) + strlen(enviroment) + strlen(parameter) + 256;

    buffer = malloc(buffer_length);
    if (buffer == NULL) {
        exit(EXIT_FAILURE);
    }

    sprintf(buffer,
            enviroment,
            conf.port,
            parameter,
            query_string,
            fn_buffer);

    f = popen(buffer, "r");
    if(f == NULL) {
        DBG("Unable to execute the requested CGI script\n");
        send_error(fd, 403, "CGI script cannot be executed");
        free(buffer);
        close(lfd);
        return;
    }

    while((i = fread(buffer, 1, sizeof(buffer), f)) > 0) {
        if (write(fd, buffer, i) < 0) {
            fclose(f);
            free(buffer);
            close(lfd);
            return;
        }
    }

    fclose(f);
    free(buffer);
    close(lfd);
}


/******************************************************************************
Description.: Perform a command specified by parameter. Send response to fd.
Input Value.: * fd.......: filedescriptor to send HTTP response to.
              * parameter: contains the command and value as string.
              * id.......: specifies which server-context to choose.
Return Value: -
******************************************************************************/
void command(int id, int fd, char *parameter)
{
    char buffer[BUFFER_SIZE] = {0};
    char *command = NULL, *svalue = NULL, *value, *command_id_string;
    int res = 0, ivalue = 0, command_id = -1,  len = 0;

    DBG("parameter is: %s\n", parameter);

    /* sanity check of parameter-string */
    if(parameter == NULL || strlen(parameter) >= 255 || strlen(parameter) == 0) {
        DBG("parameter string looks bad\n");
        send_error(fd, 400, "Parameter-string of command does not look valid.");
        return;
    }

    /* command format:
        ?control&dest=0plugin=0&id=0&group=0&value=0
        where:
        dest: specifies the command destination (input, output, program itself) 0-1-2
        plugin specifies the plugin id  (not acceptable at the commands sent to the program itself)
        id: the control id
        group: the control's group eg. V4L2 control, jpg control, etc. This is optional
        value: value the control
    */

    /* search for required variable "command" */
    if((command = strstr(parameter, "id=")) == NULL) {
        DBG("no command id specified\n");
        send_error(fd, 400, "no GET variable \"id=...\" found, it is required to specify which command id to execute");
        return;
    }

    /* allocate and copy command string */
    command += strlen("id=");
    len = strspn(command, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_1234567890");
    if((command = strndup(command, len)) == NULL) {
        send_error(fd, 500, "could not allocate memory");
        LOG("could not allocate memory\n");
        return;
    }

    /* convert the command to id */
    command_id_string = command;
    len = strspn(command_id_string, "-1234567890");
    if((svalue = strndup(command_id_string, len)) == NULL) {
        if(command != NULL) free(command);
        send_error(fd, 500, "could not allocate memory");
        LOG("could not allocate memory\n");
        return;
    }

    command_id = MAX(MIN(strtol(svalue, NULL, 10), INT_MAX), INT_MIN);
    DBG("command id string: %s converted to int = %d\n", command, command_id);

    /* find and convert optional parameter "value" */
    if((value = strstr(parameter, "value=")) != NULL) {
        value += strlen("value=");
        len = strspn(value, "-1234567890");
        if((svalue = strndup(value, len)) == NULL) {
            if(command != NULL) free(command);
            send_error(fd, 500, "could not allocate memory");
            LOG("could not allocate memory\n");
            return;
        }
        ivalue = MAX(MIN(strtol(svalue, NULL, 10), INT_MAX), INT_MIN);
        DBG("The command value converted value form string %s to integer %d\n", svalue, ivalue);
    }

    int group = IN_CMD_GENERIC;
    if((value = strstr(parameter, "group=")) != NULL) {
        value += strlen("group=");
        len = strspn(value, "-1234567890");
        if((svalue = strndup(value, len)) == NULL) {
            if(command != NULL) free(command);
            send_error(fd, 500, "could not allocate memory");
            LOG("could not allocate memory\n");
            return;
        }
        group = MAX(MIN(strtol(svalue, NULL, 10), INT_MAX), INT_MIN);
        DBG("The command type value converted value form string %s to integer %d\n", svalue, group);
    }

    int dest = Dest_Input;
    if((value = strstr(parameter, "dest=")) != NULL) {
        value += strlen("dest=");
        len = strspn(value, "-1234567890");
        if((svalue = strndup(value, len)) == NULL) {
            if(command != NULL) free(command);
            send_error(fd, 500, "could not allocate memory");
            LOG("could not allocate memory\n");
            return;
        }
        dest = MAX(MIN(strtol(svalue, NULL, 10), INT_MAX), INT_MIN);
        #ifdef DEBUG
        switch (dest) {
            case Dest_Input:
                DBG("The command destination value converted form the string \"%s\" to integer %d -> INPUT\n", svalue, dest );
                break;
            case Dest_Output:
                DBG("The command destination value converted form the string \"%s\" to integer %d -> OUTPUT\n", svalue, dest );
                break;
            case Dest_Program:
                DBG("The command destination value converted form the string \"%s\" to integer %d -> PROGRAM\n", svalue, dest );
                break;
        }
        #endif
    }

    int plugin_no = 0; // default plugin no = 0 for compatibility reasons
    if((value = strstr(parameter, "plugin=")) != NULL) {
        value += strlen("plugin=");
        len = strspn(value, "-1234567890");
        if((svalue = strndup(value, len)) == NULL) {
            if(command != NULL) free(command);
            send_error(fd, 500, "could not allocate memory");
            LOG("could not allocate memory\n");
            return;
        }
        plugin_no = MAX(MIN(strtol(svalue, NULL, 10), INT_MAX), INT_MIN);
        DBG("The plugin number value converted value form string %s to integer %d\n", svalue, plugin_no);
    } else {
        value = NULL;
    }

    switch(dest) {
    case Dest_Input:
        if(plugin_no < pglobal->incnt) {
            res = pglobal->in[plugin_no].cmd(plugin_no, command_id, group, ivalue, value);
        } else {
            DBG("Invalid plugin number: %d because only %d input plugins loaded", plugin_no,  pglobal->incnt-1);
        }
        break;
    case Dest_Output:
        if(plugin_no < pglobal->outcnt) {
            res = pglobal->out[plugin_no].cmd(plugin_no, command_id, group, ivalue, value);
        } else {
            DBG("Invalid plugin number: %d because only %d output plugins loaded", plugin_no,  pglobal->incnt-1);
        }
        break;
    case Dest_Program:
        break;
    default:
        fprintf(stderr, "Illegal command destination: %d\n", dest);
    }

    /* Send HTTP-response */
    sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
            "Content-type: text/plain\r\n" \
            STD_HEADER \
            "\r\n" \
            "%s: %d", command, res);

    if(write(fd, buffer, strlen(buffer)) < 0) {
        DBG("write failed, done anyway\n");
    }

    if(command != NULL) free(command);
    if(svalue != NULL) free(svalue);
}

/******************************************************************************
Description.: Serve a connected TCP-client. This thread function is called
              for each connect of a HTTP client like a webbrowser. It determines
              if it is a valid HTTP request and dispatches between the different
              response options.
Input Value.: arg is the filedescriptor and server-context of the connected TCP
              socket. It must have been allocated so it is freeable by this
              thread function.
Return Value: always NULL
******************************************************************************/
/* thread for clients that connected to this server */
void *client_thread(void *arg)
{
    int cnt;
    char query_suffixed = 0;
    int input_number = 0;
    char buffer[BUFFER_SIZE] = {0}, *pb = buffer;
    iobuffer iobuf;
    request req;
    cfd lcfd; /* local-connected-file-descriptor */

    /* we really need the fildescriptor and it must be freeable by us */
    if(arg != NULL) {
        memcpy(&lcfd, arg, sizeof(cfd));
        free(arg);
    } else
        return NULL;

    /* initializes the structures */
    init_iobuffer(&iobuf);
    init_request(&req);

    /* What does the client want to receive? Read the request. */
    memset(buffer, 0, sizeof(buffer));
    if((cnt = _readline(lcfd.fd, &iobuf, buffer, sizeof(buffer) - 1, 5)) == -1) {
        close(lcfd.fd);
        return NULL;
    }

    req.query_string = NULL;

    /* determine what to deliver */
    if(strstr(buffer, "GET /?action=snapshot") != NULL) {
        req.type = A_SNAPSHOT;
        query_suffixed = 255;
        #ifdef MANAGMENT
        if (check_client_status(lcfd.client)) {
            req.type = A_UNKNOWN;
            lcfd.client->last_take_time.tv_sec += piggy_fine;
            send_error(lcfd.fd, 403, "frame already sent");
            query_suffixed = 0;
        }
        #endif
    #ifdef WXP_COMPAT
    } else if((strstr(buffer, "GET /cam") != NULL) && (strstr(buffer, ".jpg") != NULL)) {
        req.type = A_SNAPSHOT_WXP;
        query_suffixed = 255;
        #ifdef MANAGMENT
        if (check_client_status(lcfd.client)) {
            req.type = A_UNKNOWN;
            lcfd.client->last_take_time.tv_sec += piggy_fine;
            send_error(lcfd.fd, 403, "frame already sent");
            query_suffixed = 0;
        }
        #endif
    #endif
    } else if(strstr(buffer, "POST /stream") != NULL) {
        req.type = A_STREAM;
        query_suffixed = 255;
        #ifdef MANAGMENT
        if (check_client_status(lcfd.client)) {
            req.type = A_UNKNOWN;
            lcfd.client->last_take_time.tv_sec += piggy_fine;
            send_error(lcfd.fd, 403, "frame already sent");
            query_suffixed = 0;
        }
        #endif
    } else if(strstr(buffer, "GET /?action=stream") != NULL) {
        req.type = A_STREAM;
        query_suffixed = 255;
        #ifdef MANAGMENT
        if (check_client_status(lcfd.client)) {
            req.type = A_UNKNOWN;
            lcfd.client->last_take_time.tv_sec += piggy_fine;
            send_error(lcfd.fd, 403, "frame already sent");
            query_suffixed = 0;
        }
        #endif
    #ifdef WXP_COMPAT
    } else if((strstr(buffer, "GET /cam") != NULL) && (strstr(buffer, ".mjpg") != NULL)) {
        req.type = A_STREAM_WXP;
        query_suffixed = 255;
        #ifdef MANAGMENT
        if (check_client_status(lcfd.client)) {
            req.type = A_UNKNOWN;
            lcfd.client->last_take_time.tv_sec += piggy_fine;
            send_error(lcfd.fd, 403, "frame already sent");
            query_suffixed = 0;
        }
        #endif
    #endif
    } else if(strstr(buffer, "GET /?action=take") != NULL) {
        int len;
        req.type = A_TAKE;
        query_suffixed = 255;

        /* advance by the length of known string */
        if((pb = strstr(buffer, "GET /?action=take")) == NULL) {
            DBG("HTTP request seems to be malformed\n");
            send_error(lcfd.fd, 400, "Malformed HTTP request");
            close(lcfd.fd);
            query_suffixed = 0;
            return NULL;
        }
        pb += strlen("GET /?action=take"); // a pb points to thestring after the first & after command

        /* only accept certain characters */
        len = MIN(MAX(strspn(pb, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-=&1234567890%./"), 0), 100);
        req.parameter = malloc(len + 1);
        if(req.parameter == NULL) {
            exit(EXIT_FAILURE);
        }
        memset(req.parameter, 0, len + 1);
        strncpy(req.parameter, pb, len);

        if(unescape(req.parameter) == -1) {
            free(req.parameter);
            send_error(lcfd.fd, 500, "could not properly unescape command parameter string");
            LOG("could not properly unescape command parameter string\n");
            close(lcfd.fd);
            return NULL;
        }
    } else if((strstr(buffer, "GET /input") != NULL) && (strstr(buffer, ".json") != NULL)) {
        req.type = A_INPUT_JSON;
        query_suffixed = 255;
    } else if((strstr(buffer, "GET /output") != NULL) && (strstr(buffer, ".json") != NULL)) {
        req.type = A_OUTPUT_JSON;
        query_suffixed = 255;
    } else if(strstr(buffer, "GET /program.json") != NULL) {
        req.type = A_PROGRAM_JSON;
    #ifdef MANAGMENT
    } else if(strstr(buffer, "GET /clients.json") != NULL) {
        req.type = A_CLIENTS_JSON;
    #endif
    } else if(strstr(buffer, "GET /?action=command") != NULL) {
        int len;
        req.type = A_COMMAND;

        /* advance by the length of known string */
        if((pb = strstr(buffer, "GET /?action=command")) == NULL) {
            DBG("HTTP request seems to be malformed\n");
            send_error(lcfd.fd, 400, "Malformed HTTP request");
            close(lcfd.fd);
            return NULL;
        }
        pb += strlen("GET /?action=command"); // a pb points to thestring after the first & after command

        /* only accept certain characters */
        len = MIN(MAX(strspn(pb, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-=&1234567890%./"), 0), 100);

        req.parameter = malloc(len + 1);
        if(req.parameter == NULL) {
            exit(EXIT_FAILURE);
        }
        memset(req.parameter, 0, len + 1);
        strncpy(req.parameter, pb, len);

        if(unescape(req.parameter) == -1) {
            free(req.parameter);
            send_error(lcfd.fd, 500, "could not properly unescape command parameter string");
            LOG("could not properly unescape command parameter string\n");
            close(lcfd.fd);
            return NULL;
        }

        DBG("command parameter (len: %d): \"%s\"\n", len, req.parameter);
    } else {
        int len;

        DBG("try to serve a file\n");
        req.type = A_FILE;

        if((pb = strstr(buffer, "GET /")) == NULL) {
            DBG("HTTP request seems to be malformed\n");
            send_error(lcfd.fd, 400, "Malformed HTTP request");
            close(lcfd.fd);
            return NULL;
        }

        pb += strlen("GET /");
        len = MIN(MAX(strspn(pb, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._-1234567890"), 0), 100);
        req.parameter = malloc(len + 1);
        if(req.parameter == NULL) {
            exit(EXIT_FAILURE);
        }

        memset(req.parameter, 0, len + 1);
        strncpy(req.parameter, pb, len);

        if (strstr(pb, ".cgi") != NULL) {
            req.type = A_CGI;
            pb = strchr(pb, '?');
            if (pb != NULL) {
                pb++; // skip the ?
                len = strspn(pb, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._-1234567890=&");
                req.query_string = malloc(len + 1);
                if (req.query_string == NULL)
                    exit(EXIT_FAILURE);
                memset(req.query_string, 0, len + 1);
                strncpy(req.query_string, pb, len);
            } else {
                req.query_string = malloc(2);
                if (req.query_string == NULL)
                    exit(EXIT_FAILURE);
                sprintf(req.query_string, " ");
            }
        }
        DBG("parameter (len: %d): \"%s\"\n", len, req.parameter);
    }

    /*
     * Since when we are working with multiple input plugins
     * there are some url which could have a _[plugin number suffix]
     * For compatibility reasons it could be left in that case the output will be
     * generated from the 0. input plugin
     */
    if(query_suffixed) {
        char *sch = strchr(buffer, '_');
        if(sch != NULL) {  // there is an _ in the url so the input number should be present
            DBG("Suffix character: %s\n", sch + 1); // FIXME if more than 10 input plugin is added
            char numStr[3];
            memset(numStr, 0, 3);
            strncpy(numStr, sch + 1, 1);
            input_number = atoi(numStr);

            if ((req.type == A_SNAPSHOT_WXP) || (req.type == A_STREAM_WXP)) { // webcamxp adds offset to the camera number
                input_number--;
            }
        }
        DBG("plugin_no: %d\n", input_number);
    }

    /*
     * parse the rest of the HTTP-request
     * the end of the request-header is marked by a single, empty line with "\r\n"
     */
    do {
        memset(buffer, 0, sizeof(buffer));

        if((cnt = _readline(lcfd.fd, &iobuf, buffer, sizeof(buffer) - 1, 5)) == -1) {
            free_request(&req);
            close(lcfd.fd);
            return NULL;
        }

        if(strcasestr(buffer, "User-Agent: ") != NULL) {
            req.client = strdup(buffer + strlen("User-Agent: "));
        } else if(strcasestr(buffer, "Authorization: Basic ") != NULL) {
            req.credentials = strdup(buffer + strlen("Authorization: Basic "));
            decodeBase64(req.credentials);
            DBG("username:password: %s\n", req.credentials);
        }

    } while(cnt > 2 && !(buffer[0] == '\r' && buffer[1] == '\n'));

    /* check for username and password if parameter -c was given */
    if(lcfd.pc->conf.credentials != NULL) {
        if(req.credentials == NULL || strcmp(lcfd.pc->conf.credentials, req.credentials) != 0) {
            DBG("access denied\n");
            send_error(lcfd.fd, 401, "username and password do not match to configuration");
            close(lcfd.fd);
            free_request(&req);
            return NULL;
        }
        DBG("access granted\n");
    }

    /* now it's time to answer */
    if (query_suffixed) {
        if (req.type == A_OUTPUT_JSON) {
            if(!(input_number < pglobal->outcnt)) {
                DBG("Output number: %d out of range (valid: 0..%d)\n", input_number, pglobal->outcnt-1);
                send_error(lcfd.fd, 404, "Invalid output plugin number");
                req.type = A_UNKNOWN;
            }
        } else {
            if(!(input_number < pglobal->incnt)) {
                DBG("Input number: %d out of range (valid: 0..%d)\n", input_number, pglobal->incnt-1);
                send_error(lcfd.fd, 404, "Invalid input plugin number");
                req.type = A_UNKNOWN;
            }
        }
    }

    switch(req.type) {
    case A_SNAPSHOT_WXP:
    case A_SNAPSHOT:
        DBG("Request for snapshot from input: %d\n", input_number);
        send_snapshot(&lcfd, input_number);
        break;
    case A_STREAM:
        DBG("Request for stream from input: %d\n", input_number);
        send_stream(&lcfd, input_number);
        break;
    #ifdef WXP_COMPAT
    case A_STREAM_WXP:
        DBG("Request for WXP compat stream from input: %d\n", input_number);
        send_stream_wxp(&lcfd, input_number);
        break;
    #endif
    case A_COMMAND:
        if(lcfd.pc->conf.nocommands) {
            send_error(lcfd.fd, 501, "this server is configured to not accept commands");
            break;
        }
        command(lcfd.pc->id, lcfd.fd, req.parameter);
        break;
    case A_INPUT_JSON:
        DBG("Request for the Input plugin descriptor JSON file\n");
        send_input_JSON(lcfd.fd, input_number);
        break;
    case A_OUTPUT_JSON:
        DBG("Request for the Output plugin descriptor JSON file\n");
        send_output_JSON(lcfd.fd, input_number);
        break;
    case A_PROGRAM_JSON:
        DBG("Request for the program descriptor JSON file\n");
        send_program_JSON(lcfd.fd);
        break;
    #ifdef MANAGMENT
    case A_CLIENTS_JSON:
        DBG("Request for the clients JSON file\n");
        send_clients_JSON(lcfd.fd);
        break;
    #endif
    case A_FILE:
        if(lcfd.pc->conf.www_folder == NULL)
            send_error(lcfd.fd, 501, "no www-folder configured");
        else
            send_file(lcfd.pc->id, lcfd.fd, req.parameter);
        break;
    /*
        With the take argument we try to save the current image to file before we transmit it to the user.
        This is done trough the output_file plugin.
        If it not loaded, or the file could not be saved then we won't transmit the frame.
    */
    case A_TAKE: {
        int i, ret = 0, found = 0;
        for (i = 0; i<pglobal->outcnt; i++) {
            if (pglobal->out[i].name != NULL) {
                if (strstr(pglobal->out[i].name, "FILE output plugin")) {
                    found = 255;
                    DBG("output_file found id: %d\n", i);
                    char *filename = NULL;
                    char *filenamearg = NULL;
                    int len = 0;
                    DBG("Buffer: %s \n", req.parameter);
                    if((filename = strstr(req.parameter, "filename=")) != NULL) {
                        filename += strlen("filename=");
                        char *fn = strchr(filename, '&');
                        if (fn == NULL)
                            len = strlen(filename);
                        else
                            len = (int)(fn - filename);
                        filenamearg = (char*)calloc(len, sizeof(char));
                        memcpy(filenamearg, filename, len);
                        DBG("Filename = %s\n", filenamearg);
                        //int output_cmd(int plugin_id, unsigned int control_id, unsigned int group, int value, char *valueStr)
                        ret = pglobal->out[i].cmd(i, OUT_FILE_CMD_TAKE, IN_CMD_GENERIC, 0, filenamearg);
                    } else {
                        DBG("filename is not specified int the URL\n");
                        send_error(lcfd.fd, 404, "The &filename= must present for the take command in the URL");
                    }
                    break;
                }
            }
        }

        if (found == 0) {
            LOG("FILE CHANGE TEST output plugin not loaded\n");
            send_error(lcfd.fd, 404, "FILE output plugin not loaded, taking snapshot not possible");
        } else {
            if (ret == 0) {
                send_snapshot(&lcfd, input_number);
            } else {
                send_error(lcfd.fd, 404, "Taking snapshot failed!");
            }
        }
        } break;
    case A_CGI:
        DBG("cgi script: %s requested\n", req.parameter);
        execute_cgi(lcfd.pc->id, lcfd.fd, req.parameter, req.query_string);
        break;
    default:
        DBG("unknown request\n");
    }

    close(lcfd.fd);
    free_request(&req);

    DBG("leaving HTTP client thread\n");
    return NULL;
}

/******************************************************************************
Description.: This function cleans up resources allocated by the server_thread
Input Value.: arg is not used
Return Value: -
******************************************************************************/
void server_cleanup(void *arg)
{
    context *pcontext = arg;
    int i;

    OPRINT("cleaning up resources allocated by server thread #%02d\n", pcontext->id);

    for(i = 0; i < MAX_SD_LEN; i++)
        close(pcontext->sd[i]);
}

/******************************************************************************
Description.: Open a TCP socket and wait for clients to connect. If clients
              connect, start a new thread for each accepted connection.
Input Value.: arg is a pointer to the globals struct
Return Value: always NULL, will only return on exit
******************************************************************************/
void *server_thread(void *arg)
{
    int on;
    pthread_t client;
    struct addrinfo *aip, *aip2;
    struct addrinfo hints;
    struct sockaddr_storage client_addr;
    socklen_t addr_len = sizeof(struct sockaddr_storage);
    fd_set selectfds;
    int max_fds = 0;
    char name[NI_MAXHOST];
    int err;
    int i;

    context *pcontext = arg;
    pglobal = pcontext->pglobal;

    /* set cleanup handler to cleanup resources */
    pthread_cleanup_push(server_cleanup, pcontext);

    bzero(&hints, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_flags = AI_PASSIVE;
    hints.ai_socktype = SOCK_STREAM;

    snprintf(name, sizeof(name), "%d", ntohs(pcontext->conf.port));
    if((err = getaddrinfo(pcontext->conf.hostname, name, &hints, &aip)) != 0) {
        perror(gai_strerror(err));
        exit(EXIT_FAILURE);
    }

    for(i = 0; i < MAX_SD_LEN; i++)
        pcontext->sd[i] = -1;

    #ifdef MANAGMENT
    if (pthread_mutex_init(&client_infos.mutex, NULL)) {
        perror("Mutex initialization failed");
        exit(EXIT_FAILURE);
    }

    client_infos.client_count = 0;
    client_infos.infos = NULL;
    #endif

    /* open sockets for server (1 socket / address family) */
    i = 0;
    for(aip2 = aip; aip2 != NULL; aip2 = aip2->ai_next) {
        if((pcontext->sd[i] = socket(aip2->ai_family, aip2->ai_socktype, 0)) < 0) {
            continue;
        }

        /* ignore "socket already in use" errors */
        on = 1;
        if(setsockopt(pcontext->sd[i], SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0) {
            perror("setsockopt(SO_REUSEADDR) failed\n");
        }

        /* IPv6 socket should listen to IPv6 only, otherwise we will get "socket already in use" */
        on = 1;
        if(aip2->ai_family == AF_INET6 && setsockopt(pcontext->sd[i], IPPROTO_IPV6, IPV6_V6ONLY,
                (const void *)&on , sizeof(on)) < 0) {
            perror("setsockopt(IPV6_V6ONLY) failed\n");
        }

        /* perhaps we will use this keep-alive feature oneday */
        /* setsockopt(sd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)); */

        if(bind(pcontext->sd[i], aip2->ai_addr, aip2->ai_addrlen) < 0) {
            perror("bind");
            pcontext->sd[i] = -1;
            continue;
        }

        if(listen(pcontext->sd[i], 10) < 0) {
            perror("listen");
            pcontext->sd[i] = -1;
        } else {
            i++;
            if(i >= MAX_SD_LEN) {
                OPRINT("%s(): maximum number of server sockets exceeded", __FUNCTION__);
                i--;
                break;
            }
        }
    }

    pcontext->sd_len = i;

    if(pcontext->sd_len < 1) {
        OPRINT("%s(): bind(%d) failed\n", __FUNCTION__, htons(pcontext->conf.port));
        closelog();
        exit(EXIT_FAILURE);
    }

    /* create a child for every client that connects */
    while(!pglobal->stop) {
        //int *pfd = (int *)malloc(sizeof(int));
        cfd *pcfd = malloc(sizeof(cfd));

        if(pcfd == NULL) {
            fprintf(stderr, "failed to allocate (a very small amount of) memory\n");
            exit(EXIT_FAILURE);
        }

        DBG("waiting for clients to connect\n");

        do {
            FD_ZERO(&selectfds);

            for(i = 0; i < MAX_SD_LEN; i++) {
                if(pcontext->sd[i] != -1) {
                    FD_SET(pcontext->sd[i], &selectfds);

                    if(pcontext->sd[i] > max_fds)
                        max_fds = pcontext->sd[i];
                }
            }

            err = select(max_fds + 1, &selectfds, NULL, NULL, NULL);

            if(err < 0 && errno != EINTR) {
                perror("select");
                exit(EXIT_FAILURE);
            }
        } while(err <= 0);

        for(i = 0; i < max_fds + 1; i++) {
            if(pcontext->sd[i] != -1 && FD_ISSET(pcontext->sd[i], &selectfds)) {
                pcfd->fd = accept(pcontext->sd[i], (struct sockaddr *)&client_addr, &addr_len);
                pcfd->pc = pcontext;

                /* start new thread that will handle this TCP connected client */
                DBG("create thread to handle client that just established a connection\n");

                if(getnameinfo((struct sockaddr *)&client_addr, addr_len, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {
                    DBG("serving client: %s\n", name);
                }

                #if defined(MANAGMENT)
                pcfd->client = add_client(name);
                #endif

                if(pthread_create(&client, NULL, &client_thread, pcfd) != 0) {
                    DBG("could not launch another client thread\n");
                    close(pcfd->fd);
                    free(pcfd);
                    continue;
                }
                pthread_detach(client);
            }
        }
    }

    DBG("leaving server thread, calling cleanup function now\n");
    pthread_cleanup_pop(1);

    return NULL;
}

/******************************************************************************
Description.: Send a JSON file which is contains information about the input plugin's
              acceptable parameters
Input Value.: fildescriptor fd to send the answer to
Return Value: -
******************************************************************************/
void send_input_JSON(int fd, int input_number)
{
    char buffer[BUFFER_SIZE*16] = {0}; // FIXME do reallocation if the buffer size is small
    int i;
    sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
            "Content-type: %s\r\n" \
            STD_HEADER \
            "\r\n", "application/x-javascript");

    DBG("Serving the input plugin %d descriptor JSON file\n", input_number);


    sprintf(buffer + strlen(buffer),
            "{\n"
            "\"controls\": [\n");
    if(pglobal->in[input_number].in_parameters != NULL) {
        for(i = 0; i < pglobal->in[input_number].parametercount; i++) {

            char *menuString = NULL;
            if(pglobal->in[input_number].in_parameters[i].ctrl.type == V4L2_CTRL_TYPE_MENU) {
                if(pglobal->in[input_number].in_parameters[i].menuitems != NULL) {
                    int j, k = 1;
                    for(j = pglobal->in[input_number].in_parameters[i].ctrl.minimum; j <= pglobal->in[input_number].in_parameters[i].ctrl.maximum; j++) {
                        char *tempName = NULL; // temporary storage for name sanity checking

                        int prevSize = 0;
                        int itemLength = strlen((char*)&pglobal->in[input_number].in_parameters[i].menuitems[j].name);
                        tempName = (char*)calloc(itemLength + 1, sizeof(char));  // allocate space for the sanity checking
                        if (tempName == NULL) {
                            DBG("Realloc/calloc failed: %s\n", strerror(errno));
                            return;
                        }

                        check_JSON_string((char*)&pglobal->in[input_number].in_parameters[i].menuitems[j].name, tempName); // sanity check the string after non printable characters

                        itemLength += strlen("\"\": \"\"");

                        if (menuString == NULL) {
                            menuString = calloc(itemLength + 5, sizeof(char));
                        } else {
                            menuString = realloc(menuString, (strlen(menuString) + itemLength + 5) * (sizeof(char)));
                        }

                        if (menuString == NULL) {
                            DBG("Realloc/calloc failed: %s\n", strerror(errno));
                            return;
                        }
                        prevSize = strlen(menuString);

                        if(j != pglobal->in[input_number].in_parameters[i].ctrl.maximum) {
                            sprintf(menuString + prevSize, "\"%d\": \"%s\", ", j , tempName);
                        } else {
                            sprintf(menuString + prevSize, "\"%d\": \"%s\"", j , tempName);
                        }
                        k++;
                        free(tempName);
                    }
                }
            }

            sprintf(buffer + strlen(buffer),
                    "{\n"
                    "\"name\": \"%s\",\n"
                    "\"id\": \"%d\",\n"
                    "\"type\": \"%d\",\n"
                    "\"min\": \"%d\",\n"
                    "\"max\": \"%d\",\n"
                    "\"step\": \"%d\",\n"
                    "\"default\": \"%d\",\n"
                    "\"value\": \"%d\",\n"
                    "\"dest\": \"0\",\n"
                    "\"flags\": \"%d\",\n"
                    "\"group\": \"%d\"",
                    pglobal->in[input_number].in_parameters[i].ctrl.name,
                    pglobal->in[input_number].in_parameters[i].ctrl.id,
                    pglobal->in[input_number].in_parameters[i].ctrl.type,
                    pglobal->in[input_number].in_parameters[i].ctrl.minimum,
                    pglobal->in[input_number].in_parameters[i].ctrl.maximum,
                    pglobal->in[input_number].in_parameters[i].ctrl.step,
                    pglobal->in[input_number].in_parameters[i].ctrl.default_value,
                    pglobal->in[input_number].in_parameters[i].value,
                    // 0 is the code of the input plugin
                    pglobal->in[input_number].in_parameters[i].ctrl.flags,
                    pglobal->in[input_number].in_parameters[i].group
                   );

            // append the menu object to the menu typecontrols
            if(pglobal->in[input_number].in_parameters[i].ctrl.type == V4L2_CTRL_TYPE_MENU) {
                sprintf(buffer + strlen(buffer),
                        ",\n"
                        "\"menu\": {%s}\n"
                        "}",
                        menuString);
            } else {
                sprintf(buffer + strlen(buffer),
                        "\n"
                        "}");
            }

            if(i != (pglobal->in[input_number].parametercount - 1)) {
                sprintf(buffer + strlen(buffer), ",\n");
            }
            free(menuString);
        }
    } else {
        DBG("The input plugin has no paramters\n");
    }
    sprintf(buffer + strlen(buffer),
            "\n],\n"
            /*"},\n"*/);

    sprintf(buffer + strlen(buffer),
            //"{\n"
            "\"formats\": [\n");
    if(pglobal->in[input_number].in_formats != NULL) {
        for(i = 0; i < pglobal->in[input_number].formatCount; i++) {
            char *resolutionsString = NULL;
            int resolutionsStringLength = 0;
            int j = 0;
            for(j = 0; j < pglobal->in[input_number].in_formats[i].resolutionCount; j++) {
                char buffer_num[6];
                memset(buffer_num, '\0', 6);
                // JSON format example:
                // {"0": "320x240", "1": "640x480", "2": "960x720"}
                sprintf(buffer_num, "%d", j);
                resolutionsStringLength += strlen(buffer_num);
                sprintf(buffer_num, "%d", pglobal->in[input_number].in_formats[i].supportedResolutions[j].width);
                resolutionsStringLength += strlen(buffer_num);
                sprintf(buffer_num, "%d", pglobal->in[input_number].in_formats[i].supportedResolutions[j].height);
                resolutionsStringLength += strlen(buffer_num);
                if(j != (pglobal->in[input_number].in_formats[i].resolutionCount - 1)) {
                    resolutionsStringLength += (strlen("\"\": \"x\", ") + 5);
                    if (resolutionsString == NULL)
                        resolutionsString = calloc(resolutionsStringLength, sizeof(char*));
                    else
                        resolutionsString = realloc(resolutionsString, resolutionsStringLength * sizeof(char*));
                    if (resolutionsString == NULL) {
                        DBG("Realloc/calloc failed\n");
                        return;
                    }

                    sprintf(resolutionsString + strlen(resolutionsString),
                            "\"%d\": \"%dx%d\", ",
                            j,
                            pglobal->in[input_number].in_formats[i].supportedResolutions[j].width,
                            pglobal->in[input_number].in_formats[i].supportedResolutions[j].height);
                } else {
                    resolutionsStringLength += (strlen("\"\": \"x\"")+5);
                    if (resolutionsString == NULL)
                        resolutionsString = calloc(resolutionsStringLength, sizeof(char*));
                    else
                        resolutionsString = realloc(resolutionsString, resolutionsStringLength * sizeof(char*));
                    if (resolutionsString == NULL) {
                        DBG("Realloc/calloc failed\n");
                        return;
                    }
                    sprintf(resolutionsString + strlen(resolutionsString),
                            "\"%d\": \"%dx%d\"",
                            j,
                            pglobal->in[input_number].in_formats[i].supportedResolutions[j].width,
                            pglobal->in[input_number].in_formats[i].supportedResolutions[j].height);
                }
            }

            sprintf(buffer + strlen(buffer),
                    "{\n"
                    "\"id\": \"%d\",\n"
                    "\"name\": \"%s\",\n"
#ifdef V4L2_FMT_FLAG_COMPRESSED
                    "\"compressed\": \"%s\",\n"
#endif
#ifdef V4L2_FMT_FLAG_EMULATED
                    "\"emulated\": \"%s\",\n"
#endif
                    "\"current\": \"%s\",\n"
                    "\"resolutions\": {%s}\n"
                    ,
                    pglobal->in[input_number].in_formats[i].format.index,
                    pglobal->in[input_number].in_formats[i].format.description,
#ifdef V4L2_FMT_FLAG_COMPRESSED
                    pglobal->in[input_number].in_formats[i].format.flags & V4L2_FMT_FLAG_COMPRESSED ? "true" : "false",
#endif
#ifdef V4L2_FMT_FLAG_EMULATED
                    pglobal->in[input_number].in_formats[i].format.flags & V4L2_FMT_FLAG_EMULATED ? "true" : "false",
#endif
                    pglobal->in[input_number].in_formats[i].currentResolution != -1 ? "true" : "false",
                    resolutionsString
                   );

            if(pglobal->in[input_number].in_formats[i].currentResolution != -1) {
                sprintf(buffer + strlen(buffer),
                        ",\n\"currentResolution\": \"%d\"\n",
                        pglobal->in[input_number].in_formats[i].currentResolution
                       );
            }

            if(i != (pglobal->in[input_number].formatCount - 1)) {
                sprintf(buffer + strlen(buffer), "},\n");
            } else {
                sprintf(buffer + strlen(buffer), "}\n");
            }

            free(resolutionsString);
        }
    }
    sprintf(buffer + strlen(buffer),
            "\n]\n"
            "}\n");
    i = strlen(buffer);

    /* first transmit HTTP-header, afterwards transmit content of file */
    if(write(fd, buffer, i) < 0) {
        DBG("unable to serve the control JSON file\n");
    }
}


void send_program_JSON(int fd)
{
    char buffer[BUFFER_SIZE*16] = {0}; // FIXME do reallocation if the buffer size is small
    int i, k;
    sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
            "Content-type: %s\r\n" \
            STD_HEADER \
            "\r\n", "application/x-javascript");

    DBG("Serving the program descriptor JSON file\n");


    sprintf(buffer + strlen(buffer),
            "{\n"
            /*"\"program\": [\n"
            "{\n"*/
            "\"inputs\":[\n");
    for(k = 0; k < pglobal->incnt; k++) {
        sprintf(buffer + strlen(buffer),
                "{\n"
                "\"id\": \"%d\",\n"
                "\"name\": \"%s\",\n"
                "\"plugin\": \"%s\",\n"
                "\"args\": \"%s\"\n"
                "}",
                pglobal->in[k].param.id,
                pglobal->in[k].name,
                pglobal->in[k].plugin,
                pglobal->in[k].param.parameters);
        if(k != (pglobal->incnt - 1))
            sprintf(buffer + strlen(buffer), ", \n");
        else
            sprintf(buffer + strlen(buffer), "\n");
    }
    sprintf(buffer + strlen(buffer),
            /*"]\n"
            "}\n"
            "]\n"*/
            "],\n");
    sprintf(buffer + strlen(buffer),
            "\"outputs\":[\n");
    for(k = 0; k < pglobal->outcnt; k++) {
        sprintf(buffer + strlen(buffer),
                "{\n"
                "\"id\": \"%d\",\n"
                "\"name\": \"%s\",\n"
                "\"plugin\": \"%s\",\n"
                "\"args\": \"%s\"\n"
                "}",
                pglobal->out[k].param.id,
                pglobal->out[k].name,
                pglobal->out[k].plugin,
                pglobal->out[k].param.parameters);
        if(k != (pglobal->outcnt - 1))
            sprintf(buffer + strlen(buffer), ", \n");
        else
            sprintf(buffer + strlen(buffer), "\n");
    }
    sprintf(buffer + strlen(buffer),
            /*"]\n"
            "}\n"
            "]\n"*/
            "]}\n");
    i = strlen(buffer);

    /* first transmit HTTP-header, afterwards transmit content of file */
    if(write(fd, buffer, i) < 0) {
        DBG("unable to serve the program JSON file\n");
    }
}

/******************************************************************************
Description.:   checks the source string for non printable characters and replaces them with space
                the two arguments should be the same size allocated memory areas
Input Value.:   source
Return Value:   destination
******************************************************************************/
void check_JSON_string(char *source, char *destination)
{
    int i = 0;
    while (source[i] != '\0') {
        if (isprint(source[i])) {
            destination[i] = source [i];
        } else {
            destination[i] = ' ';
        }
        i++;
    }
}

/******************************************************************************
Description.: Send a JSON file which is contains information about the output plugin's
              acceptable parameters
Input Value.: fildescriptor fd to send the answer to
Return Value: -
******************************************************************************/
void send_output_JSON(int fd, int input_number)
{
    char buffer[BUFFER_SIZE*16] = {0}; // FIXME do reallocation if the buffer size is small
    int i;
    sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
            "Content-type: %s\r\n" \
            STD_HEADER \
            "\r\n", "application/x-javascript");

    DBG("Serving the output plugin %d descriptor JSON file\n", input_number);

    sprintf(buffer + strlen(buffer),
            "{\n"
            "\"controls\": [\n");
    if(pglobal->out[input_number].out_parameters != NULL) {
        for(i = 0; i < pglobal->out[input_number].parametercount; i++) {
            char *menuString = calloc(0, 0);
            if(pglobal->out[input_number].out_parameters[i].ctrl.type == V4L2_CTRL_TYPE_MENU) {
                if(pglobal->out[input_number].out_parameters[i].menuitems != NULL) {
                    int j, k = 1;
                    for(j = pglobal->out[input_number].out_parameters[i].ctrl.minimum; j <= pglobal->out[input_number].out_parameters[i].ctrl.maximum; j++) {
                        int prevSize = strlen(menuString);
                        int itemLength = strlen((char*)&pglobal->out[input_number].out_parameters[i].menuitems[j].name)  + strlen("\"\": \"\"");
                        if (menuString == NULL) {
                            menuString = calloc(itemLength, sizeof(char));
                        } else {
                            menuString = realloc(menuString, (strlen(menuString) + itemLength) * (sizeof(char)));
                        }

                        if (menuString == NULL) {
                            DBG("Realloc/calloc failed: %s\n", strerror(errno));
                            return;
                        }

                        if(j != pglobal->out[input_number].out_parameters[i].ctrl.maximum) {
                            sprintf(menuString + prevSize, "\"%d\": \"%s\", ", j , (char*)&pglobal->out[input_number].out_parameters[i].menuitems[j].name);
                        } else {
                            sprintf(menuString + prevSize, "\"%d\": \"%s\"", j , (char*)&pglobal->out[input_number].out_parameters[i].menuitems[j].name);
                        }
                        k++;
                    }
                }
            }

            sprintf(buffer + strlen(buffer),
                    "{\n"
                    "\"name\": \"%s\",\n"
                    "\"id\": \"%d\",\n"
                    "\"type\": \"%d\",\n"
                    "\"min\": \"%d\",\n"
                    "\"max\": \"%d\",\n"
                    "\"step\": \"%d\",\n"
                    "\"default\": \"%d\",\n"
                    "\"value\": \"%d\",\n"
                    "\"dest\": \"1\",\n"
                    "\"flags\": \"%d\",\n"
                    "\"group\": \"%d\"",
                    pglobal->out[input_number].out_parameters[i].ctrl.name,
                    pglobal->out[input_number].out_parameters[i].ctrl.id,
                    pglobal->out[input_number].out_parameters[i].ctrl.type,
                    pglobal->out[input_number].out_parameters[i].ctrl.minimum,
                    pglobal->out[input_number].out_parameters[i].ctrl.maximum,
                    pglobal->out[input_number].out_parameters[i].ctrl.step,
                    pglobal->out[input_number].out_parameters[i].ctrl.default_value,
                    pglobal->out[input_number].out_parameters[i].value,
                    // 1 is the code of the output plugin
                    pglobal->out[input_number].out_parameters[i].ctrl.flags,
                    pglobal->out[input_number].out_parameters[i].group
                   );

            if(pglobal->out[input_number].out_parameters[i].ctrl.type == V4L2_CTRL_TYPE_MENU) {
                sprintf(buffer + strlen(buffer),
                        ",\n"
                        "\"menu\": {%s}\n"
                        "}",
                        menuString);
            } else {
                sprintf(buffer + strlen(buffer),
                        "\n"
                        "}");
            }

            if(i != (pglobal->out[input_number].parametercount - 1)) {
                sprintf(buffer + strlen(buffer), ",\n");
            }
            free(menuString);
        }
    } else {
        DBG("The output plugin %d has no paramters\n", input_number);
    }
    sprintf(buffer + strlen(buffer),
            "\n]\n"
            /*"},\n"*/);

    sprintf(buffer + strlen(buffer),
            "}\n");
    i = strlen(buffer);

    /* first transmit HTTP-header, afterwards transmit content of file */
    if(write(fd, buffer, i) < 0) {
        DBG("unable to serve the control JSON file\n");
    }
}

#ifdef MANAGMENT
void send_clients_JSON(int fd)
{
    char buffer[BUFFER_SIZE*16] = {0}; // FIXME do reallocation if the buffer size is small
    unsigned long i = 0 ;
    sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
            "Content-type: %s\r\n" \
            STD_HEADER \
            "\r\n", "application/x-javascript");

    DBG("Serving the clients JSON file\n");

    sprintf(buffer + strlen(buffer),
            "{\n"
            "\"clients\": [\n");

    for (; i<client_infos.client_count; i++) {
        sprintf(buffer + strlen(buffer),
            "{\n"
            "\"address\": \"%s\",\n"
            "\"timestamp\": %ld\n"
            "}\n",
            client_infos.infos[i]->address,
            (unsigned long)client_infos.infos[i]->last_take_time.tv_sec);

        if(i != (client_infos.client_count - 1)) {
            sprintf(buffer + strlen(buffer), ",\n");
        }
    }

    sprintf(buffer + strlen(buffer),
            "]");

    sprintf(buffer + strlen(buffer),
            "\n}\n");
    i = strlen(buffer);

    /* first transmit HTTP-header, afterwards transmit content of file */
    if(write(fd, buffer, i) < 0) {
        DBG("unable to serve the control JSON file\n");
    }
}
#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_http/httpd.h
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#define IO_BUFFER 256
#define BUFFER_SIZE 1024

/* the boundary is used for the M-JPEG stream, it separates the multipart stream of pictures */
#define BOUNDARY "boundarydonotcross"

/*
 * this defines the buffer size for a JPG-frame
 * selecting to large values will allocate much wasted RAM for each buffer
 * selecting to small values will lead to crashes due to to small buffers
 */
#define MAX_FRAME_SIZE (256*1024)
#define TEN_K (10*1024)

/*
 * Standard header to be send along with other header information like mimetype.
 *
 * The parameters should ensure the browser does not cache our answer.
 * A browser should connect for each file and not serve files from his cache.
 * Using cached pictures would lead to showing old/outdated pictures
 * Many browser seem to ignore, or at least not always obey those headers
 * since i observed caching of files from time to time.
 */
#define STD_HEADER "Connection: close\r\n" \
    "Server: MJPG-Streamer/0.2\r\n" \
    "Cache-Control: no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0\r\n" \
    "Pragma: no-cache\r\n" \
    "Expires: Mon, 3 Jan 2000 12:34:56 GMT\r\n"

/*
 * Maximum number of server sockets (i.e. protocol families) to listen.
 */
#define MAX_SD_LEN 50

/*
 * Only the following fileypes are supported.
 *
 * Other filetypes are simply ignored!
 * This table is a 1:1 mapping of files extension to a certain mimetype.
 */
static const struct {
    const char *dot_extension;
    const char *mimetype;
} mimetypes[] = {
    { ".html", "text/html" },
    { ".htm",  "text/html" },
    { ".css",  "text/css" },
    { ".js",   "text/javascript" },
    { ".txt",  "text/plain" },
    { ".jpg",  "image/jpeg" },
    { ".jpeg", "image/jpeg" },
    { ".png",  "image/png"},
    { ".gif",  "image/gif" },
    { ".ico",  "image/x-icon" },
    { ".swf",  "application/x-shockwave-flash" },
    { ".cab",  "application/x-shockwave-flash" },
    { ".jar",  "application/java-archive" },
    { ".json", "application/json" }
};

/* the webserver determines between these values for an answer */
typedef enum {
    A_UNKNOWN,
    A_SNAPSHOT,
    A_SNAPSHOT_WXP,
    A_STREAM,
    A_STREAM_WXP,
    A_COMMAND,
    A_FILE,
    A_CGI,
    A_TAKE,
    A_INPUT_JSON,
    A_OUTPUT_JSON,
    A_PROGRAM_JSON,
    #ifdef MANAGMENT
    A_CLIENTS_JSON
    #endif
} answer_t;

/*
 * the client sends information with each request
 * this structure is used to store the important parts
 */
typedef struct {
    answer_t type;
    char *parameter;
    char *client;
    char *credentials;
    char *query_string;
} request;

/* the iobuffer structure is used to read from the HTTP-client */
typedef struct {
    int level;              /* how full is the buffer */
    char buffer[IO_BUFFER]; /* the data */
} iobuffer;

/* store configuration for each server instance */
typedef struct {
    int port;
    char *hostname;
    char *credentials;
    char *www_folder;
    char nocommands;
} config;

/* context of each server thread */
typedef struct {
    int sd[MAX_SD_LEN];
    int sd_len;
    int id;
    globals *pglobal;
    pthread_t threadID;

    config conf;
} context;


#if defined(MANAGMENT)
/*
 * this struct is used to hold information from the clients address, and last picture take time
 */
typedef struct _client_info {
    struct _client_info *next;
    char *address;
    struct timeval last_take_time;
} client_info;

struct {
    client_info **infos;
    unsigned int client_count;
    pthread_mutex_t mutex;
} client_infos;

#endif

/*
 * this struct is just defined to allow passing all necessary details to a worker thread
 * "cfd" is for connected/accepted filedescriptor
 */
typedef struct {
    context *pc;
    int fd;
    #ifdef MANAGMENT
    client_info *client;
    #endif
} cfd;



/* prototypes */
void *server_thread(void *arg);
void send_error(int fd, int which, char *message);
void send_output_JSON(int fd, int plugin_number);
void send_input_JSON(int fd, int plugin_number);
void send_program_JSON(int fd);
void check_JSON_string(char *source, char *destination);

#ifdef MANAGMENT
client_info *add_client(char *address);
int check_client_status(client_info *client);
void update_client_timestamp(client_info *client);
void send_clients_JSON(int fd);
#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_http/output_http.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <syslog.h>

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "../../mjpg_streamer.h"
#include "../../utils.h"
#include "httpd.h"

#define OUTPUT_PLUGIN_NAME "HTTP output plugin"
/*
 * keep context for each server
 */
context servers[MAX_OUTPUT_PLUGINS];

/******************************************************************************
Description.: print help for this plugin to stdout
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
            " Help for output plugin..: "OUTPUT_PLUGIN_NAME"\n" \
            " ---------------------------------------------------------------\n" \
            " The following parameters can be passed to this plugin:\n\n" \
            " [-w | --www ]...........: folder that contains webpages in \n" \
            "                           flat hierarchy (no subfolders)\n" \
            " [-p | --port ]..........: TCP port for this HTTP server\n" \
	    " [-l ] --listen ]........: Listen on Hostname / IP\n" \
            " [-c | --credentials ]...: ask for \"username:password\" on connect\n" \
            " [-n | --nocommands ]....: disable execution of commands\n"
            " ---------------------------------------------------------------\n");
}

/*** plugin interface functions ***/
/******************************************************************************
Description.: Initialize this plugin.
              parse configuration parameters,
              store the parsed values in global variables
Input Value.: All parameters to work with.
              Among many other variables the "param->id" is quite important -
              it is used to distinguish between several server instances
Return Value: 0 if everything is OK, other values signal an error
******************************************************************************/
int output_init(output_parameter *param, int id)
{
    int i;
    int  port;
    char *credentials, *www_folder, *hostname = NULL;
    char nocommands;

    DBG("output #%02d\n", param->id);

    port = htons(8080);
    credentials = NULL;
    www_folder = NULL;
    nocommands = 0;

    param->argv[0] = OUTPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"p", required_argument, 0, 0},
            {"port", required_argument, 0, 0},
            {"l", required_argument , 0, 0},
	    {"listen", required_argument, 0, 0},
            {"c", required_argument, 0, 0},
            {"credentials", required_argument, 0, 0},
            {"w", required_argument, 0, 0},
            {"www", required_argument, 0, 0},
            {"n", no_argument, 0, 0},
            {"nocommands", no_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

            /* p, port */
        case 2:
        case 3:
            DBG("case 2,3\n");
            port = htons(atoi(optarg));
            break;
       
            /* Interface name */
	case 4:
	case 5:
            DBG("case 4,5\n");
	    hostname = strdup(optarg);
	    break;

            /* c, credentials */
        case 6:
        case 7:
            DBG("case 6,7\n");
            credentials = strdup(optarg);
            break;

            /* w, www */
        case 8:
        case 9:
            DBG("case 8,9\n");
            www_folder = malloc(strlen(optarg) + 2);
            strcpy(www_folder, optarg);
            if(optarg[strlen(optarg)-1] != '/')
                strcat(www_folder, "/");
            break;

            /* n, nocommands */
        case 10:
        case 11:
            DBG("case 10,11\n");
            nocommands = 1;
            break;
        }
    }

    servers[param->id].id = param->id;
    servers[param->id].pglobal = param->global;
    servers[param->id].conf.port = port;
    servers[param->id].conf.hostname = hostname;
    servers[param->id].conf.credentials = credentials;
    servers[param->id].conf.www_folder = www_folder;
    servers[param->id].conf.nocommands = nocommands;

    OPRINT("www-folder-path......: %s\n", (www_folder == NULL) ? "disabled" : www_folder);
    OPRINT("HTTP TCP port........: %d\n", ntohs(port));
    OPRINT("HTTP Listen Address..: %s\n", hostname);
    OPRINT("username:password....: %s\n", (credentials == NULL) ? "disabled" : credentials);
    OPRINT("commands.............: %s\n", (nocommands) ? "disabled" : "enabled");

    param->global->out[id].name = malloc((strlen(OUTPUT_PLUGIN_NAME) + 1) * sizeof(char));
    sprintf(param->global->out[id].name, OUTPUT_PLUGIN_NAME);

    return 0;
}

/******************************************************************************
Description.: this will stop the server thread, client threads
              will not get cleaned properly, because they run detached and
              no pointer is kept. This is not a huge issue, because this
              funtion is intended to clean up the biggest mess on shutdown.
Input Value.: id determines which server instance to send commands to
Return Value: always 0
******************************************************************************/
int output_stop(int id)
{

    DBG("will cancel server thread #%02d\n", id);
    pthread_cancel(servers[id].threadID);

    return 0;
}

/******************************************************************************
Description.: This creates and starts the server thread
Input Value.: id determines which server instance to send commands to
Return Value: always 0
******************************************************************************/
int output_run(int id)
{
    DBG("launching server thread #%02d\n", id);

    /* create thread and pass context to thread function */
    pthread_create(&(servers[id].threadID), NULL, server_thread, &(servers[id]));
    pthread_detach(servers[id].threadID);

    return 0;
}

/******************************************************************************
Description.: This is just an example function, to show how the output
              plugin could implement some special command.
              If you want to control some GPIO Pin this is a good place to
              implement it. Dont forget to add command types and a mapping.
Input Value.: cmd is the command type
              id determines which server instance to send commands to
Return Value: 0 indicates success, other values indicate an error
******************************************************************************/
int output_cmd(int plugin, unsigned int control_id, unsigned int group, int value)
{
    DBG("command (%d, value: %d) for group %d triggered for plugin instance #%02d\n", control_id, value, group, plugin);
    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_http/README.md
================
mjpg-streamer output plugin: output_http
========================================

This plugin streams JPEG data from input plugins via HTTP.

Usage
=====

    mjpg_streamer [input plugin options] -o 'output_http.so [options]'

```
---------------------------------------------------------------
The following parameters can be passed to this plugin:

[-w | --www ]...........: folder that contains webpages in 
                          flat hierarchy (no subfolders)
[-p | --port ]..........: TCP port for this HTTP server
[-l ] --listen ]........: Listen on Hostname / IP
[-c | --credentials ]...: ask for "username:password" on connect
[-n | --nocommands ]....: disable execution of commands
---------------------------------------------------------------
```

Browser/VLC
-----------

To view the stream use VLC or Firefox/Chrome and open the URL:

    http://127.0.0.1:8080/?action=stream

If there are multiple input plugins, you can access each stream individually:

    http://127.0.0.1:8080/?action=stream_0
    http://127.0.0.1:8080/?action=stream_1

To do the same as the GET request above using NSURLSession in Objective-C, a POST request seems to work: 

    POST http://127.0.0.1:8080/stream 

To view a single JPEG just open this URL:

    http://127.0.0.1:8080/?action=snapshot

mplayer
-------

To play the HTTP M-JPEG stream with mplayer:

    # mplayer -fps 30 -demuxer lavf "http://127.0.0.1:8080/?action=stream&ignored.mjpg"

It might be necessary to configure mplayer to prefer IPv4 instead of IPv6:

    # vi ~./mplayer/config
    add or change the option: prefer-ipv4=yes


Notes
=====

If you would like to replace a WebcamXP based system with an mjpg-streamer based
you may use the  WXP_COMPAT argument to cmake. If you compile with this argument
the mjpg stream will be available as cam_1.mjpg and the still jpg snapshot as
cam_1.jpg. 

    # mkdir _build
    # cd _build && cmake -DWXP_COMPAT=ON ..
    # make

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_rtsp/CMakeLists.txt
================
MJPG_STREAMER_PLUGIN_OPTION(output_rtsp "RTSP output plugin")
MJPG_STREAMER_PLUGIN_COMPILE(output_rtsp output_rtsp.c)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_rtsp/output_rtsp.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

/*
  This output plugin is based on code from output_file.c
  Writen by Dimitrios Zachariadis
  Version 0.1, May 2010

  It provides a mechanism to take snapshots with a trigger from a UDP packet.
  The UDP msg contains the path for the snapshot jpeg file
  It echoes the message received back to the sender, after taking the snapshot
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <resolv.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>

#include <dirent.h>


#include "../../utils.h"
#include "../../mjpg_streamer.h"

#define OUTPUT_PLUGIN_NAME "RTSP output plugin"

enum RTSP_State {
    RTSP_State_Setup,
    RTSP_State_Playing,
    RTSP_State_Paused,
    RTSP_State_Teardown,
};

static pthread_t worker;
static globals *pglobal;
static int fd, max_frame_size;
static unsigned char *frame = NULL;
static char *command = NULL;
static int input_number = 0;

// UDP port
static int port = 554;

/******************************************************************************
Description.: print a help message
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
            " Help for output plugin..: "OUTPUT_PLUGIN_NAME"\n" \
            " ---------------------------------------------------------------\n" \
            " The following parameters can be passed to this plugin:\n\n" \
            " [-p | --port ]..........: UDP port to listen for picture requests. UDP message is the filename to save\n\n" \
            " [-i | --input ].......: read frames from the specified input plugin (first input plugin between the arguments is the 0th)\n\n" \
            " ---------------------------------------------------------------\n");
}

/******************************************************************************
Description.: clean up allocated resources
Input Value.: unused argument
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
    OPRINT("cleaning up resources allocated by worker thread\n");

    if(frame != NULL) {
        free(frame);
    }
    close(fd);
}

/******************************************************************************
Description.: this is the main worker thread
              it loops forever, grabs a fresh frame and stores it to file
Input Value.:
Return Value:
******************************************************************************/
void *worker_thread(void *arg)
{
    int ok = 1, frame_size = 0, rc = 0;
    char buffer1[1024] = {0};
    unsigned char *tmp_framebuffer = NULL;

    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, NULL);

    // set UDP server data structures ---------------------------
    if(port <= 0) {
        OPRINT("a valid UDP port must be provided\n");
        return NULL;
    }
    struct sockaddr_in addr;
    int sd;
    int bytes;
    unsigned int addr_len = sizeof(addr);
    char udpbuffer[1024] = {0};
    sd = socket(PF_INET, SOCK_DGRAM, 0);
    bzero(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);
    if(bind(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
        perror("bind");
    // -----------------------------------------------------------

    while(ok >= 0 && !pglobal->stop) {
        DBG("waiting for a UDP message\n");

        // UDP receive ---------------------------------------------
        memset(udpbuffer, 0, sizeof(udpbuffer));
        bytes = recvfrom(sd, udpbuffer, sizeof(udpbuffer), 0, (struct sockaddr*)&addr, &addr_len);
        // ---------------------------------------------------------



        DBG("waiting for fresh frame\n");
        pthread_mutex_lock(&pglobal->in[input_number].db);
        pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

        /* read buffer */
        frame_size = pglobal->in[input_number].size;

        /* check if buffer for frame is large enough, increase it if necessary */
        if(frame_size > max_frame_size) {
            DBG("increasing buffer size to %d\n", frame_size);

            max_frame_size = frame_size + (1 << 16);
            if((tmp_framebuffer = realloc(frame, max_frame_size)) == NULL) {
                pthread_mutex_unlock(&pglobal->in[input_number].db);
                LOG("not enough memory\n");
                return NULL;
            }

            frame = tmp_framebuffer;
        }

        /* copy frame to our local buffer now */
        memcpy(frame, pglobal->in[input_number].buf, frame_size);

        /* allow others to access the global buffer again */
        pthread_mutex_unlock(&pglobal->in[input_number].db);

        /* only save a file if a name came in with the UDP message */
        if(strlen(udpbuffer) > 0) {
            DBG("writing file: %s\n", udpbuffer);

            /* open file for write. Path must pre-exist */
            if((fd = open(udpbuffer, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
                OPRINT("could not open the file %s\n", udpbuffer);
                return NULL;
            }

            /* save picture to file */
            if(write(fd, frame, frame_size) < 0) {
                OPRINT("could not write to file %s\n", udpbuffer);
                perror("write()");
                close(fd);
                return NULL;
            }

            close(fd);
        }

        // send back client's message that came in udpbuffer
        sendto(sd, udpbuffer, bytes, 0, (struct sockaddr*)&addr, sizeof(addr));

        /* call the command if user specified one, pass current filename as argument */
        if(command != NULL) {
            memset(buffer1, 0, sizeof(buffer1));

            /* udpbuffer still contains the filename, pass it to the command as parameter */
            snprintf(buffer1, sizeof(buffer1), "%s \"%s\"", command, udpbuffer);
            DBG("calling command %s", buffer1);

            /* in addition provide the filename as environment variable */
            if((rc = setenv("MJPG_FILE", udpbuffer, 1)) != 0) {
                LOG("setenv failed (return value %d)\n", rc);
            }

            /* execute the command now */
            if((rc = system(buffer1)) != 0) {
                LOG("command failed (return value %d)\n", rc);
            }
        }
    }

    // close UDP port
    if(port > 0)
        close(sd);

    /* cleanup now */
    pthread_cleanup_pop(1);

    return NULL;
}

/*** plugin interface functions ***/
/******************************************************************************
Description.: this function is called first, in order to initialise
              this plugin and pass a parameter string
Input Value.: parameters
Return Value: 0 if everything is ok, non-zero otherwise
******************************************************************************/
int output_init(output_parameter *param)
{
    int i;

    param->argv[0] = OUTPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"p", required_argument, 0, 0},
            {"port", required_argument, 0, 0},
            {"i", required_argument, 0, 0},
            {"input", required_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;
        case 2:
        case 3:
            DBG("case 2,3\n");
            port = atoi(optarg);
            break;
            /* i, input */
        case 4:
        case 5:
            DBG("case 4,5\n");
            input_number = atoi(optarg);
            break;
        }
    }

    pglobal = param->global;
    if(!(input_number < pglobal->incnt)) {
        OPRINT("ERROR: the %d input_plugin number is too much only %d plugins loaded\n", input_number, pglobal->incnt);
        return 1;
    }

    OPRINT("input plugin.....: %d: %s\n", input_number, pglobal->in[input_number].plugin);
    OPRINT("UDP port..........: %d\n", port);
    return 0;
}

/******************************************************************************
Description.: calling this function stops the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_stop(int id)
{
    DBG("will cancel worker thread\n");
    pthread_cancel(worker);
    return 0;
}

/******************************************************************************
Description.: calling this function creates and starts the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_run(int id)
{
    DBG("launching worker thread\n");
    pthread_create(&worker, 0, worker_thread, NULL);
    pthread_detach(worker);
    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_udp/CMakeLists.txt
================
MJPG_STREAMER_PLUGIN_OPTION(output_udp "UDP output stream plugin")
MJPG_STREAMER_PLUGIN_COMPILE(output_udp output_udp.c)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_udp/output_udp.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

/*
  This output plugin is based on code from output_file.c
  Writen by Dimitrios Zachariadis
  Version 0.1, May 2010

  It provides a mechanism to take snapshots with a trigger from a UDP packet.
  The UDP msg contains the path for the snapshot jpeg file
  It echoes the message received back to the sender, after taking the snapshot
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <resolv.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>

#include <dirent.h>

#include "../../utils.h"
#include "../../mjpg_streamer.h"

#define OUTPUT_PLUGIN_NAME "UDP output plugin"

static pthread_t worker;
static globals *pglobal;
static int fd, delay, max_frame_size;
static char *folder = "/tmp";
static unsigned char *frame = NULL;
static char *command = NULL;
static int input_number = 0;

// UDP port
static int port = 0;

/******************************************************************************
Description.: print a help message
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
            " Help for output plugin..: "OUTPUT_PLUGIN_NAME"\n" \
            " ---------------------------------------------------------------\n" \
            " The following parameters can be passed to this plugin:\n\n" \
            " [-f | --folder ]........: folder to save pictures\n" \
            " [-d | --delay ].........: delay after saving pictures in ms\n" \
            " [-c | --command ].......: execute command after saveing picture\n" \
            " [-p | --port ]..........: UDP port to listen for picture requests. UDP message is the filename to save\n\n" \
            " [-i | --input ].......: read frames from the specified input plugin (first input plugin between the arguments is the 0th)\n\n" \
            " ---------------------------------------------------------------\n");
}

/******************************************************************************
Description.: clean up allocated resources
Input Value.: unused argument
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
    OPRINT("cleaning up resources allocated by worker thread\n");

    if(frame != NULL) {
        free(frame);
    }
    close(fd);
}

/******************************************************************************
Description.: this is the main worker thread
              it loops forever, grabs a fresh frame and stores it to file
Input Value.:
Return Value:
******************************************************************************/
void *worker_thread(void *arg)
{
    int ok = 1, frame_size = 0, rc = 0;
    char buffer1[1024] = {0};
    unsigned char *tmp_framebuffer = NULL;

    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, NULL);

    // set UDP server data structures ---------------------------
    if(port <= 0) {
        OPRINT("a valid UDP port must be provided\n");
        return NULL;
    }
    struct sockaddr_in addr;
    int sd;
    int bytes;
    unsigned int addr_len = sizeof(addr);
    char udpbuffer[1024] = {0};
    sd = socket(PF_INET, SOCK_DGRAM, 0);
    bzero(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);
    if(bind(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
        perror("bind");
    // -----------------------------------------------------------

    while(ok >= 0 && !pglobal->stop) {
        DBG("waiting for a UDP message\n");

        // UDP receive ---------------------------------------------
        memset(udpbuffer, 0, sizeof(udpbuffer));
        bytes = recvfrom(sd, udpbuffer, sizeof(udpbuffer), 0, (struct sockaddr*)&addr, &addr_len);
        // ---------------------------------------------------------



        DBG("waiting for fresh frame\n");
        pthread_mutex_lock(&pglobal->in[input_number].db);
        pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

        /* read buffer */
        frame_size = pglobal->in[input_number].size;

        /* check if buffer for frame is large enough, increase it if necessary */
        if(frame_size > max_frame_size) {
            DBG("increasing buffer size to %d\n", frame_size);

            max_frame_size = frame_size + (1 << 16);
            if((tmp_framebuffer = realloc(frame, max_frame_size)) == NULL) {
                pthread_mutex_unlock(&pglobal->in[input_number].db);
                LOG("not enough memory\n");
                return NULL;
            }

            frame = tmp_framebuffer;
        }

        /* copy frame to our local buffer now */
        memcpy(frame, pglobal->in[input_number].buf, frame_size);

        /* allow others to access the global buffer again */
        pthread_mutex_unlock(&pglobal->in[input_number].db);

        /* only save a file if a name came in with the UDP message */
        if(strlen(udpbuffer) > 0) {
            DBG("writing file: %s\n", udpbuffer);

            /* open file for write. Path must pre-exist */
            if((fd = open(udpbuffer, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
                OPRINT("could not open the file %s\n", udpbuffer);
                return NULL;
            }

            /* save picture to file */
            if(write(fd, frame, frame_size) < 0) {
                OPRINT("could not write to file %s\n", udpbuffer);
                perror("write()");
                close(fd);
                return NULL;
            }

            close(fd);
        }

        // send back client's message that came in udpbuffer
        sendto(sd, udpbuffer, bytes, 0, (struct sockaddr*)&addr, sizeof(addr));

        /* call the command if user specified one, pass current filename as argument */
        if(command != NULL) {
            memset(buffer1, 0, sizeof(buffer1));

            /* udpbuffer still contains the filename, pass it to the command as parameter */
            snprintf(buffer1, sizeof(buffer1), "%s \"%s\"", command, udpbuffer);
            DBG("calling command %s", buffer1);

            /* in addition provide the filename as environment variable */
            if((rc = setenv("MJPG_FILE", udpbuffer, 1)) != 0) {
                LOG("setenv failed (return value %d)\n", rc);
            }

            /* execute the command now */
            if((rc = system(buffer1)) != 0) {
                LOG("command failed (return value %d)\n", rc);
            }
        }

        /* if specified, wait now */
        if(delay > 0) {
            usleep(1000 * delay);
        }
    }

    // close UDP port
    if(port > 0)
        close(sd);

    /* cleanup now */
    pthread_cleanup_pop(1);

    return NULL;
}

/*** plugin interface functions ***/
/******************************************************************************
Description.: this function is called first, in order to initialise
              this plugin and pass a parameter string
Input Value.: parameters
Return Value: 0 if everything is ok, non-zero otherwise
******************************************************************************/
int output_init(output_parameter *param)
{
    int i;

    delay = 0;

    param->argv[0] = OUTPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"f", required_argument, 0, 0},
            {"folder", required_argument, 0, 0},
            {"d", required_argument, 0, 0},
            {"delay", required_argument, 0, 0},
            {"c", required_argument, 0, 0},
            {"command", required_argument, 0, 0},
            {"p", required_argument, 0, 0},
            {"port", required_argument, 0, 0},
            {"i", required_argument, 0, 0},
            {"input", required_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

            /* f, folder */
        case 2:
        case 3:
            DBG("case 2,3\n");
            folder = malloc(strlen(optarg) + 1);
            strcpy(folder, optarg);
            if(folder[strlen(folder)-1] == '/')
                folder[strlen(folder)-1] = '\0';
            break;

            /* d, delay */
        case 4:
        case 5:
            DBG("case 4,5\n");
            delay = atoi(optarg);
            break;

            /* c, command */
        case 6:
        case 7:
            DBG("case 6,7\n");
            command = strdup(optarg);
            break;
            /* p, port */
        case 8:
        case 9:
            DBG("case 8,9\n");
            port = atoi(optarg);
            break;
            /* i, input */
        case 10:
        case 11:
            DBG("case 10,11\n");
            input_number = atoi(optarg);
            break;
        }
    }

    pglobal = param->global;
    if(!(input_number < pglobal->incnt)) {
        OPRINT("ERROR: the %d input_plugin number is too much only %d plugins loaded\n", input_number, pglobal->incnt);
        return 1;
    }
    OPRINT("input plugin.....: %d: %s\n", input_number, pglobal->in[input_number].plugin);
    OPRINT("output folder.....: %s\n", folder);
    OPRINT("delay after save..: %d\n", delay);
    OPRINT("command...........: %s\n", (command == NULL) ? "disabled" : command);
    if(port > 0) {
        OPRINT("UDP port..........: %d\n", port);
    } else {
        OPRINT("UDP port..........: %s\n", "disabled");
    }
    return 0;
}

/******************************************************************************
Description.: calling this function stops the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_stop(int id)
{
    DBG("will cancel worker thread\n");
    pthread_cancel(worker);
    return 0;
}

/******************************************************************************
Description.: calling this function creates and starts the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_run(int id)
{
    DBG("launching worker thread\n");
    pthread_create(&worker, 0, worker_thread, NULL);
    pthread_detach(worker);
    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_viewer/CMakeLists.txt
================
find_package(SDL)

MJPG_STREAMER_PLUGIN_OPTION(output_viewer "SDL output viewer plugin"
                            ONLYIF JPEG_LIB SDL_FOUND)

if (PLUGIN_OUTPUT_VIEWER)
    include_directories(${SDL_INCLUDE_DIR})
    MJPG_STREAMER_PLUGIN_COMPILE(output_viewer output_viewer.c)
    target_link_libraries(output_viewer ${SDL_LIBRARY} ${JPEG_LIB})
endif()

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_viewer/output_viewer.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2008 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <pthread.h>
#include <syslog.h>

#include <SDL/SDL.h>
#include <jpeglib.h>


#include "../../utils.h"
#include "../../mjpg_streamer.h"

#define OUTPUT_PLUGIN_NAME "VIEWER output plugin"

static pthread_t worker;
static globals *pglobal;
static unsigned char *frame = NULL;
static int input_number = 0;

/******************************************************************************
Description.: print a help message
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    fprintf(stderr, " ---------------------------------------------------------------\n" \
            " Help for output plugin..: "OUTPUT_PLUGIN_NAME"\n" \
            " ---------------------------------------------------------------\n");
}

/******************************************************************************
Description.: clean up allocated resources
Input Value.: unused argument
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;

    if(!first_run) {
        DBG("already cleaned up resources\n");
        return;
    }

    first_run = 0;
    OPRINT("cleaning up resources allocated by worker thread\n");

    free(frame);
    SDL_Quit();
}

typedef struct {
    struct jpeg_source_mgr pub;

    Uint8 *jpegdata;
    int jpegsize;
} my_source_mgr;

static void init_source(j_decompress_ptr cinfo)
{
    return;
}

static int fill_input_buffer(j_decompress_ptr cinfo)
{
    my_source_mgr * src = (my_source_mgr *) cinfo->src;

    src->pub.next_input_byte = src->jpegdata;
    src->pub.bytes_in_buffer = src->jpegsize;

    return TRUE;
}

static void skip_input_data(j_decompress_ptr cinfo, long num_bytes)
{
    my_source_mgr * src = (my_source_mgr *) cinfo->src;

    if(num_bytes > 0) {
        src->pub.next_input_byte += (size_t) num_bytes;
        src->pub.bytes_in_buffer -= (size_t) num_bytes;
    }
}

static void term_source(j_decompress_ptr cinfo)
{
    return;
}

static void jpeg_init_src(j_decompress_ptr cinfo, Uint8 *jpegdata, int jpegsize)
{
    my_source_mgr *src;

    if(cinfo->src == NULL) {  /* first time for this JPEG object? */
        cinfo->src = (struct jpeg_source_mgr *)(*cinfo->mem->alloc_small)((j_common_ptr) cinfo, JPOOL_PERMANENT, sizeof(my_source_mgr));
        src = (my_source_mgr *) cinfo->src;
    }

    src = (my_source_mgr *) cinfo->src;
    src->pub.init_source = init_source;
    src->pub.fill_input_buffer = fill_input_buffer;
    src->pub.skip_input_data = skip_input_data;
    src->pub.resync_to_restart = jpeg_resync_to_restart;
    src->pub.term_source = term_source;
    src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
    src->pub.next_input_byte = NULL; /* until buffer loaded */

    src->jpegdata = jpegdata;
    src->jpegsize = jpegsize;
}

static void my_error_exit(j_common_ptr cinfo)
{
    DBG("JPEG data contains an error\n");
}

static void my_error_output_message(j_common_ptr cinfo)
{
    DBG("JPEG data contains an error\n");
}

typedef struct {
    int height;
    int width;
    unsigned char *buffer;
    int buffersize;
} decompressed_image;

int decompress_jpeg(unsigned char *jpeg, int jpegsize, decompressed_image *image)
{
    struct jpeg_decompress_struct cinfo;
    JSAMPROW rowptr[1];
    struct jpeg_error_mgr jerr;

    /* create an error handler that does not terminate MJPEG-streamer */
    cinfo.err = jpeg_std_error(&jerr);
    jerr.error_exit = my_error_exit;
    jerr.output_message = my_error_output_message;

    /* create the decompressor structures */
    jpeg_create_decompress(&cinfo);

    /* initalize the structures of decompressor */
    jpeg_init_src(&cinfo, jpeg, jpegsize);

    /* read the JPEG header data */
    if(jpeg_read_header(&cinfo, TRUE) < 0) {
        jpeg_destroy_decompress(&cinfo);
        DBG("could not read the header\n");
        return 1;
    }

    /*
     * I just expect RGB colored JPEGs, so the num_components must be three
     */
    if(cinfo.num_components != 3) {
        jpeg_destroy_decompress(&cinfo);
        DBG("unsupported number of components (~colorspace)\n");
        return 1;
    }

    /* just use RGB output and adjust decompression parameters */
    cinfo.out_color_space = JCS_RGB;
    cinfo.quantize_colors = FALSE;
    /* to scale the decompressed image, the fraction could be changed here */
    cinfo.scale_num   = 1;
    cinfo.scale_denom = 1;
    cinfo.dct_method = JDCT_FASTEST;
    cinfo.do_fancy_upsampling = FALSE;

    jpeg_calc_output_dimensions(&cinfo);

    /* store the image information */
    image->width = cinfo.output_width;
    image->height = cinfo.output_height;

    /*
     * just allocate a new buffer if not already allocated
     * pay a lot attention, that the calling function has to ensure, that the buffer
     * must be large enough
     */
    if(image->buffer == NULL) {
        image->buffersize = image->width * image->height * cinfo.num_components;
        /* the calling function has to ensure that this buffer will become freed after use! */
        image->buffer = malloc(image->buffersize);
        if(image->buffer == NULL) {
            jpeg_destroy_decompress(&cinfo);
            DBG("allocating memory failed\n");
            return 1;
        }
    }

    /* start to decompress */
    if(jpeg_start_decompress(&cinfo) < 0) {
        jpeg_destroy_decompress(&cinfo);
        DBG("could not start decompression\n");
        return 1;
    }

    while(cinfo.output_scanline < cinfo.output_height) {
        rowptr[0] = (JSAMPROW)(Uint8 *)image->buffer + cinfo.output_scanline * image->width * cinfo.num_components;

        if(jpeg_read_scanlines(&cinfo, rowptr, (JDIMENSION) 1) < 0) {
            jpeg_destroy_decompress(&cinfo);
            DBG("could not decompress this line\n");
            return 1;
        }
    }

    if(jpeg_finish_decompress(&cinfo) < 0) {
        jpeg_destroy_decompress(&cinfo);
        DBG("could not finish compression\n");
        return 1;
    }

    /* all is done */
    jpeg_destroy_decompress(&cinfo);

    return 0;
}

/******************************************************************************
Description.: this is the main worker thread
              it loops forever, grabs a fresh frame, decompressed the JPEG
              and displays the decoded data using SDL
Input Value.:
Return Value:
******************************************************************************/
void *worker_thread(void *arg)
{
    int frame_size = 0, firstrun = 1;

    SDL_Surface *screen = NULL, *image = NULL;
    decompressed_image rgbimage;

    /* initialze the buffer for the decompressed image */
    rgbimage.buffersize = 0;
    rgbimage.buffer = NULL;

    /* initialze the SDL video subsystem */
    if(SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr, "Couldn't initialize SDL: %s\n", SDL_GetError());
        exit(EXIT_FAILURE);
    }

    /* just allocate a large buffer for the JPEGs */
    if((frame = malloc(4096 * 1024)) == NULL) {
        OPRINT("not enough memory for worker thread\n");
        exit(EXIT_FAILURE);
    }

    /* set cleanup handler to cleanup allocated resources */
    pthread_cleanup_push(worker_cleanup, NULL);

    while(!pglobal->stop) {
        DBG("waiting for fresh frame\n");
        pthread_mutex_lock(&pglobal->in[input_number].db);
        pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

        /* read buffer */
        frame_size = pglobal->in[input_number].size;
        memcpy(frame, pglobal->in[input_number].buf, frame_size);

        pthread_mutex_unlock(&pglobal->in[input_number].db);

        /* decompress the JPEG and store results in memory */
        if(decompress_jpeg(frame, frame_size, &rgbimage)) {
            DBG("could not properly decompress JPEG data\n");
            continue;
        }

        if(firstrun) {
            /* create the primary surface (the visible window) */
            screen = SDL_SetVideoMode(rgbimage.width, rgbimage.height, 0, SDL_ANYFORMAT | SDL_HWSURFACE);
            SDL_WM_SetCaption("MJPG-Streamer Viewer", NULL);

            /* create a SDL surface to display the data */
            image = SDL_AllocSurface(SDL_SWSURFACE, rgbimage.width, rgbimage.height, 24,
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
                                     0x0000FF, 0x00FF00, 0xFF0000,
#else
                                     0xFF0000, 0x00FF00, 0x0000FF,
#endif
                                     0);

            /* copy the decoded data across */
            memcpy(image->pixels, rgbimage.buffer, rgbimage.width * rgbimage.height * 3);
            free(rgbimage.buffer);

            /* now, that we know the dimensions, we can directly copy to the right surface */
            rgbimage.buffer = image->pixels;
            rgbimage.buffersize = rgbimage.width * rgbimage.height * 3;

            firstrun = 0;
        }

        /* copy the image to the primary surface */
        SDL_BlitSurface(image, NULL, screen, NULL);

        /* redraw the whole surface */
        SDL_Flip(screen);
    }

    pthread_cleanup_pop(1);

    /* get rid of the image */
    SDL_FreeSurface(image);

    return NULL;
}

/*** plugin interface functions ***/
/******************************************************************************
Description.: this function is called first, in order to initialise
              this plugin and pass a parameter string
Input Value.: parameters
Return Value: 0 if everything is ok, non-zero otherwise
******************************************************************************/
int output_init(output_parameter *param)
{
    int i;

    param->argv[0] = OUTPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"i", required_argument, 0, 0},
            {"input", required_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;
            /* i, input */
        case 2:
        case 3:
            DBG("case 2,3\n");
            input_number = atoi(optarg);
            break;
        }
    }

    pglobal = param->global;
    if(!(input_number < pglobal->incnt)) {
        OPRINT("ERROR: the %d input_plugin number is too much only %d plugins loaded\n", input_number, pglobal->incnt);
        return 1;
    }
    OPRINT("input plugin.....: %d: %s\n", input_number, pglobal->in[input_number].plugin);

    return 0;
}

/******************************************************************************
Description.: calling this function stops the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_stop(int id)
{
    DBG("will cancel worker thread\n");
    pthread_cancel(worker);
    return 0;
}

/******************************************************************************
Description.: calling this function creates and starts the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_run(int id)
{
    DBG("launching worker thread\n");
    pthread_create(&worker, 0, worker_thread, NULL);
    pthread_detach(worker);
    return 0;
}

int output_cmd()
{


}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_viewer/README.md
================
mjpg-streamer output plugin: output_viewer
==========================================

This is a simple plugin that will display the input plugin stream in an SDL
window.

You must have libsdl-devel installed (or similar) in order for this plugin to
be compiled & installed.

Usage
=====

    mjpg_streamer [input plugin options] -o 'output_viewer.so'

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_zmqserver/CMakeLists.txt
================
include(FindZeroMQ)
include(FindProtobuf-c)

MJPG_STREAMER_PLUGIN_OPTION(output_zmqserver "ZMQ Server output plugin"
                            ONLYIF ZeroMQ_LIBRARY PROTOBUF_C_LIBRARY)


if (PLUGIN_OUTPUT_ZMQSERVER)
    protobuf_c_generate(PROTO_SRC PROTO_HEADER package.proto)
    include_directories(${ZeroMQ_INCLUDE_DIR})
    include_directories(${PROTOBUF_C_INCLUDE_DIR})
    include_directories(${CMAKE_CURRENT_BINARY_DIR})
    MJPG_STREAMER_PLUGIN_COMPILE(output_zmqserver ${PROTO_SRC} output_zmqserver.c)
    target_link_libraries(output_zmqserver ${ZeroMQ_LIBRARY} ${PROTOBUF_C_LIBRARY})
endif()

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_zmqserver/output_zmqserver.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>
#include <dirent.h>
#include <netinet/in.h>
#include <zmq.h>

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "package.pb-c.h"
#include "output_zmqserver.h"

#include "../../utils.h"
#include "../../mjpg_streamer.h"

#define OUTPUT_PLUGIN_NAME "UDPSERVER output plugin"

#define MAX_ZMQ_BUFFER_SIZE 10

static pthread_t worker;
static globals *pglobal;
static int fd, ringbuffer_size = -1, ringbuffer_exceed = 0, max_frame_size;
static char *folder = "/tmp";
static unsigned char *frame = NULL;
static unsigned char *frames[MAX_ZMQ_BUFFER_SIZE];
static char *command = NULL;
static int input_number = 0;
static char *mjpgFileName = NULL;
static char *zmqAddress = NULL;
static int zmqBufferSize = 3;
static int zmqBufferPos = 0;
static Pb__Package pbPackage = PB__PACKAGE__INIT; // Package

static void *context;
static void *publisher;
static void *buf;                         // Buffer to store serialized data
static int bufferSize;

static clock_t begin, end;

/******************************************************************************
Description.: print a help message
Input Value.: -
Return Value: -
******************************************************************************/
void help(void)
{
    // TODO: Update available command line arguments.
    fprintf(stderr, " ---------------------------------------------------------------\n" \
            " Help for output plugin..: "OUTPUT_PLUGIN_NAME"\n" \
            " ---------------------------------------------------------------\n" \
            " The following parameters can be passed to this plugin:\n\n" \
            " [-f | --folder ]........: folder to save pictures\n" \
            " [-m | --mjpeg ].........: save the frames to an mjpg file \n" \
            " [-i | --input ].........: read frames from the specified input plugin\n" \
            " The following arguments are takes effect only if the current mode is not MJPG\n" \
            " [-s | --size ]..........: size of ring buffer (max number of pictures to hold)\n" \
            " [-e | --exceed ]........: allow ringbuffer to exceed limit by this amount\n" \
            " [-c | --command ].......: execute command after saving picture\n"\
            " ---------------------------------------------------------------\n");
}

/******************************************************************************
Description.: clean up allocated ressources
Input Value.: unused argument
Return Value: -
******************************************************************************/
void worker_cleanup(void *arg)
{
    static unsigned char first_run = 1;
    int i;

    if (mjpgFileName != NULL) {
        close(fd);
    }

    if(!first_run) {
        DBG("already cleaned up ressources\n");
        return;
    }

    first_run = 0;
    OPRINT("cleaning up ressources allocated by worker thread\n");

    if(frame != NULL) {
        free(frame);
    }
    close(fd);

    // cleanup zmq
    zmq_close (publisher);
    zmq_ctx_destroy (context);

    // Free the allocated serialized buffer
    free(buf);

    // Free protobuf message
    for (i = 0; i < pbPackage.n_frame; ++i)
    {
        free(pbPackage.frame[i]);
    }
    free(pbPackage.frame);
}

/******************************************************************************
Description.: compares a directory entry with a pattern
Input Value.: directory entry
Return Value: 0 if string do not match, 1 if they match
******************************************************************************/
int check_for_filename(const struct dirent *entry)
{
    int rc;

    int year, month, day, hour, minute, second;
    unsigned long long number;

    /*
     * try to scan the string using scanf
     * I would like to use a define for this format string later...
     */
    rc = sscanf(entry->d_name, "%d_%d_%d_%d_%d_%d_picture_%09llu.jpg", &year, \
                &month, \
                &day, \
                &hour, \
                &minute, \
                &second, \
                &number);

    DBG("%s, rc is %d (%d, %d, %d, %d, %d, %d, %llu)\n", entry->d_name, \
        rc, \
        year, \
        month, \
        day, \
        hour, \
        minute, \
        second, \
        number);

    /* if scanf could find all values, it matches our filenames */
    if(rc != 7) return 0;

    return 1;
}

/******************************************************************************
Description.: delete oldest files, just keep "size" most recent files
              This funtion MAY delete the wrong files if the time is not valid
Input Value.: how many files to keep
Return Value: -
******************************************************************************/
void maintain_ringbuffer(int size)
{
    struct dirent **namelist;
    int n, i;
    char buffer[1<<16];

    /* do nothing if ringbuffer is not set or wrong value is set */
    if(size < 0) return;

    /* get a sorted list of directory items */
    n = scandir(folder, &namelist, check_for_filename, alphasort);
    if(n < 0) {
        perror("scandir");
        return;
    }

    DBG("found %d directory entries\n", n);

    /* delete the first (thus oldest) number of files */
    for(i = 0; i < (n - size); i++) {

        /* put together the folder name and the directory item */
        snprintf(buffer, sizeof(buffer), "%s/%s", folder, namelist[i]->d_name);

        DBG("delete: %s\n", buffer);

        /* mark item for deletion */
        if(unlink(buffer) == -1) {
            perror("could not delete file");
        }

        /* free allocated memory for name */
        free(namelist[i]);
    }

    /* keep the rest, but we still have to free every result */
    for(i = MAX(n - size, 0); i < n; i++) {
        DBG("keep: %s\n", namelist[i]->d_name);
        free(namelist[i]);
    }

    /* free last just allocated ressources */
    free(namelist);
}

/******************************************************************************
Description.: this is the main worker thread
              it loops forever, grabs a fresh frame and stores it to file
Input Value.:
Return Value:
******************************************************************************/
void *worker_thread(void *arg)
{
    int ok = 1, frame_size = 0, rc = 0;
    char buffer1[1024] = {0}, buffer2[1024] = {0};
    unsigned long long counter = 0;
    unsigned char *tmp_framebuffer = NULL;

    //  Prepare our context and publisher
    //char zmqAddress[20];
    if (zmqAddress == NULL) {
        LOG("No ZMQ address specified");
    }

    context = zmq_ctx_new ();
    publisher = zmq_socket (context, ZMQ_PUB);
    //snprintf(zmqAddress, 20u, "epgm://eth0;239.1.1.1:%i", zmqPort);

    if (zmq_bind (publisher, zmqAddress) == -1) {
        LOG("Couldn't create zmq socket.\n");
    }

    unsigned len;                      // Length of serialized data
    char topic[] = "frames";
    struct timeval timestamp;
    int i;

    buf = NULL;
    for (i = 0; i < MAX_ZMQ_BUFFER_SIZE; ++i)
    {
        frames[i] = NULL;
    }

    pbPackage.n_frame = zmqBufferSize;
    if ((pbPackage.frame = malloc(sizeof(Pb__Package__Frame*) * pbPackage.n_frame)) == NULL) {
        LOG("not enough memory\n");
    }
    for (i = 0; i < pbPackage.n_frame; ++i)
    {
        if ((pbPackage.frame[i] = malloc(sizeof(Pb__Package__Frame))) == NULL) {
            LOG("not enough memory\n");
        }
        pb__package__frame__init(pbPackage.frame[i]);
    }
    /* set cleanup handler to cleanup allocated ressources */
    pthread_cleanup_push(worker_cleanup, NULL);

    while(ok >= 0 && !pglobal->stop) {
        DBG("waiting for fresh frame\n");

        pthread_mutex_lock(&pglobal->in[input_number].db);
        pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);

        /* read buffer */
        frame_size = pglobal->in[input_number].size;

        /* set the right frame to store the data */
        frame = frames[zmqBufferPos];

        /* check if buffer for frame is large enough, increase it if necessary */
        if((frame_size > max_frame_size) || (frame == NULL)) {
            DBG("increasing buffer size to %d\n", frame_size);

            if (frame_size > max_frame_size) {
                max_frame_size = frame_size + (1 << 16);
            }
            if((tmp_framebuffer = realloc(frame, max_frame_size)) == NULL) {
                pthread_mutex_unlock(&pglobal->in[input_number].db);
                LOG("not enough memory\n");
                return NULL;
            }

            if ((setvbuf(stdout, NULL, _IOFBF, max_frame_size)) != 0) {
                DBG("setvbuf failed.\n");
            }

            frame = tmp_framebuffer;
        }

        /* copy v4l2_buffer timeval to user space */
        timestamp = pglobal->in[input_number].timestamp;

        /* copy frame to our local buffer now */
        memcpy(frame, pglobal->in[input_number].buf, frame_size);

        /* resync again with the frame buffer */
        frames[zmqBufferPos] = frame;

        /* allow others to access the global buffer again */
        pthread_mutex_unlock(&pglobal->in[input_number].db);

        if (mjpgFileName == NULL) { // single files with ringbuffer mode
            DBG("Packaging data: %lld\n", counter);
            counter++;

            begin = clock();

            /* allocate enough memory to store a serialized string */
            if ((buf == NULL) || (bufferSize < (max_frame_size * zmqBufferSize + 20)))
            {
                bufferSize = (max_frame_size * zmqBufferSize + 20);
                buf = realloc(buf, bufferSize);
                if (buf == NULL) {
                    LOG("Not enough memory");
                }
            }

            /* fill protobuf data */
            pbPackage.frame[zmqBufferPos]->timestamp_unix = (u_int32_t)time(NULL);
            pbPackage.frame[zmqBufferPos]->timestamp_s = (u_int32_t)timestamp.tv_sec;
            pbPackage.frame[zmqBufferPos]->timestamp_us = (u_int32_t)timestamp.tv_usec;
            pbPackage.frame[zmqBufferPos]->blob.data = frame;
            pbPackage.frame[zmqBufferPos]->blob.len = frame_size;

            zmqBufferPos++;

            if (zmqBufferPos == zmqBufferSize)
            {
                DBG("transmitting ZMQ: %lld\n", counter);
                /* pack protobuf data */
                len = pb__package__get_packed_size(&pbPackage);
                DBG("packing data: %i %i", max_frame_size, len);
                pb__package__pack(&pbPackage, buf);

                DBG("sending data");
                // send data using zmq
                if ((zmq_send(publisher, topic, strlen(topic), ZMQ_SNDMORE) == -1) || (zmq_send(publisher, buf, len, 0) == -1)) {
                    DBG("ZMQ Transmission failure");
                }

                zmqBufferPos = 0;
            }

            end = clock();
            DBG("Time1: %f\n", (double)(end-begin) / CLOCKS_PER_SEC);
            begin = clock();

            /* call the command if user specified one, pass current filename as argument */
            if(command != NULL) {
                memset(buffer1, 0, sizeof(buffer1));

                /* buffer2 still contains the filename, pass it to the command as parameter */
                snprintf(buffer1, sizeof(buffer1), "%s \"%s\"", command, buffer2);
                DBG("calling command %s", buffer1);

                /* in addition provide the filename as environment variable */
                if((rc = setenv("MJPG_FILE", buffer2, 1)) != 0) {
                    LOG("setenv failed (return value %d)\n", rc);
                }

                /* execute the command now */
                if((rc = system(buffer1)) != 0) {
                    LOG("command failed (return value %d)\n", rc);
                }
            }

            end = clock();
            DBG("Time2: %f\n", (double)(end-begin) / CLOCKS_PER_SEC);
            begin = clock();

            /*
             * maintain ringbuffer
             * do not maintain ringbuffer for each picture, this saves ressources since
             * each run of the maintainance function involves sorting/malloc/free operations
             */
            if(ringbuffer_exceed <= 0) {
                /* keep ringbuffer excactly at specified siOUTPUT_PLUGIN_NAMEze */
                maintain_ringbuffer(ringbuffer_size);
            } else if(counter == 1 || counter % (ringbuffer_exceed + 1) == 0) {
                DBG("counter: %llu, will clean-up now\n", counter);
                maintain_ringbuffer(ringbuffer_size);
            }

            end = clock();
            DBG("Time3: %f\n", (double)(end-begin) / CLOCKS_PER_SEC);

        } else { // recording to MJPG file
            DBG("Entered else branch!\n");
            /* save picture to file */
            //if(write(fileno(stdout), frame, frame_size) < 0) {
            if(fwrite(frame, sizeof(unsigned char), frame_size, stdout) < 0) {
                OPRINT("could not write to file %s\n", buffer2);
                perror("fwrite()");
                close(fd);
                return NULL;
            }
        }
    }

    /* cleanup now */
    pthread_cleanup_pop(1);

    return NULL;
}

/*** plugin interface functions ***/
/******************************************************************************
Description.: this function is called first, in order to initialize
              this plugin and pass a parameter string
Input Value.: parameters
Return Value: 0 if everything is OK, non-zero otherwise
******************************************************************************/
int output_init(output_parameter *param, int id)
{
	int i;
    pglobal = param->global;
    pglobal->out[id].name = malloc((1+strlen(OUTPUT_PLUGIN_NAME))*sizeof(char));
    sprintf(pglobal->out[id].name, "%s", OUTPUT_PLUGIN_NAME);
    DBG("OUT plugin %d name: %s\n", id, pglobal->out[id].name);

    param->argv[0] = OUTPUT_PLUGIN_NAME;

    /* show all parameters for DBG purposes */
    for(i = 0; i < param->argc; i++) {
        DBG("argv[%d]=%s\n", i, param->argv[i]);
    }

    reset_getopt();
    while(1) {
        int option_index = 0, c = 0;
        static struct option long_options[] = {
            {"h", no_argument, 0, 0
            },
            {"help", no_argument, 0, 0},
            {"f", required_argument, 0, 0},
            {"folder", required_argument, 0, 0},
            {"s", required_argument, 0, 0},
            {"size", required_argument, 0, 0},
            {"e", required_argument, 0, 0},
            {"exceed", required_argument, 0, 0},
            {"i", required_argument, 0, 0},
            {"input", required_argument, 0, 0},
            {"m", required_argument, 0, 0},
            {"mjpeg", required_argument, 0, 0},
            {"a", required_argument, 0, 0},
            {"address", required_argument, 0, 0},
            {"b", required_argument, 0, 0},
            {"buffer_size", required_argument, 0, 0},
            {0, 0, 0, 0}
        };

        c = getopt_long_only(param->argc, param->argv, "", long_options, &option_index);

        /* no more options to parse */
        if(c == -1) break;

        /* unrecognized option */
        if(c == '?') {
            help();
            return 1;
        }

        switch(option_index) {
            /* h, help */
        case 0:
        case 1:
            DBG("case 0,1\n");
            help();
            return 1;
            break;

            /* f, folder */
        case 2:
        case 3:
            DBG("case 2,3\n");
            folder = malloc(strlen(optarg) + 1);
            strcpy(folder, optarg);
            if(folder[strlen(folder)-1] == '/')
                folder[strlen(folder)-1] = '\0';
            break;

            /* s, size */
        case 4:
        case 5:
            DBG("case 4,5\n");
            ringbuffer_size = atoi(optarg);
            break;

            /* e, exceed */
        case 6:
        case 7:
            DBG("case 6,7\n");
            ringbuffer_exceed = atoi(optarg);
            break;
            /* i, input*/
        case 8:
        case 9:
            DBG("case 8,9\n");
            input_number = atoi(optarg);
            break;
            /* m mjpeg */
        case 10:
        case 11:
            DBG("case 10,11\n");
            mjpgFileName = strdup(optarg);
            break;
            /* a address */
        case 12:
        case 13:
            DBG("case 12,13\n");
            zmqAddress = strdup(optarg);
            break;
            /* buffer_size */
        case 14:
        case 15:
            DBG("case 14,15\n");
            zmqBufferSize = atoi(optarg);
            break;
        }
    }

    if(!(input_number < pglobal->incnt)) {
        OPRINT("ERROR: the %d input_plugin number is too much only %d plugins loaded\n", input_number, param->global->incnt);
        return 1;
    }

    OPRINT("output folder.....: %s\n", folder);
    OPRINT("input plugin.....: %d: %s\n", input_number, pglobal->in[input_number].plugin);
    if  (mjpgFileName == NULL) {
        if(ringbuffer_size > 0) {
            OPRINT("ringbuffer size...: %d to %d\n", ringbuffer_size, ringbuffer_size + ringbuffer_exceed);
        } else {
            OPRINT("ringbuffer size...: %s\n", "no ringbuffer");
        }
    } else {
        char *fnBuffer = malloc(strlen(mjpgFileName) + strlen(folder) + 3);
        sprintf(fnBuffer, "%s/%s", folder, mjpgFileName);

        OPRINT("output file.......: %s\n", fnBuffer);
        if((fd = open(fnBuffer, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
            OPRINT("could not open the file %s\n", fnBuffer);
            free(fnBuffer);
            return 1;
        }
        free(fnBuffer);
    }

    param->global->out[id].parametercount = 2;

    param->global->out[id].out_parameters = (control*) calloc(2, sizeof(control));

    control take_ctrl;
	take_ctrl.group = IN_CMD_GENERIC;
	take_ctrl.menuitems = NULL;
	take_ctrl.value = 1;
	take_ctrl.class_id = 0;

	take_ctrl.ctrl.id = OUT_FILE_CMD_TAKE;
	take_ctrl.ctrl.type = V4L2_CTRL_TYPE_BUTTON;
	strcpy((char*) take_ctrl.ctrl.name, "Take snapshot");
	take_ctrl.ctrl.minimum = 0;
	take_ctrl.ctrl.maximum = 1;
	take_ctrl.ctrl.step = 1;
	take_ctrl.ctrl.default_value = 0;

	param->global->out[id].out_parameters[0] = take_ctrl;

    control filename_ctrl;
	filename_ctrl.group = IN_CMD_GENERIC;
	filename_ctrl.menuitems = NULL;
	filename_ctrl.value = 1;
	filename_ctrl.class_id = 0;

	filename_ctrl.ctrl.id = OUT_FILE_CMD_FILENAME;
	filename_ctrl.ctrl.type = V4L2_CTRL_TYPE_STRING;
	strcpy((char*) filename_ctrl.ctrl.name, "Filename");
	filename_ctrl.ctrl.minimum = 0;
	filename_ctrl.ctrl.maximum = 32;
	filename_ctrl.ctrl.step = 1;
	filename_ctrl.ctrl.default_value = 0;

	param->global->out[id].out_parameters[1] = filename_ctrl;


    return 0;
}

/******************************************************************************
Description.: calling this function stops the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_stop(int id)
{
    DBG("will cancel worker thread\n");
    pthread_cancel(worker);
    return 0;
}

/******************************************************************************
Description.: calling this function creates and starts the worker thread
Input Value.: -
Return Value: always 0
******************************************************************************/
int output_run(int id)
{
    DBG("launching worker thread\n");
    pthread_create(&worker, 0, worker_thread, NULL);
    pthread_detach(worker);
    return 0;
}

int output_cmd(int plugin_id, unsigned int control_id, unsigned int group, int value, char *valueStr)
{
    int i = 0;
    DBG("command (%d, value: %d) for group %d triggered for plugin instance #%02d\n", control_id, value, group, plugin_id);
    switch(group) {
		case IN_CMD_GENERIC:
			for(i = 0; i < pglobal->out[plugin_id].parametercount; i++) {
				if((pglobal->out[plugin_id].out_parameters[i].ctrl.id == control_id) && (pglobal->out[plugin_id].out_parameters[i].group == IN_CMD_GENERIC)) {
					DBG("Generic control found (id: %d): %s\n", control_id, pglobal->out[plugin_id].out_parameters[i].ctrl.name);
					switch(control_id) {
                            case OUT_FILE_CMD_TAKE: {
                                if (valueStr != NULL) {
                                    int frame_size = 0;
                                    unsigned char *tmp_framebuffer = NULL;

                                    if(pthread_mutex_lock(&pglobal->in[input_number].db)) {
                                        DBG("Unable to lock mutex\n");
                                        return -1;
                                    }
                                    /* read buffer */
                                    frame_size = pglobal->in[input_number].size;

                                    /* check if buffer for frame is large enough, increase it if necessary */
                                    if(frame_size > max_frame_size) {
                                        DBG("increasing buffer size to %d\n", frame_size);

                                        max_frame_size = frame_size + (1 << 16);
                                        if((tmp_framebuffer = realloc(frame, max_frame_size)) == NULL) {
                                            pthread_mutex_unlock(&pglobal->in[input_number].db);
                                            LOG("not enough memory\n");
                                            return -1;
                                        }

                                        frame = tmp_framebuffer;
                                    }

                                    /* copy frame to our local buffer now */
                                    memcpy(frame, pglobal->in[input_number].buf, frame_size);

                                    /* allow others to access the global buffer again */
                                    pthread_mutex_unlock(&pglobal->in[input_number].db);

                                    DBG("writing file: %s\n", valueStr);

                                    int fd;
                                    /* open file for write */
                                    if((fd = open(valueStr, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) < 0) {
                                        OPRINT("could not open the file %s\n", valueStr);
                                        return -1;
                                    }

                                    /* save picture to file */
                                    //if(write(fileno(stdout), frame, frame_size) < 0) {
                                    if(fwrite(frame, sizeof(unsigned char), frame_size, stdout) < 0) {
                                        OPRINT("could not write to file %s\n", valueStr);
                                        perror("fwrite()");
                                        close(fd);
                                        return -1;
                                    }

                                    close(fd);
                                } else {
                                    DBG("No filename specified\n");
                                    return -1;
                                }
                            } break;
                            case OUT_FILE_CMD_FILENAME: {
                                DBG("Not yet implemented\n");
                                return -1;
                            } break;
                            default: {
                                DBG("Unknown command\n");
                                return -1;
                            } break;
					}
					DBG("Ctrl %s new value: %d\n", pglobal->out[plugin_id].out_parameters[i].ctrl.name, value);
					return 0;
				}
			}
			DBG("Requested generic control (%d) did not found\n", control_id);
			return -1;
			break;
	}
    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_zmqserver/output_zmqserver.h
================
#ifndef OUTPUT_FILE_H
#define OUTPUT_FILE_H

#define OUT_FILE_CMD_TAKE           1
#define OUT_FILE_CMD_FILENAME       2

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_zmqserver/package.proto
================
syntax = "proto2";
package pb;

message Package {
    message Frame {
        required uint32       timestamp_unix = 1;
        required uint32       timestamp_s   = 2;
        required uint32       timestamp_us  = 3;
        required bytes        blob          = 4;
    }

    repeated Frame frame = 1;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output_zmqserver/README.md
================
# mjpg-streamer output plugin: output_zmqserver

This plugin streams out the video data via
[ZeroMQ](http://zeromq.org/) serialized as
[Protobuf](https://developers.google.com/protocol-buffers/) data.

Please take a look at the protobuf definition for more details about the message format:
[package.proto](package.proto)


You must have libzmq-dev and libprobot-c0-dev installed (or similar)
in order for this plugin to be compiled & installed.

On debian you need following libraries:

```bash
sudo apt-get install libzmq4-dev libprotobuf-dev libprotobuf-c0-dev protobuf-c-compiler
```

## Usage

```bash
mjpg_streamer [input plugin options] -o 'output_zmqserver.so --address [zmq-uri] --buffer_size [output ring buffer size]'
```


## Examples

The plugin was created for [Machinekit](http://machinekit.io) and
[QtQuickVcp](https://github.com/machinekit/qtquickvcp).

You can find the Qt/QML counterpart here:
[videoview](https://github.com/machinekit/QtQuickVcp/tree/master/src/videoview)

Additionally, Machinekit contains a tool that wraps mjpg-streamer and
the plugin invokation:
[videoserver](https://github.com/machinekit/machinekit/tree/master/src/machinetalk/videoserver)

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/input.h
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <syslog.h>
#include "../mjpg_streamer.h"
#define INPUT_PLUGIN_PREFIX " i: "
#define IPRINT(...) { char _bf[1024] = {0}; snprintf(_bf, sizeof(_bf)-1, __VA_ARGS__); fprintf(stderr, "%s", INPUT_PLUGIN_PREFIX); fprintf(stderr, "%s", _bf); syslog(LOG_INFO, "%s", _bf); }

/* parameters for input plugin */
typedef struct _input_parameter input_parameter;
struct _input_parameter {
    int id;
    char *parameters;
    int argc;
    char *argv[MAX_PLUGIN_ARGUMENTS];
    struct _globals *global;
};

typedef struct _input_resolution input_resolution;
struct _input_resolution {
    unsigned int width;
    unsigned int height;
};

typedef struct _input_format input_format;
struct _input_format {
    struct v4l2_fmtdesc format;
    input_resolution *supportedResolutions;
    int resolutionCount;
    char currentResolution;
};

/* structure to store variables/functions for input plugin */
typedef struct _input input;
struct _input {
    char *plugin;
    char *name;
    void *handle;

    input_parameter param; // this holds the command line arguments

    // input plugin parameters
    struct _control *in_parameters;
    int parametercount;


    struct v4l2_jpegcompression jpegcomp;

    /* signal fresh frames */
    pthread_mutex_t db;
    pthread_cond_t  db_update;

    /* global JPG frame, this is more or less the "database" */
    unsigned char *buf;
    int size;

    /* v4l2_buffer timestamp */
    struct timeval timestamp;

    input_format *in_formats;
    int formatCount;
    int currentFormat; // holds the current format number
    
    void *context; // private data for the plugin

    int (*init)(input_parameter *, int id);
    int (*stop)(int);
    int (*run)(int);
    int (*cmd)(int plugin, unsigned int control_id, unsigned int group, int value, char *value_str);
};

================
File: mjpg-streamer/mjpg-streamer-experimental/plugins/output.h
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include "../mjpg_streamer.h"
#define OUTPUT_PLUGIN_PREFIX " o: "
#define OPRINT(...) { char _bf[1024] = {0}; snprintf(_bf, sizeof(_bf)-1, __VA_ARGS__); fprintf(stderr, "%s", OUTPUT_PLUGIN_PREFIX); fprintf(stderr, "%s", _bf); syslog(LOG_INFO, "%s", _bf); }

/* parameters for output plugin */
typedef struct _output_parameter output_parameter;
struct _output_parameter {
    int id;
    char *parameters;
    int argc;
    char *argv[MAX_PLUGIN_ARGUMENTS];
    struct _globals *global;
};



/* structure to store variables/functions for output plugin */
typedef struct _output output;
struct _output {
    char *plugin;
    char *name;
    void *handle;
    output_parameter param;

    // input plugin parameters
    struct _control *out_parameters;
    int parametercount;

    int (*init)(output_parameter *param, int id);
    int (*stop)(int);
    int (*run)(int);
    int (*cmd)(int plugin, unsigned int control_id, unsigned int group, int value, char *value_str);
};

================
File: mjpg-streamer/mjpg-streamer-experimental/scripts/make_deb.sh
================
#!/bin/sh

# update via git
git pull

# find out the current revision
GITVERSION="$(export LANG=C && export LC_ALL=C && echo $(git show -s --format=%at-%H))"

# run cmake before our checkinstall run
cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr .

# use checkinstall to create the DEB package
sudo checkinstall -D \
                  --pkgname "mjpg-streamer" \
                  --pkgversion "$GITVERSION" \
                  --pkgrelease "1" \
                  --maintainer "tom_stoeveken@users.sourceforge.net" \
                  --requires "libjpeg62" \
                  --nodoc \
                    make DESTDIR=/usr install

================
File: mjpg-streamer/mjpg-streamer-experimental/scripts/mjpg-streamer.default
================
# Configuration for /etc/init.d/mjpg-streamer

# The init.d script will only run if this variable non-empty.
MJPG_STREAMER_USER=webcam

# base directory to use. This is where mjpg-streamer's `make install`
# copies files by default.
BASEDIR=/usr/local

# The directory where the mjpg-streamer shared libraries reside.
LIB_DIR=${BASEDIR}/lib/mjpg-streamer

# https://github.com/OctoPrint/OctoPrint/wiki/Webcams-known-to-work
CAMERA_OPTIONS="-r 1280x720 -f 30"

# Document this.
WWW_ROOT=/var/local/www

# Path to the mjpg-streamer executable. Make sure this matches your
# installation.
DAEMON=${BASEDIR}/bin/mjpg_streamer

# The input library.
INPUT_UVC_LIB=${LIB_DIR}/input_uvc.so

# The output library.
OUTPUT_HTTP_LIB=${LIB_DIR}/output_http.so

# WWW directory.
WWW_ROOT=/var/local/www

# Umask of files mjpg-streamer generates, Change this to 022 if *not* running
# mjpg-streamer as its own, separate user.
UMASK=000

# Should we run at startup?
START=yes

================
File: mjpg-streamer/mjpg-streamer-experimental/scripts/mjpg-streamer.init
================
#!/bin/sh

### BEGIN INIT INFO
# Provides:          mjpg-streamer
# Required-Start:    $local_fs networking
# Required-Stop:
# Should-Start:
# Should-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: mjpg-streamer daemon
# Description:       Starts the mjpg-streamer daemon with the user specified in
#                    /etc/default/mjpg-streamer.
### END INIT INFO

# Author: Sami Olmari & Gina Häußge

# Set to true to aid in debugging with this script fails to
# start.
debug_me=false

if [[ $debug_me == true ]]; then

	# Close STDOUT
	exec 1<&-
	# Close STDERR
	exec 2<&-

	LOG_FILE=/home/webcam/mjpg_streamer.log

	# Open STDOUT as $LOG_FILE file for read and write.
	exec 1<>$LOG_FILE

	# Redirect STDERR to STDOUT
	exec 2>&1

	# Display shell commands with expanded args
	set -x
fi

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DESC="mjpg-streamer Daemon"
NAME="mjpg-streamer"
PKGNAME=mjpg-streamer
PIDFILE=/var/run/$PKGNAME.pid
SCRIPTNAME=/etc/init.d/$PKGNAME
DEFAULTS=/etc/default/$PKGNAME

# Read configuration variable file if it is present
[ -r $DEFAULTS ] && . $DEFAULTS

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions

# Exit if the DAEMON is not set
if [ -z "$DAEMON" ]
then
    log_warning_msg "Not starting $PKGNAME, DAEMON not set in $DEFAULTS."
    exit 0
fi

# Exit if the DAEMON is not installed
[ -x "$DAEMON" ] || exit 0

# Load the VERBOSE setting and other rcS variables
[ -f /etc/default/rcS ] && . /etc/default/rcS

if [ -z "$START" -o "$START" != "yes" ]
then
   log_warning_msg "Not starting $PKGNAME, edit $DEFAULTS to start it."
   exit 0
fi

if [ -z "$MJPG_STREAMER_USER" ]
then
    log_warning_msg "Not starting $PKGNAME, MJPG_STREAMER_USER not set in $DEFAULTS."
    exit 0
fi

#
# Function to verify if a pid is alive
#
is_alive()
{
   pid=`cat $1` > /dev/null 2>&1
   kill -0 $pid > /dev/null 2>&1
   return $?
}

#
# Function that starts the daemon/service
#
do_start()
{
   # Return
   #   0 if daemon has been started
   #   1 if daemon was already running
   #   2 if daemon could not be started

   is_alive $PIDFILE
   RETVAL="$?"

   if [ $RETVAL != 0 ]; then
       start-stop-daemon --verbose --start --background --pidfile $PIDFILE --make-pidfile \
       --exec $DAEMON --chuid $MJPG_STREAMER_USER --user $MJPG_STREAMER_USER \
       --umask $UMASK -- -i "${INPUT_UVC_LIB} ${CAMERA_OPTIONS}" -o "${OUTPUT_HTTP_LIB} -w ${WWW_ROOT}"
       RETVAL="$?"
   fi
}

#
# Function that stops the daemon/service
#
do_stop()
{
   # Return
   #   0 if daemon has been stopped
   #   1 if daemon was already stopped
   #   2 if daemon could not be stopped
   #   other if a failure occurred

   start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --user $MJPG_STREAMER_USER --pidfile $PIDFILE
   RETVAL="$?"
   [ "$RETVAL" = "2" ] && return 2

   rm -f $PIDFILE

   [ "$RETVAL" = "0"  ] && return 0 || return 1
}

case "$1" in
  start)
   [ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
   do_start
   case "$?" in
      0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
      2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
   esac
   ;;
  stop)
   [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
   do_stop
   case "$?" in
      0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
      2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
   esac
   ;;
  status)
   status_of_proc -p $PIDFILE $DAEMON $NAME && exit 0 || exit $?
   ;;
  restart)
   log_daemon_msg "Restarting $DESC" "$NAME"
   do_stop
   case "$?" in
     0|1)
      do_start
      case "$?" in
         0) log_end_msg 0 ;;
         1) log_end_msg 1 ;; # Old process is still running
         *) log_end_msg 1 ;; # Failed to start
      esac
      ;;
     *)
        # Failed to stop
      log_end_msg 1
      ;;
   esac
   ;;
  *)
   echo "Usage: $SCRIPTNAME {start|stop|status|restart}" >&2
   exit 3
   ;;
esac

================
File: mjpg-streamer/mjpg-streamer-experimental/scripts/mjpg-streamer.service
================
[Unit]
Description=A Linux-UVC streaming application with Pan/Tilt
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=webcam
ExecStart=/usr/local/bin/mjpg_streamer

[Install]
WantedBy=multi-user.target

================
File: mjpg-streamer/mjpg-streamer-experimental/scripts/README.md
================
# Script files for mjpg-streamer.

Assumes mjpg-streamer is installed at /usr/local/bin/mjpg_streamer and
that there is a user account `webcam` for running these scripts.

If you have a different setup you'll need to adjust
mjpg-streamer.default (init) or mjpg-streamer.service (systemd)
accordingly.

The `webcam` user will need access to /dev/video*. To add this run:

```sh
sudo adduser webcam video
sudo usermod -a -G video webcam
```

## init

```
mjpg-streamer.default   => /etc/default/mjpg-streamer
mjpg-streamer.init      => /etc/init.d/mjpg-streamer
```

After copying the above files run:

```sh
sudo update-rc.d mjpg-streamer defaults
sudo systemctl daemon-reload
```

## systemd

```
mjpg-streamer.service   => /etc/systemd/system/mjpg-streamer.service
```

================
File: mjpg-streamer/mjpg-streamer-experimental/www/control.htm
================
<html style="overflow-y: auto;">
  <head>
    <script type="text/javascript" src="jquery.js"></script>
    
	<link type="text/css" href="jquery.ui.custom.css" rel="stylesheet" />
    <script type="text/javascript" src="jquery.ui.core.min.js"></script>    
    <script type="text/javascript" src="jquery.ui.widget.min.js"></script>    
    <script type="text/javascript" src="jquery.ui.tabs.min.js"></script>    
            
    <link type="text/css" rel="stylesheet" href="JQuerySpinBtn.css" />
    <script type="text/javascript" src="JQuerySpinBtn.js"></script>    
    
	<script type="text/javascript">
	$(function() {
		$("#tabs").tabs();
	});
	
	$(document).ready(function() {
		//top.resizeTo($(window).width(), $(document).height() + (top.outerHeight - $(window).height()));
	});
	</script>

  </head>
  <body style="overflow-y: auto;">
    <script type="text/javascript"> 
    		
		function setControl(dest, plugin, id, group, value) {
          $.get('./?action=command&dest=' +		dest +
          						'&plugin=' +	plugin+
          						'&id='+ 		id + 
          						'&group='+ 		group + 
          						'&value=' +		value );
        }

        function setControl_bool(dest, plugin, id, group, value) {
          if (value == false)
            setControl(dest, plugin, id, group, 0);
          else
            setControl(dest, plugin, id, group, 1);
        }

        function setControl_string(dest, plugin, id, group, value) {
          if (value.length < minlength) {
            alert("The input string has to be least"+minlength+" characters!");
            return;
          }
          $.get('./?action=command&dest=' +		dest +
          						'&plugin=' +	plugin+
          						'&id='+ 		id + 
          						'&group='+ 		group + 
          						'&value=' +		value , 
			function(data){
             alert("Data Loaded: " + data);
           });
        }
                        
        function setResolution(plugin, controlId, group, value) {
	        $.get('./?action=command&dest=0'	+		// resolution command always goes to the input plugin
					'&plugin=' +	plugin+
					'&id'+ 			controlId + 
					'&group=1'	+					// IN_CMD_RESOLUTION == 1,		
					'&value=' +		value, 
				function(data){
				     if (data == 0) {
				     	$("#statustd").text("Success");
				     } else {
				     	$("#statustd").text("Error: " + data);
				     }
		        }
	        );
        }
                
        function addControl(plugin_id, suffix) {
        var dest = suffix=="in"?0:1;
        $.getJSON(suffix+"put_"+plugin_id+".json",
          function(data) {
            $.each(data.controls, function(i,item){
              $('<tr/>').attr("id", "tr_"+suffix+"_"+plugin_id+"_"+item.group+"_"+item.id).appendTo("#controltable_"+suffix+"-"+plugin_id);
              // BUTTON type controls does not have a label 
              if (item.type == 4) {
                $("<td/>").appendTo("#tr-"+item.id);
              } else {
                if (item.type == 6) { // Class type controls
                  $("<td/>").text(item.name).attr("style", "font-weight:bold;").appendTo("#tr_"+suffix+"_"+plugin_id+"_"+item.group+"_"+item.id);
                  return;
                } else {
                  $("<td/>").text(item.name).appendTo("#tr_"+suffix+"_"+plugin_id+"_"+item.group+"_"+item.id);
                }
              }

              $("<td/>").attr("id", "td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id)
              	.appendTo("#tr_"+suffix+"_"+plugin_id+"_"+item.group+"_"+item.id);
              if((item.type == 1) || (item.type == 5)) { // integer type controls
                if ((item.id == 10094852) && (item.group == 1) && (item.dest == 0)) { //V4L2_CID_PAN_RELATIVE
				  $("<button/>")
                  .attr("type", "button")
                  .attr("style", "width: 50%; height: 100%;")
                  .text("<")
                  .click(function(){setControl(dest, plugin_id, item.id, item.group, 200);})
                  .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
                  $("<button/>")
                  .attr("type", "button")
                  .attr("style", "width: 50%; height: 100%;")
                  .text(">")
                  .click(function(){setControl(dest, plugin_id, item.id, item.group, -200);})
                  .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
                } else if ((item.id == 10094853) && 
                		   (item.group == 1) && 
                		   (item.dest == 0)){ // V4L2_CID_TILT_RELATIVE
        		   $("<button/>")
                  .attr("type", "button")
                  .attr("style", "width: 50%; height: 100%;")
                  .text("^")
                  .click(function(){setControl(dest, plugin_id, item.id, item.group, -200);})
                  .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
                  $("<button/>")
                  .attr("type", "button")
                  .attr("style", "width: 50%; height: 100%;")
                  .text("ˇ")
                  .click(function(){setControl(dest, plugin_id, item.id, item.group, 200);})
                  .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
                } else { // another non spec control
                    var options = {min: item.min, max: item.max, step: item.step,}
		            $("<input/>")
		              .attr("value", item.value)
		              .attr("id", "spinbox-"+item.id)
		              .SpinButton(options)
		              .bind("valueChanged", function() {setControl(dest, plugin_id, item.id, item.group, $(this).val());})
		              .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
                } 
              } else if (item.type == 2) { // boolean type controls
                if (item.value == "1")
                  $("<input/>")
                    .attr("type", "checkbox")
                    .attr("checked", "checked")
                    .change(function(){setControl_bool(dest, plugin_id, item.id, item.group, ($(this).attr("checked")?1:0));})
		            .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
                else
                  $("<input/>")
                    .attr("type", "checkbox")
                    .change(function(){setControl_bool(dest, plugin_id, item.id, item.group, ($(this).attr("checked")?1:0));})
                    .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
              } else if (item.type == 7) { // string type controls
                  $("<input/>").attr("value", item.value).appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
              } else if (item.type == 3) { // menu
                $("<select/>")
                  .attr("name", "select-"+item.id)
                  .attr("id", "menu-"+item.id)
                  .attr("style", "width: 100%;")
                  .change(function(){setControl(dest, plugin_id, item.id, item.group, $(this).val());})
                  .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
                $.each(item.menu, function(val, text) {
                    if (item.value == val) {
                      $("#menu-"+item.id).append($('<option></option>').attr("selected", "selected").val(val).html(text));
                    } else {
                      $("#menu-"+item.id).append($('<option></option>').val(val).html(text));
                    }
                });
              } else if (item.type == 4) { // button type
                $("<button/>")
                  .attr("type", "button")
                  .attr("style", "width: 100%; height: 100%;")
                  .text(item.name)
                  .click(function(){setControl(dest, plugin_id, item.id, item.group, 0);})
                  .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
              } else if (item.type == 7) { // string  type
                $("<input/>")
                    .attr("type", "text")
                    .attr("maxlength", item.max)
                    .change(function(){setControl_string(dest, plugin_id, item.id, item.group, $(this).text());})
                    .appendTo("#td_ctrl_"+suffix+"_"+plugin_id+"_"+item.group+"-"+item.id);
              } else {
                 alert("Unknown control type: "+item.type);
              }
            });
          }
        );
        }

	    $.getJSON("program.json", 
	    	function(data) {
	    		$.each(data.inputs, 
	    			function(i,input){
		        		$("<li/>").attr("id", "li_in-"+input.id).appendTo("#ul_tabs");
						$("<a/>").attr("href", "#controldiv_in-"+input.id)
							.text(input.name).appendTo("#li_in-"+input.id);
						$("<div/>").attr("id", "controldiv_in-"+input.id).appendTo("#tabs");
						$("<table/>").attr("id", "controltable_in-"+input.id).appendTo("#controldiv_in-"+input.id);
		    		}
	    		)
	    		
	    		$.each(data.outputs, 
	    			function(i,output){
		        		$("<li/>").attr("id", "li_out-"+output.id).appendTo("#ul_tabs");
						$("<a/>").attr("href", "#controldiv_out-"+output.id)
							.text(output.name).appendTo("#li_out-"+output.id);
						$("<div/>").attr("id", "controldiv_out-"+output.id).appendTo("#tabs");
						$("<table/>").attr("id", "controltable_out-"+output.id).appendTo("#controldiv_out-"+output.id);
		    		}
	    		)
	    	
	    		$.each(data.inputs, 
	    			function(i,input){
	    				addControl(input.id, "in");
		    		}
	    		)
	    		
	    		$.each(data.outputs, 
	    			function(i,output){
	    				addControl(output.id, "out");
		    		}
	    		)
	    		
	    		$( "#tabs" ).tabs();
	    	}
	    );

       $(function() {
			
		});
        /*$.getJSON("input.json",
          function(data) {
          	$.each(data.formats, function(i,item){
          	  if (item.current == "true") {
          	  $("<select/>")
                  .attr("id", "select-resolution")
                  .attr("style", "width: 100%;")
                  .change(function(){setResolution($(this).val());})
                  .appendTo("#resolutions");
           	    $.each(item.resolutions, function(val,res){
           	    	if (item.currentResolution == val) {
                      $("#select-resolution").append($('<option></option>').attr("selected", "selected").val(val).html(res));
                    } else {
                      $("#select-resolution").append($('<option></option>').val(val).html(res));
                    }
           	    });
          	  }
          	});
          });*/
    </script>
    
    <div id="tabs">
		<ul id="ul_tabs"></ul>
  	</div>

  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/fix.css
================
/**************** IE fixes ****************/

html
{overflow:hidden;}

body
{height:100%; width:100%; overflow:auto;}

================
File: mjpg-streamer/mjpg-streamer-experimental/www/functions.js
================
s////////////////////////////////////////////////////////////////////////////////

var xmlHttp;

function stateCallback() {
  var stat, rstate;
  if( !xmlHttp ) return;

  try {
    rstate = xmlHttp.readyState;
  } catch (err) {
    alert(err);
  }

  switch( rstate )
  {
    // uninitialized
    case 0:
    // loading
    case 1:
    // loaded
    case 2:
    // interactive
    case 3:
    break;
    // complete, so act on response
    case 4:
    // check http status
      try {
        stat = xmlHttp.status;
      }
      catch (err) {
        stat = "xmlHttp.status does not exist";
      }
      if( stat == 200 )    // success
      {
          AJAX_response(xmlHttp.responseText);
      }
      // loading not successfull, e.g. page not available
      else { }
  }
}

function init_AJAX() 
{
  var new_xmlHttp;

  try
  {
    // Internet Explorer
    if( window.ActiveXObject )
    {
      for( var i = 5; i; i-- )
      {
        try
        {
          // loading of a newer version of msxml dll (msxml3 - msxml5) failed
          // use fallback solution
          // old style msxml version independent, deprecated
          if( i == 2 ) {
            new_xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
          }
          // try to use the latest msxml dll
          else {
            new_xmlHttp = new ActiveXObject( "Msxml2.XMLHTTP." + i + ".0" );
          }
          break;
        }
        catch( excNotLoadable ) {
          new_xmlHttp = false;
        }
      }
    }
    // Mozilla, Opera und Safari
    else if( window.XMLHttpRequest ) {
      new_xmlHttp = new XMLHttpRequest();
    }
  }
  catch( excNotLoadable ) {
    new_xmlHttp = false;
  }

  new_xmlHttp.onreadystatechange = stateCallback;

  xmlHttp = new_xmlHttp;
}

function AJAX_get(url) {
  if( xmlHttp ) {
    xmlHttp.abort();
    xmlHttp = false;
  }

  init_AJAX();
  xmlHttp.open("GET", url, true);
  xmlHttp.send(null);
}

////////////////////////////////////////////////////////////////////////////////

function setTextById(element, text) {
  document.getElementById(element).firstChild.nodeValue = text;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/www/index.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>MJPG-streamer</title>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <!--[if IE 6]>
    <link rel="stylesheet" href="fix.css" type="text/css" />
    <![endif]-->
  </head>

  <body>
    <div id="sidebar">
      <h1>MJPG-Streamer Demo Pages</h1>
      <h2>a resource-friendly streaming application</h2>

      <div id="menu">
        <a class="active" href="index.html">Home</a>
        <a href="static.html">Static</a>
        <a href="stream.html">Stream</a>
        <a href="java.html">Java</a>
        <a href="javascript.html">Javascript</a>
        <a href="videolan.html">VideoLAN</a>
        <a target="_blank" onClick="window.open(this.href, '_blank'); return false;" href="control.htm">Control</a>
      </div>

      <h3>Version info:</h3>
      <p>v0.1 (Okt 22, 2007)</p>
    </div>

    <div id="content">
      <h1>About</h1>
      <h2>Details about the M-JPEG streamer</h2>

      <h3>Congratulations</h3>
      <p>You sucessfully managed to install this streaming webserver. If you can see this page, you can also access the stream of JPGs, which can originate from your webcam for example. This installation consists of these example pages and you may customize the look and content.</p>

      <img src="example.jpg" width="512" height="160" alt="just an image" />
      <p>The reason for developing this software was the need of a simple and ressource friendly streaming application for Linux-UVC compatible webcams. The predecessor <i>uvc-streamer</i> is working well, but i wanted to implement a few more ideas. For instance, plugins can be used to process the images. One input plugin copies images to a global variable, multiple output plugins can access those images. For example this webpage is served by the <i>output_http.so</i> plugin.</p>

      <a href="static.html"><img src="./?action=snapshot" width="170" height="128" alt="static image example" /></a>
      <p>The image displayed here was grabbed by the input plugin. The HTTP request contains the GET parameters <i>action=snapshot</i>. This requests one single picture from the image-input. To display another example, just click on the picture.</p>

      <h3>About the examples</h3>
      <p>To view the stream with any browser you may try the <i>javascript</i> or <i>java</i> subpages. Firefox is able to display the M-JPEG-stream directly.</p>

      <h3>About this server</h3>
      <p>This server is running a software written for the MJPG-streamer project. The MJPG-streamer developers can not be made responsible for installations of this software.</p>

      <p>&copy; The <a href="http://mjpg-streamer.sf.net">MJPG-streamer team</a> | Design by <a href="http://andreasviklund.com">Andreas Viklund</a></p>
    </div>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/java_control.html
================
<html>
  <head>
    <title>My webcams</title>
    <script language="javascript" type="text/javascript" src="functions.js"></script>
    <script language="javascript">

      function send_command(cmd) {
        document.getElementById('hints').firstChild.nodeValue = "Send command: " + cmd;
        AJAX_get('./?action=command&command='+ cmd)
      }

      function AJAX_response(text) {
        document.getElementById('hints').firstChild.nodeValue = "Got response: " + text;
      }

    </script>
  </head>
  <body>
    <center>
      <form name="command_panel" action="" onsubmit="return false;">
        <table width="100%"  border="0" align="center" cellpadding="10" cellspacing="0">
        <tr>
          <td>&nbsp;</td>
          <td width="640">
            <p align="center">
              <input name="tilt_up" type="button" onClick="send_command('tilt_minus')" value="^">
              &nbsp;
              <input name="tilt_up_full" type="button" onClick="send_command('tilt_set&value=-'+90)" value="^^">
              &nbsp;
              <input name="tilt_up_value" type="input" id="tilt_up_value" value="0" style="width: 40px">
              <input name="tilt_up_to" type="button" onClick="send_command('tilt_set&value=-'+this.form.tilt_up_value.value)" value="^ to">
            </p>
          </td>
          <td colspan="3">&nbsp;</td>
        </tr>
        <tr>
          <td height="40%">&nbsp;</td>
          <td width="640" rowspan="3">
            <applet code="com.charliemouse.cambozola.Viewer" archive="cambozola.jar" width="640" height="480">
              <param name="url" value="./?action=stream"/>
            </applet>
          </td>
          <td colspan="3" valign="top">
            <div align="left">
              <table  border="0" cellspacing="4" cellpadding="0">
                <tr>
                  <td>
                    <input name="brightness_minus" type="button" onClick="send_command('brightness_minus')" value="-">
                  </td>
                  <td>
                    <div align="center">Brightness</div>
                  </td>
                  <td>
                    <input name="brightness_plus" type="button" onClick="send_command('brightness_plus')" value="+">
                  </td>
                </tr>
                <tr>
                  <td>
                    <input name="contrast_minus" type="button" onClick="send_command('contrast_minus')" value="-">
                  </td>
                  <td>
                    <div align="center">Contrast</div>
                  </td>
                  <td>
                    <input name="contrast_plus" type="button" onClick="send_command('contrast_plus')" value="+">
                  </td>
                </tr>
                <tr>
                  <td>
                    <input name="saturation_minus" type="button" onClick="send_command('saturation_minus')" value="-">
                  </td>
                  <td>
                    <div align="center">Saturation</div>
                  </td>
                  <td>
                    <input name="saturation_plus" type="button" onClick="send_command('saturation_plus')" value="+">
                  </td>
                </tr>
                <tr>
                  <td>
                    <input name="gain_minus" type="button" onClick="send_command('gain_minus')" value="-">
                  </td>
                  <td>
                    <div align="center">Gain</div>
                  </td>
                  <td>
                    <input name="gain_plus" type="button" onClick="send_command('gain_plus')" value="+">
                  </td>
                </tr>
                <tr>
                  <td colspan="3">
                    <div align="center">
                      <input name="reset" type="button" onClick="send_command('reset')" value="Reset Settings">
                    </div>
                  </td>
                </tr>
                <tr>
                  <td colspan="3">
                    <div align="center">
                      <input name="reset_pan_tilt" type="button" onClick="send_command('reset_pan_tilt')" value="Reset pan&tilt">
                    </div>
                  </td>
                </tr>
              </table>
            </div>
          </td>
        </tr>
        <tr>
          <td valign="middle">
            <p align="right">
              <input name="pan_left_full" type="button" onClick="send_command('pan_set&value='+90)" value="<<">
              &nbsp;
              <input name="pan_left" type="button" onClick="send_command('pan_plus')" value="<">
              <input name="pan_left_to" type="button" onClick="send_command('pan_set&value='+this.form.pan_left_value.value)" value="< to">
              <input name="pan_left_value" type="input" value="0" style="width: 40px">
            </p>
          </td>
          <td colspan="3" valign="middle">
            <p align="left">
              <input name="pan_right" type="button" onClick="send_command('pan_minus')" value=">">
              &nbsp;
              <input name="pan_right_full" type="button" onClick="send_command('pan_set&value=-'+90)" value=">>">
              <input name="pan_right_value" type="input" value="0" style="width: 40px">
              <input name="pan_right_to" type="button" onClick="send_command('pan_set&value=-'+this.form.pan_right_value.value)" value="to >">
            </p>
          </td>
        </tr>
        <tr>
          <td height="40%">&nbsp;</td>
          <td colspan="3" valign="top">&nbsp;</td>
        </tr>
        <tr>
          <td>&nbsp;</td>
          <td width="640">
            <div align="center">
              <input name="tilt_down" type="button" onClick="send_command('tilt_plus')" value="v">
              &nbsp;
              <input name="tilt_down_full" type="button" onClick="send_command('tilt_set&value='+90)" value="vv">
              &nbsp;
              <input name="tilt_down_value" type="input" value="0" style="width: 40px">
              <input name="tilt_down_to" type="button" onClick="send_command('tilt_set&value='+this.form.tilt_down_value.value)" value="to v">
            </div>
          </td>
          <td colspan="3">&nbsp;</td>
        </tr>
        </table>
    </form>

    <div id="hints">Status</div>
    </center>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/java_simple.html
================
<html>
  <head>
    <title>MJPG-Streamer - Java Example</title>
  </head>
  <body>
    <center>
      <applet code="com.charliemouse.cambozola.Viewer" archive="cambozola.jar" width="640" height="480">
        <param name="url" value="./?action=stream"/>
      </applet>
    </center>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/java.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>MJPG-streamer</title>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <!--[if IE 6]>
    <link rel="stylesheet" href="fix.css" type="text/css" />
    <![endif]-->
  </head>

  <body>
    <div id="sidebar">
      <h1>MJPG-Streamer Demo Pages</h1>
      <h2>a resource-friendly streaming application</h2>

      <div id="menu">
        <a href="index.html">Home</a>
        <a href="static.html">Static</a> 
        <a href="stream.html">Stream</a> 
        <a class="active" href="java.html">Java</a>
        <a href="javascript.html">Javascript</a>
        <a href="videolan.html">VideoLAN</a>
        <a target="_blank" onClick="window.open(this.href, '_blank','width=400,height=400'); return false;" href="control.htm">Control</a>
      </div>

      <h3>Version info:</h3>
      <p>v0.1 (Okt 22, 2007)</p>
    </div>

    <div id="content">
      <h1>Java</h1>
      <h2>Display the stream with java</h2>

      <h3>Hints</h3>
      <p>This example shows the stream by using a java applet. It works with any browser with java support. To see a simple example click <a href="java_simple.html">here</a>. <a href="java_control.html">Another example</a> shows how to place controls around the java-applet.</p>

      <h3>Source snippet</h3>
      <p><pre>&lt;applet code="com.charliemouse.cambozola.Viewer" archive="cambozola.jar" width="512" height="384"&gt;
&lt;param name="url" value="./?action=stream"/&gt;
&lt;/applet&gt;</pre></p>

      <applet code="com.charliemouse.cambozola.Viewer" archive="cambozola.jar" width="512" height="384">
        <param name="url" value="./?action=stream"/>
        <param name="watermarks" value="favicon.png|left,top"/>
      </applet>

      <h3>About the Java applet</h3>
      <p>The used java applet is called <a href="http://www.charliemouse.com/code/cambozola/"><i>cambozola</i></a>.
      Here is the license:<br />
      <iframe src="LICENSE.txt" name="LICENSE" width="512" height="200" scrolling="yes">
        <p><a href="LICENSE.txt">license</a></p>
      </iframe>
      </p>

      <p>&copy; The <a href="http://mjpg-streamer.sf.net">MJPG-streamer team</a> | Design by <a href="http://andreasviklund.com">Andreas Viklund</a></p>
    </div>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/javascript_motiondetection.html
================
<html>
  <head>
    <title>MJPEG-Streamer</title>

    <!-- refresh page after a few seconds, prevents hang-ups -->
    <meta http-equiv="refresh" content="60" />
  </head>

<script language="javascript" type="text/javascript" src="functions.js"></script>
<script type="text/javascript">

/*******************************************************************************
  Copyright (C) 2009 Tom Stoeveken
  This program is free software;
  you can redistribute it and/or modify it under the terms of the
  GNU General Public License, version 2.
  See the file COPYING for details.
*******************************************************************************/

var img1 = null;
var img2 = null;
var canvas = null;

/*
  compare two images and count the differences

  input.: image1 and image2 are Image() objects
  input.: canvas is a Canvas() object to draw with
  input.: threshold specifies by how much the color value of a pixel
          must differ before they are regarded to be different

  return: number of different pixels
*/
function compare(image1, image2, canvas, threshold) {
  var movement = 0;
  var ctx = canvas.getContext("2d");
  var width = canvas.width/2, height = canvas.height/2;

  // copy images into canvas element
  // these steps scale the images and decodes the image data
  ctx.drawImage(image1, 0, 0, width, height);
  ctx.drawImage(image2, width, 0, width, height);

  // this makes r,g,b,alpha data of images available
  var pixels1 = ctx.getImageData(0, 0, width, height);
  var pixels2 = ctx.getImageData(width, 0, width, height);
  var pixels_diff = ctx.getImageData(0, 0, width, height);

  // substract picture1 from picture2
  // if they differ set color value to max,
  // if the difference is below threshold set difference to 0.
  for (var x = 0; x < pixels1.width; x++) {
    for (var y = 0; y < pixels1.height; y++) {

      // each pixel has a red, green, blue and alpha value
      // all values are stored in a linear array
      var i = x*4 + y*4*pixels1.width;

      pixels_diff.data[i] = (Math.abs(pixels1.data[i] - pixels2.data[i])>threshold)?255:0;
      pixels_diff.data[i+1] = (Math.abs(pixels1.data[i] - pixels2.data[i])>threshold)?255:0;
      pixels_diff.data[i+2] = (Math.abs(pixels1.data[i] - pixels2.data[i])>threshold)?255:0;
      pixels_diff.data[i+3] = 255;

      // count differing pixels
      movement += Math.min(1, pixels_diff.data[i] + pixels_diff.data[i+1] + pixels_diff.data[i+2]);
    }
  }

  ctx.putImageData(pixels_diff, width/2, height);

  return movement;
}

/*
  Callback function for completed picture downloads

  With every new picture a compare() is performed.
  The new picture is 'img1', the previous picture is stored in 'img2'.
*/
function newPictureComplete() {
  // just compare if there are two pictures
  if ( img2 != null ) {
    var res;

    try {
      // compare the two pictures, the given threshold helps to ignore noise
      res = compare(img1, img2, canvas, 50);
    }
    catch(e) {
      // errors can happen if the pictures were corrupted during transfer
      // instead of giving up, just proceed
    }

    // show to the user if we regards this as motion
    // decide for a color depending on movement (more then N pixels)
    // draw into free area of canvas
    // (hardcoded positions for better performance)
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = ( res > 5 ) ? "rgb(200,0,0)" : "rgb(0,200,0)";
    ctx.fillRect (0, 50, 25, 50); ctx.fillRect (75, 50, 25, 50);

    // send server our finding that there was some movement
    if ( res > 5 ) {
      AJAX_get('./?action=command&command=store')
    }
  }

  // copy reference of img1 to img2
  img2 = img1;
  img2.onload = null;
  // load a new picture into img1
  img1 = new Image();
  img1.onload=newPictureComplete;

  // load next picture in a few milliseconds
  // the server blocks anyway until a fresh picture has arrived, so it can never be faster
  // than the framerate. This timeout is intended to have the option
  // to lower the required processing power at client side.
  window.setTimeout("img1.src='./?action=snapshot&unique='+Math.random();", 1);
}

/*
  Initialize the elements

  * Create a Canvas() object and insert it into the page
  * Download the first image
  * Pause the Livestream again if we were paused previously
    This way we will not pause, but we will lower the refresh rate
    For a proper pause, the page can not be reloaded
*/
function run() {
  canvas = document.createElement("canvas");
  canvas.width = 100;
  canvas.height = 100;
  canvas.id = "comparison_canvas";
  document.getElementById("comparison").appendChild(canvas);

  img1 = new Image();
  img1.onload=newPictureComplete;
  img1.src = "./?action=snapshot";

  if ( window.name.indexOf('paused') != -1 )
    play_pause(document.getElementById("stream"));
}

/*
  Callback function for AJAX command

  input.: text is the response of the server
*/
function AJAX_response(text) {
  // nothing to do
  // later we might show a little folder symbol or so that dissapears
  // after a while
}

/*
  can toggle play/pause of the HTTP-push live preview

  input.: 'img' is the Image() object displaying the stream/picture
*/
function play_pause(img) {
  if ( img.src.indexOf('./?action=stream') != -1 ) {
    img.src = "./?action=snapshot&unique="+Math.random();

    // to keep the play/pause state over a page reload
    // this persistent property of the window can be (mis)used
    // it is a simple, but not so clean way of doing it
    // a cookie or server side scripting would be better in order to
    // pass information from one page to the other (reload)
    window.name = 'paused';
  } else {
    img.src = "./?action=stream";
    window.name = 'streaming';
  }
}

</script>
<body onload="run()">

  <fieldset style="background-color: silver; width: 200px; float: left">
    <legend style="background-color: silver; border: 1px solid black">Motion Detection</legend>
    <div id="comparison"></div>
  </fieldset>

  <fieldset style="background-color: silver; width: 50%">
    <legend style="background-color: silver; border: 1px solid black">Lifestream</legend>
    <img id="stream" src="./?action=stream" width="100%" onclick="play_pause(this)" />
  </fieldset>

</body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/javascript_simple.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>MJPEG-Streamer</title>
</head>
<script type="text/javascript">

/* Copyright (C) 2007 Richard Atterer, richard©atterer.net
   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License, version 2. See the file
   COPYING for details. */

var imageNr = 0; // Serial number of current image
var finished = new Array(); // References to img objects which have finished downloading
var paused = false;

function createImageLayer() {
  var img = new Image();
  img.style.position = "absolute";
  img.style.zIndex = -1;
  img.onload = imageOnload;
  img.onclick = imageOnclick;
  img.src = "./?action=snapshot&n=" + (++imageNr);
  var webcam = document.getElementById("webcam");
  webcam.insertBefore(img, webcam.firstChild);
}

// Two layers are always present (except at the very beginning), to avoid flicker
function imageOnload() {
  this.style.zIndex = imageNr; // Image finished, bring to front!
  while (1 < finished.length) {
    var del = finished.shift(); // Delete old image(s) from document
    del.parentNode.removeChild(del);
  }
  finished.push(this);
  if (!paused) createImageLayer();
}

function imageOnclick() { // Clicking on the image will pause the stream
  paused = !paused;
  if (!paused) createImageLayer();
}

</script>
<body onload="createImageLayer();">

<div id="webcam"><noscript><img src="./?action=snapshot" /></noscript></div>

</body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/javascript.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>MJPG-streamer</title>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <!--[if IE 6]>
    <link rel="stylesheet" href="fix.css" type="text/css" />
    <![endif]-->
    <script type="text/javascript">

      /* Copyright (C) 2007 Richard Atterer, richard©atterer.net
       * This program is free software; you can redistribute it and/or modify it
       * under the terms of the GNU General Public License, version 2. See the file
       * COPYING for details.
       */

      var imageNr = 0; // Serial number of current image
      var finished = new Array(); // References to img objects which have finished downloading
      var paused = false;
      var previous_time = new Date();
      var fNi = 0, msAvg = 0, fpsAvg = 0, fcnt = 0, fN = 80, msa = [], wsize = 4;

      function createImageLayer() {
        var img = new Image();
        img.style.position = "absolute";
        img.style.zIndex = -1;
        img.onload = imageOnload;
        img.onclick = imageOnclick;
        img.width = 512;
        img.height = 384;
        img.src = "./?action=snapshot&n=" + (++imageNr);
        var webcam = document.getElementById("webcam");
		window.info = document.getElementById('info').firstChild;
		window.ravgFps = document.getElementById('ravgfps').firstChild;
		window.ravgMs = document.getElementById('ravgms').firstChild;
		webcam.insertBefore(img, webcam.firstChild);
		document.getElementById('fN').firstChild.nodeValue = fN;
      }
	

	function runningAvgs (delta) {
		// delta is the measured frame period
		var len;
		if (fcnt < fN) {

			fcnt++;
			// we need to populate the sample array
			msa.push(delta);
			// calculate average period so far
			msAvg += (delta - msAvg) / fcnt;
			
		} else {
			/*
				running average (fN samples) according to the formula:
				rAvg = rAvg - value_fN_samples_back / fN + newest_value / fN
			*/
			msAvg += (delta - msa[0])/fN;
			// drop oldest ms value, msa[0]
			msa = msa.slice(1);
			// append newest value, delta
			msa.push(delta);
		}
		// calculate average fps
		fpsAvg = 1000 / msAvg;
		/*
			once every fN frames, check if we need to adjust the averaging window
			since faster rates seem to need more samples to reach a stable(er) readout
		*/
		if (++fNi == fN) {

			fNi = 0;
			// new window size
			fN = parseInt(fpsAvg * wsize);
			len = fcnt - fN;
			// if our sample array, msa, has extra samples, then trim it to the new size
			if (len > 0) {

				// adjust averaging window (nr of samples)
				msa = msa.splice(len);
				// avoid populating the sample array again
				fcnt = fN;
			}
		}
	}

      // Two layers are always present (except at the very beginning), to avoid flicker
      function imageOnload() {
        this.style.zIndex = imageNr; // Image finished, bring to front!
        while (1 < finished.length) {
          var del = finished.shift(); // Delete old image(s) from document
          del.parentNode.removeChild(del);
        }
        finished.push(this);
        current_time = new Date();
        delta = current_time.getTime() - previous_time.getTime();
        fps   = (1000.0 / delta).toFixed(1);
		runningAvgs(delta);
        info.nodeValue = delta + " ms (" + fps + " fps)";
		ravgFps.nodeValue = fpsAvg.toFixed(1);
		ravgMs.nodeValue = msAvg.toFixed(0);
		previous_time = current_time;
        if (!paused) createImageLayer();
      }

      function imageOnclick() { // Clicking on the image will pause the stream
        paused = !paused;
        if (!paused) createImageLayer();
      }

    </script>
  </head>

  <body onload="createImageLayer();">
    <div id="sidebar">
      <h1>MJPG-Streamer Demo Pages</h1>
      <h2>a resource-friendly streaming application</h2>

      <div id="menu">
        <a href="index.html">Home</a>
        <a href="static.html">Static</a>
        <a href="stream.html">Stream</a>
        <a href="java.html">Java</a>
        <a class="active" href="javascript.html">Javascript</a>
        <a href="videolan.html">VideoLAN</a>
        <a target="_blank" onClick="window.open(this.href, '_blank','width=400,height=400'); return false;" href="control.htm">Control</a>
      </div>

      <h3>Version info:</h3>
      <p>v0.1 (Okt 22, 2007)</p>

      <h3>Runtime info:</h3>
      <p><span id="info">-</span><br/>
      Avg<sub id="fN">-</sub> : <span  id="ravgms">-</span> ms (<span  id="ravgfps">-</span> fps)
      </p>
      </div>

    <div id="content">
      <h1>Javascript</h1>
      <h2>Display the stream with javascript</h2>

      <h3>Hints</h3>
        <p>This example shows the stream by using java script. It works with most browsers. To see a simple example click <a href="javascript_simple.html">here</a>.</p>

        <div id="webcam" style="width:512px;height:394px"><noscript><img src="./?action=snapshot" width="512px" height="384px" /></noscript></div>

      <p>&copy; The <a href="http://mjpg-streamer.sf.net">MJPG-streamer team</a> | Design by <a href="http://andreasviklund.com">Andreas Viklund</a></p>
    </div>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/jquery.js
================
/*!
 * jQuery JavaScript Library v1.4.2
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Sat Feb 13 22:33:48 2010 -0500
 */
(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll("left")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b==="object"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?
e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,"events");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type==="click")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=
j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType==="mouseenter"||i.preType==="mouseleave")f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return"live."+(a&&a!=="*"?a+".":"")+b.replace(/\./g,"`").replace(/ /g,
"&")}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=
true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return"scrollTo"in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,Ua=/^.[^:#\[\.,]*$/,Va=/\S/,
Wa=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,Xa=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a==="body"&&!b){this.context=s;this[0]=s.body;this.selector="body";this.length=1;return this}if(typeof a==="string")if((d=Ta.exec(a))&&
(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&/^\w+$/.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,
a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:"",jquery:"1.4.2",length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===
"find")f.selector=this.selector+(this.selector?" ":"")+d;else if(b)f.selector=this.selector+"."+b+"("+d+")";return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),"slice",R.call(arguments).join(","))},map:function(a){return this.pushStack(c.map(this,
function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a==="boolean"){f=a;a=arguments[1]||{};b=2}if(typeof a!=="object"&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||
c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler("ready")}},bindReady:function(){if(!xa){xa=true;if(s.readyState==="complete")return c.ready();if(s.addEventListener){s.addEventListener("DOMContentLoaded",
L,false);A.addEventListener("load",c.ready,false)}else if(s.attachEvent){s.attachEvent("onreadystatechange",L);A.attachEvent("onload",c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)==="[object Function]"},isArray:function(a){return $.call(a)==="[object Array]"},isPlainObject:function(a){if(!a||$.call(a)!=="[object Object]"||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,"constructor")&&!aa.call(a.constructor.prototype,
"isPrototypeOf"))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!=="string"||!a)return null;a=c.trim(a);if(/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function("return "+
a))();else c.error("Invalid JSON: "+a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName("head")[0]||s.documentElement,d=s.createElement("script");d.type="text/javascript";if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],
d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||"").replace(Wa,"")},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a==="string"||c.isFunction(a)||typeof a!=="function"&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===
a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length==="number")for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b==="string"){d=a;a=d[b];b=w}else if(b&&
!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=/(webkit)[ \/]([\w.]+)/.exec(a)||/(opera)(?:.*version)?[ \/]([\w.]+)/.exec(a)||/(msie) ([\w.]+)/.exec(a)||!/compatible/.test(a)&&/(mozilla)(?:.*? rv:([\w.]+))?/.exec(a)||[];return{browser:a[1]||"",version:a[2]||"0"}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=
true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener("DOMContentLoaded",L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState==="complete"){s.detachEvent("onreadystatechange",L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement("script"),d=s.createElement("div"),f="script"+J();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
var e=d.getElementsByTagName("*"),j=d.getElementsByTagName("a")[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(j.getAttribute("style")),hrefNormalized:j.getAttribute("href")==="/a",opacity:/^0.55$/.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:s.createElement("select").appendChild(s.createElement("option")).selected,
parentNode:d.removeChild(d.appendChild(s.createElement("div"))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type="text/javascript";try{b.appendChild(s.createTextNode("window."+f+"=1;"))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function k(){c.support.noCloneEvent=
false;d.detachEvent("onclick",k)});d.cloneNode(true).fireEvent("onclick")}d=s.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement("div");k.style.width=k.style.paddingLeft="1px";s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display="none"});a=function(k){var n=
s.createElement("div");k="on"+k;var r=k in n;if(!r){n.setAttribute(k,"return;");r=typeof n[k]==="function"}return r};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=e=j=null}})();c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};var G="jQuery"+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,
applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b==="string"&&d===w)return null;f||(f=++Ya);if(typeof b==="object"){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b==="string"?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];
else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a==="undefined"&&this.length)return c.data(this[0]);else if(typeof a==="object")return this.each(function(){c.data(this,a)});var d=a.split(".");d[1]=d[1]?"."+d[1]:"";if(b===w){var f=this.triggerHandler("getData"+d[1]+"!",[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger("setData"+d[1]+"!",[d[0],b]).each(function(){c.data(this,
a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),f=d.shift();if(f==="inprogress")f=d.shift();if(f){b==="fx"&&d.unshift("inprogress");f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===
w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var Aa=/[\n\t]/g,ca=/\s+/,Za=/\r/g,$a=/href|src|style/,ab=/(button|input)/i,bb=/(button|input|object|select|textarea)/i,
cb=/^(a|area)$/i,Ba=/radio|checkbox/;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j=" "+e.className+" ",
i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf(" "+b[o]+" ")<0)i+=" "+b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr("class")))});if(a&&typeof a==="string"||a===w)for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=(" "+e.className+" ").replace(Aa," "),i=0,o=b.length;i<o;i++)j=j.replace(" "+b[i]+" ",
" ");e.className=c.trim(j)}else e.className=""}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b==="boolean";if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?"addClass":"removeClass"](e)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,"__className__",this.className);this.className=
this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(Aa," ").indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,"option"))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,"select")){var d=b.selectedIndex,f=[],e=b.options;b=b.type==="select-one";if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=
e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Za,"")}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r==="number")r+="";if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,"select")){var u=c.makeArray(r);c("option",this).each(function(){this.selected=
c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b==="type"&&ab.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");
a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b==="style"){if(e)a.style.cssText=""+d;return a.style.cssText}e&&a.setAttribute(b,""+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=/\.(.*)$/,db=function(a){return a.replace(/[^\w\s\.\|`]/g,
function(b){return"\\"+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split(" ");for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(".")>-1){r=k.split(".");
k=r.shift();j.namespace=r.slice(0).sort().join(".")}else{r=[];j.namespace=""}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent("on"+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),
C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(e in C)c.event.remove(a,e+b)}else{for(b=b.split(" ");e=b[j++];){n=e;i=e.indexOf(".")<0;o=[];if(!i){o=e.split(".");e=o.shift();k=new RegExp("(^|\\.)"+c.map(o.slice(0).sort(),db).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=
null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a==="object"?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf("!")>=0){a.type=
e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,"handle"))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+e]&&d["on"+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&
f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,"a")&&e==="click",k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f["on"+e])f["on"+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f["on"+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;
if(!b){d=a.type.split(".");a.type=d.shift();f=new RegExp("(^|\\.)"+d.slice(0).sort().join("\\.(?:.*\\.)?")+"(\\.|$)")}e=c.data(this,"events");d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,"");c.each(c.data(this,
"events").live||[],function(){if(d===this.origType.replace(O,""))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=
a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,
isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit=
{setup:function(){if(this.nodeName.toLowerCase()!=="form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length)return na("submit",this,arguments)});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13)return na("submit",this,arguments)})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};
if(!c.support.changeBubbles){var da=/textarea|input|select/i,ea,Fa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,"_change_data");e=Fa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",
e);if(!(f===w||e===f))if(f!=null||e){a.type="change";return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,
"_change_data",Fa(a))}},setup:function(){if(this.type==="file")return false;for(var a in ea)c.event.add(this,a+".specialChange",ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,
d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,f,e){if(typeof d==="object"){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b==="one"?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d==="unload"&&b!=="one")this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&
!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},
toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,
u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||"").split(" ");(i=d[o++])!=null;){j=O.exec(i);k="";if(j){k=j[0];i=i.replace(O,"")}if(i==="hover")d.push("mouseenter"+k,"mouseleave"+k);else{n=i;if(i==="focus"||i==="blur"){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b==="live"?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),
function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent("onunload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h="",l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];
if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!=="string"){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!=="string")return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(""),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();
t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]==="~"||p[0]==="+")&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D="";if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||
g);if(j.call(y)==="[object Array]")if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];
for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!=="\\"){q[1]=(q[1]||"").replace(/\\/g,"");m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],"");break}}}}m||(m=h.getElementsByTagName("*"));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-
1)!=="\\"){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],"");if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var n=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
CLASS:/\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},
relative:{"+":function(g,h){var l=typeof h==="string",m=l&&!/\W/.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},">":function(g,h){var l=typeof h==="string";if(l&&!/\W/.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=
l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},"":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("parentNode",h,m,g,p,l)},"~":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("previousSibling",h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!=="undefined"&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!=="undefined"){var l=[];
h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute("name")===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g=" "+g[1].replace(/\\/g,"")+" ";if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&(" "+v.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},
CHILD:function(g){if(g[1]==="nth"){var h=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(/\\/g,"");if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,h,l,m,q){if(g[1]==="not")if((f.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,
g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},
text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},
setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q==="contains")return(g.textContent||g.innerText||a([g])||"").indexOf(h[3])>=0;else if(q==="not"){h=
h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l==="first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=
m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute("id")===h},TAG:function(g,h){return h==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+"";var m=h[2];h=h[4];return g==null?m==="!=":m===
"="?l===h:m==="*="?l.indexOf(h)>=0:m==="~="?(" "+l+" ").indexOf(h)>=0:!h?l&&g!==false:m==="!="?l!==h:m==="^="?l.indexOf(h)===0:m==="$="?l.substr(l.length-h.length)===h:m==="|="?l===h||l.substr(0,h.length+1)===h+"-":false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+/(?![^\[]*\])(?![^\(]*\))/.source);n.leftMatch[u]=new RegExp(/(^(?:.|\r|\n)*?)/.source+n.match[u].source.replace(/\\(\d+)/g,function(g,
h){return"\\"+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)==="[object Array]")Array.prototype.push.apply(h,g);else if(typeof g.length==="number")for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||
!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if("sourceIndex"in s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=
h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement("div"),h="script"+(new Date).getTime();g.innerHTML="<a name='"+h+"'/>";var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!=="undefined"&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!=="undefined"&&
q.getAttributeNode("id").nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement("div");g.appendChild(s.createComment(""));if(g.getElementsByTagName("*").length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]==="*"){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML="<a href='#'></a>";
if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")n.attrHandle.href=function(h){return h.getAttribute("href",2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement("div");h.innerHTML="<p class='TEST'></p>";if(!(h.querySelectorAll&&h.querySelectorAll(".TEST").length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();
(function(){var g=s.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){n.order.splice(1,0,"CLASS");n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!=="undefined"&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:
function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false},ga=function(g,h){var l=[],m="",q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,"")}g=n.relative[g]?g+"*":g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=/Until$/,fb=/^(?:parents|prevUntil|prevAll)/,
gb=/,/;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b==="string"){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,f=0,e=this.length;f<e;f++){d=b.length;
c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),"not",a)},filter:function(a){return this.pushStack(Ia(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j=
{},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===
"string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a==="string"?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",
d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?
a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f==="string")e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===
1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja=/ jQuery\d+="(?:\d+|null)"/g,V=/^\s+/,Ka=/(<([\w:]+)[^>]*?)\/>/g,hb=/^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i,La=/<([\w:]+)/,ib=/<tbody/i,jb=/<|&#?\w+;/,ta=/<script|<object|<embed|<option|<style/i,ua=/checked\s*(?:[^=]|=\s*.checked.)/i,Ma=function(a,b,d){return hb.test(d)?
a:b+"></"+d+">"},F={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName("*"));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,"").replace(/=([^="'>\s]+\/)>/g,'="$1">').replace(V,"")],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find("*"),b.find("*"))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,
""):null;else if(typeof a==="string"&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&
this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,"table")?u.getElementsByTagName("tbody")[0]||
u.appendChild(u.ownerDocument.createElement("tbody")):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i==="string"&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===
1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,"tr");for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);
return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement==="undefined")b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i==="number")i+="";if(i){if(typeof i==="string"&&!jb.test(i))i=b.createTextNode(i);else if(typeof i==="string"){i=i.replace(Ka,Ma);var o=(La.exec(i)||["",
""])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement("div");for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o==="table"&&!n?r.firstChild&&r.firstChild.childNodes:k[1]==="<table>"&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],"tbody")&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=
c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],"script")&&(!e[j].type||e[j].type.toLowerCase()==="text/javascript"))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName("script"))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?
c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=/z-?index|font-?weight|opacity|zoom|line-?height/i,Na=/alpha\([^)]*\)/,Oa=/opacity=([^)]*)/,ha=/float/i,ia=/-([a-z])/ig,lb=/([A-Z])/g,mb=/^-?\d+(?:px)?$/i,nb=/^-?\d/,ob={position:"absolute",visibility:"hidden",display:"block"},pb=["Left","Right"],qb=["Top","Bottom"],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?"cssFloat":"styleFloat",ja=
function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e==="number"&&!kb.test(f))e+="px";c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b==="width"||b==="height")&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b==="opacity"){if(e){f.zoom=1;b=parseInt(d,10)+""==="NaN"?"":"alpha(opacity="+d*100+")";a=f.filter||c.curCSS(a,"filter")||"";f.filter=
Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf("opacity=")>=0?parseFloat(Oa.exec(f.filter)[1])/100+"":""}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b==="width"||b==="height"){var e,j=b==="width"?pb:qb;function i(){e=b==="width"?a.offsetWidth:a.offsetHeight;f!=="border"&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,"padding"+this,true))||0);if(f==="margin")e+=parseFloat(c.curCSS(a,"margin"+this,true))||0;else e-=parseFloat(c.curCSS(a,
"border"+this+"Width",true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b==="opacity"&&a.currentStyle){f=Oa.test(a.currentStyle.filter||"")?parseFloat(RegExp.$1)/100+"":"";return f===""?"1":f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b="float";b=b.replace(lb,"-$1").toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=
a.getPropertyValue(b);if(b==="opacity"&&f==="")f="1"}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d==="fontSize"?"1em":f||0;f=e.pixelLeft+"px";e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=
a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()==="tr";return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,"display")==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=/<script(.|\s)*?\/script>/gi,ub=/select|textarea/i,vb=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,N=/=\?(&|$)/,ka=/\?/,wb=/(\?|&)_=.*?(&|$)/,xb=/^(\w+:)?\/\/([^\/?#]+)/,yb=/%20/g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==
"string")return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf(" ");if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b==="object"){b=c.param(b,c.ajaxSettings.traditional);f="POST"}var j=this;c.ajax({url:a,type:f,dataType:"html",data:b,complete:function(i,o){if(o==="success"||o==="notmodified")j.html(e?c("<div />").append(i.responseText.replace(tb,"")).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},
serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),
function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,
global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!=="file:"||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject("Microsoft.XMLHTTP")}catch(a){}},accepts:{xml:"application/xml, text/xml",html:"text/html",script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&
e.success.call(k,o,i,x);e.global&&f("ajaxSuccess",[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f("ajaxComplete",[x,e]);e.global&&!--c.active&&c.event.trigger("ajaxStop")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!=="string")e.data=c.param(e.data,e.traditional);if(e.dataType==="jsonp"){if(n==="GET")N.test(e.url)||(e.url+=(ka.test(e.url)?
"&":"?")+(e.jsonp||"callback")+"=?");else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+"&":"")+(e.jsonp||"callback")+"=?";e.dataType="json"}if(e.dataType==="json"&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||"jsonp"+sb++;if(e.data)e.data=(e.data+"").replace(N,"="+j+"$1");e.url=e.url.replace(N,"="+j+"$1");e.dataType="script";A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType==="script"&&e.cache===null)e.cache=false;if(e.cache===
false&&n==="GET"){var r=J(),u=e.url.replace(wb,"$1_="+r+"$2");e.url=u+(u===e.url?(ka.test(e.url)?"&":"?")+"_="+r:"")}if(e.data&&n==="GET")e.url+=(ka.test(e.url)?"&":"?")+e.data;e.global&&!c.active++&&c.event.trigger("ajaxStart");r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType==="script"&&n==="GET"&&r){var z=s.getElementsByTagName("head")[0]||s.documentElement,C=s.createElement("script");C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=
false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader("Content-Type",e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader("If-Modified-Since",
c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader("If-None-Match",c.etag[e.url])}r||x.setRequestHeader("X-Requested-With","XMLHttpRequest");x.setRequestHeader("Accept",e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+", */*":e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger("ajaxStop");x.abort();return false}e.global&&f("ajaxSend",[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q==="abort"){E||
d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q==="timeout")){E=true;x.onreadystatechange=c.noop;i=q==="timeout"?"timeout":!c.httpSuccess(x)?"error":e.ifModified&&c.httpNotModified(x,e.url)?"notmodified":"success";var p;if(i==="success")try{o=c.httpData(x,e.dataType,e)}catch(v){i="parsererror";p=v}if(i==="success"||i==="notmodified")j||b();else c.handleError(e,x,i,p);d();q==="timeout"&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);
g("abort")}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g("timeout")},e.timeout);try{x.send(n==="POST"||n==="PUT"||n==="DELETE"?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger("ajaxError",[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===
1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),f=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader("content-type")||"",e=b==="xml"||!b&&f.indexOf("xml")>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b===
"json"||!b&&f.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&f.indexOf("javascript")>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||/\[\]$/.test(i)?f(i,n):d(i+"["+(typeof n==="object"||c.isArray(n)?k:"")+"]",n)});else!b&&o!=null&&typeof o==="object"?c.each(o,function(k,n){d(i+"["+k+"]",n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+"="+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;
if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join("&").replace(yb,"+")}});var la={},Ab=/toggle|show|hide/,Bb=/^([+-]=)?([\d+-.]+)(.*)$/,W,va=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K("show",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");
this[a].style.display=d||"";if(c.css(this[a],"display")==="none"){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c("<"+d+" />").appendTo("body");f=e.css("display");if(f==="none")f="block";e.remove();la[d]=f}c.data(this[a],"olddisplay",f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],"olddisplay")||"";return this}},hide:function(a,b){if(a||a===0)return this.animate(K("hide",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");!d&&d!=="none"&&c.data(this[a],
"olddisplay",c.css(this[a],"display"))}a=0;for(b=this.length;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(K("toggle",3),a,b);return this},fadeTo:function(a,b,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d)},
animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?"each":"queue"](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(":hidden"),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]==="hide"&&o||a[i]==="show"&&!o)return j.complete.call(this);if((i==="height"||i==="width")&&this.style){j.display=c.css(this,"display");j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=
j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow="hidden";j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u==="toggle"?o?"show":"hide":u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||"px";if(E!=="px"){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]==="-="?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);
this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K("show",1),slideUp:K("hide",1),slideToggle:K("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a==="object"?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===
"number"?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||
c.fx.step._default)(this);if((this.prop==="height"||this.prop==="width")&&this.elem.style)this.elem.style.display="block"},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;
this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=
this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,"olddisplay");this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,"display")==="none")this.elem.style.display="block"}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,
e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||
c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset="getBoundingClientRect"in s.documentElement?
function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=
this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position==="fixed")break;j=e?e.getComputedStyle(b,null):b.currentStyle;
k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!=="visible"){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position==="relative"||f.position==="static"){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&
f.position==="fixed"){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement("div"),d,f,e,j=parseFloat(c.curCSS(a,"marginTop",true))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position="fixed";f.style.top="20px";this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);
c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,"marginTop",true))||0;d+=parseFloat(c.curCSS(a,"marginLeft",true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(/static/.test(c.curCSS(a,"position")))a.style.position="relative";var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,"top",true),10)||0,i=parseInt(c.curCSS(a,"left",true),10)||0;if(c.isFunction(b))b=b.call(a,
d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};"using"in b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=/^body|html$/i.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,"marginTop",true))||0;d.left-=parseFloat(c.curCSS(a,"marginLeft",true))||0;f.top+=parseFloat(c.curCSS(b[0],"borderTopWidth",true))||0;f.left+=parseFloat(c.curCSS(b[0],"borderLeftWidth",true))||0;return{top:d.top-
f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!/^body|html$/i.test(a.nodeName)&&c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?"pageXOffset"in j?j[a?"pageYOffset":
"pageXOffset"]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();c.fn["inner"+b]=function(){return this[0]?c.css(this[0],d,false,"padding"):null};c.fn["outer"+b]=function(f){return this[0]?c.css(this[0],d,false,f?"margin":"border"):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});return"scrollTo"in
e&&e.document?e.document.compatMode==="CSS1Compat"&&e.document.documentElement["client"+b]||e.document.body["client"+b]:e.nodeType===9?Math.max(e.documentElement["client"+b],e.body["scroll"+b],e.documentElement["scroll"+b],e.body["offset"+b],e.documentElement["offset"+b]):f===w?c.css(e,d):this.css(d,typeof f==="string"?f:f+"px")}});A.jQuery=A.$=c})(window);

================
File: mjpg-streamer/mjpg-streamer-experimental/www/jquery.rotate.js
================
// modified by mmikowski 20090803
// * Added semicolons after function declarations;
//   their omission broke YUI compressor
// * Converted to Unix style line endings
// modified by mmikowski 20100114 for firefox 3.5 support
// * See http://code.google.com/p/jquery-rotate/issues/detail?id=3#c2 comment 1
//   I had to rewrite this to resolve multiple rotations
//

jQuery.fn.rotate = function(angle,whence) {

var fnRotate = function(canvas,rotation){
    var costheta = Math.cos(rotation);
    var sintheta = Math.sin(rotation);
    canvas.style.width
      = canvas.width
      = Math.abs(costheta*canvas.oImage.width)
      + Math.abs(sintheta*canvas.oImage.height)
      ;
    canvas.style.height
      = canvas.height
      = Math.abs(costheta*canvas.oImage.height)
      + Math.abs(sintheta*canvas.oImage.width)
      ;

    var context = canvas.getContext('2d');
    context.save();
    if (rotation <= Math.PI/2) {
      context.translate(sintheta*canvas.oImage.height,0);
    } else if (rotation <= Math.PI) {
      context.translate(canvas.width,-costheta*canvas.oImage.height);
    } else if (rotation <= 1.5*Math.PI) {
      context.translate(-costheta*canvas.oImage.width,canvas.height);
    } else {
      context.translate(0,-sintheta*canvas.oImage.width);
    }
    context.rotate(rotation);
    context.drawImage(canvas.oImage, 0, 0, canvas.oImage.width, canvas.oImage.height);
    context.restore();
  };
  var p = this.get(0);

  // we store the angle inside the image tag for persistence
  if (!whence) {
    p.angle = ((p.angle==undefined?0:p.angle) + angle) % 360;
  } else {
    p.angle = angle;
  }

  if (p.angle >= 0) {
    var rotation = Math.PI * p.angle / 180;
  } else {
    var rotation = Math.PI * (360+p.angle) / 180;
  }

  if (document.all && !window.opera) {
    var canvas = document.createElement('img');

    var costheta = Math.cos(rotation);
    var sintheta = Math.sin(rotation);
    canvas.src = p.src;
    canvas.height = p.height;
    canvas.width  = p.width;

    canvas.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11="+costheta+",M12="+(-sintheta)+",M21="+sintheta+",M22="+costheta+",SizingMethod='auto expand')";
  } else {
    var canvas = document.createElement('canvas');
    if (!p.oImage) {
      canvas.oImage = new Image();
      canvas.oImage.src = p.src;
      canvas.oImage.width = p.width;
      canvas.oImage.height = p.height;

      canvas.oImage.onload = function(){ fnRotate(canvas,rotation) };
    } else {
      canvas.oImage = p.oImage;
      fnRotate(canvas,rotation);
    }
  }
  canvas.id = p.id;
  canvas.angle = p.angle;
  p.parentNode.replaceChild(canvas, p);
};

jQuery.fn.rotateRight = function(angle) {
  this.rotate(angle==undefined?90:angle);
};

jQuery.fn.rotateLeft = function(angle) {
  this.rotate(angle==undefined?-90:-angle);
};

================
File: mjpg-streamer/mjpg-streamer-experimental/www/jquery.ui.core.min.js
================
/*!
 * jQuery UI 1.8.4
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function(c,j){function k(a){return!c(a).parents().andSelf().filter(function(){return c.curCSS(this,"visibility")==="hidden"||c.expr.filters.hidden(this)}).length}c.ui=c.ui||{};if(!c.ui.version){c.extend(c.ui,{version:"1.8.4",plugin:{add:function(a,b,d){a=c.ui[a].prototype;for(var e in d){a.plugins[e]=a.plugins[e]||[];a.plugins[e].push([b,d[e]])}},call:function(a,b,d){if((b=a.plugins[b])&&a.element[0].parentNode)for(var e=0;e<b.length;e++)a.options[b[e][0]]&&b[e][1].apply(a.element,d)}},contains:function(a,
b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(a,b){if(c(a).css("overflow")==="hidden")return false;b=b&&b==="left"?"scrollLeft":"scrollTop";var d=false;if(a[b]>0)return true;a[b]=1;d=a[b]>0;a[b]=0;return d},isOverAxis:function(a,b,d){return a>b&&a<b+d},isOver:function(a,b,d,e,h,i){return c.ui.isOverAxis(a,d,h)&&c.ui.isOverAxis(b,e,i)},keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,
CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});c.fn.extend({_focus:c.fn.focus,focus:function(a,b){return typeof a==="number"?this.each(function(){var d=this;setTimeout(function(){c(d).focus();b&&b.call(d)},a)}):this._focus.apply(this,arguments)},enableSelection:function(){return this.attr("unselectable",
"off").css("MozUserSelect","")},disableSelection:function(){return this.attr("unselectable","on").css("MozUserSelect","none")},scrollParent:function(){var a;a=c.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(c.curCSS(this,"position",1))&&/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(c.curCSS(this,
"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0);return/fixed/.test(this.css("position"))||!a.length?c(document):a},zIndex:function(a){if(a!==j)return this.css("zIndex",a);if(this.length){a=c(this[0]);for(var b;a.length&&a[0]!==document;){b=a.css("position");if(b==="absolute"||b==="relative"||b==="fixed"){b=parseInt(a.css("zIndex"));if(!isNaN(b)&&b!=0)return b}a=a.parent()}}return 0}});c.each(["Width","Height"],function(a,b){function d(f,g,l,m){c.each(e,function(){g-=
parseFloat(c.curCSS(f,"padding"+this,true))||0;if(l)g-=parseFloat(c.curCSS(f,"border"+this+"Width",true))||0;if(m)g-=parseFloat(c.curCSS(f,"margin"+this,true))||0});return g}var e=b==="Width"?["Left","Right"]:["Top","Bottom"],h=b.toLowerCase(),i={innerWidth:c.fn.innerWidth,innerHeight:c.fn.innerHeight,outerWidth:c.fn.outerWidth,outerHeight:c.fn.outerHeight};c.fn["inner"+b]=function(f){if(f===j)return i["inner"+b].call(this);return this.each(function(){c.style(this,h,d(this,f)+"px")})};c.fn["outer"+
b]=function(f,g){if(typeof f!=="number")return i["outer"+b].call(this,f);return this.each(function(){c.style(this,h,d(this,f,true,g)+"px")})}});c.extend(c.expr[":"],{data:function(a,b,d){return!!c.data(a,d[3])},focusable:function(a){var b=a.nodeName.toLowerCase(),d=c.attr(a,"tabindex");if("area"===b){b=a.parentNode;d=b.name;if(!a.href||!d||b.nodeName.toLowerCase()!=="map")return false;a=c("img[usemap=#"+d+"]")[0];return!!a&&k(a)}return(/input|select|textarea|button|object/.test(b)?!a.disabled:"a"==
b?a.href||!isNaN(d):!isNaN(d))&&k(a)},tabbable:function(a){var b=c.attr(a,"tabindex");return(isNaN(b)||b>=0)&&c(a).is(":focusable")}})}})(jQuery);

================
File: mjpg-streamer/mjpg-streamer-experimental/www/jquery.ui.custom.css
================
/*
 * jQuery UI CSS Framework @VERSION
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Theming/API
 */

/* Layout helpers
----------------------------------*/
.ui-helper-hidden { display: none; }
.ui-helper-hidden-accessible { position: absolute; left: -99999999px; }
.ui-helper-reset { margin: 0; padding: 0; border: 0; outline: 0; line-height: 1.3; text-decoration: none; font-size: 100%; list-style: none; }
.ui-helper-clearfix:after { content: "."; display: block; height: 0; clear: both; visibility: hidden; }
.ui-helper-clearfix { display: inline-block; }
/* required comment for clearfix to work in Opera \*/
* html .ui-helper-clearfix { height:1%; }
.ui-helper-clearfix { display:block; }
/* end clearfix */
.ui-helper-zfix { width: 100%; height: 100%; top: 0; left: 0; position: absolute; opacity: 0; filter:Alpha(Opacity=0); }


/* Interaction Cues
----------------------------------*/
.ui-state-disabled { cursor: default !important; }


/* Icons
----------------------------------*/

/* states and images */
.ui-icon { display: block; text-indent: -99999px; overflow: hidden; background-repeat: no-repeat; }


/* Misc visuals
----------------------------------*/

/* Overlays */
.ui-widget-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }


/*
 * jQuery UI CSS Framework @VERSION
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Theming/API
 *
 * To view and modify this theme, visit http://jqueryui.com/themeroller/?ffDefault=Trebuchet%20MS,%20Tahoma,%20Verdana,%20Arial,%20sans-serif&fwDefault=bold&fsDefault=1.1em&cornerRadius=4px&bgColorHeader=f6a828&bgTextureHeader=12_gloss_wave.png&bgImgOpacityHeader=35&borderColorHeader=e78f08&fcHeader=ffffff&iconColorHeader=ffffff&bgColorContent=eeeeee&bgTextureContent=03_highlight_soft.png&bgImgOpacityContent=100&borderColorContent=dddddd&fcContent=333333&iconColorContent=222222&bgColorDefault=f6f6f6&bgTextureDefault=02_glass.png&bgImgOpacityDefault=100&borderColorDefault=cccccc&fcDefault=1c94c4&iconColorDefault=ef8c08&bgColorHover=fdf5ce&bgTextureHover=02_glass.png&bgImgOpacityHover=100&borderColorHover=fbcb09&fcHover=c77405&iconColorHover=ef8c08&bgColorActive=ffffff&bgTextureActive=02_glass.png&bgImgOpacityActive=65&borderColorActive=fbd850&fcActive=eb8f00&iconColorActive=ef8c08&bgColorHighlight=ffe45c&bgTextureHighlight=03_highlight_soft.png&bgImgOpacityHighlight=75&borderColorHighlight=fed22f&fcHighlight=363636&iconColorHighlight=228ef1&bgColorError=b81900&bgTextureError=08_diagonals_thick.png&bgImgOpacityError=18&borderColorError=cd0a0a&fcError=ffffff&iconColorError=ffd27a&bgColorOverlay=666666&bgTextureOverlay=08_diagonals_thick.png&bgImgOpacityOverlay=20&opacityOverlay=50&bgColorShadow=000000&bgTextureShadow=01_flat.png&bgImgOpacityShadow=10&opacityShadow=20&thicknessShadow=5px&offsetTopShadow=-5px&offsetLeftShadow=-5px&cornerRadiusShadow=5px
 */


/* Component containers
----------------------------------*/
.ui-widget { font-family: Trebuchet MS, Tahoma, Verdana, Arial, sans-serif; font-size: 1.1em; }
.ui-widget .ui-widget { font-size: 1em; }
.ui-widget input, .ui-widget select, .ui-widget textarea, .ui-widget button { font-family: Trebuchet MS, Tahoma, Verdana, Arial, sans-serif; font-size: 1em; }
.ui-widget-content { border: 1px solid #dddddd; background: #eeeeee url(images/ui-bg_highlight-soft_100_eeeeee_1x100.png) 50% top repeat-x; color: #333333; }
.ui-widget-content a { color: #333333; }
.ui-widget-header { border: 1px solid #e78f08; background: #f6a828 url(images/ui-bg_gloss-wave_35_f6a828_500x100.png) 50% 50% repeat-x; color: #ffffff; font-weight: bold; }
.ui-widget-header a { color: #ffffff; }

/* Interaction states
----------------------------------*/
.ui-state-default, .ui-widget-content .ui-state-default, .ui-widget-header .ui-state-default { border: 1px solid #cccccc; background: #f6f6f6 url(images/ui-bg_glass_100_f6f6f6_1x400.png) 50% 50% repeat-x; font-weight: bold; color: #1c94c4; }
.ui-state-default a, .ui-state-default a:link, .ui-state-default a:visited { color: #1c94c4; text-decoration: none; }
.ui-state-hover, .ui-widget-content .ui-state-hover, .ui-widget-header .ui-state-hover, .ui-state-focus, .ui-widget-content .ui-state-focus, .ui-widget-header .ui-state-focus { border: 1px solid #fbcb09; background: #fdf5ce url(images/ui-bg_glass_100_fdf5ce_1x400.png) 50% 50% repeat-x; font-weight: bold; color: #c77405; }
.ui-state-hover a, .ui-state-hover a:hover { color: #c77405; text-decoration: none; }
.ui-state-active, .ui-widget-content .ui-state-active, .ui-widget-header .ui-state-active { border: 1px solid #fbd850; background: #ffffff url(images/ui-bg_glass_65_ffffff_1x400.png) 50% 50% repeat-x; font-weight: bold; color: #eb8f00; }
.ui-state-active a, .ui-state-active a:link, .ui-state-active a:visited { color: #eb8f00; text-decoration: none; }
.ui-widget :active { outline: none; }

/* Interaction Cues
----------------------------------*/
.ui-state-highlight, .ui-widget-content .ui-state-highlight, .ui-widget-header .ui-state-highlight  {border: 1px solid #fed22f; background: #ffe45c url(images/ui-bg_highlight-soft_75_ffe45c_1x100.png) 50% top repeat-x; color: #363636; }
.ui-state-highlight a, .ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a { color: #363636; }
.ui-state-error, .ui-widget-content .ui-state-error, .ui-widget-header .ui-state-error {border: 1px solid #cd0a0a; background: #b81900 url(images/ui-bg_diagonals-thick_18_b81900_40x40.png) 50% 50% repeat; color: #ffffff; }
.ui-state-error a, .ui-widget-content .ui-state-error a, .ui-widget-header .ui-state-error a { color: #ffffff; }
.ui-state-error-text, .ui-widget-content .ui-state-error-text, .ui-widget-header .ui-state-error-text { color: #ffffff; }
.ui-priority-primary, .ui-widget-content .ui-priority-primary, .ui-widget-header .ui-priority-primary { font-weight: bold; }
.ui-priority-secondary, .ui-widget-content .ui-priority-secondary,  .ui-widget-header .ui-priority-secondary { opacity: .7; filter:Alpha(Opacity=70); font-weight: normal; }
.ui-state-disabled, .ui-widget-content .ui-state-disabled, .ui-widget-header .ui-state-disabled { opacity: .35; filter:Alpha(Opacity=35); background-image: none; }

/* Icons
----------------------------------*/

/* states and images */
.ui-icon { width: 16px; height: 16px; background-image: url(images/ui-icons_222222_256x240.png); }
.ui-widget-content .ui-icon {background-image: url(images/ui-icons_222222_256x240.png); }
.ui-widget-header .ui-icon {background-image: url(images/ui-icons_ffffff_256x240.png); }
.ui-state-default .ui-icon { background-image: url(images/ui-icons_ef8c08_256x240.png); }
.ui-state-hover .ui-icon, .ui-state-focus .ui-icon {background-image: url(images/ui-icons_ef8c08_256x240.png); }
.ui-state-active .ui-icon {background-image: url(images/ui-icons_ef8c08_256x240.png); }
.ui-state-highlight .ui-icon {background-image: url(images/ui-icons_228ef1_256x240.png); }
.ui-state-error .ui-icon, .ui-state-error-text .ui-icon {background-image: url(images/ui-icons_ffd27a_256x240.png); }

/* positioning */
.ui-icon-carat-1-n { background-position: 0 0; }
.ui-icon-carat-1-ne { background-position: -16px 0; }
.ui-icon-carat-1-e { background-position: -32px 0; }
.ui-icon-carat-1-se { background-position: -48px 0; }
.ui-icon-carat-1-s { background-position: -64px 0; }
.ui-icon-carat-1-sw { background-position: -80px 0; }
.ui-icon-carat-1-w { background-position: -96px 0; }
.ui-icon-carat-1-nw { background-position: -112px 0; }
.ui-icon-carat-2-n-s { background-position: -128px 0; }
.ui-icon-carat-2-e-w { background-position: -144px 0; }
.ui-icon-triangle-1-n { background-position: 0 -16px; }
.ui-icon-triangle-1-ne { background-position: -16px -16px; }
.ui-icon-triangle-1-e { background-position: -32px -16px; }
.ui-icon-triangle-1-se { background-position: -48px -16px; }
.ui-icon-triangle-1-s { background-position: -64px -16px; }
.ui-icon-triangle-1-sw { background-position: -80px -16px; }
.ui-icon-triangle-1-w { background-position: -96px -16px; }
.ui-icon-triangle-1-nw { background-position: -112px -16px; }
.ui-icon-triangle-2-n-s { background-position: -128px -16px; }
.ui-icon-triangle-2-e-w { background-position: -144px -16px; }
.ui-icon-arrow-1-n { background-position: 0 -32px; }
.ui-icon-arrow-1-ne { background-position: -16px -32px; }
.ui-icon-arrow-1-e { background-position: -32px -32px; }
.ui-icon-arrow-1-se { background-position: -48px -32px; }
.ui-icon-arrow-1-s { background-position: -64px -32px; }
.ui-icon-arrow-1-sw { background-position: -80px -32px; }
.ui-icon-arrow-1-w { background-position: -96px -32px; }
.ui-icon-arrow-1-nw { background-position: -112px -32px; }
.ui-icon-arrow-2-n-s { background-position: -128px -32px; }
.ui-icon-arrow-2-ne-sw { background-position: -144px -32px; }
.ui-icon-arrow-2-e-w { background-position: -160px -32px; }
.ui-icon-arrow-2-se-nw { background-position: -176px -32px; }
.ui-icon-arrowstop-1-n { background-position: -192px -32px; }
.ui-icon-arrowstop-1-e { background-position: -208px -32px; }
.ui-icon-arrowstop-1-s { background-position: -224px -32px; }
.ui-icon-arrowstop-1-w { background-position: -240px -32px; }
.ui-icon-arrowthick-1-n { background-position: 0 -48px; }
.ui-icon-arrowthick-1-ne { background-position: -16px -48px; }
.ui-icon-arrowthick-1-e { background-position: -32px -48px; }
.ui-icon-arrowthick-1-se { background-position: -48px -48px; }
.ui-icon-arrowthick-1-s { background-position: -64px -48px; }
.ui-icon-arrowthick-1-sw { background-position: -80px -48px; }
.ui-icon-arrowthick-1-w { background-position: -96px -48px; }
.ui-icon-arrowthick-1-nw { background-position: -112px -48px; }
.ui-icon-arrowthick-2-n-s { background-position: -128px -48px; }
.ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; }
.ui-icon-arrowthick-2-e-w { background-position: -160px -48px; }
.ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; }
.ui-icon-arrowthickstop-1-n { background-position: -192px -48px; }
.ui-icon-arrowthickstop-1-e { background-position: -208px -48px; }
.ui-icon-arrowthickstop-1-s { background-position: -224px -48px; }
.ui-icon-arrowthickstop-1-w { background-position: -240px -48px; }
.ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; }
.ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; }
.ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; }
.ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; }
.ui-icon-arrowreturn-1-w { background-position: -64px -64px; }
.ui-icon-arrowreturn-1-n { background-position: -80px -64px; }
.ui-icon-arrowreturn-1-e { background-position: -96px -64px; }
.ui-icon-arrowreturn-1-s { background-position: -112px -64px; }
.ui-icon-arrowrefresh-1-w { background-position: -128px -64px; }
.ui-icon-arrowrefresh-1-n { background-position: -144px -64px; }
.ui-icon-arrowrefresh-1-e { background-position: -160px -64px; }
.ui-icon-arrowrefresh-1-s { background-position: -176px -64px; }
.ui-icon-arrow-4 { background-position: 0 -80px; }
.ui-icon-arrow-4-diag { background-position: -16px -80px; }
.ui-icon-extlink { background-position: -32px -80px; }
.ui-icon-newwin { background-position: -48px -80px; }
.ui-icon-refresh { background-position: -64px -80px; }
.ui-icon-shuffle { background-position: -80px -80px; }
.ui-icon-transfer-e-w { background-position: -96px -80px; }
.ui-icon-transferthick-e-w { background-position: -112px -80px; }
.ui-icon-folder-collapsed { background-position: 0 -96px; }
.ui-icon-folder-open { background-position: -16px -96px; }
.ui-icon-document { background-position: -32px -96px; }
.ui-icon-document-b { background-position: -48px -96px; }
.ui-icon-note { background-position: -64px -96px; }
.ui-icon-mail-closed { background-position: -80px -96px; }
.ui-icon-mail-open { background-position: -96px -96px; }
.ui-icon-suitcase { background-position: -112px -96px; }
.ui-icon-comment { background-position: -128px -96px; }
.ui-icon-person { background-position: -144px -96px; }
.ui-icon-print { background-position: -160px -96px; }
.ui-icon-trash { background-position: -176px -96px; }
.ui-icon-locked { background-position: -192px -96px; }
.ui-icon-unlocked { background-position: -208px -96px; }
.ui-icon-bookmark { background-position: -224px -96px; }
.ui-icon-tag { background-position: -240px -96px; }
.ui-icon-home { background-position: 0 -112px; }
.ui-icon-flag { background-position: -16px -112px; }
.ui-icon-calendar { background-position: -32px -112px; }
.ui-icon-cart { background-position: -48px -112px; }
.ui-icon-pencil { background-position: -64px -112px; }
.ui-icon-clock { background-position: -80px -112px; }
.ui-icon-disk { background-position: -96px -112px; }
.ui-icon-calculator { background-position: -112px -112px; }
.ui-icon-zoomin { background-position: -128px -112px; }
.ui-icon-zoomout { background-position: -144px -112px; }
.ui-icon-search { background-position: -160px -112px; }
.ui-icon-wrench { background-position: -176px -112px; }
.ui-icon-gear { background-position: -192px -112px; }
.ui-icon-heart { background-position: -208px -112px; }
.ui-icon-star { background-position: -224px -112px; }
.ui-icon-link { background-position: -240px -112px; }
.ui-icon-cancel { background-position: 0 -128px; }
.ui-icon-plus { background-position: -16px -128px; }
.ui-icon-plusthick { background-position: -32px -128px; }
.ui-icon-minus { background-position: -48px -128px; }
.ui-icon-minusthick { background-position: -64px -128px; }
.ui-icon-close { background-position: -80px -128px; }
.ui-icon-closethick { background-position: -96px -128px; }
.ui-icon-key { background-position: -112px -128px; }
.ui-icon-lightbulb { background-position: -128px -128px; }
.ui-icon-scissors { background-position: -144px -128px; }
.ui-icon-clipboard { background-position: -160px -128px; }
.ui-icon-copy { background-position: -176px -128px; }
.ui-icon-contact { background-position: -192px -128px; }
.ui-icon-image { background-position: -208px -128px; }
.ui-icon-video { background-position: -224px -128px; }
.ui-icon-script { background-position: -240px -128px; }
.ui-icon-alert { background-position: 0 -144px; }
.ui-icon-info { background-position: -16px -144px; }
.ui-icon-notice { background-position: -32px -144px; }
.ui-icon-help { background-position: -48px -144px; }
.ui-icon-check { background-position: -64px -144px; }
.ui-icon-bullet { background-position: -80px -144px; }
.ui-icon-radio-off { background-position: -96px -144px; }
.ui-icon-radio-on { background-position: -112px -144px; }
.ui-icon-pin-w { background-position: -128px -144px; }
.ui-icon-pin-s { background-position: -144px -144px; }
.ui-icon-play { background-position: 0 -160px; }
.ui-icon-pause { background-position: -16px -160px; }
.ui-icon-seek-next { background-position: -32px -160px; }
.ui-icon-seek-prev { background-position: -48px -160px; }
.ui-icon-seek-end { background-position: -64px -160px; }
.ui-icon-seek-start { background-position: -80px -160px; }
/* ui-icon-seek-first is deprecated, use ui-icon-seek-start instead */
.ui-icon-seek-first { background-position: -80px -160px; }
.ui-icon-stop { background-position: -96px -160px; }
.ui-icon-eject { background-position: -112px -160px; }
.ui-icon-volume-off { background-position: -128px -160px; }
.ui-icon-volume-on { background-position: -144px -160px; }
.ui-icon-power { background-position: 0 -176px; }
.ui-icon-signal-diag { background-position: -16px -176px; }
.ui-icon-signal { background-position: -32px -176px; }
.ui-icon-battery-0 { background-position: -48px -176px; }
.ui-icon-battery-1 { background-position: -64px -176px; }
.ui-icon-battery-2 { background-position: -80px -176px; }
.ui-icon-battery-3 { background-position: -96px -176px; }
.ui-icon-circle-plus { background-position: 0 -192px; }
.ui-icon-circle-minus { background-position: -16px -192px; }
.ui-icon-circle-close { background-position: -32px -192px; }
.ui-icon-circle-triangle-e { background-position: -48px -192px; }
.ui-icon-circle-triangle-s { background-position: -64px -192px; }
.ui-icon-circle-triangle-w { background-position: -80px -192px; }
.ui-icon-circle-triangle-n { background-position: -96px -192px; }
.ui-icon-circle-arrow-e { background-position: -112px -192px; }
.ui-icon-circle-arrow-s { background-position: -128px -192px; }
.ui-icon-circle-arrow-w { background-position: -144px -192px; }
.ui-icon-circle-arrow-n { background-position: -160px -192px; }
.ui-icon-circle-zoomin { background-position: -176px -192px; }
.ui-icon-circle-zoomout { background-position: -192px -192px; }
.ui-icon-circle-check { background-position: -208px -192px; }
.ui-icon-circlesmall-plus { background-position: 0 -208px; }
.ui-icon-circlesmall-minus { background-position: -16px -208px; }
.ui-icon-circlesmall-close { background-position: -32px -208px; }
.ui-icon-squaresmall-plus { background-position: -48px -208px; }
.ui-icon-squaresmall-minus { background-position: -64px -208px; }
.ui-icon-squaresmall-close { background-position: -80px -208px; }
.ui-icon-grip-dotted-vertical { background-position: 0 -224px; }
.ui-icon-grip-dotted-horizontal { background-position: -16px -224px; }
.ui-icon-grip-solid-vertical { background-position: -32px -224px; }
.ui-icon-grip-solid-horizontal { background-position: -48px -224px; }
.ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; }
.ui-icon-grip-diagonal-se { background-position: -80px -224px; }


/* Misc visuals
----------------------------------*/

/* Corner radius */
.ui-corner-tl { -moz-border-radius-topleft: 4px; -webkit-border-top-left-radius: 4px; border-top-left-radius: 4px; }
.ui-corner-tr { -moz-border-radius-topright: 4px; -webkit-border-top-right-radius: 4px; border-top-right-radius: 4px; }
.ui-corner-bl { -moz-border-radius-bottomleft: 4px; -webkit-border-bottom-left-radius: 4px; border-bottom-left-radius: 4px; }
.ui-corner-br { -moz-border-radius-bottomright: 4px; -webkit-border-bottom-right-radius: 4px; border-bottom-right-radius: 4px; }
.ui-corner-top { -moz-border-radius-topleft: 4px; -webkit-border-top-left-radius: 4px; border-top-left-radius: 4px; -moz-border-radius-topright: 4px; -webkit-border-top-right-radius: 4px; border-top-right-radius: 4px; }
.ui-corner-bottom { -moz-border-radius-bottomleft: 4px; -webkit-border-bottom-left-radius: 4px; border-bottom-left-radius: 4px; -moz-border-radius-bottomright: 4px; -webkit-border-bottom-right-radius: 4px; border-bottom-right-radius: 4px; }
.ui-corner-right {  -moz-border-radius-topright: 4px; -webkit-border-top-right-radius: 4px; border-top-right-radius: 4px; -moz-border-radius-bottomright: 4px; -webkit-border-bottom-right-radius: 4px; border-bottom-right-radius: 4px; }
.ui-corner-left { -moz-border-radius-topleft: 4px; -webkit-border-top-left-radius: 4px; border-top-left-radius: 4px; -moz-border-radius-bottomleft: 4px; -webkit-border-bottom-left-radius: 4px; border-bottom-left-radius: 4px; }
.ui-corner-all { -moz-border-radius: 4px; -webkit-border-radius: 4px; border-radius: 4px; }

/* Overlays */
.ui-widget-overlay { background: #666666 url(images/ui-bg_diagonals-thick_20_666666_40x40.png) 50% 50% repeat; opacity: .50;filter:Alpha(Opacity=50); }
.ui-widget-shadow { margin: -5px 0 0 -5px; padding: 5px; background: #000000 url(images/ui-bg_flat_10_000000_40x100.png) 50% 50% repeat-x; opacity: .20;filter:Alpha(Opacity=20); -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px; }/*
 * jQuery UI Tabs @VERSION
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs#theming
 */
.ui-tabs { position: relative; padding: .2em; zoom: 1; } /* position: relative prevents IE scroll bug (element with position: relative inside container with overflow: auto appear as "fixed") */
.ui-tabs .ui-tabs-nav { margin: 0; padding: .2em .2em 0; }
.ui-tabs .ui-tabs-nav li { list-style: none; float: left; position: relative; top: 1px; margin: 0 .2em 1px 0; border-bottom: 0 !important; padding: 0; white-space: nowrap; }
.ui-tabs .ui-tabs-nav li a { float: left; padding: .5em 1em; text-decoration: none; }
.ui-tabs .ui-tabs-nav li.ui-tabs-selected { margin-bottom: 0; padding-bottom: 1px; }
.ui-tabs .ui-tabs-nav li.ui-tabs-selected a, .ui-tabs .ui-tabs-nav li.ui-state-disabled a, .ui-tabs .ui-tabs-nav li.ui-state-processing a { cursor: text; }
.ui-tabs .ui-tabs-nav li a, .ui-tabs.ui-tabs-collapsible .ui-tabs-nav li.ui-tabs-selected a { cursor: pointer; } /* first selector in group seems obsolete, but required to overcome bug in Opera applying cursor: text overall if defined elsewhere... */
.ui-tabs .ui-tabs-panel { display: block; border-width: 0; padding: 1em 1.4em; background: none; }
.ui-tabs .ui-tabs-hide { display: none !important; }
body {overflow-y: scroll;}

================
File: mjpg-streamer/mjpg-streamer-experimental/www/jquery.ui.tabs.min.js
================
/*
 * jQuery UI Tabs 1.8.4
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(d,p){function u(){return++v}function w(){return++x}var v=0,x=0;d.widget("ui.tabs",{options:{add:null,ajaxOptions:null,cache:false,cookie:null,collapsible:false,disable:null,disabled:[],enable:null,event:"click",fx:null,idPrefix:"ui-tabs-",load:null,panelTemplate:"<div></div>",remove:null,select:null,show:null,spinner:"<em>Loading&#8230;</em>",tabTemplate:"<li><a href='#{href}'><span>#{label}</span></a></li>"},_create:function(){this._tabify(true)},_setOption:function(a,e){if(a=="selected")this.options.collapsible&&
e==this.options.selected||this.select(e);else{this.options[a]=e;this._tabify()}},_tabId:function(a){return a.title&&a.title.replace(/\s/g,"_").replace(/[^A-Za-z0-9\-_:\.]/g,"")||this.options.idPrefix+u()},_sanitizeSelector:function(a){return a.replace(/:/g,"\\:")},_cookie:function(){var a=this.cookie||(this.cookie=this.options.cookie.name||"ui-tabs-"+w());return d.cookie.apply(null,[a].concat(d.makeArray(arguments)))},_ui:function(a,e){return{tab:a,panel:e,index:this.anchors.index(a)}},_cleanup:function(){this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function(){var a=
d(this);a.html(a.data("label.tabs")).removeData("label.tabs")})},_tabify:function(a){function e(g,f){g.css("display","");!d.support.opacity&&f.opacity&&g[0].style.removeAttribute("filter")}var b=this,c=this.options,h=/^#.+/;this.list=this.element.find("ol,ul").eq(0);this.lis=d("li:has(a[href])",this.list);this.anchors=this.lis.map(function(){return d("a",this)[0]});this.panels=d([]);this.anchors.each(function(g,f){var j=d(f).attr("href"),l=j.split("#")[0],q;if(l&&(l===location.toString().split("#")[0]||
(q=d("base")[0])&&l===q.href)){j=f.hash;f.href=j}if(h.test(j))b.panels=b.panels.add(b._sanitizeSelector(j));else if(j!=="#"){d.data(f,"href.tabs",j);d.data(f,"load.tabs",j.replace(/#.*$/,""));j=b._tabId(f);f.href="#"+j;f=d("#"+j);if(!f.length){f=d(c.panelTemplate).attr("id",j).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(b.panels[g-1]||b.list);f.data("destroy.tabs",true)}b.panels=b.panels.add(f)}else c.disabled.push(g)});if(a){this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all");
this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.lis.addClass("ui-state-default ui-corner-top");this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom");if(c.selected===p){location.hash&&this.anchors.each(function(g,f){if(f.hash==location.hash){c.selected=g;return false}});if(typeof c.selected!=="number"&&c.cookie)c.selected=parseInt(b._cookie(),10);if(typeof c.selected!=="number"&&this.lis.filter(".ui-tabs-selected").length)c.selected=
this.lis.index(this.lis.filter(".ui-tabs-selected"));c.selected=c.selected||(this.lis.length?0:-1)}else if(c.selected===null)c.selected=-1;c.selected=c.selected>=0&&this.anchors[c.selected]||c.selected<0?c.selected:0;c.disabled=d.unique(c.disabled.concat(d.map(this.lis.filter(".ui-state-disabled"),function(g){return b.lis.index(g)}))).sort();d.inArray(c.selected,c.disabled)!=-1&&c.disabled.splice(d.inArray(c.selected,c.disabled),1);this.panels.addClass("ui-tabs-hide");this.lis.removeClass("ui-tabs-selected ui-state-active");
if(c.selected>=0&&this.anchors.length){this.panels.eq(c.selected).removeClass("ui-tabs-hide");this.lis.eq(c.selected).addClass("ui-tabs-selected ui-state-active");b.element.queue("tabs",function(){b._trigger("show",null,b._ui(b.anchors[c.selected],b.panels[c.selected]))});this.load(c.selected)}d(window).bind("unload",function(){b.lis.add(b.anchors).unbind(".tabs");b.lis=b.anchors=b.panels=null})}else c.selected=this.lis.index(this.lis.filter(".ui-tabs-selected"));this.element[c.collapsible?"addClass":
"removeClass"]("ui-tabs-collapsible");c.cookie&&this._cookie(c.selected,c.cookie);a=0;for(var i;i=this.lis[a];a++)d(i)[d.inArray(a,c.disabled)!=-1&&!d(i).hasClass("ui-tabs-selected")?"addClass":"removeClass"]("ui-state-disabled");c.cache===false&&this.anchors.removeData("cache.tabs");this.lis.add(this.anchors).unbind(".tabs");if(c.event!=="mouseover"){var k=function(g,f){f.is(":not(.ui-state-disabled)")&&f.addClass("ui-state-"+g)},n=function(g,f){f.removeClass("ui-state-"+g)};this.lis.bind("mouseover.tabs",
function(){k("hover",d(this))});this.lis.bind("mouseout.tabs",function(){n("hover",d(this))});this.anchors.bind("focus.tabs",function(){k("focus",d(this).closest("li"))});this.anchors.bind("blur.tabs",function(){n("focus",d(this).closest("li"))})}var m,o;if(c.fx)if(d.isArray(c.fx)){m=c.fx[0];o=c.fx[1]}else m=o=c.fx;var r=o?function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.hide().removeClass("ui-tabs-hide").animate(o,o.duration||"normal",function(){e(f,o);b._trigger("show",
null,b._ui(g,f[0]))})}:function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.removeClass("ui-tabs-hide");b._trigger("show",null,b._ui(g,f[0]))},s=m?function(g,f){f.animate(m,m.duration||"normal",function(){b.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");e(f,m);b.element.dequeue("tabs")})}:function(g,f){b.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");b.element.dequeue("tabs")};this.anchors.bind(c.event+".tabs",
function(){var g=this,f=d(g).closest("li"),j=b.panels.filter(":not(.ui-tabs-hide)"),l=d(b._sanitizeSelector(g.hash));if(f.hasClass("ui-tabs-selected")&&!c.collapsible||f.hasClass("ui-state-disabled")||f.hasClass("ui-state-processing")||b._trigger("select",null,b._ui(this,l[0]))===false){this.blur();return false}c.selected=b.anchors.index(this);b.abort();if(c.collapsible)if(f.hasClass("ui-tabs-selected")){c.selected=-1;c.cookie&&b._cookie(c.selected,c.cookie);b.element.queue("tabs",function(){s(g,
j)}).dequeue("tabs");this.blur();return false}else if(!j.length){c.cookie&&b._cookie(c.selected,c.cookie);b.element.queue("tabs",function(){r(g,l)});b.load(b.anchors.index(this));this.blur();return false}c.cookie&&b._cookie(c.selected,c.cookie);if(l.length){j.length&&b.element.queue("tabs",function(){s(g,j)});b.element.queue("tabs",function(){r(g,l)});b.load(b.anchors.index(this))}else throw"jQuery UI Tabs: Mismatching fragment identifier.";d.browser.msie&&this.blur()});this.anchors.bind("click.tabs",
function(){return false})},_getIndex:function(a){if(typeof a=="string")a=this.anchors.index(this.anchors.filter("[href$="+a+"]"));return a},destroy:function(){var a=this.options;this.abort();this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs");this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.anchors.each(function(){var e=d.data(this,"href.tabs");if(e)this.href=
e;var b=d(this).unbind(".tabs");d.each(["href","load","cache"],function(c,h){b.removeData(h+".tabs")})});this.lis.unbind(".tabs").add(this.panels).each(function(){d.data(this,"destroy.tabs")?d(this).remove():d(this).removeClass("ui-state-default ui-corner-top ui-tabs-selected ui-state-active ui-state-hover ui-state-focus ui-state-disabled ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide")});a.cookie&&this._cookie(null,a.cookie);return this},add:function(a,e,b){if(b===p)b=this.anchors.length;
var c=this,h=this.options;e=d(h.tabTemplate.replace(/#\{href\}/g,a).replace(/#\{label\}/g,e));a=!a.indexOf("#")?a.replace("#",""):this._tabId(d("a",e)[0]);e.addClass("ui-state-default ui-corner-top").data("destroy.tabs",true);var i=d("#"+a);i.length||(i=d(h.panelTemplate).attr("id",a).data("destroy.tabs",true));i.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide");if(b>=this.lis.length){e.appendTo(this.list);i.appendTo(this.list[0].parentNode)}else{e.insertBefore(this.lis[b]);
i.insertBefore(this.panels[b])}h.disabled=d.map(h.disabled,function(k){return k>=b?++k:k});this._tabify();if(this.anchors.length==1){h.selected=0;e.addClass("ui-tabs-selected ui-state-active");i.removeClass("ui-tabs-hide");this.element.queue("tabs",function(){c._trigger("show",null,c._ui(c.anchors[0],c.panels[0]))});this.load(0)}this._trigger("add",null,this._ui(this.anchors[b],this.panels[b]));return this},remove:function(a){a=this._getIndex(a);var e=this.options,b=this.lis.eq(a).remove(),c=this.panels.eq(a).remove();
if(b.hasClass("ui-tabs-selected")&&this.anchors.length>1)this.select(a+(a+1<this.anchors.length?1:-1));e.disabled=d.map(d.grep(e.disabled,function(h){return h!=a}),function(h){return h>=a?--h:h});this._tabify();this._trigger("remove",null,this._ui(b.find("a")[0],c[0]));return this},enable:function(a){a=this._getIndex(a);var e=this.options;if(d.inArray(a,e.disabled)!=-1){this.lis.eq(a).removeClass("ui-state-disabled");e.disabled=d.grep(e.disabled,function(b){return b!=a});this._trigger("enable",null,
this._ui(this.anchors[a],this.panels[a]));return this}},disable:function(a){a=this._getIndex(a);var e=this.options;if(a!=e.selected){this.lis.eq(a).addClass("ui-state-disabled");e.disabled.push(a);e.disabled.sort();this._trigger("disable",null,this._ui(this.anchors[a],this.panels[a]))}return this},select:function(a){a=this._getIndex(a);if(a==-1)if(this.options.collapsible&&this.options.selected!=-1)a=this.options.selected;else return this;this.anchors.eq(a).trigger(this.options.event+".tabs");return this},
load:function(a){a=this._getIndex(a);var e=this,b=this.options,c=this.anchors.eq(a)[0],h=d.data(c,"load.tabs");this.abort();if(!h||this.element.queue("tabs").length!==0&&d.data(c,"cache.tabs"))this.element.dequeue("tabs");else{this.lis.eq(a).addClass("ui-state-processing");if(b.spinner){var i=d("span",c);i.data("label.tabs",i.html()).html(b.spinner)}this.xhr=d.ajax(d.extend({},b.ajaxOptions,{url:h,success:function(k,n){d(e._sanitizeSelector(c.hash)).html(k);e._cleanup();b.cache&&d.data(c,"cache.tabs",
true);e._trigger("load",null,e._ui(e.anchors[a],e.panels[a]));try{b.ajaxOptions.success(k,n)}catch(m){}},error:function(k,n){e._cleanup();e._trigger("load",null,e._ui(e.anchors[a],e.panels[a]));try{b.ajaxOptions.error(k,n,a,c)}catch(m){}}}));e.element.dequeue("tabs");return this}},abort:function(){this.element.queue([]);this.panels.stop(false,true);this.element.queue("tabs",this.element.queue("tabs").splice(-2,2));if(this.xhr){this.xhr.abort();delete this.xhr}this._cleanup();return this},url:function(a,
e){this.anchors.eq(a).removeData("cache.tabs").data("load.tabs",e);return this},length:function(){return this.anchors.length}});d.extend(d.ui.tabs,{version:"1.8.4"});d.extend(d.ui.tabs.prototype,{rotation:null,rotate:function(a,e){var b=this,c=this.options,h=b._rotate||(b._rotate=function(i){clearTimeout(b.rotation);b.rotation=setTimeout(function(){var k=c.selected;b.select(++k<b.anchors.length?k:0)},a);i&&i.stopPropagation()});e=b._unrotate||(b._unrotate=!e?function(i){i.clientX&&b.rotate(null)}:
function(){t=c.selected;h()});if(a){this.element.bind("tabsshow",h);this.anchors.bind(c.event+".tabs",e);h()}else{clearTimeout(b.rotation);this.element.unbind("tabsshow",h);this.anchors.unbind(c.event+".tabs",e);delete this._rotate;delete this._unrotate}return this}})})(jQuery);

================
File: mjpg-streamer/mjpg-streamer-experimental/www/jquery.ui.widget.min.js
================
/*!
 * jQuery UI Widget 1.8.4
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function(b,j){var k=b.fn.remove;b.fn.remove=function(a,c){return this.each(function(){if(!c)if(!a||b.filter(a,[this]).length)b("*",this).add([this]).each(function(){b(this).triggerHandler("remove")});return k.call(b(this),a,c)})};b.widget=function(a,c,d){var e=a.split(".")[0],f;a=a.split(".")[1];f=e+"-"+a;if(!d){d=c;c=b.Widget}b.expr[":"][f]=function(h){return!!b.data(h,a)};b[e]=b[e]||{};b[e][a]=function(h,g){arguments.length&&this._createWidget(h,g)};c=new c;c.options=b.extend(true,{},c.options);
b[e][a].prototype=b.extend(true,c,{namespace:e,widgetName:a,widgetEventPrefix:b[e][a].prototype.widgetEventPrefix||a,widgetBaseClass:f},d);b.widget.bridge(a,b[e][a])};b.widget.bridge=function(a,c){b.fn[a]=function(d){var e=typeof d==="string",f=Array.prototype.slice.call(arguments,1),h=this;d=!e&&f.length?b.extend.apply(null,[true,d].concat(f)):d;if(e&&d.substring(0,1)==="_")return h;e?this.each(function(){var g=b.data(this,a),i=g&&b.isFunction(g[d])?g[d].apply(g,f):g;if(i!==g&&i!==j){h=i;return false}}):
this.each(function(){var g=b.data(this,a);if(g){d&&g.option(d);g._init()}else b.data(this,a,new c(d,this))});return h}};b.Widget=function(a,c){arguments.length&&this._createWidget(a,c)};b.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:false},_createWidget:function(a,c){b.data(c,this.widgetName,this);this.element=b(c);this.options=b.extend(true,{},this.options,b.metadata&&b.metadata.get(c)[this.widgetName],a);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()});
this._create();this._init()},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName);this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled ui-state-disabled")},widget:function(){return this.element},option:function(a,c){var d=a,e=this;if(arguments.length===0)return b.extend({},e.options);if(typeof a==="string"){if(c===j)return this.options[a];d={};d[a]=c}b.each(d,function(f,
h){e._setOption(f,h)});return e},_setOption:function(a,c){this.options[a]=c;if(a==="disabled")this.widget()[c?"addClass":"removeClass"](this.widgetBaseClass+"-disabled ui-state-disabled").attr("aria-disabled",c);return this},enable:function(){return this._setOption("disabled",false)},disable:function(){return this._setOption("disabled",true)},_trigger:function(a,c,d){var e=this.options[a];c=b.Event(c);c.type=(a===this.widgetEventPrefix?a:this.widgetEventPrefix+a).toLowerCase();d=d||{};if(c.originalEvent){a=
b.event.props.length;for(var f;a;){f=b.event.props[--a];c[f]=c.originalEvent[f]}}this.element.trigger(c,d);return!(b.isFunction(e)&&e.call(this.element[0],c,d)===false||c.isDefaultPrevented())}}})(jQuery);

================
File: mjpg-streamer/mjpg-streamer-experimental/www/JQuerySpinBtn.css
================
/*
	Styles to make ordinary <INPUT type="text"/> look like a spinbutton/spinbox control.
	Use with JQuerySpinBtn.js to provide the spin functionality by reacting to mouse etc.
	(Requires a reference to the JQuery library found at http://jquery.com/src/latest/)
	(Hats-off to John Resig for creating the excellent JQuery library. It is fab.)

	This control is achieved with no extra html markup whatsoever and uses unobtrusive javascript.

	Written by George Adamson, Software Unity (george.jquery@softwareunity.com) September 2006.
	Big improvements added by Mark Gibson, (mgibson@designlinks.net) September 2006.

	Do contact me with comments and suggestions but please don't ask for support.
	As much as I'd love to help with specific problems I have plenty to get on with already!

	Go ahead and use it in your own projects. This code is provided 'as is'.
	Sure I've tested in heaps of ways. Its good for me, but you use it at your own risk.
	SoftwareUnity and I are certainly not responsible if your computer sets fire to the sofa,
	hacks into the pentagon, hijacks a plane or gives you any kind of hassle whatsoever.

	If you'd like your spin-button image in a different place then you'll need to alter both
	the CSS below and the javascript isMouseOverUpDn() function to accommodate the new position.
	You could even have left and right buttons either side of the textbox.
*/

INPUT.spin-button {
	padding-right:20px;					/* Padding pevents text from covering the up/dn img. Works better in Firefox but also causes textbox to widen by 20px. Arrows can go wonky in IE when text is too long. Perhaps it could be fixed with script that monitored the horiz-scroll position? */
	background-repeat:no-repeat;		/* Warning: Img may disappear in Firefox if you use 'background-attachment:fixed' ! */
	background-position:100% 0%;
	background-image:url(spinbtn_updn.gif);
}

INPUT.spin-button.up {					/* Change button img when mouse is over the UP-arrow */
	cursor:pointer;
	background-position:100% -20px;		/* 18px matches height of 2 visible buttons */
}
INPUT.spin-button.down {				/* Change button img when mouse is over the DOWN-arrow */
	cursor:pointer;
	background-position:100% -40px;		/* 36px matches height of 2x2 visible buttons */
}

================
File: mjpg-streamer/mjpg-streamer-experimental/www/JQuerySpinBtn.js
================
/* 
 * Spinbutton plugin for jQuery
 * http://www.softwareunity.com/jquery/JQuerySpinBtn/
 *
 * Adds bells and whistles to any ordinary textbox to
 * make it look and feel like a SpinButton Control.
 *
 * Copyright (c) 2006-2009 Software Unity Ltd
 * Dual licensed under the MIT and GPL licenses.
 * http://www.softwareunity.com/jquery/MIT-LICENSE.txt
 * http://www.softwareunity.com/jquery/GPL-LICENSE.txt
 *
 * Originally written by George Adamson, Software Unity (george.jquery@softwareunity.com) August 2006.
 * - Added min/max options
 * - Added step size option
 * - Added bigStep (page up/down) option
 *
 * Modifications made by Mark Gibson, (mgibson@designlinks.net) September 2006:
 * - Converted to jQuery plugin
 * - Allow limited or unlimited min/max values
 * - Allow custom class names, and add class to input element
 * - Removed global vars
 * - Reset (to original or through config) when invalid value entered
 * - Repeat whilst holding mouse button down (with initial pause, like keyboard repeat)
 * - Support mouse wheel in Firefox
 * - Fix double click in IE
 * - Refactored some code and renamed some vars
 *
 * Tested in IE6, Opera9, Firefox 1.5
 * v1.0  11 Aug 2006 - George Adamson	- First release
 * v1.1     Aug 2006 - George Adamson	- Minor enhancements
 * v1.2  27 Sep 2006 - Mark Gibson		- Major enhancements
 * v1.3a 28 Sep 2006 - George Adamson	- Minor enhancements
 
 Sample usage:
 
	// Create group of settings to initialise spinbutton(s). (Optional)
	var myOptions = {
					min: 0,						// Set lower limit.
					max: 100,					// Set upper limit.
					step: 1,					// Set increment size.
					spinClass: mySpinBtnClass,	// CSS class to style the spinbutton. (Class also specifies url of the up/down button image.)
					upClass: mySpinUpClass,		// CSS class for style when mouse over up button.
					downClass: mySpinDnClass	// CSS class for style when mouse over down button.
					}
 
	$(document).ready(function(){

		// Initialise INPUT element(s) as SpinButtons: (passing options if desired)
		$("#myInputElement").SpinButton(myOptions);

	});
 
 */
$.fn.SpinButton = function(cfg){
	return this.each(function(){

		// Apply specified options or defaults:
		// (Ought to refactor this some day to use $.extend() instead)
		this.spinCfg = {
			//min: cfg && cfg.min ? Number(cfg.min) : null,
			//max: cfg && cfg.max ? Number(cfg.max) : null,
			min: cfg && !isNaN(parseFloat(cfg.min)) ? Number(cfg.min) : null,	// Fixes bug with min:0
			max: cfg && !isNaN(parseFloat(cfg.max)) ? Number(cfg.max) : null,
			step: cfg && cfg.step ? Number(cfg.step) : 1,
			page: cfg && cfg.page ? Number(cfg.page) : 10,
			upClass: cfg && cfg.upClass ? cfg.upClass : 'up',
			downClass: cfg && cfg.downClass ? cfg.downClass : 'down',
			reset: cfg && cfg.reset ? cfg.reset : this.value,
			delay: cfg && cfg.delay ? Number(cfg.delay) : 500,
			interval: cfg && cfg.interval ? Number(cfg.interval) : 100,
			_btn_width: 20,
			_btn_height: 12,
			_direction: null,
			_delay: null,
			_repeat: null,
		};


		this.adjustValue = function(i){
			var v = (isNaN(this.value) ? this.spinCfg.reset : Number(this.value)) + Number(i);
			if (this.spinCfg.min !== null) v = Math.max(v, this.spinCfg.min);
			if (this.spinCfg.max !== null) v = Math.min(v, this.spinCfg.max);
			this.value = v;
			$(this).trigger("valueChanged");
		};
		
		$(this)
		.addClass(cfg && cfg.spinClass ? cfg.spinClass : 'spin-button')
		
		.mousemove(function(e){
			// Determine which button mouse is over, or not (spin direction):
			var x = e.pageX || e.x;
			var y = e.pageY || e.y;
			var el = e.target || e.srcElement;
			var direction = 
				(x > coord(el,'offsetLeft') + el.offsetWidth - this.spinCfg._btn_width)
				? ((y < coord(el,'offsetTop') + this.spinCfg._btn_height) ? 1 : -1) : 0;
			
			if (direction !== this.spinCfg._direction) {
				// Style up/down buttons:
				switch(direction){
					case 1: // Up arrow:
						$(this).removeClass(this.spinCfg.downClass).addClass(this.spinCfg.upClass);
						break;
					case -1: // Down arrow:
						$(this).removeClass(this.spinCfg.upClass).addClass(this.spinCfg.downClass);
						break;
					default: // Mouse is elsewhere in the textbox
						$(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
				}
				
				// Set spin direction:
				this.spinCfg._direction = direction;
			}
		})
		
		.mouseout(function(){
			// Reset up/down buttons to their normal appearance when mouse moves away:
			$(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
			this.spinCfg._direction = null;
		})
		
		.mousedown(function(e){
			if (this.spinCfg._direction != 0) {
				// Respond to click on one of the buttons:
				var self = this;
				var adjust = function() {
					self.adjustValue(self.spinCfg._direction * self.spinCfg.step);
				};
			
				adjust();
				
				// Initial delay before repeating adjustment
				self.spinCfg._delay = window.setTimeout(function() {
					adjust();
					// Repeat adjust at regular intervals
					self.spinCfg._repeat = window.setInterval(adjust, self.spinCfg.interval);
				}, self.spinCfg.delay);
			}
		})
		
		.mouseup(function(e){
			// Cancel repeating adjustment
			window.clearInterval(this.spinCfg._repeat);
			window.clearTimeout(this.spinCfg._delay);
		})
		
		.dblclick(function(e) {
			if ($.browser.msie)
				this.adjustValue(this.spinCfg._direction * this.spinCfg.step);
		})
		
		.keydown(function(e){
			// Respond to up/down arrow keys.
			switch(e.keyCode){
				case 38: this.adjustValue(this.spinCfg.step);  break; // Up
				case 40: this.adjustValue(-this.spinCfg.step); break; // Down
				case 33: this.adjustValue(this.spinCfg.page);  break; // PageUp
				case 34: this.adjustValue(-this.spinCfg.page); break; // PageDown
			}
		})

		.bind("mousewheel", function(e){
			// Respond to mouse wheel in IE. (It returns up/dn motion in multiples of 120)
			if (e.wheelDelta >= 120)
				this.adjustValue(this.spinCfg.step);
			else if (e.wheelDelta <= -120)
				this.adjustValue(-this.spinCfg.step);
			
			e.preventDefault();
		})
		
		.change(function(e){
			this.adjustValue(0);
		});
		
		if (this.addEventListener) {
			// Respond to mouse wheel in Firefox
			this.addEventListener('DOMMouseScroll', function(e) {
				if (e.detail > 0)
					this.adjustValue(-this.spinCfg.step);
				else if (e.detail < 0)
					this.adjustValue(this.spinCfg.step);
				
				e.preventDefault();
			}, false);
		}
	});
	
	function coord(el,prop) {
		var c = el[prop], b = document.body;
		
		while ((el = el.offsetParent) && (el != b)) {
			if (!$.browser.msie || (el.currentStyle.position != 'relative'))
				c += el[prop];
		}
		
		return c;
	}
};

================
File: mjpg-streamer/mjpg-streamer-experimental/www/LICENSE.txt
================
GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.

================
File: mjpg-streamer/mjpg-streamer-experimental/www/static_simple.html
================
<html>
  <head>
    <title>MJPG-Streamer - Static Example</title>
  </head>
  <body>
    <center>
      <img src="./?action=snapshot" alt="This is a static snapshot" />
    </center>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/static.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>MJPG-streamer</title>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <!--[if IE 6]>
    <link rel="stylesheet" href="fix.css" type="text/css" />
    <![endif]-->
  </head>

  <body>
    <div id="sidebar">
      <h1>MJPG-Streamer Demo Pages</h1>
      <h2>a resource-friendly streaming application</h2>

      <div id="menu">
        <a href="index.html">Home</a>
        <a class="active" href="static.html">Static</a> 
        <a href="stream.html">Stream</a> 
        <a href="java.html">Java</a> 
        <a href="javascript.html">Javascript</a>
        <a href="videolan.html">VideoLAN</a>
        <a target="_blank" onClick="window.open(this.href, '_blank','width=400,height=400'); return false;" href="control.htm">Control</a>
      </div>

      <h3>Version info:</h3>
      <p>v0.1 (Okt 22, 2007)</p>
    </div>

    <div id="content">
      <h1>Static</h1>
      <h2>A static snapshot</h2>

      <h3>Hints</h3>
      <p>This example shows a static snapshot. It should work with any browser. To see a simple example click <a href="static_simple.html">here</a>.</p>

      <h3>Source snippet</h3>
      <p><pre>&lt;img src="./?action=snapshot" /&gt;</pre></p>

      <img src="./?action=snapshot" alt="This is a static snapshot" width="512px" height="384px" />

      <p>&copy; The <a href="http://mjpg-streamer.sf.net">MJPG-streamer team</a> | Design by <a href="http://andreasviklund.com">Andreas Viklund</a></p>
    </div>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/stream_simple.html
================
<html>
  <head>
    <title>MJPG-Streamer - Stream Example</title>
  </head>
  <body>
    <center>
      <img src="./?action=stream" />
    </center>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/stream.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>MJPG-streamer</title>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>    
    <script type="text/javascript" src="jquery.rotate.js"></script>
    <!--[if IE 6]>
    <link rel="stylesheet" href="fix.css" type="text/css" />
    <![endif]-->
    <script type="text/javascript">
    
    var phi = 0, flipped = 0, mirrored = 0;

	function setXformClass () {
		$('.xform').each(function(idx,el) {
			el.className = "xform x" +(flipped ? "-flipped":"") + (mirrored ? "-mirrored" : "") + "-rotated-" + phi;
		});
	}
    $(document).ready(function() {
		// set rotation angle phi and toggle rotate class
		$('#rotate').click(function() {
			phi = (phi + 90) % 360;
			setXformClass();
			if (phi % 180) {
				$('.xform-p').addClass('rotated');
			} else {
				$('.xform-p').removeClass('rotated');
			}
		});
		// toggle mirror class component
		$('#mirror').click(function() {
			mirrored = ! mirrored;
			setXformClass();
		});
		// toggle flip class component
		$('#flip').click(function() {
			flipped = ! flipped;
			setXformClass();
		});
	});
	</script>
  </head>

  <body>
    <div id="sidebar">
      <h1>MJPG-Streamer Demo Pages</h1>
      <h2>a resource-friendly streaming application</h2>

      <div id="menu">
        <a href="index.html">Home</a>
        <a href="static.html">Static</a> 
        <a class="active" href="stream.html">Stream</a> 
        <a href="java.html">Java</a> 
        <a href="javascript.html">Javascript</a>
        <a href="videolan.html">VideoLAN</a>
        <a target="_blank" onClick="window.open(this.href, '_blank','width=400,height=400'); return false;" href="control.htm">Control</a>
      </div>

      <h3>Version info:</h3>
      <p>v0.1 (Okt 22, 2007)</p>
    </div>

    <div id="content">
      <h1>Stream</h1>
      <h2>Display the stream</h2>

      <h3>Hints</h3>
      <p>This example shows a stream. It works with a few browsers like Firefox for example. To see a simple example click <a href="stream_simple.html">here</a>. You may have to reload this page by pressing F5 one or more times.</p>

      <h3>Source snippet</h3>
      <p><pre>&lt;img src="./?action=stream" /&gt;</pre></p>

	<p id="xform">
		<button id="rotate"><div class="btnface"></div></button>
		<button id="mirror"><div class="btnface"></div></button>
		<button id="flip"><div class="btnface"></div></button>
	</p>
	<p class="xform-p"></p>
	<p id="streamwrap" class="xform-p">
		<img id="streamimage" class="xform" src="./?action=stream" />
	</p>

	<p>&copy; The <a href="http://mjpg-streamer.sf.net">MJPG-streamer team</a> | Design by <a href="http://andreasviklund.com">Andreas Viklund</a></p>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/www/style.css
================
/* andreas07 - an open source xhtml/css website layout by Andreas Viklund - http://andreasviklund.com . Free to use for any purpose as long as the proper credits are given for the original design work.

Version: 1.1, November 28, 2005 */

/**************** Page and tag styles ****************/

body
{margin:0; padding:0; color:#303030; background:#fafafa url(bodybg.gif) top left repeat-y; font:76% Verdana,Tahoma,sans-serif;}

ul
{list-style:circle; margin:15px 0 20px 0; font-size:0.9em;}

li
{margin:0 0 8px 25px;}

a
{color:#d85d5d; font-weight:bold; text-decoration:none;}

a:hover
{color:#505050; text-decoration:underline;}

img
{float:left; margin:0 15px 15px 0; padding:1px; border:1px solid #d0d0d0;}

a img
{border-color:#d85d5d;}

a img:hover
{background:#d85d5d; border-color:#d85d5d;}

/**************** Sidebar area styles ****************/

#sidebar
{position:absolute; top:0; left:0; width:220px; height:100%; overflow:auto; background:#e0e0e0 url(sidebarbg.gif) top right repeat-y; text-align:right;}

body > #sidebar
{position:fixed;}

#sidebar h1
{margin:20px 18px 0 5px; color:#d85d5d; font-size:1.6em; letter-spacing:-2px; text-align:right;}

#sidebar h2, #sidebar h3
{margin:0 20px 18px 5px; color:#808080; font-size:1.1em; font-weight:bold; letter-spacing:-1px; text-align:right;}

#sidebar h3
{margin:20px 18px 4px 5px; color:#606060;}

#sidebar  p
{margin:0 20px 18px 5px; color:#606060; font-size:0.8em;}

#sidebar a
{color:#808080}

/**************** Navigation menu styles ****************/

#menu a
{display:block; width:202px; padding:5px 18px 5px 0; color:#606060; background:#e0e0e0 url(sidebarbg.gif) top right repeat-y; font-size:1.8em; font-weight:normal; text-decoration:none; letter-spacing:-2px;}

#menu a:hover 
{color:#303030; background:#f0f0f0 url(sidebarbg.gif) top right repeat-y;}

#menu a.active
{padding:5px 18px 5px 0; background:#fafafa; border-top:2px solid #c0c0c0; border-bottom:2px solid #c0c0c0;}

#menu a.active:hover
{color:#505050; background:#fafafa;}

/**************** Content area styles ****************/

#content
{width:520px; margin:0 0 0 240px; padding:20px 0; background:#fafafa;}

#content p
{margin:0 0 20px 0; line-height:1.5em;}

#content h1
{margin:0; color:#d85d5d; font-size:4em; letter-spacing:-5px; text-align:center;}

#content h2
{margin:0; color:#808080; font-weight:normal; font-size:2.5em; letter-spacing:-2px; text-align:center;}

#content h3
{clear:both; margin:30px 0 10px 0; color:#d85d5d; font-weight:normal; font-size: 2em; letter-spacing:-2px;}

#streamimage {
width:520px; height: 390px;
}

#xform {
	text-align:right;
	margin:0 !important;
}
#streamwrap {
	height:350px
}
#streamwrap.rotated {
	height:450px
}
p.xform-p {
	height:5px;
	margin-bottom:0 !important;
}
p.xform-p.rotated {
	height:50px;
	margin-bottom:20px !important;
}

/*
	CSS3 transformations: rotate, flip, mirror
*/

img.x-rotated-0 {}
img.x-rotated-90 {
	-moz-transform: rotate(90deg);
	-webkit-transform: rotate(90deg);
}
img.x-rotated-180 {
	-moz-transform: rotate(180deg);
	-webkit-transform: rotate(180deg);
}
img.x-rotated-270 {
	-moz-transform: rotate(270deg);
	-webkit-transform: rotate(270deg);
}
img.x-mirrored-rotated-0 {
	-moz-transform: scaleX(-1);
	-webkit-transform: scaleX(-1);
}
img.x-mirrored-rotated-90 {
	-moz-transform: rotate(90deg) scaleX(-1);
	-webkit-transform: rotate(90deg) scaleX(-1);
}
img.x-mirrored-rotated-180 {
	-moz-transform: rotate(180deg) scaleX(-1);
	-webkit-transform: rotate(180deg) scaleX(-1);
}
img.x-mirrored-rotated-270 {
	-moz-transform: rotate(270deg) scaleX(-1);
	-webkit-transform: rotate(270deg) scaleX(-1);
}
img.x-flipped-rotated-0 {
	-moz-transform: scaleY(-1);
	-webkit-transform: scaleY(-1);
}
img.x-flipped-rotated-90 {
	-moz-transform: rotate(90deg) scaleY(-1);
	-webkit-transform: rotate(90deg) scaleY(-1);
}
img.x-flipped-rotated-180 {
	-moz-transform: rotate(180deg) scaleY(-1);
	-webkit-transform: rotate(180deg) scaleY(-1);
}
img.x-flipped-rotated-270 {
	-moz-transform: rotate(270deg) scaleY(-1);
	-webkit-transform: rotate(270deg) scaleY(-1);
}
img.x-flipped-mirrored-rotated-0 {
	-moz-transform: scale(-1,-1);
	-webkit-transform: scale(-1,-1);
}
img.x-flipped-mirrored-rotated-90 {
	-moz-transform: rotate(90deg) scale(-1,-1);
	-webkit-transform: rotate(90deg) scale(-1,-1);
}
img.x-flipped-mirrored-rotated-180 {
	-moz-transform: rotate(180deg) scale(-1,-1);
	-webkit-transform: rotate(180deg) scale(-1,-1);
}
img.x-flipped-mirrored-rotated-270 {
	-moz-transform: rotate(270deg) scale(-1,-1);
	-webkit-transform: rotate(270deg) scale(-1,-1);
}
.btnface {
	height:30px;
	width:30px;
}
#rotate .btnface {
	background:url("rotateicons.png") no-repeat scroll 7px 50% transparent;
}
#flip .btnface {
	background:url("rotateicons.png") no-repeat scroll -65px 50% transparent;
}
#mirror .btnface {
	background:url("rotateicons.png") no-repeat scroll -30px 50% transparent;
}

/* averages */

#fN {
	position: relative;
	top: 5px;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/www/videolan.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>MJPG-streamer</title>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <!--[if IE 6]>
    <link rel="stylesheet" href="fix.css" type="text/css" />
    <![endif]-->
  </head>

  <script type="text/javascript">
    var href = window.location.href;
    var root = href.substr(0, href.lastIndexOf('/'));

    function playlist(link, hint) {
      var res = true;

      if (hint)
        res = confirm("Please open the following playlist directly with the VideoLAN Player");

      if ( !res ) {
        link.href = "#";
        return false;
      }

      var m3u = "data:playlist/mjpgstreamer,#EXTM3U%0A%0A#EXTINF:-1,Webcam%20MJPG-Stream%0A" + root + "/?action=stream";
      link.href = m3u;
      return true;
    }
    
    function run() {
      document.getElementById("stream").firstChild.nodeValue = root + "/?action=stream";
    }
  </script>

  <body onload="run();">
    <div id="sidebar">
      <h1>MJPG-Streamer Demo Pages</h1>
      <h2>a resource-friendly streaming application</h2>

      <div id="menu">
        <a href="index.html">Home</a>
        <a href="static.html">Static</a>
        <a href="stream.html">Stream</a>
        <a href="java.html">Java</a>
        <a href="javascript.html">Javascript</a>
        <a class="active" href="videolan.html">VideoLAN</a>
        <a target="_blank" onClick="window.open(this.href, '_blank','width=400,height=400'); return false;" href="control.htm">Control</a>
      </div>

      <h3>Version info:</h3>
      <p>v0.1 (Okt 22, 2007)</p>
    </div>

    <div id="content">
      <h1>VideoLAN</h1>
      <h2>Show the stream in VideoLAN Player</h2>

      <h3>Javascript generated M3U-Playlist</h3>
      <p>Click this link and a <a onclick="return playlist(this, true);" href="#">M3U-Playlist</a> will be created in Javascript. However, this example requires Javascript and it was just tested with Firefox 3.0. It should work with Opera and Chrome, as well as with IE8.</p>
      
      <h3>Enter the stream manually</h3>
      <p>You can open VLC and enter the network stream:<br /><pre id="stream">http://&lt;IP&gt;:&lt;port&gt;/?action=stream</pre></p>

      <p>&nbsp;</p>

      <p>&copy; The <a href="http://mjpg-streamer.sf.net">MJPG-streamer team</a> | Design by <a href="http://andreasviklund.com">Andreas Viklund</a></p>
    </div>
  </body>
</html>

================
File: mjpg-streamer/mjpg-streamer-experimental/CMakeLists.txt
================
cmake_minimum_required(VERSION 2.8.3)
set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})

project("mjpg-streamer" C)

# If the user doesn't manually specify a build type, use 'Release'
message("CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}")
if("${CMAKE_BUILD_TYPE}" STREQUAL "")
  SET(CMAKE_BUILD_TYPE "Release")
endif()

SET(COMPILE_DEFINITIONS -Werror -Wall)

include(CheckLibraryExists) 
include(CheckIncludeFiles)
include(FeatureSummary)

include(mjpg_streamer_utils)

#
# Get the current git hash
#
execute_process(
  COMMAND git rev-parse HEAD
  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
  RESULT_VARIABLE GIT_RESULT
  OUTPUT_VARIABLE GIT_HASH
  OUTPUT_STRIP_TRAILING_WHITESPACE
)

if(GIT_RESULT EQUAL 0)
  add_definitions("-DGIT_HASH=\"${GIT_HASH}\"")
endif()

#
# Options
#
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -DDEBUG")

add_feature_option(WXP_COMPAT "Enable compatibility with WebcamXP" OFF)

if (WXP_COMPAT)
    add_definitions(-DWXP_COMPAT)
endif (WXP_COMPAT)

set (MJPG_STREAMER_PLUGIN_INSTALL_PATH "lib/mjpg-streamer")

#
# Global dependencies
#

find_library(JPEG_LIB jpeg)


#
# Input plugins
#

add_subdirectory(plugins/input_file)
add_subdirectory(plugins/input_http)
add_subdirectory(plugins/input_opencv)
add_subdirectory(plugins/input_raspicam)
add_subdirectory(plugins/input_ptp2)
add_subdirectory(plugins/input_uvc)

#
# Output plugins
#

add_subdirectory(plugins/output_file)
add_subdirectory(plugins/output_http)
add_subdirectory(plugins/output_rtsp)
add_subdirectory(plugins/output_udp)
add_subdirectory(plugins/output_viewer)
add_subdirectory(plugins/output_zmqserver)

#
# mjpg_streamer executable
#

# This adds the plugin installation directory to the default DT_RUNPATH, so
# that the user shouldn't need to set LD_LIBRARY_PATH if using 'make install'
# ... however, DT_RUNPATH allows overriding via LD_LIBRARY_PATH if you really
#     need to do it

set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--enable-new-dtags")
set (CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
set (CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_PREFIX}/${MJPG_STREAMER_PLUGIN_INSTALL_PATH})
set (CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)


add_executable(mjpg_streamer mjpg_streamer.c
                             utils.c)

target_link_libraries(mjpg_streamer pthread dl)
install(TARGETS mjpg_streamer DESTINATION bin)

#
# www directory
#

install(DIRECTORY www DESTINATION share/mjpg-streamer)


#
# Show enabled/disabled features
#

feature_summary(WHAT ALL)

#
# Final warning
#

if("${CMAKE_CURRENT_SOURCE_DIR}" STREQUAL "${CMAKE_CURRENT_BINARY_DIR}")
  message(WARNING "The source directory is the same as binary directory. \"make clean\" may damage the source tree")
endif()

================
File: mjpg-streamer/mjpg-streamer-experimental/docker-start.sh
================
#!/bin/sh
set -e

export LD_LIBRARY_PATH="/mjpg-streamer/mjpg-streamer-experimental"
./mjpg_streamer -o "$1" -i "$2"

================
File: mjpg-streamer/mjpg-streamer-experimental/Dockerfile
================
FROM chunliu/docker-opencv

MAINTAINER Chun Liu <https://github.com/chunliu>
LABEL Description="A Docker image for mjpg_streamer." Version="0.3"

# Build mjpg_streamer
# Need to run container with the device: docker run -t -i -p 8080:8080/tcp --device=/dev/video0 image:tag
RUN git clone https://github.com/jacksonliam/mjpg-streamer.git 

WORKDIR /mjpg-streamer/mjpg-streamer-experimental

RUN make \ 
    && make install \
    && chmod +x docker-start.sh

EXPOSE 8080/TCP

ENTRYPOINT ["/mjpg-streamer/mjpg-streamer-experimental/docker-start.sh", "output_http.so -w ./www"]

CMD ["input_uvc.so"]

================
File: mjpg-streamer/mjpg-streamer-experimental/LICENSE
================
GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

================
File: mjpg-streamer/mjpg-streamer-experimental/makedeb.sh
================
#!/bin/bash

rm -rf _pkg
install -Dm755 mjpg_streamer _pkg/usr/bin/mjpg_streamer
install -d _pkg/usr/lib
install *.so _pkg/usr/lib
install -D mjpg_streamer@.service _pkg/lib/systemd/system/mjpg_streamer@.service
mkdir -p _pkg/usr/share/mjpg_streamer
cp -r www _pkg/usr/share/mjpg_streamer/www

version="$(grep '#define SOURCE_VERSION' mjpg_streamer.h | awk '{gsub(/"/, ""); print $3}')"
fpm --output-type deb --input-type dir --chdir _pkg --after-install postinstall.sh --name mjpg-streamer --version $version

================
File: mjpg-streamer/mjpg-streamer-experimental/Makefile
================
###############################################################
#
#   mjpg-streamer
#
#   This Makefile is just a wrapper around cmake, if you want
#   to do more complex things than what is provided here you 
#   should use cmake directly.
#
###############################################################

.DEFAULT_GOAL: all
.PHONY: all clean distclean install
	
CMAKE_BUILD_TYPE ?= Release
	
all:
	[ -d _build ] || mkdir _build
	[ -f _build/Makefile ] || (cd _build && cmake  -DCMAKE_BUILD_TYPE=$(CMAKE_BUILD_TYPE) ..)
	make -C _build
	
	@cp _build/mjpg_streamer .
	@find _build -name "*.so" -type f -exec cp {} . \;
	
install:
	make -C _build install
	
clean:
	[ ! -f _build/Makefile ] || make -C _build clean
	rm -f mjpg_streamer *.so

distclean: clean
	rm -rf _build

================
File: mjpg-streamer/mjpg-streamer-experimental/mjpg_streamer.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <pthread.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <syslog.h>
#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>

#include "utils.h"
#include "mjpg_streamer.h"

/* globals */
static globals global;

/******************************************************************************
Description.: Display a help message
Input Value.: argv[0] is the program name and the parameter progname
Return Value: -
******************************************************************************/
static void help(char *progname)
{
    fprintf(stderr, "-----------------------------------------------------------------------\n");
    fprintf(stderr, "Usage: %s\n" \
            "  -i | --input \"<input-plugin.so> [parameters]\"\n" \
            "  -o | --output \"<output-plugin.so> [parameters]\"\n" \
            " [-h | --help ]........: display this help\n" \
            " [-v | --version ].....: display version information\n" \
            " [-b | --background]...: fork to the background, daemon mode\n", progname);
    fprintf(stderr, "-----------------------------------------------------------------------\n");
    fprintf(stderr, "Example #1:\n" \
            " To open an UVC webcam \"/dev/video1\" and stream it via HTTP:\n" \
            "  %s -i \"input_uvc.so -d /dev/video1\" -o \"output_http.so\"\n", progname);
    fprintf(stderr, "-----------------------------------------------------------------------\n");
    fprintf(stderr, "Example #2:\n" \
            " To open an UVC webcam and stream via HTTP port 8090:\n" \
            "  %s -i \"input_uvc.so\" -o \"output_http.so -p 8090\"\n", progname);
    fprintf(stderr, "-----------------------------------------------------------------------\n");
    fprintf(stderr, "Example #3:\n" \
            " To get help for a certain input plugin:\n" \
            "  %s -i \"input_uvc.so --help\"\n", progname);
    fprintf(stderr, "-----------------------------------------------------------------------\n");
    fprintf(stderr, "In case the modules (=plugins) can not be found:\n" \
            " * Set the default search path for the modules with:\n" \
            "   export LD_LIBRARY_PATH=/path/to/plugins,\n" \
            " * or put the plugins into the \"/lib/\" or \"/usr/lib\" folder,\n" \
            " * or instead of just providing the plugin file name, use a complete\n" \
            "   path and filename:\n" \
            "   %s -i \"/path/to/modules/input_uvc.so\"\n", progname);
    fprintf(stderr, "-----------------------------------------------------------------------\n");
}

/******************************************************************************
Description.: pressing CTRL+C sends signals to this process instead of just
              killing it plugins can tidily shutdown and free allocated
              resources. The function prototype is defined by the system,
              because it is a callback function.
Input Value.: sig tells us which signal was received
Return Value: -
******************************************************************************/
static void signal_handler(int sig)
{
    int i;

    /* signal "stop" to threads */
    LOG("setting signal to stop\n");
    global.stop = 1;
    usleep(1000 * 1000);

    /* clean up threads */
    LOG("force cancellation of threads and cleanup resources\n");
    for(i = 0; i < global.incnt; i++) {
        global.in[i].stop(i);
        /*for (j = 0; j<MAX_PLUGIN_ARGUMENTS; j++) {
            if (global.in[i].param.argv[j] != NULL) {
                free(global.in[i].param.argv[j]);
            }
        }*/
    }

    for(i = 0; i < global.outcnt; i++) {
        global.out[i].stop(global.out[i].param.id);
        pthread_cond_destroy(&global.in[i].db_update);
        pthread_mutex_destroy(&global.in[i].db);
        /*for (j = 0; j<MAX_PLUGIN_ARGUMENTS; j++) {
            if (global.out[i].param.argv[j] != NULL)
                free(global.out[i].param.argv[j]);
        }*/
    }
    usleep(1000 * 1000);

    /* close handles of input plugins */
    for(i = 0; i < global.incnt; i++) {
        dlclose(global.in[i].handle);
    }

    for(i = 0; i < global.outcnt; i++) {
        int j, skip = 0;
        DBG("about to decrement usage counter for handle of %s, id #%02d, handle: %p\n", \
            global.out[i].plugin, global.out[i].param.id, global.out[i].handle);

        for(j=i+1; j<global.outcnt; j++) {
          if ( global.out[i].handle == global.out[j].handle ) {
            DBG("handles are pointing to the same destination (%p == %p)\n", global.out[i].handle, global.out[j].handle);
            skip = 1;
          }
        }
        if ( skip ) {
          continue;
        }

        DBG("closing handle %p\n", global.out[i].handle);

        dlclose(global.out[i].handle);
    }
    DBG("all plugin handles closed\n");

    LOG("done\n");

    closelog();
    exit(0);
    return;
}

static int split_parameters(char *parameter_string, int *argc, char **argv)
{
    int count = 1;
    argv[0] = NULL; // the plugin may set it to 'INPUT_PLUGIN_NAME'
    if(parameter_string != NULL && strlen(parameter_string) != 0) {
        char *arg = NULL, *saveptr = NULL, *token = NULL;

        arg = strdup(parameter_string);

        if(strchr(arg, ' ') != NULL) {
            token = strtok_r(arg, " ", &saveptr);
            if(token != NULL) {
                argv[count] = strdup(token);
                count++;
                while((token = strtok_r(NULL, " ", &saveptr)) != NULL) {
                    argv[count] = strdup(token);
                    count++;
                    if(count >= MAX_PLUGIN_ARGUMENTS) {
                        IPRINT("ERROR: too many arguments to input plugin\n");
                        return 0;
                    }
                }
            }
        }
        free(arg);
    }
    *argc = count;
    return 1;
}

/******************************************************************************
Description.:
Input Value.:
Return Value:
******************************************************************************/
int main(int argc, char *argv[])
{
    //char *input  = "input_uvc.so --resolution 640x480 --fps 5 --device /dev/video0";
    char *input[MAX_INPUT_PLUGINS];
    char *output[MAX_OUTPUT_PLUGINS];
    int daemon = 0, i, j;
    size_t tmp = 0;

    output[0] = "output_http.so --port 8080";
    global.outcnt = 0;
    global.incnt = 0;

    /* parameter parsing */
    while(1) {
        int c = 0;
        static struct option long_options[] = {
            {"help", no_argument, NULL, 'h'},
            {"input", required_argument, NULL, 'i'},
            {"output", required_argument, NULL, 'o'},
            {"version", no_argument, NULL, 'v'},
            {"background", no_argument, NULL, 'b'},
            {NULL, 0, NULL, 0}
        };

        c = getopt_long(argc, argv, "hi:o:vb", long_options, NULL);

        /* no more options to parse */
        if(c == -1) break;

        switch(c) {
        case 'i':
            input[global.incnt++] = strdup(optarg);
            break;

        case 'o':
            output[global.outcnt++] = strdup(optarg);
            break;

        case 'v':
            printf("MJPG Streamer Version: %s\n",
#ifdef GIT_HASH
            GIT_HASH
#else
            SOURCE_VERSION
#endif
            );
            return 0;
            break;

        case 'b':
            daemon = 1;
            break;

        case 'h': /* fall through */
        default:
            help(argv[0]);
            exit(EXIT_FAILURE);
        }
    }

    openlog("MJPG-streamer ", LOG_PID | LOG_CONS, LOG_USER);
    //openlog("MJPG-streamer ", LOG_PID|LOG_CONS|LOG_PERROR, LOG_USER);
    syslog(LOG_INFO, "starting application");

    /* fork to the background */
    if(daemon) {
        LOG("enabling daemon mode");
        daemon_mode();
    }

    /* ignore SIGPIPE (send by OS if transmitting to closed TCP sockets) */
    signal(SIGPIPE, SIG_IGN);

    /* register signal handler for <CTRL>+C in order to clean up */
    if(signal(SIGINT, signal_handler) == SIG_ERR) {
        LOG("could not register signal handler\n");
        closelog();
        exit(EXIT_FAILURE);
    }

    /*
     * messages like the following will only be visible on your terminal
     * if not running in daemon mode
     */
#ifdef GIT_HASH
    LOG("MJPG Streamer Version: git rev: %s\n", GIT_HASH);
#else
    LOG("MJPG Streamer Version.: %s\n", SOURCE_VERSION);
#endif

    /* check if at least one output plugin was selected */
    if(global.outcnt == 0) {
        /* no? Then use the default plugin instead */
        global.outcnt = 1;
    }

    /* open input plugin */
    for(i = 0; i < global.incnt; i++) {
        /* this mutex and the conditional variable are used to synchronize access to the global picture buffer */
        if(pthread_mutex_init(&global.in[i].db, NULL) != 0) {
            LOG("could not initialize mutex variable\n");
            closelog();
            exit(EXIT_FAILURE);
        }
        if(pthread_cond_init(&global.in[i].db_update, NULL) != 0) {
            LOG("could not initialize condition variable\n");
            closelog();
            exit(EXIT_FAILURE);
        }

        tmp = (size_t)(strchr(input[i], ' ') - input[i]);
        global.in[i].stop      = 0;
        global.in[i].context   = NULL;
        global.in[i].buf       = NULL;
        global.in[i].size      = 0;
        global.in[i].plugin = (tmp > 0) ? strndup(input[i], tmp) : strdup(input[i]);
        global.in[i].handle = dlopen(global.in[i].plugin, RTLD_LAZY);
        if(!global.in[i].handle) {
            LOG("ERROR: could not find input plugin\n");
            LOG("       Perhaps you want to adjust the search path with:\n");
            LOG("       # export LD_LIBRARY_PATH=/path/to/plugin/folder\n");
            LOG("       dlopen: %s\n", dlerror());
            closelog();
            exit(EXIT_FAILURE);
        }
        global.in[i].init = dlsym(global.in[i].handle, "input_init");
        if(global.in[i].init == NULL) {
            LOG("%s\n", dlerror());
            exit(EXIT_FAILURE);
        }
        global.in[i].stop = dlsym(global.in[i].handle, "input_stop");
        if(global.in[i].stop == NULL) {
            LOG("%s\n", dlerror());
            exit(EXIT_FAILURE);
        }
        global.in[i].run = dlsym(global.in[i].handle, "input_run");
        if(global.in[i].run == NULL) {
            LOG("%s\n", dlerror());
            exit(EXIT_FAILURE);
        }
        /* try to find optional command */
        global.in[i].cmd = dlsym(global.in[i].handle, "input_cmd");

        global.in[i].param.parameters = strchr(input[i], ' ');

        for (j = 0; j<MAX_PLUGIN_ARGUMENTS; j++) {
            global.in[i].param.argv[j] = NULL;
        }

        split_parameters(global.in[i].param.parameters, &global.in[i].param.argc, global.in[i].param.argv);
        global.in[i].param.global = &global;
        global.in[i].param.id = i;

        if(global.in[i].init(&global.in[i].param, i)) {
            LOG("input_init() return value signals to exit\n");
            closelog();
            exit(0);
        }
    }

    /* open output plugin */
    for(i = 0; i < global.outcnt; i++) {
        tmp = (size_t)(strchr(output[i], ' ') - output[i]);
        global.out[i].plugin = (tmp > 0) ? strndup(output[i], tmp) : strdup(output[i]);
        global.out[i].handle = dlopen(global.out[i].plugin, RTLD_LAZY);
        if(!global.out[i].handle) {
            LOG("ERROR: could not find output plugin %s\n", global.out[i].plugin);
            LOG("       Perhaps you want to adjust the search path with:\n");
            LOG("       # export LD_LIBRARY_PATH=/path/to/plugin/folder\n");
            LOG("       dlopen: %s\n", dlerror());
            closelog();
            exit(EXIT_FAILURE);
        }
        global.out[i].init = dlsym(global.out[i].handle, "output_init");
        if(global.out[i].init == NULL) {
            LOG("%s\n", dlerror());
            exit(EXIT_FAILURE);
        }
        global.out[i].stop = dlsym(global.out[i].handle, "output_stop");
        if(global.out[i].stop == NULL) {
            LOG("%s\n", dlerror());
            exit(EXIT_FAILURE);
        }
        global.out[i].run = dlsym(global.out[i].handle, "output_run");
        if(global.out[i].run == NULL) {
            LOG("%s\n", dlerror());
            exit(EXIT_FAILURE);
        }

        /* try to find optional command */
        global.out[i].cmd = dlsym(global.out[i].handle, "output_cmd");

        global.out[i].param.parameters = strchr(output[i], ' ');

        for (j = 0; j<MAX_PLUGIN_ARGUMENTS; j++) {
            global.out[i].param.argv[j] = NULL;
        }
        split_parameters(global.out[i].param.parameters, &global.out[i].param.argc, global.out[i].param.argv);

        global.out[i].param.global = &global;
        global.out[i].param.id = i;
        if(global.out[i].init(&global.out[i].param, i)) {
            LOG("output_init() return value signals to exit\n");
            closelog();
            exit(EXIT_FAILURE);
        }
    }

    /* start to read the input, push pictures into global buffer */
    DBG("starting %d input plugin\n", global.incnt);
    for(i = 0; i < global.incnt; i++) {
        syslog(LOG_INFO, "starting input plugin %s", global.in[i].plugin);
        if(global.in[i].run(i)) {
            LOG("can not run input plugin %d: %s\n", i, global.in[i].plugin);
            closelog();
            return 1;
        }
    }

    DBG("starting %d output plugin(s)\n", global.outcnt);
    for(i = 0; i < global.outcnt; i++) {
        syslog(LOG_INFO, "starting output plugin: %s (ID: %02d)", global.out[i].plugin, global.out[i].param.id);
        global.out[i].run(global.out[i].param.id);
    }

    /* wait for signals */
    pause();

    return 0;
}

================
File: mjpg-streamer/mjpg-streamer-experimental/mjpg_streamer.h
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#ifndef MJPG_STREAMER_H
#define MJPG_STREAMER_H
#define SOURCE_VERSION "2.0"

/* FIXME take a look to the output_http clients thread marked with fixme if you want to set more then 10 plugins */
#define MAX_INPUT_PLUGINS 10
#define MAX_OUTPUT_PLUGINS 10
#define MAX_PLUGIN_ARGUMENTS 32

#include <linux/types.h>          /* for videodev2.h */
#include <linux/videodev2.h>
#include <pthread.h>

#ifdef DEBUG
#define DBG(...) fprintf(stderr, " DBG(%s, %s(), %d): ", __FILE__, __FUNCTION__, __LINE__); fprintf(stderr, __VA_ARGS__)
#else
#define DBG(...)
#endif

#define LOG(...) { char _bf[1024] = {0}; snprintf(_bf, sizeof(_bf)-1, __VA_ARGS__); fprintf(stderr, "%s", _bf); syslog(LOG_INFO, "%s", _bf); }

#include "plugins/input.h"
#include "plugins/output.h"

/* global variables that are accessed by all plugins */
typedef struct _globals globals;

/* an enum to identify the commands destination*/
typedef enum {
    Dest_Input = 0,
    Dest_Output = 1,
    Dest_Program = 2,
} command_dest;

/* commands which can be send to the input plugin */
//typedef enum _cmd_group cmd_group;
enum _cmd_group {
    IN_CMD_GENERIC =        0, // if you use non V4L2 input plugin you not need to deal the groups.
    IN_CMD_V4L2 =           1,
    IN_CMD_RESOLUTION =     2,
    IN_CMD_JPEG_QUALITY =   3,
    IN_CMD_PWC =            4,
};

typedef struct _control control;
struct _control {
    struct v4l2_queryctrl ctrl;
    int value;
    struct v4l2_querymenu *menuitems;
    /*  In the case the control a V4L2 ctrl this variable will specify
        that the control is a V4L2_CTRL_CLASS_USER control or not.
        For non V4L2 control it is not acceptable, leave it 0.
    */
    int class_id;
    int group;
};

struct _globals {
    int stop;

    /* input plugin */
    input in[MAX_INPUT_PLUGINS];
    int incnt;

    /* output plugin */
    output out[MAX_OUTPUT_PLUGINS];
    int outcnt;

    /* pointer to control functions */
    //int (*control)(int command, char *details);
};

#endif

================
File: mjpg-streamer/mjpg-streamer-experimental/mjpg_streamer@.service
================
[Unit]
Description=A server for streaming Motion-JPEG from a video capture device
After=network.target

[Service]
User=mjpg_streamer
ExecStart=/usr/bin/mjpg_streamer -i 'input_uvc.so -d /dev/%I' -o 'output_http.so -w /usr/share/mjpg_streamer/www'

[Install]
WantedBy=multi-user.target

================
File: mjpg-streamer/mjpg-streamer-experimental/postinstall.sh
================
#!/bin/sh
adduser --system --ingroup video mjpg_streamer

================
File: mjpg-streamer/mjpg-streamer-experimental/README.md
================
mjpg-streamer
=============

Currently no issues are known, but since this software is quite young and not used widely it may cause problems. You must really know what you are doing, if you use this software. If you want to use the software you are obliged to check if the sourcecode does what you expect it to do and take the risk yourself to use it.


Usage
=====

When launching mjpg-streamer, you specify one or more input plugins and an output plugin. For example, to stream a V4L compatible webcam via an HTTP server (the most common use case), you
can do something like this:

	mjpg_streamer -i input_uvc.so -o output_http.so

Each plugin supports various options, you can view the plugin's options via its `--help` option:

	mjpg_streamer -i 'input_uvc.so --help'


More examples can be found in the start.sh bash script.

Plugin documentation
====================

Input plugins:

* input_file
* input_http
* input_opencv ([documentation](plugins/input_opencv/README.md))
* input_ptp2
* input_raspicam ([documentation](plugins/input_raspicam/README.md))
* input_uvc ([documentation](plugins/input_uvc/README.md))

Output plugins:

* output_file
* output_http ([documentation](plugins/output_http/README.md))
* ~output_rtsp~ (not functional)
* ~output_udp~ (not functional)
* output_viewer ([documentation](plugins/output_viewer/README.md))

================
File: mjpg-streamer/mjpg-streamer-experimental/start.sh
================
#!/bin/sh

#/******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
#******************************************************************************/

## This example shows how to invoke mjpg-streamer from the command line

export LD_LIBRARY_PATH="$(pwd)"
#./mjpg_streamer -i "input_uvc.so --help"

./mjpg_streamer -i "./input_uvc.so" -o "./output_http.so -w ./www"
#./mjpg_streamer -i "./input_uvc.so -n -f 30 -r 1280x960"  -o "./output_http.so -w ./www" 
#./mjpg_streamer -i "./input_uvc.so -n -f 30 -r 640x480 -d /dev/video0"  -o "./output_http.so -w ./www" &
#./mjpg_streamer -i "./input_uvc.so -d /dev/video0" -i "./input_uvc.so -d /dev/video1" -o "./output_http.so -w ./www"
#valgrind ./mjpg_streamer -i "./input_uvc.so" -o "./output_http.so -w ./www"

#./mjpg_streamer -i "./input_uvc.so -n -f 30 -r 1280x960" -o "./output_udpserver.so --port 2001"
#./mjpg_streamer -i "./input_uvc.so -n -f 30 -r 640x480" -o "./output_udpserver.so --address epgm://eth0;239.1.1.1:2001"
#./mjpg_streamer -i "./input_uvc.so -n -f 30 -r 640x480 -d /dev/video0" -o "./output_zmqserver.so --address tcp://*:2001 --buffer_size 2"
## pwd echos the current path you are working at,
## the backticks open a subshell to execute the command pwd first
## the exported variable name configures ldopen() to search a certain
## folder for *.so modules
#export LD_LIBRARY_PATH=`pwd`

## this is the minimum command line to start mjpg-streamer with webpages
## for the input-plugin default parameters are used
#./mjpg_streamer -o "output_http.so -w `pwd`/www"

## to query help for the core:
# ./mjpg_streamer --help

## to query help for the input-plugin "input_uvc.so":
# ./mjpg_streamer --input "input_uvc.so --help"

## to query help for the output-plugin "output_file.so":
# ./mjpg_streamer --output "output_file.so --help"

## to query help for the output-plugin "output_http.so":
# ./mjpg_streamer --output "output_http.so --help"

## to specify a certain device, framerage and resolution for the input plugin:
# ./mjpg_streamer -i "input_uvc.so -d /dev/video2 -r 320x240 -f 10"

## to start both, the http-output-plugin and write to files every 15 second:
# mkdir pics
# ./mjpg_streamer -o "output_http.so -w `pwd`/www" -o "output_file.so -f pics -d 15000"

## to protect the webserver with a username and password (!! can easily get sniffed and decoded, it is just base64 encoded !!)
# ./mjpg-streamer -o "output_http.so -w ./www -c UsErNaMe:SeCrEt"

## If you want to track down errors, use this simple testpicture plugin as input source.
## to use the testpicture input plugin instead of a webcam or folder:
#./mjpg_streamer -i "input_testpicture.so -r 320x240 -d 500" -o "output_http.so -w www"

## The input_file.so plugin watches a folder for new files, it does not matter where
## the JPEG files orginate from. For instance it is possible to grab the desktop and 
## store the files to a folder:
# mkdir -p /tmp/input
# while true; do xwd -root | convert - -scale 640 /tmp/input/bla.jpg; sleep 0.5; done &
## Then the files can be read from the folder "/tmp/input" and served via HTTP
# ./mjpg_streamer -i "input_file.so -f /tmp/input -r" -o "output_http.so -w www"

## To upload files to a FTP server (edit the script first)
# ./mjpg_streamer -i input_testpicture.so -o "output_file.so --command plugins/output_file/examples/ftp_upload.sh"

## To create a control only interface useful for controlling the pan/tilt throug
## a webpage while another program streams video/audio, like skype.
#./mjpg_streamer -i "./input_control.so" -o "./output_http.so -w ./www"

================
File: mjpg-streamer/mjpg-streamer-experimental/TODO
================
TODO list:

Core:
Implement the string type controls handling.
Add support for runtime resolution change (WIP but broken)
Put capture timestamp to the EXIF data
Save and load the configuration from a file. 

Plugins:
Create some kind of UDP/RTP based streaming plugin
Make the output_file plugin to be able to record mjpg video.

================
File: mjpg-streamer/mjpg-streamer-experimental/utils.c
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <linux/types.h>
#include <string.h>
#include <fcntl.h>
#include <wait.h>
#include <time.h>
#include <limits.h>
#include <linux/stat.h>
#include <sys/stat.h>

#include "utils.h"

/******************************************************************************
Description.:
Input Value.:
Return Value:
******************************************************************************/
void daemon_mode(void)
{
    int fr = 0;

    fr = fork();
    if(fr < 0) {
        fprintf(stderr, "fork() failed\n");
        exit(1);
    }
    if(fr > 0) {
        exit(0);
    }

    if(setsid() < 0) {
        fprintf(stderr, "setsid() failed\n");
        exit(1);
    }

    fr = fork();
    if(fr < 0) {
        fprintf(stderr, "fork() failed\n");
        exit(1);
    }
    if(fr > 0) {
        fprintf(stderr, "forked to background (%d)\n", fr);
        exit(0);
    }

    umask(0);

    fr = chdir("/");
    if(fr != 0) {
        fprintf(stderr, "chdir(/) failed\n");
        exit(0);
    }

    close(0);
    close(1);
    close(2);

    open("/dev/null", O_RDWR);

    fr = dup(0);
    fr = dup(0);
}


/*
 * Common webcam resolutions with information from
 * http://en.wikipedia.org/wiki/Graphics_display_resolution
 */
static const struct {
    const char *string;
    const int width, height;
} resolutions[] = {
    { "QQVGA", 160,  120  },
    { "QCIF",  176,  144  },
    { "CGA",   320,  200  },
    { "QVGA",  320,  240  },
    { "CIF",   352,  288  },
    { "PAL",   720,  576  },
    { "VGA",   640,  480  },
    { "SVGA",  800,  600  },
    { "XGA",   1024, 768  },
    { "HD",    1280, 720  },
    { "SXGA",  1280, 1024 },
    { "UXGA",  1600, 1200 },
    { "FHD",   1920, 1280 },
};

/******************************************************************************
Description.: convienence function for input plugins
Input Value.:
Return Value:
******************************************************************************/
void parse_resolution_opt(const char * optarg, int * width, int * height) {
    int i;

    /* try to find the resolution in lookup table "resolutions" */
    for(i = 0; i < LENGTH_OF(resolutions); i++) {
        if(strcmp(resolutions[i].string, optarg) == 0) {
            *width  = resolutions[i].width;
            *height = resolutions[i].height;
            return;
        }
    }
    
    /* parse value as decimal value */
    if (sscanf(optarg, "%dx%d", width, height) != 2) {
        fprintf(stderr, "Invalid height/width '%s' specified!\n", optarg);
        exit(EXIT_FAILURE);
    }
}

void resolutions_help(const char * padding) {
    int i;
    for(i = 0; i < LENGTH_OF(resolutions); i++) {
        fprintf(stderr, "%s ", resolutions[i].string);
        if((i + 1) % 6 == 0)
            fprintf(stderr, "\n%s", padding);
    }
    fprintf(stderr, "\n%sor a custom value like the following" \
    "\n%sexample: 640x480\n", padding, padding);
}

================
File: mjpg-streamer/mjpg-streamer-experimental/utils.h
================
/*******************************************************************************
#                                                                              #
#      MJPG-streamer allows to stream JPG frames from an input-plugin          #
#      to several output plugins                                               #
#                                                                              #
#      Copyright (C) 2007 Tom Stöveken                                         #
#                                                                              #
# This program is free software; you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation; version 2 of the License.                      #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA    #
#                                                                              #
*******************************************************************************/

#define ABS(a) (((a) < 0) ? -(a) : (a))
#ifndef MIN
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#endif
#define LENGTH_OF(x) (sizeof(x)/sizeof(x[0]))

/******************************************************************************
Description.: getopt must get reset, otherwise it can only be called once
Input Value.: -
Return Value: -
******************************************************************************/
static inline void reset_getopt(void)
{
    /* optind=1; opterr=1; optopt=63; */
#ifdef __GLIBC__
    optind = 0;
#else
    optind = 1;
#endif

#ifdef HAVE_OPTRESET
    optreset = 1;
#endif
}

void daemon_mode(void);

/******************************************************************************
 Getopt utility macros
 
 Each of these assumes that you're storing options in a struct called 'settings'
 which has a var and var_set variable. If the option is set, then var will 
 be set to the value, and var_set will be set to 1.
******************************************************************************/

#define OPTION_INT(idx, v) \
  case idx: \
    DBG("case " #idx); \
    if (sscanf(optarg, "%d", &settings->v) != 1) { \
        fprintf(stderr, "Invalid value '%s' for -" #v " (integer required)\n", optarg); \
        exit(EXIT_FAILURE); \
    } \
    settings->v##_set = 1;

#define OPTION_INT_AUTO(idx, v) \
  case idx: \
    DBG("case " #idx); \
    if (strcasecmp("auto", optarg) == 0) { \
        settings->v##_auto = 1; \
    } else if (sscanf(optarg, "%d", &settings->v) != 1) { \
        fprintf(stderr, "Invalid value '%s' for -" #v " (auto or integer required)\n", optarg); \
        exit(EXIT_FAILURE); \
    } \
    settings->v##_set = 1;

/* 1 is true, 0 is false */
#define OPTION_BOOL(idx, v) \
  case idx: \
    DBG("case " #idx); \
    if (strcasecmp("true", optarg) == 0) { \
        settings->v = 1; \
    } else if (strcasecmp("false", optarg) == 0) { \
        settings->v = 0; \
    } else { \
        fprintf(stderr, "Invalid value '%s' for -" #v " (true/false accepted)\n", optarg); \
        exit(EXIT_FAILURE); \
    } \
    settings->v##_set = 1;

/* table must be defined as array of structs with 'k', 'v' strings */
#define OPTION_MULTI(idx, var, table) \
  case idx: \
    DBG("case " #idx); \
    settings->var##_set = 0; \
    for(i = 0; i < LENGTH_OF(table); i++) { \
        if(strcasecmp(table[i].k, optarg) == 0) { \
            settings->var = table[i].v; \
            settings->var##_set = 1; \
            break; \
        } \
    } \
    if (settings->var##_set == 0) { \
        fprintf(stderr, "Invalid value '%s' for -" #var "\n", optarg); \
        exit(EXIT_FAILURE); \
    }
    
#define OPTION_MULTI_OR_INT(idx, var1, var1_default, var2, table) \
  case idx: \
    DBG("case " #idx); \
    settings->var1 = var1_default; \
    for(i = 0; i < LENGTH_OF(table); i++) { \
        if(strcasecmp(table[i].k, optarg) == 0) { \
            settings->var1 = table[i].v; \
            break; \
        } \
    } \
    if (settings->var1 == var1_default) { \
        if (sscanf(optarg, "%d", &settings->var2) != 1) { \
            fprintf(stderr, "Invalid value '%s' for -" #var2 "\n", optarg); \
            exit(EXIT_FAILURE); \
        } \
    } \
    settings->var2##_set = 1;

void resolutions_help(const char * padding);
void parse_resolution_opt(const char * optarg, int * width, int * height);

================
File: mjpg-streamer/.gitignore
================
# Compiled Object files
*.slo
*.lo
*.o

# Compiled Dynamic libraries
*.so

# Compiled Static libraries
*.lai
*.la
*.a

# Python
__pycache__
*.pyc

/mjpg-streamer-experimental/mjpg_streamer
/mjpg-streamer-experimental/_build
*.deb
_pkg/
doc/

================
File: mjpg-streamer/README.md
================
mjpg-streamer
=============

This is a fork of http://sourceforge.net/projects/mjpg-streamer/ with added support for the Raspberry Pi camera via the input_raspicam plugin.

mjpg-streamer is a command line application that copies JPEG frames from one
or more input plugins to multiple output plugins. It can be used to stream
JPEG files over an IP-based network from a webcam to various types of viewers
such as Chrome, Firefox, Cambozola, VLC, mplayer, and other software capable
of receiving MJPG streams.

It was originally written for embedded devices with very limited resources in
terms of RAM and CPU. Its predecessor "uvc_streamer" was created because
Linux-UVC compatible cameras directly produce JPEG-data, allowing fast and
perfomant M-JPEG streams even from an embedded device running OpenWRT. The
input module "input_uvc.so" captures such JPG frames from a connected webcam.
mjpg-streamer now supports a variety of different input devices.

Security warning
----------------

**WARNING**: mjpg-streamer should not be used on untrusted networks!
By default, anyone with access to the network that mjpg-streamer is running
on will be able to access it.

Plugins
-------

Input plugins:

* input_file
* input_http
* input_opencv ([documentation](mjpg-streamer-experimental/plugins/input_opencv/README.md))
* input_ptp2
* input_raspicam ([documentation](mjpg-streamer-experimental/plugins/input_raspicam/README.md))
* input_uvc ([documentation](mjpg-streamer-experimental/plugins/input_uvc/README.md))

Output plugins:

* output_file
* output_http ([documentation](mjpg-streamer-experimental/plugins/output_http/README.md))
* ~output_rtsp~ (not functional)
* ~output_udp~ (not functional)
* output_viewer ([documentation](mjpg-streamer-experimental/plugins/output_viewer/README.md))
* output_zmqserver ([documentation](mjpg-streamer-experimental/plugins/output_zmqserver/README.md))

Building & Installation
=======================

You must have cmake installed. You will also probably want to have a development
version of libjpeg installed. I used libjpeg8-dev. e.g.

    sudo apt-get install cmake libjpeg8-dev

If you do not have gcc (and g++ for the opencv plugin) you may need to install those.

    sudo apt-get install gcc g++

Simple compilation
------------------

This will build and install all plugins that can be compiled.

    cd mjpg-streamer-experimental
    make
    sudo make install
    
By default, everything will be compiled in "release" mode. If you wish to compile
with debugging symbols enabled, you can do this:

    cd mjpg-streamer-experimental
    make distclean
    make CMAKE_BUILD_TYPE=Debug
    sudo make install
    
Advanced compilation (via CMake)
--------------------------------

There are options available to enable/disable plugins, setup options, etc. This
shows the basic steps to enable the experimental HTTP management feature:

    cd mjpg-streamer-experimental
    mkdir _build
    cd _build
    cmake -DENABLE_HTTP_MANAGEMENT=ON ..
    make
    sudo make install

Usage
=====
From the mjpeg streamer experimental
folder:
```
export LD_LIBRARY_PATH=.
./mjpg_streamer -o "output_http.so -w ./www" -i "input_raspicam.so"
```

See [README.md](mjpg-streamer-experimental/README.md) or the individual plugin's documentation for more details.

Discussion / Questions / Help
=============================

Probably best in this thread
http://www.raspberrypi.org/phpBB3/viewtopic.php?f=43&t=45178

Authors
=======

mjpg-streamer was originally created by Tom Stöveken, and has received
improvements from many collaborators since then.


License
=======

mjpg-streamer is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
GNU General Public License for more details.

================
File: public/css/style.css
================
/* File: public/css/style.css */

body {
    font-family: 'Courier New', Courier, monospace;
    line-height: 1.6;
    margin: 0;
    padding: 20px;
    background-color: #000000;
    color: #00ff00;
}

h1, h2, h3, h4, h5, h6 {
    color: #00ff00;
    text-shadow: 0 0 5px #00ff00;
}

a {
    color: #00ffff;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
    text-shadow: 0 0 5px #00ffff;
}

.button {
    display: inline-block;
    background-color: #003300;
    color: #00ff00;
    padding: 10px 15px;
    border: 1px solid #00ff00;
    border-radius: 5px;
    cursor: pointer;
    text-decoration: none;
    margin: 10px 0;
}

.button:hover {
    background-color: #004400;
    text-decoration: none;
    box-shadow: 0 0 10px #00ff00;
}

form {
    background-color: #001100;
    padding: 20px;
    border-radius: 5px;
    border: 1px solid #00ff00;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
}

form div {
    margin-bottom: 15px;
}

label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

input[type="text"],
input[type="number"],
textarea,
select {
    width: 100%;
    padding: 8px;
    border: 1px solid #00ff00;
    border-radius: 4px;
    background-color: #000000;
    color: #00ff00;
    box-sizing: border-box;
}

button {
    background-color: #003300;
    color: #00ff00;
    padding: 10px 15px;
    border: 1px solid #00ff00;
    border-radius: 5px;
    cursor: pointer;
}

button:hover {
    background-color: #004400;
    box-shadow: 0 0 10px #00ff00;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    background-color: #001100;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
}

table, th, td {
    border: 1px solid #00ff00;
}

th, td {
    padding: 12px;
    text-align: left;
}

th {
    background-color: #002200;
    font-weight: bold;
}

tr:nth-child(even) {
    background-color: #001800;
}

#parts-container, #sounds-container {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
}

#available-parts, #selected-parts, #available-sounds, #selected-sounds {
    width: 40%;
}

#available-parts select, #selected-parts select, #available-sounds select, #selected-sounds select {
    width: 100%;
    height: 200px;
    background-color: #001100;
    color: #00ff00;
    border: 1px solid #00ff00;
}

#parts-container > div:nth-child(2), #sounds-container > div:nth-child(2) {
    display: flex;
    flex-direction: column;
    justify-content: center;
}

#parts-container button, #sounds-container button {
    margin: 5px;
}

input[type="file"] {
    background-color: #001100;
    color: #00ff00;
    border: 1px solid #00ff00;
    padding: 5px;
    border-radius: 4px;
}

option {
    background-color: #001100;
    color: #00ff00;
}

input:focus, textarea:focus, select:focus {
    outline: none;
    box-shadow: 0 0 5px #00ff00;
}

#cameraStream {
    width: 50%;
    max-width: 640px;
    aspect-ratio: 16 / 9;
    background-color: #000;
    margin-bottom: 20px;
}

.camera-controls {
    margin-top: 10px;
    margin-bottom: 20px;
}

.camera-controls button,
.camera-controls label,
.camera-controls select {
    margin-right: 10px;
}

.monitoring-section {
    margin-bottom: 20px;
}

#armStatus {
    font-weight: bold;
}

#armStatus.armed {
    color: #ff0000;
}

#armStatus.disarmed {
    color: #00ff00;
}

.character-section {
    display: flex;
    align-items: flex-start;
    margin-bottom: 20px;
}

.character-image {
    width: 250px;
    height: 250px;
    object-fit: cover;
    margin-right: 20px;
    border: 1px solid #0f0;
}

.character-info {
    flex-grow: 1;
}

.scene-container {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
}

.scene-box {
    width: 45%;
    border: 1px solid #0f0;
    padding: 10px;
}

.scene-controls {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

#availableScenes, #activatedScenes {
    width: 100%;
    height: 200px;
    overflow-y: auto;
    border: 1px solid #0f0;
    background-color: #001100;
    color: #0f0;
    padding: 5px;
}

#activatedScenes {
    list-style-type: none;
    margin: 0;
    padding: 5px;
}

.output-section {
    width: 100%;
    height: 300px;
    overflow-y: scroll;
    border: 1px solid #0f0;
    padding: 10px;
    background-color: #001100;
    margin-bottom: 20px;
}

================
File: public/stream/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:2
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:1.666667,
playlist0.ts
#EXT-X-ENDLIST

================
File: public/stream/stream.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:12
#EXT-X-MEDIA-SEQUENCE:28
#EXTINF:12.500000,
stream28.ts
#EXTINF:9.800000,
stream29.ts
#EXT-X-ENDLIST

================
File: routes/activeModeRoutes.js
================
const express = require('express');
const router = express.Router();
const characterService = require('../services/characterService');
const sceneService = require('../services/sceneService');

router.get('/', async (req, res) => {
    try {
        const characters = await characterService.getAllCharacters();
        res.render('active-mode', { 
            title: 'Active Mode',
            characters: characters
        });
    } catch (error) {
        console.error('Error fetching data for Active Mode:', error);
        res.status(500).send('An error occurred while loading Active Mode');
    }
});

router.get('/character/:id', async (req, res) => {
    try {
        const characterId = parseInt(req.params.id);
        const character = await characterService.getCharacterById(characterId);
        if (character) {
            res.json(character);
        } else {
            res.status(404).json({ error: 'Character not found' });
        }
    } catch (error) {
        console.error('Error fetching character:', error);
        res.status(500).json({ error: 'An error occurred while fetching the character' });
    }
});

router.get('/character/:id/scenes', async (req, res) => {
    try {
        const characterId = parseInt(req.params.id);
        const scenes = await sceneService.getScenesByCharacterId(characterId);
        res.json(scenes);
    } catch (error) {
        console.error('Error fetching scenes for character:', error);
        res.status(500).json({ error: 'An error occurred while fetching scenes' });
    }
});

module.exports = router;

================
File: routes/characterRoutes.js
================
const express = require('express');
const router = express.Router();
const characterService = require('../services/characterService');
const partService = require('../services/partService');
const soundService = require('../services/soundService');
const fs = require('fs').promises;
const path = require('path');
const multer = require('multer');

const upload = multer({
    dest: path.join(__dirname, '../public/images/characters')
});

router.get('/', async (req, res) => {
    try {
        const characters = await characterService.getAllCharacters();
        const parts = await partService.getAllParts();
        const sounds = await soundService.getAllSounds();
        res.render('characters', { title: 'Characters', characters, parts, sounds });
    } catch (error) {
        console.error('Error fetching characters:', error);
        res.status(500).send('An error occurred while fetching characters');
    }
});

router.get('/new', async (req, res) => {
    try {
        const parts = await partService.getAllParts();
        const sounds = await soundService.getAllSounds();
        res.render('character-form', { title: 'Add New Character', action: '/characters', character: {}, parts, sounds });
    } catch (error) {
        console.error('Error rendering new character form:', error);
        res.status(500).send('An error occurred while loading the new character form');
    }
});

router.get('/:id/edit', async (req, res) => {
    try {
        const character = await characterService.getCharacterById(parseInt(req.params.id));
        const parts = await partService.getAllParts();
        const sounds = await soundService.getAllSounds();
        if (character) {
            res.render('character-form', { title: 'Edit Character', action: `/characters/${character.id}`, character, parts, sounds });
        } else {
            res.status(404).send('Character not found');
        }
    } catch (error) {
        console.error('Error fetching character:', error);
        res.status(500).send('An error occurred while fetching the character');
    }
});

router.post('/', upload.single('character_image'), async (req, res) => {
    try {
        const newCharacter = {
            char_name: req.body.char_name,
            char_description: req.body.char_description,
            parts: req.body.parts ? req.body.parts.map(Number) : [],
            sounds: req.body.sounds ? req.body.sounds.map(Number) : [],
            image: req.file ? req.file.filename : null
        };
        await characterService.createCharacter(newCharacter);
        res.redirect('/characters');
    } catch (error) {
        console.error('Error creating character:', error);
        res.status(500).send('An error occurred while creating the character');
    }
});

router.post('/:id', upload.single('character_image'), async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const updatedCharacter = {
            char_name: req.body.char_name,
            char_description: req.body.char_description,
            parts: req.body.parts ? req.body.parts.map(Number) : [],
            sounds: req.body.sounds ? req.body.sounds.map(Number) : []
        };
        if (req.file) {
            const character = await characterService.getCharacterById(id);
            if (character.image) {
                const oldImagePath = path.join(__dirname, '../public/images/characters', character.image);
                await fs.unlink(oldImagePath).catch(console.error);
            }
            updatedCharacter.image = req.file.filename;
        }
        await characterService.updateCharacter(id, updatedCharacter);
        res.redirect('/characters');
    } catch (error) {
        console.error('Error updating character:', error);
        res.status(500).send('An error occurred while updating the character');
    }
});

router.post('/:id/delete', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const character = await characterService.getCharacterById(id);
        if (character.image) {
            const imagePath = path.join(__dirname, '../public/images/characters', character.image);
            await fs.unlink(imagePath).catch(console.error);
        }
        await characterService.deleteCharacter(id);
        res.sendStatus(200);
    } catch (error) {
        console.error('Error deleting character:', error);
        res.status(500).send('An error occurred while deleting the character');
    }
});

router.get('/:id/parts', async (req, res) => {
    try {
        const characterId = parseInt(req.params.id);
        const character = await characterService.getCharacterById(characterId);
        
        if (!character) {
            return res.status(404).json({ error: 'Character not found' });
        }

        const allParts = await partService.getAllParts();
        const characterParts = allParts.filter(part => character.parts.includes(part.id));

        res.json(characterParts);
    } catch (error) {
        console.error('Error in GET /characters/:id/parts route:', error);
        res.status(500).json({ error: 'An error occurred while fetching character parts' });
    }
});

module.exports = router;

================
File: routes/ledRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id, 10);
        console.log('Editing LED with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const part = await partService.getPartById(id);
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/led', { title: 'Edit LED', action: `/parts/led/${part.id}`, part, characters });
    } catch (error) {
        console.error('Error fetching LED:', error);
        res.status(500).send('An error occurred while fetching the LED: ' + error.message);
    }
});

router.post('/', async (req, res) => {
    try {
        const newLed = {
            name: req.body.name,
            type: 'led',
            characterId: parseInt(req.body.characterId, 10),
            gpioPin: parseInt(req.body.gpioPin, 10) || 26
        };
        const createdLed = await partService.createPart(newLed);
        console.log('Created LED:', createdLed);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating LED:', error);
        res.status(500).send('An error occurred while creating the LED: ' + error.message);
    }
});

router.post('/test', async (req, res) => {
    try {
        console.log('LED Test Route - Request body:', req.body);
        const { gpioPin, brightness, duration } = req.body;
        const scriptPath = path.join(__dirname, '..', 'scripts', 'led_control.py');
        console.log('LED test script path:', scriptPath);
        const process = spawn('python3', [
            scriptPath,
            gpioPin.toString(),
            'on',
            duration.toString(),
            brightness.toString()
        ]);

        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log(`Python script output: ${data}`);
        });

        process.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error(`Python script error: ${data}`);
        });

        process.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            if (code === 0) {
                res.json({ success: true, message: 'LED test completed successfully', output: stdout });
            } else {
                res.status(500).json({ success: false, message: 'LED test failed', error: stderr });
            }
        });
    } catch (error) {
        console.error('Error testing LED:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the LED', error: error.message });
    }
});

router.post('/:id', async (req, res) => {
    try {
        console.log('Update LED Route - Request params:', req.params);
        console.log('Update LED Route - Request body:', req.body);

        const id = parseInt(req.params.id, 10);
        console.log('Updating LED with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const updatedLed = {
            id: id,
            name: req.body.name,
            type: 'led',
            characterId: parseInt(req.body.characterId, 10),
            gpioPin: parseInt(req.body.gpioPin, 10) || 26
        };
        console.log('Updated LED data:', updatedLed);
        const result = await partService.updatePart(id, updatedLed);
        console.log('Updated LED:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating LED:', error);
        res.status(500).send('An error occurred while updating the LED: ' + error.message);
    }
});

module.exports = router;

================
File: routes/lightRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id, 10);
        console.log('Editing Light with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const part = await partService.getPartById(id);
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/light', { title: 'Edit Light', action: `/parts/light/${part.id}`, part, characters });
    } catch (error) {
        console.error('Error fetching light:', error);
        res.status(500).send('An error occurred while fetching the light: ' + error.message);
    }
});

router.post('/', async (req, res) => {
    try {
        const newLight = {
            name: req.body.name,
            type: 'light',
            characterId: parseInt(req.body.characterId, 10),
            gpioPin: parseInt(req.body.gpioPin, 10) || 26
        };
        const createdLight = await partService.createPart(newLight);
        console.log('Created light:', createdLight);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating light:', error);
        res.status(500).send('An error occurred while creating the light: ' + error.message);
    }
});

router.post('/test', async (req, res) => {
    try {
        console.log('Light Test Route - Request body:', req.body);
        const { gpioPin, state, duration } = req.body;
        const scriptPath = path.join(__dirname, '..', 'scripts', 'light_control.py');
        console.log('Light test script path:', scriptPath);
        const process = spawn('python3', [
            scriptPath,
            gpioPin.toString(),
            state,
            duration.toString()
        ]);

        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log(`Python script output: ${data}`);
        });

        process.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error(`Python script error: ${data}`);
        });

        process.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            if (code === 0) {
                res.json({ success: true, message: 'Light test completed successfully', output: stdout });
            } else {
                res.status(500).json({ success: false, message: 'Light test failed', error: stderr });
            }
        });
    } catch (error) {
        console.error('Error testing light:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the light', error: error.message });
    }
});

router.post('/:id', async (req, res) => {
    try {
        console.log('Update Light Route - Request params:', req.params);
        console.log('Update Light Route - Request body:', req.body);

        const id = parseInt(req.params.id, 10);
        console.log('Updating Light with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const updatedLight = {
            id: id,
            name: req.body.name,
            type: 'light',
            characterId: parseInt(req.body.characterId, 10),
            gpioPin: parseInt(req.body.gpioPin, 10) || 26
        };
        console.log('Updated Light data:', updatedLight);
        const result = await partService.updatePart(id, updatedLight);
        console.log('Updated light:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating light:', error);
        res.status(500).send('An error occurred while updating the light: ' + error.message);
    }
});

module.exports = router;

================
File: routes/linearActuatorRoutes.js
================
// File: routes/linearActuatorRoutes.js

const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

// Route to list all linear actuators (commented out for now)
/*
router.get('/', async (req, res) => {
    try {
        const parts = await partService.getAllParts();
        const linearActuators = parts.filter(part => part.type === 'linear-actuator');
        res.render('linear-actuators-list', { title: 'Linear Actuators', linearActuators });
    } catch (error) {
        console.error('Error fetching linear actuators:', error);
        res.status(500).send('An error occurred while fetching linear actuators');
    }
});
*/

// Route to render the form for a new linear actuator
router.get('/new', async (req, res) => {
    try {
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/linear-actuator', { 
            title: 'New Linear Actuator', 
            action: '/parts/linear-actuator', 
            part: {}, 
            characters 
        });
    } catch (error) {
        console.error('Error rendering new linear actuator form:', error);
        res.status(500).send('An error occurred while loading the new linear actuator form');
    }
});

// Route to create a new linear actuator (commented out for now)
/*
router.post('/', async (req, res) => {
    try {
        const newActuator = {
            name: req.body.name,
            type: 'linear-actuator',
            characterId: parseInt(req.body.characterId),
            directionPin: parseInt(req.body.directionPin) || 18,
            pwmPin: parseInt(req.body.pwmPin) || 13
        };
        const createdActuator = await partService.createPart(newActuator);
        console.log('Created linear actuator:', createdActuator);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating linear actuator:', error);
        res.status(500).send('An error occurred while creating the linear actuator: ' + error.message);
    }
});
*/

// Route to test the linear actuator
router.post('/test', async (req, res) => {
    try {
        const { direction, speed, duration, directionPin, pwmPin } = req.body;
        const scriptPath = path.join(__dirname, '..', 'scripts', 'linear_actuator_control.py');
        
        console.log('Executing script with parameters:', { direction, speed, duration, directionPin, pwmPin });
        
        const process = spawn('python3', [
            scriptPath,
            direction,
            speed.toString(),
            duration.toString(),
            directionPin.toString(),
            pwmPin.toString()
        ]);

        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log(`Python script output: ${data}`);
        });

        process.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error(`Python script error: ${data}`);
        });

        process.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            if (code === 0) {
                res.json({ success: true, message: 'Linear actuator test completed successfully', output: stdout });
            } else {
                res.status(500).json({ success: false, message: 'Linear actuator test failed', error: stderr });
            }
        });
    } catch (error) {
        console.error('Error testing linear actuator:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the linear actuator', error: error.message });
    }
});

module.exports = router;

================
File: routes/partRoutes.js
================
// File: routes/partRoutes.js

const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/', async (req, res) => {
    try {
        const parts = await partService.getAllParts();
        const characters = await characterService.getAllCharacters();
        res.render('parts', { title: 'Parts', parts, characters });
    } catch (error) {
        console.error('Error fetching parts:', error);
        res.status(500).send('An error occurred while fetching parts');
    }
});

router.get('/new/:type', async (req, res) => {
    try {
        const { type } = req.params;
        const characters = await characterService.getAllCharacters();
        res.render(`part-forms/${type}`, { 
            title: `Add ${type.charAt(0).toUpperCase() + type.slice(1)}`, 
            action: `/parts/${type}`, 
            part: {}, 
            characters 
        });
    } catch (error) {
        console.error('Error rendering new part form:', error);
        res.status(500).send('An error occurred while loading the new part form');
    }
});

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const part = await partService.getPartById(id);
        const characters = await characterService.getAllCharacters();
        res.render(`part-forms/${part.type}`, {
            title: `Edit ${part.type.charAt(0).toUpperCase() + part.type.slice(1)}`,
            action: `/parts/${part.type}/${part.id}`,
            part,
            characters
        });
    } catch (error) {
        console.error('Error fetching part for edit:', error);
        res.status(500).send('An error occurred while fetching the part');
    }
});

router.get('/all', async (req, res) => {
    try {
        const parts = await partService.getAllParts();
        res.json(parts);
    } catch (error) {
        console.error('Error fetching all parts:', error);
        res.status(500).json({ error: 'An error occurred while fetching parts' });
    }
});

router.get('/os-test', async (req, res) => {
    res.render('os-test', { title: 'OS Test' });
});

router.post('/os-test', async (req, res) => {
    const { partId, command } = req.body;

    try {
        const part = await partService.getPartById(partId);
        let scriptPath;
        if (part.type === 'linear-actuator') {
            scriptPath = path.join(__dirname, '..', 'scripts', 'linear_actuator_control.py');
        } else {
            scriptPath = path.join(__dirname, '..', 'scripts', `${part.type}_control.py`);
        }
        
        const process = spawn('python3', [scriptPath, ...command.split(' ').slice(2)]);

        let output = '';
        let error = '';

        process.stdout.on('data', (data) => {
            output += data.toString();
        });

        process.stderr.on('data', (data) => {
            error += data.toString();
        });

        process.on('close', (code) => {
            res.json({ output: output || error, exitCode: code });
        });
    } catch (error) {
        console.error('Error running OS test:', error);
        res.status(500).json({ error: 'An error occurred while running the OS test' });
    }
});

router.get('/os-test-stream', (req, res) => {
    const { command } = req.query;
    
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive'
    });

    const process = spawn('python3', command.split(' ').slice(1));

    process.stdout.on('data', (data) => {
        res.write(`data: ${JSON.stringify({output: data.toString()})}\n\n`);
    });

    process.stderr.on('data', (data) => {
        res.write(`data: ${JSON.stringify({output: `Error: ${data.toString()}`})}\n\n`);
    });

    process.on('close', (code) => {
        res.write(`data: ${JSON.stringify({done: true})}\n\n`);
        res.end();
    });
});

router.post('/:id/delete', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        await partService.deletePart(id);
        res.status(200).json({ message: 'Part deleted successfully' });
    } catch (error) {
        console.error('Error deleting part:', error);
        res.status(500).json({ error: 'An error occurred while deleting the part' });
    }
});

router.post('/linear-actuator/test', async (req, res) => {
    try {
        const { direction, speed, duration, directionPin, pwmPin } = req.body;
        const scriptPath = path.join(__dirname, '..', 'scripts', 'linear_actuator_control.py');
        const process = spawn('python3', [
            scriptPath,
            direction,
            speed.toString(),
            duration.toString(),
            directionPin.toString(),
            pwmPin.toString()
        ]);

        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log(`Python script output: ${data}`);
        });

        process.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error(`Python script error: ${data}`);
        });

        process.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            if (code === 0) {
                res.json({ success: true, message: 'Linear actuator test completed successfully', output: stdout });
            } else {
                res.status(500).json({ success: false, message: 'Linear actuator test failed', error: stderr });
            }
        });
    } catch (error) {
        console.error('Error testing linear actuator:', error);
        res.status(500).json({ success: false, message: 'An error occurred while testing the linear actuator', error: error.message });
    }
});

module.exports = router;

================
File: routes/sceneRoutes.js
================
// File: routes/sceneRoutes.js

const express = require('express');
const router = express.Router();
const sceneController = require('../controllers/sceneController');
const scenePlayerController = require('../controllers/scenePlayerController');

router.get('/', sceneController.getAllScenes);
router.get('/new', sceneController.newScene);
router.get('/:id', scenePlayerController.getScenePlayer);
router.get('/:id/edit', sceneController.getSceneById);
router.post('/', sceneController.createScene);
router.post('/:id', sceneController.updateScene);
router.delete('/:id', sceneController.deleteScene);
router.get('/:id/play', scenePlayerController.playScene);
router.post('/:id/stop', scenePlayerController.stopScene);
router.post('/stop-all', scenePlayerController.stopAllScenes);

module.exports = router;

================
File: routes/sensorRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const { spawn } = require('child_process');
const path = require('path');

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const part = await partService.getPartById(id);
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/sensor', { title: 'Edit Sensor', action: `/parts/sensor/${part.id}`, part, characters });
    } catch (error) {
        console.error('Error fetching sensor:', error);
        res.status(500).send('An error occurred while fetching the sensor: ' + error.message);
    }
});

router.post('/', async (req, res) => {
    try {
        const newSensor = {
            name: req.body.name,
            type: 'sensor',
            characterId: parseInt(req.body.characterId),
            sensorType: req.body.sensorType,
            gpioPin: parseInt(req.body.gpioPin) || 16,
            active: req.body.active === 'on'
        };
        const createdSensor = await partService.createPart(newSensor);
        console.log('Created sensor:', createdSensor);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating sensor:', error);
        res.status(500).send('An error occurred while creating the sensor: ' + error.message);
    }
});

router.post('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const updatedSensor = {
            id: id,
            name: req.body.name,
            type: 'sensor',
            characterId: parseInt(req.body.characterId),
            sensorType: req.body.sensorType,
            gpioPin: parseInt(req.body.gpioPin) || 16,
            active: req.body.active === 'on'
        };
        const result = await partService.updatePart(id, updatedSensor);
        console.log('Updated sensor:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating sensor:', error);
        res.status(500).send('An error occurred while updating the sensor: ' + error.message);
    }
});

router.get('/test-sensor', async (req, res) => {
    try {
        const sensorId = parseInt(req.query.id);
        const gpioPin = parseInt(req.query.gpioPin);

        if (isNaN(sensorId) || isNaN(gpioPin)) {
            throw new Error('Invalid sensor ID or GPIO pin');
        }

        const scriptPath = path.join(__dirname, '..', 'scripts', 'test_sensor.py');

        res.writeHead(200, {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
        });

        const python = spawn('sudo', ['python3', scriptPath, gpioPin.toString()]);

        python.stdout.on('data', (data) => {
            res.write(`data: ${data}\n\n`);
        });

        python.stderr.on('data', (data) => {
            console.error(`Python script error: ${data}`);
            res.write(`data: ${JSON.stringify({ error: data.toString() })}\n\n`);
        });

        python.on('close', (code) => {
            console.log(`Python script exited with code ${code}`);
            res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
            res.end();
        });

        req.on('close', () => {
            python.kill();
        });
    } catch (error) {
        console.error('Error testing sensor:', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

module.exports = router;

================
File: routes/servoRoutes.js
================
const express = require('express');
const router = express.Router();
const partService = require('../services/partService');
const characterService = require('../services/characterService');
const servoController = require('../controllers/servoController');

router.get('/:id/edit', async (req, res) => {
    try {
        const id = parseInt(req.params.id, 10);
        console.log('Editing Servo with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const part = await partService.getPartById(id);
        if (!part) {
            throw new Error('Part not found');
        }
        const characters = await characterService.getAllCharacters();
        res.render('part-forms/servo', { title: 'Edit Servo', action: `/parts/servo/${part.id}`, part, characters });
    } catch (error) {
        console.error('Error fetching servo:', error);
        res.status(500).send('An error occurred while fetching the servo: ' + error.message);
    }
});

router.post('/', async (req, res) => {
    try {
        const newServo = {
            name: req.body.name,
            type: 'servo',
            characterId: parseInt(req.body.characterId, 10),
            servoType: req.body.servoType,
            channel: parseInt(req.body.channel, 10),
            minPulse: parseInt(req.body.minPulse, 10),
            maxPulse: parseInt(req.body.maxPulse, 10),
            defaultAngle: parseInt(req.body.defaultAngle, 10)
        };
        const createdServo = await partService.createPart(newServo);
        console.log('Created servo:', createdServo);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error creating servo:', error);
        res.status(500).send('An error occurred while creating the servo: ' + error.message);
    }
});

router.post('/test', servoController.testServo);

router.post('/stop', servoController.stopServo);

router.post('/:id', async (req, res) => {
    try {
        console.log('Update Servo Route - Request params:', req.params);
        console.log('Update Servo Route - Request body:', req.body);

        const id = parseInt(req.params.id, 10);
        console.log('Updating Servo with ID:', id, 'Type:', typeof id);
        if (isNaN(id)) {
            throw new Error('Invalid part ID');
        }
        const updatedServo = {
            id: id,
            name: req.body.name,
            type: 'servo',
            characterId: parseInt(req.body.characterId, 10),
            servoType: req.body.servoType,
            channel: parseInt(req.body.channel, 10),
            minPulse: parseInt(req.body.minPulse, 10),
            maxPulse: parseInt(req.body.maxPulse, 10),
            defaultAngle: parseInt(req.body.defaultAngle, 10)
        };
        console.log('Updated Servo data:', updatedServo);
        const result = await partService.updatePart(id, updatedServo);
        console.log('Updated servo:', result);
        res.redirect('/parts');
    } catch (error) {
        console.error('Error updating servo:', error);
        res.status(500).send('An error occurred while updating the servo: ' + error.message);
    }
});

module.exports = router;

================
File: routes/soundRoutes.js
================
// File: routes/soundRoutes.js

const express = require('express');
const path = require('path');
const { spawn } = require('child_process');
const soundService = require('../services/soundService');
const multer = require('multer');
const fs = require('fs').promises;
const router = express.Router();

// Multer setup for file uploads
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, 'public/sounds/');
    },
    filename: function (req, file, cb) {
        cb(null, Date.now() + path.extname(file.originalname));
    }
});
const upload = multer({ storage: storage });

let soundPlayerProcess = null;

function startSoundPlayer() {
    if (!soundPlayerProcess) {
        const scriptPath = path.resolve(__dirname, '..', 'scripts', 'sound_player.py');
        soundPlayerProcess = spawn('python3', [scriptPath]);

        soundPlayerProcess.stdout.on('data', (data) => {
            console.log(`Sound player output: ${data}`);
        });

        soundPlayerProcess.stderr.on('data', (data) => {
            console.error(`Sound player error: ${data}`);
        });

        soundPlayerProcess.on('close', (code) => {
            console.log(`Sound player exited with code ${code}`);
            soundPlayerProcess = null;
        });
    }
}

router.get('/', async (req, res) => {
    try {
        const sounds = await soundService.getAllSounds();
        res.render('sounds', { title: 'Sounds', sounds });
    } catch (error) {
        console.error('Error fetching sounds:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.get('/new', (req, res) => {
    res.render('sound-form', { title: 'Add New Sound', action: '/sounds', sound: null });
});

router.get('/:id/edit', async (req, res) => {
    try {
        const sound = await soundService.getSoundById(parseInt(req.params.id));
        if (sound) {
            res.render('sound-form', { title: 'Edit Sound', action: `/sounds/${sound.id}`, sound });
        } else {
            res.status(404).json({ error: 'Sound not found', details: `No sound with id ${req.params.id}` });
        }
    } catch (error) {
        console.error('Error fetching sound:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.post('/', upload.single('sound_file'), async (req, res) => {
    try {
        const newSound = {
            name: req.body.name,
            filename: req.file.filename
        };
        await soundService.createSound(newSound);
        res.redirect('/sounds');
    } catch (error) {
        console.error('Error adding sound:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.post('/:id', upload.single('sound_file'), async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const updatedSound = {
            name: req.body.name
        };
        
        if (req.file) {
            const sound = await soundService.getSoundById(id);
            if (sound.filename) {
                const oldFilePath = path.join(__dirname, '../public/sounds', sound.filename);
                await fs.unlink(oldFilePath).catch(console.error);
            }
            updatedSound.filename = req.file.filename;
        }

        await soundService.updateSound(id, updatedSound);
        res.redirect('/sounds');
    } catch (error) {
        console.error('Error updating sound:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.post('/:id/play', async (req, res) => {
    try {
        const soundId = parseInt(req.params.id);
        console.log('Received request to play sound with ID:', soundId);

        const sound = await soundService.getSoundById(soundId);
        
        if (!sound) {
            console.error('Sound not found for ID:', soundId);
            return res.status(404).json({ error: 'Sound not found', details: `No sound with id ${soundId}`, soundId });
        }

        console.log('Found sound:', sound);

        const filePath = path.resolve(__dirname, '..', 'public', 'sounds', sound.filename);
        console.log('Absolute file path:', filePath);

        try {
            await fs.access(filePath, fs.constants.R_OK);
            console.log('File exists and is readable:', filePath);
        } catch (error) {
            console.error('File access error:', error);
            return res.status(404).json({ error: 'Sound file not accessible', details: error.message, filePath });
        }

        startSoundPlayer();

        if (!soundPlayerProcess) {
            return res.status(500).json({ error: 'Failed to start sound player' });
        }

        const command = `PLAY|${sound.id}|${filePath}\n`;
        soundPlayerProcess.stdin.write(command);

        res.status(200).json({ 
            message: 'Playing sound on character',
            sound: sound.name,
            file: sound.filename
        });

    } catch (error) {
        console.error('Error in /play route:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

router.post('/:id/delete', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const sound = await soundService.getSoundById(id);
        if (sound.filename) {
            const filePath = path.join(__dirname, '../public/sounds', sound.filename);
            await fs.unlink(filePath).catch(console.error);
        }
        await soundService.deleteSound(id);
        res.status(200).json({ message: 'Sound deleted successfully' });
    } catch (error) {
        console.error('Error deleting sound:', error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
});

module.exports = router;

================
File: scripts/active-mode.js
================
// File: scripts/active-mode.js

$(document).ready(function() {
    let isArmed = false;
    let currentEventSource = null;

    $('#characterSelect').change(fetchCharacterInfo);
    $('#addScenes').click(addScenes);
    $('#removeScenes').click(removeScenes);
    $('#activatedScenes').sortable().selectable();
    $('#armButton').click(armSystem);
    $('#disarmButton').click(disarmSystem);
    $('#stopAllSteps').click(stopAllSteps);

    // Load the first character by default
    loadFirstCharacter();

    function loadFirstCharacter() {
        const firstCharacter = $('#characterSelect option:first');
        if (firstCharacter.length > 0) {
            $('#characterSelect').val(firstCharacter.val()).trigger('change');
        }
    }

    function fetchCharacterInfo() {
        const characterId = $(this).val();
        if (characterId) {
            $.get(`/active-mode/character/${characterId}`, displayCharacterInfo)
                .fail(handleCharacterInfoError);
            fetchScenes(characterId);
        } else {
            clearCharacterInfo();
        }
    }

    function displayCharacterInfo(character) {
        let infoHtml = `<h3>${character.char_name}</h3><p>${character.char_description}</p>`;
        $('#characterInfo').html(infoHtml);
        
        if (character.image) {
            $('#characterImage').attr('src', `/images/characters/${character.image}`).attr('alt', character.char_name);
        } else {
            $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
        }
    }

    function handleCharacterInfoError(jqXHR, textStatus, errorThrown) {
        console.error("Error fetching character info:", textStatus, errorThrown);
        $('#characterInfo').html('<p>Failed to load character information. Please try again.</p>');
        $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
    }

    function clearCharacterInfo() {
        $('#characterInfo').empty();
        $('#availableScenes').empty();
        $('#activatedScenes').empty();
        $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
    }

    function fetchScenes(characterId) {
        $.get(`/active-mode/character/${characterId}/scenes`, displayScenes)
            .fail(handleSceneFetchError);
    }

    function displayScenes(scenes) {
        $('#availableScenes').empty();
        scenes.forEach(function(scene) {
            $('#availableScenes').append(`<option value="${scene.id}">${scene.scene_name}</option>`);
        });
    }

    function handleSceneFetchError(jqXHR, textStatus, errorThrown) {
        console.error("Error fetching scenes:", textStatus, errorThrown);
        $('#availableScenes').html('<option>Failed to load scenes</option>');
    }

    function addScenes() {
        $('#availableScenes option:selected').each(function() {
            const sceneId = $(this).val();
            const sceneName = $(this).text();
            $('#activatedScenes').append(`<li data-id="${sceneId}">${sceneName}</li>`);
            $(this).remove();
        });
    }

    function removeScenes() {
        $('#activatedScenes li.ui-selected').each(function() {
            const sceneId = $(this).data('id');
            const sceneName = $(this).text();
            $('#availableScenes').append(`<option value="${sceneId}">${sceneName}</option>`);
            $(this).remove();
        });
    }

    function armSystem() {
        if ($('#activatedScenes li').length === 0) {
            alert('Please select at least one scene to activate.');
            return;
        }
        isArmed = true;
        $(this).prop('disabled', true);
        $('#disarmButton').prop('disabled', false);
        $('#armStatus').text('ARMED').removeClass('disarmed').addClass('armed');
        logArmedModeOutput('System armed. Starting Active Mode.');
        startActiveModeLoop();
    }

    function disarmSystem() {
        isArmed = false;
        $(this).prop('disabled', true);
        $('#armButton').prop('disabled', false);
        $('#armStatus').text('DISARMED').removeClass('armed').addClass('disarmed');
        logArmedModeOutput('System disarmed. Active Mode stopped.');
        stopAllSteps();
    }

    function stopAllSteps() {
        if (currentEventSource) {
            currentEventSource.close();
        }
        $.post('/scenes/stop-all')
            .done(function(response) {
                logArmedModeOutput('All steps stopped: ' + response.message);
            })
            .fail(function(xhr, status, error) {
                console.error('Error stopping all steps:', error);
                logArmedModeOutput('Error stopping all steps: ' + error);
            });
    }

    function startActiveModeLoop() {
        const scenes = $('#activatedScenes li').map(function() {
            return $(this).data('id');
        }).get();

        function runNextScene(index) {
            if (!isArmed) return;
            if (index >= scenes.length) {
                index = 0; // Reset to the beginning of the list
            }
            const sceneId = scenes[index];
            logArmedModeOutput(`Starting execution of scene ${sceneId}`);
            runScene(sceneId).then(() => {
                logArmedModeOutput(`Completed execution of scene ${sceneId}`);
                setTimeout(() => runNextScene(index + 1), 5000); // 5 seconds between scenes
            }).catch((error) => {
                logArmedModeOutput(`Error executing scene ${sceneId}: ${error.message}`);
                setTimeout(() => runNextScene(index + 1), 5000); // Continue to next scene even if there's an error
            });
        }

        runNextScene(0);
    }

    function runScene(sceneId) {
        return new Promise((resolve, reject) => {
            if (currentEventSource) {
                currentEventSource.close();
            }
            currentEventSource = new EventSource(`/scenes/${sceneId}/play`);

            currentEventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleSceneExecutionUpdate(data);
            };

            currentEventSource.onerror = function(error) {
                console.error('EventSource failed:', error);
                currentEventSource.close();
                reject(new Error(`Failed to execute scene ${sceneId}`));
            };

            currentEventSource.addEventListener('close', function(event) {
                currentEventSource.close();
                resolve();
            });
        });
    }

    function handleSceneExecutionUpdate(data) {
        if (data.error) {
            logArmedModeOutput(`Error: ${data.error}`);
        } else if (data.message) {
            logArmedModeOutput(data.message);
        }
    }

    function logArmedModeOutput(message) {
        const timestamp = new Date().toLocaleTimeString();
        $('#armedModeOutput').append(`<p>[${timestamp}] ${message}</p>`);
        $('#armedModeOutput').scrollTop($('#armedModeOutput')[0].scrollHeight);
    }
});

================
File: scripts/audio.js
================
const { spawn, exec } = require('child_process');
const WebSocket = require('ws');
const path = require('path');

class Audio {
    constructor() {
        this.audioProcess = null;
        this.wss = null;
        this.audioDevice = 'plughw:CARD=Device,DEV=0';
        this.micVolume = 1.0;
        this.retryCount = 0;
        this.maxRetries = 3;
    }

    startStream(server) {
        this.wss = new WebSocket.Server({ server, path: '/audiostream' });

        this.wss.on('connection', (ws) => {
            console.log('New WebSocket connection for audio stream');
            if (!this.audioProcess) {
                this.startAudioProcess(ws);
            }

            ws.on('close', () => {
                console.log('WebSocket connection closed for audio stream');
            });
        });

        console.log('Audio stream server started');
    }

    startAudioProcess(ws) {
        const scriptPath = path.join(__dirname, 'sound_player.py');
        this.audioProcess = spawn('python3', [scriptPath]);

        this.audioProcess.stdout.on('data', (data) => {
            console.log(`Sound player output: ${data}`);
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(data);
            }
        });

        this.audioProcess.stderr.on('data', (data) => {
            console.error(`Sound player error: ${data}`);
        });

        this.audioProcess.on('close', (code) => {
            console.log(`Sound player exited with code ${code}`);
            this.audioProcess = null;
            if (this.retryCount < this.maxRetries) {
                this.retryCount++;
                console.log(`Retrying to start sound player (Attempt ${this.retryCount})`);
                this.startAudioProcess(ws);
            } else {
                console.error('Max retries reached. Unable to start sound player.');
            }
        });

        this.audioProcess.on('error', (error) => {
            console.error(`Error starting audio stream: ${error}`);
        });

        // Set the audio device
        this.setAudioDevice(this.audioDevice);
    }

    stopAudioProcess() {
        if (this.audioProcess) {
            this.audioProcess.kill();
            this.audioProcess = null;
        }
    }

    playSound(soundId, filePath) {
        if (this.audioProcess) {
            const command = `PLAY|${soundId}|${filePath}\n`;
            this.audioProcess.stdin.write(command);
        } else {
            console.error('Audio process is not running');
            this.startAudioProcess(this.wss.clients.values().next().value);
        }
    }

    stopSound(soundId) {
        if (this.audioProcess) {
            const command = `STOP|${soundId}\n`;
            this.audioProcess.stdin.write(command);
        } else {
            console.error('Audio process is not running');
        }
    }

    stopAllSounds() {
        if (this.audioProcess) {
            const command = `STOP_ALL\n`;
            this.audioProcess.stdin.write(command);
        } else {
            console.error('Audio process is not running');
        }
    }

    setMicVolume(volume) {
        this.micVolume = volume;
        console.log(`Mic volume set to: ${volume}`);
        // Implement mic volume control logic here if needed
    }

    setAudioDevice(device) {
        this.audioDevice = device;
        console.log(`Setting audio device to: ${device}`);
        if (this.audioProcess) {
            const command = `DEVICE|${device}\n`;
            this.audioProcess.stdin.write(command);
        }
    }

    getAudioDevices(callback) {
        console.log('Fetching audio devices...');
        exec('aplay -L', (error, stdout, stderr) => {
            if (error) {
                console.error(`Error getting audio devices: ${error}`);
                callback([]);
                return;
            }
            console.log('Raw audio device output:', stdout);
            const devices = stdout.split('\n')
                .filter(line => line.trim() !== '' && !line.startsWith(' '))
                .map(line => line.trim())
                .filter(line => line.includes('CARD=') || line === 'default');
            console.log('Parsed audio devices:', devices);
            callback(devices);
        });
    }
}

module.exports = new Audio();

================
File: scripts/camera.js
================
const { exec } = require('child_process');

class Camera {
    constructor() {
        this.streamProcess = null;
        this.nightMode = false;
        this.resolution = '640x480';
        this.framerate = '15';
    }

    startStream() {
        this.findAvailableVideoDevice((device) => {
            if (device) {
                this.startStreamWithDevice(device);
            } else {
                console.error('No available video devices found');
            }
        });
    }

    findAvailableVideoDevice(callback) {
        exec('ls /dev/video*', (error, stdout, stderr) => {
            if (error) {
                console.error('Error finding video devices:', error);
                callback(null);
                return;
            }
            const devices = stdout.trim().split('\n');
            console.log('Available video devices:', devices);
            if (devices.length > 0) {
                callback(devices[0]);
            } else {
                callback(null);
            }
        });
    }

    startStreamWithDevice(device) {
        const mjpegStreamerCommand = `mjpg_streamer -i "input_uvc.so -d ${device} -r ${this.resolution} -f ${this.framerate}" -o "output_http.so -p 8080"`;
        exec(mjpegStreamerCommand, (error, stdout, stderr) => {
            if (error) {
                console.error(`Error starting mjpg-streamer with device ${device}: ${error}`);
                console.error(`stderr: ${stderr}`);
                return;
            }
            console.log(`mjpg-streamer started successfully with device ${device}`);
            console.log(`stdout: ${stdout}`);
        });
    }

    stopStream() {
        exec('pkill mjpg_streamer', (error, stdout, stderr) => {
            if (error) {
                console.error(`Error stopping mjpg-streamer: ${error}`);
                return;
            }
            console.log('mjpg-streamer stopped successfully');
        });
    }

    toggleNightMode() {
        this.nightMode = !this.nightMode;
        console.log(`Night mode: ${this.nightMode ? 'ON' : 'OFF'}`);
        // Implement night mode logic here if your camera supports it
    }

    restartStream() {
        this.stopStream();
        setTimeout(() => {
            this.startStream();
        }, 1000); // Wait for 1 second before restarting the stream
    }
}

module.exports = new Camera();

================
File: scripts/led_control.py
================
import RPi.GPIO as GPIO
import time
import sys

def setup_gpio():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)

def cleanup_gpio():
    GPIO.cleanup()

def control_light(gpio_pin, state, duration, brightness=None):
    setup_gpio()
    GPIO.setup(gpio_pin, GPIO.OUT)

    try:
        if brightness is not None:
            pwm = GPIO.PWM(gpio_pin, 100)  # 100 Hz frequency
            pwm.start(0)
            if state.lower() == 'on':
                pwm.ChangeDutyCycle(int(brightness))
                print(f"LED on GPIO pin {gpio_pin} is ON with brightness {brightness}%")
            else:
                pwm.ChangeDutyCycle(0)
                print(f"LED on GPIO pin {gpio_pin} is OFF")
        else:
            if state.lower() == 'on':
                GPIO.output(gpio_pin, GPIO.HIGH)
                print(f"Light on GPIO pin {gpio_pin} is ON")
            elif state.lower() == 'off':
                GPIO.output(gpio_pin, GPIO.LOW)
                print(f"Light on GPIO pin {gpio_pin} is OFF")
            else:
                print("Invalid state. Use 'on' or 'off'.")
                return

        time.sleep(float(duration) / 1000)  # Convert duration to seconds
    finally:
        if brightness is not None:
            pwm.stop()
        cleanup_gpio()

if __name__ == "__main__":
    if len(sys.argv) < 4 or len(sys.argv) > 5:
        print("Usage: python light_control.py <gpio_pin> <state> <duration> [brightness]")
        sys.exit(1)

    gpio_pin = int(sys.argv[1])
    state = sys.argv[2]
    duration = int(sys.argv[3])
    brightness = int(sys.argv[4]) if len(sys.argv) == 5 else None

    try:
        control_light(gpio_pin, state, duration, brightness)
        print("Light control completed successfully")
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)
    finally:
        cleanup_gpio()

================
File: scripts/light_control.py
================
import RPi.GPIO as GPIO
import time
import sys

def setup_gpio():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)

def cleanup_gpio():
    GPIO.cleanup()

def control_light(gpio_pin, state, duration, brightness=None):
    setup_gpio()
    GPIO.setup(gpio_pin, GPIO.OUT)

    try:
        if brightness is not None:
            pwm = GPIO.PWM(gpio_pin, 100)  # 100 Hz frequency
            pwm.start(0)
            if state.lower() == 'on':
                pwm.ChangeDutyCycle(int(brightness))
                print(f"LED on GPIO pin {gpio_pin} is ON with brightness {brightness}%")
            else:
                pwm.ChangeDutyCycle(0)
                print(f"LED on GPIO pin {gpio_pin} is OFF")
        else:
            if state.lower() == 'on':
                GPIO.output(gpio_pin, GPIO.HIGH)
                print(f"Light on GPIO pin {gpio_pin} is ON")
            elif state.lower() == 'off':
                GPIO.output(gpio_pin, GPIO.LOW)
                print(f"Light on GPIO pin {gpio_pin} is OFF")
            else:
                print("Invalid state. Use 'on' or 'off'.")
                return

        time.sleep(float(duration) / 1000)  # Convert duration to seconds
    finally:
        if brightness is not None:
            pwm.stop()
        cleanup_gpio()

if __name__ == "__main__":
    if len(sys.argv) < 4 or len(sys.argv) > 5:
        print("Usage: python light_control.py <gpio_pin> <state> <duration> [brightness]")
        sys.exit(1)

    gpio_pin = int(sys.argv[1])
    state = sys.argv[2]
    duration = int(sys.argv[3])
    brightness = int(sys.argv[4]) if len(sys.argv) == 5 else None

    try:
        control_light(gpio_pin, state, duration, brightness)
        print("Light control completed successfully")
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)
    finally:
        cleanup_gpio()

================
File: scripts/linear_actuator_control.py
================
# File: scripts/linear_actuator_control.py

import RPi.GPIO as GPIO
import time
import sys

def setup_gpio(dir_pin, pwm_pin):
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(dir_pin, GPIO.OUT)
    GPIO.setup(pwm_pin, GPIO.OUT)
    return GPIO.PWM(pwm_pin, 100)  # 100Hz frequency

def control_actuator(direction, speed, duration, dir_pin, pwm_pin):
    pwm = setup_gpio(dir_pin, pwm_pin)
    
    try:
        GPIO.output(dir_pin, GPIO.LOW if direction == 'forward' else GPIO.HIGH)
        pwm.start(speed)
        time.sleep(duration / 1000)  # Convert duration to seconds
    finally:
        pwm.stop()
        GPIO.cleanup([dir_pin, pwm_pin])

if __name__ == "__main__":
    if len(sys.argv) < 4:
        print("Usage: python3 linear_actuator_control.py <direction> <speed> <duration> [dir_pin] [pwm_pin]")
        sys.exit(1)

    direction = sys.argv[1]
    speed = int(sys.argv[2])
    duration = int(sys.argv[3])
    dir_pin = int(sys.argv[4]) if len(sys.argv) > 4 else 18
    pwm_pin = int(sys.argv[5]) if len(sys.argv) > 5 else 13

    try:
        control_actuator(direction, speed, duration, dir_pin, pwm_pin)
        print("Linear actuator control successful")
    except Exception as e:
        print(f"Error controlling linear actuator: {str(e)}")
        sys.exit(1)

================
File: scripts/motor_control.py
================
import RPi.GPIO as GPIO
import sys
import time
import logging

# Set up logging
logging.basicConfig(filename='motor_control.log', level=logging.DEBUG, 
                    format='%(asctime)s - %(levelname)s - %(message)s')

def control_motor(direction, speed, duration, dir_pin, pwm_pin):
    logging.info(f"Controlling motor: direction={direction}, speed={speed}, duration={duration}, dir_pin={dir_pin}, pwm_pin={pwm_pin}")

    GPIO.setmode(GPIO.BCM)
    GPIO.setup(dir_pin, GPIO.OUT)
    GPIO.setup(pwm_pin, GPIO.OUT)

    pwm = GPIO.PWM(pwm_pin, 100)  # Use a default frequency of 100 Hz
    pwm.start(0)

    try:
        GPIO.output(dir_pin, GPIO.HIGH if direction == 'forward' else GPIO.LOW)
        pwm.ChangeDutyCycle(int(speed))
        time.sleep(int(duration) / 1000)  # Convert duration to seconds
        pwm.ChangeDutyCycle(0)
    except Exception as e:
        logging.error(f"Error controlling motor: {str(e)}")
        raise
    finally:
        pwm.stop()
        GPIO.cleanup([dir_pin, pwm_pin])

if __name__ == "__main__":
    if len(sys.argv) != 6:
        logging.error("Incorrect number of arguments")
        print("Usage: python motor_control.py <direction> <speed> <duration> <dir_pin> <pwm_pin>")
        sys.exit(1)

    direction = sys.argv[1]
    speed = sys.argv[2]
    duration = sys.argv[3]
    dir_pin = int(sys.argv[4])
    pwm_pin = int(sys.argv[5])

    try:
        control_motor(direction, speed, duration, dir_pin, pwm_pin)
        print("Motor control successful")
    except Exception as e:
        logging.error(f"Error: {str(e)}")
        print(f"Error: {str(e)}")
    finally:
        # Only clean up if GPIO was set up
        if GPIO.getmode() is not None:
            GPIO.cleanup()
            logging.info("GPIO cleanup completed")

================
File: scripts/scene-player.js
================
// File: scripts/scene-player.js

$(document).ready(function() {
    let currentStep = 0;
    let eventSource = null;
    const steps = sceneData.steps || [];

    function logMessage(message) {
        const logBox = $("#log-box");
        logBox.append(`<p>${new Date().toLocaleTimeString()} - ${message}</p>`);
        logBox.scrollTop(logBox[0].scrollHeight);
        console.log(message);
    }

    function updateCurrentStep(index) {
        $(".step").removeClass("current-step");
        if (index >= 0 && index < steps.length) {
            $(`#step-${index}`).addClass("current-step");
        }
    }

    $("#backward-btn").click(function() {
        if (currentStep > 0) {
            currentStep--;
            logMessage(`Moved to step ${currentStep + 1}: ${steps[currentStep].name}`);
            updateCurrentStep(currentStep);
        } else {
            logMessage("Already at the beginning of the scene");
        }
    });

    $("#forward-btn").click(function() {
        if (currentStep < steps.length - 1) {
            currentStep++;
            logMessage(`Moved to step ${currentStep + 1}: ${steps[currentStep].name}`);
            updateCurrentStep(currentStep);
        } else {
            logMessage("Reached the end of the scene");
        }
    });

    $("#run-btn").click(function() {
        $(this).prop('disabled', true);
        $("#backward-btn").prop('disabled', true);
        $("#forward-btn").prop('disabled', true);
        logMessage(`Running scene from step ${currentStep + 1}`);
        runScene();
    });

    $("#stop-btn").click(function() {
        stopAllSteps();
    });

    function runScene() {
        if (eventSource) {
            eventSource.close();
        }

        eventSource = new EventSource(`/scenes/${sceneData.id}/play?startStep=${currentStep}`);

        eventSource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            if (data.message) {
                logMessage(data.message);
            }
            if (data.currentStep !== undefined) {
                currentStep = data.currentStep;
                updateCurrentStep(currentStep);
            }
            if (data.error) {
                logMessage(`Error: ${data.error}`);
            }
        };

        eventSource.onerror = function(error) {
            console.error('EventSource failed:', error);
            eventSource.close();
            resetControlButtons();
            logMessage("Scene execution stopped due to an error");
        };

        eventSource.addEventListener('close', function(event) {
            eventSource.close();
            resetControlButtons();
            logMessage("Scene execution completed");
        });
    }

    function stopAllSteps() {
        if (eventSource) {
            eventSource.close();
        }

        $.ajax({
            url: `/scenes/${sceneData.id}/stop`,
            method: 'POST',
            success: function(response) {
                logMessage("All steps stopped");
                resetControlButtons();
            },
            error: function(xhr, status, error) {
                console.error('Error stopping steps:', error);
                logMessage(`Error stopping steps: ${error}`);
                resetControlButtons();
            }
        });
    }

    function resetControlButtons() {
        $("#run-btn").prop('disabled', false);
        $("#backward-btn").prop('disabled', false);
        $("#forward-btn").prop('disabled', false);
    }

    // Initial scene overview
    logMessage(`Scene Overview: "${sceneData.scene_name}"`);
    logMessage(`Total steps: ${steps.length}`);
    steps.forEach((step, index) => {
        logMessage(`Step ${index + 1}: ${step.name} (Type: ${step.type}${step.concurrent ? ', Concurrent' : ''})`);
    });
});

================
File: scripts/sensor_control.py
================
import RPi.GPIO as GPIO
import time
import sys

def setup_gpio():
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)

def cleanup_gpio():
    GPIO.cleanup()

def control_sensor(gpio_pin, timeout):
    setup_gpio()
    GPIO.setup(gpio_pin, GPIO.IN)

    print(f"Monitoring sensor on GPIO pin {gpio_pin} for {timeout} seconds")

    end_time = time.time() + float(timeout)
    while time.time() < end_time:
        if GPIO.input(gpio_pin):
            print("Motion detected!")
            return True
        time.sleep(0.1)

    print("No motion detected within timeout period")
    return False

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python sensor_control.py <gpio_pin> <timeout>")
        sys.exit(1)

    gpio_pin = int(sys.argv[1])
    timeout = float(sys.argv[2])

    try:
        motion_detected = control_sensor(gpio_pin, timeout)
        print(f"Motion detected: {motion_detected}")
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)
    finally:
        cleanup_gpio()

    sys.exit(0 if motion_detected else 1)

================
File: scripts/servo_control.py
================
import RPi.GPIO as GPIO
import sys
import time

def setup_gpio(pin):
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(pin, GPIO.OUT)
    return GPIO.PWM(pin, 50)  # 50 Hz PWM frequency

def angle_to_duty_cycle(angle):
    return 2.5 + (angle / 18)  # Maps 0-180 degrees to 2.5-12.5% duty cycle

def control_servo(pin, angle, frequency, duty_cycle, duration):
    pwm = setup_gpio(pin)
    try:
        pwm.ChangeFrequency(frequency)
        pwm.start(duty_cycle)
        pwm.ChangeDutyCycle(angle_to_duty_cycle(angle))
        time.sleep(duration / 1000)  # Convert duration to seconds
    finally:
        pwm.stop()
        GPIO.cleanup(pin)

if __name__ == "__main__":
    if len(sys.argv) != 6:
        print("Usage: python servo_control.py <pin> <angle> <frequency> <duty_cycle> <duration>")
        sys.exit(1)

    pin = int(sys.argv[1])
    angle = float(sys.argv[2])
    frequency = float(sys.argv[3])
    duty_cycle = float(sys.argv[4])
    duration = int(sys.argv[5])

    try:
        control_servo(pin, angle, frequency, duty_cycle, duration)
        print("Servo control successful")
    except Exception as e:
        print(f"Error controlling servo: {str(e)}")
        sys.exit(1)

================
File: scripts/sound_player.py
================
import sys
import json
import signal
import subprocess
from threading import Thread, Event, Lock

class SoundPlayer:
    def __init__(self):
        self.processes = {}
        self.exit_event = Event()
        self.lock = Lock()
        self.audio_device = 'default'

    def play_sound(self, sound_id, file_path):
        with self.lock:
            if sound_id in self.processes:
                self.stop_sound(sound_id)
            
            try:
                process = subprocess.Popen(['aplay', '-D', self.audio_device, file_path], 
                                           stdout=subprocess.PIPE, 
                                           stderr=subprocess.PIPE)
                self.processes[sound_id] = process
                print(json.dumps({"status": "playing", "sound_id": sound_id, "file": file_path}))
                sys.stdout.flush()
                
                def wait_for_completion():
                    stdout, stderr = process.communicate()
                    with self.lock:
                        if sound_id in self.processes and self.processes[sound_id] == process:
                            if process.returncode == 0 and not self.exit_event.is_set():
                                print(json.dumps({"status": "finished", "sound_id": sound_id, "file": file_path}))
                            else:
                                print(json.dumps({"status": "error", "sound_id": sound_id, "file": file_path, "error": stderr.decode()}))
                            sys.stdout.flush()
                            del self.processes[sound_id]
                
                Thread(target=wait_for_completion).start()
            except Exception as e:
                print(json.dumps({"status": "error", "sound_id": sound_id, "file": file_path, "error": str(e)}))
                sys.stdout.flush()

    def stop_sound(self, sound_id):
        with self.lock:
            if sound_id in self.processes:
                process = self.processes[sound_id]
                process.terminate()
                process.wait()
                del self.processes[sound_id]
                print(json.dumps({"status": "stopped", "sound_id": sound_id}))
                sys.stdout.flush()

    def stop_all_sounds(self):
        with self.lock:
            for sound_id, process in list(self.processes.items()):
                process.terminate()
                process.wait()
                del self.processes[sound_id]
                print(json.dumps({"status": "stopped", "sound_id": sound_id}))
                sys.stdout.flush()
        print(json.dumps({"status": "all_stopped"}))
        sys.stdout.flush()

    def run(self):
        while not self.exit_event.is_set():
            try:
                command = input().strip()
                if command == "EXIT":
                    break
                elif command == "STOP_ALL":
                    self.stop_all_sounds()
                elif command.startswith("DEVICE|"):
                    _, self.audio_device = command.split("|")
                    print(json.dumps({"status": "device_set", "device": self.audio_device}))
                    sys.stdout.flush()
                else:
                    cmd, sound_id, file_path = command.split("|")
                    if cmd == "PLAY":
                        self.play_sound(sound_id, file_path)
                    elif cmd == "STOP":
                        self.stop_sound(sound_id)
            except Exception as e:
                print(json.dumps({"status": "error", "error": str(e)}))
                sys.stdout.flush()

        self.stop_all_sounds()

def signal_handler(signum, frame):
    player.exit_event.set()

if __name__ == "__main__":
    player = SoundPlayer()
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    player.run()

================
File: scripts/test_sensor.py
================
from gpiozero import MotionSensor
import json
import sys
import time

def test_motion_sensor(pin, duration=30):
    pir = MotionSensor(pin)
    end_time = time.time() + duration

    while time.time() < end_time:
        if pir.motion_detected:
            print(json.dumps({"status": "Motion Detected"}), flush=True)
        else:
            print(json.dumps({"status": "No Motion"}), flush=True)
        time.sleep(0.5)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(json.dumps({"error": "Usage: python test_sensor.py <pin>"}), file=sys.stderr)
        sys.exit(1)
    
    try:
        pin = int(sys.argv[1])
        test_motion_sensor(pin)
    except ValueError:
        print(json.dumps({"error": "Invalid GPIO pin number"}), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(json.dumps({"error": str(e)}), file=sys.stderr)
        sys.exit(1)

================
File: services/characterService.js
================
const fs = require('fs').promises;
const path = require('path');

const dataPath = path.join(__dirname, '../data/characters.json');

const getAllCharacters = async () => {
    try {
        const data = await fs.readFile(dataPath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
};

const getCharacterById = async (id) => {
    const characters = await getAllCharacters();
    return characters.find(character => character.id === parseInt(id));
};

const createCharacter = async (characterData) => {
    const characters = await getAllCharacters();
    const newCharacter = {
        id: characters.length > 0 ? Math.max(...characters.map(c => c.id)) + 1 : 1,
        ...characterData
    };
    characters.push(newCharacter);
    await fs.writeFile(dataPath, JSON.stringify(characters, null, 2));
    return newCharacter;
};

const updateCharacter = async (id, characterData) => {
    const characters = await getAllCharacters();
    const index = characters.findIndex(character => character.id === parseInt(id));
    if (index !== -1) {
        characters[index] = { ...characters[index], ...characterData, id: parseInt(id) };
        await fs.writeFile(dataPath, JSON.stringify(characters, null, 2));
        return characters[index];
    }
    throw new Error('Character not found');
};

const deleteCharacter = async (id) => {
    const characters = await getAllCharacters();
    const filteredCharacters = characters.filter(character => character.id !== parseInt(id));
    if (filteredCharacters.length === characters.length) {
        throw new Error('Character not found');
    }
    await fs.writeFile(dataPath, JSON.stringify(filteredCharacters, null, 2));
};

module.exports = {
    getAllCharacters,
    getCharacterById,
    createCharacter,
    updateCharacter,
    deleteCharacter
};

================
File: services/partService.js
================
const fs = require('fs').promises;
const path = require('path');

const dataPath = path.join(__dirname, '../data/parts.json');

const getAllParts = async () => {
    try {
        const data = await fs.readFile(dataPath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
};

const getPartById = async (id) => {
    console.log('Getting part by ID:', id, 'Type:', typeof id);
    if (id === undefined || id === null) {
        throw new Error('Part ID is required');
    }
    const parts = await getAllParts();
    const part = parts.find(part => part.id === parseInt(id, 10));
    if (!part) {
        console.log(`Part not found with id: ${id}`);
        throw new Error(`Part not found with id: ${id}`);
    }
    console.log('Found part:', part);
    return part;
};

const createPart = async (partData) => {
    const parts = await getAllParts();
    const newPart = {
        id: parts.length > 0 ? Math.max(...parts.map(p => p.id)) + 1 : 1,
        ...partData
    };
    
    if (newPart.type === 'servo') {
        newPart.servoType = partData.servoType;
        newPart.channel = partData.channel;
        newPart.minPulse = partData.minPulse;
        newPart.maxPulse = partData.maxPulse;
        newPart.defaultAngle = partData.defaultAngle;
    }
    
    parts.push(newPart);
    await fs.writeFile(dataPath, JSON.stringify(parts, null, 2));
    return newPart;
};

const updatePart = async (id, partData) => {
    console.log('Updating part - ID:', id, 'Type:', typeof id);
    console.log('Updating part - Data:', partData);
    const parts = await getAllParts();
    const index = parts.findIndex(part => part.id === parseInt(id, 10));
    console.log('Found part index:', index);
    if (index === -1) {
        console.log(`Part not found with id: ${id}`);
        throw new Error(`Part not found with id: ${id}`);
    }
    parts[index] = { ...parts[index], ...partData, id: parseInt(id, 10) };
    
    if (parts[index].type === 'servo') {
        parts[index].servoType = partData.servoType;
        parts[index].channel = partData.channel;
        parts[index].minPulse = partData.minPulse;
        parts[index].maxPulse = partData.maxPulse;
        parts[index].defaultAngle = partData.defaultAngle;
    }
    
    await fs.writeFile(dataPath, JSON.stringify(parts, null, 2));
    console.log('Updated part:', parts[index]);
    return parts[index];
};

const deletePart = async (id) => {
    const parts = await getAllParts();
    const filteredParts = parts.filter(part => part.id !== parseInt(id, 10));
    if (filteredParts.length === parts.length) {
        throw new Error(`Part not found with id: ${id}`);
    }
    await fs.writeFile(dataPath, JSON.stringify(filteredParts, null, 2));
};

module.exports = {
    getAllParts,
    getPartById,
    createPart,
    updatePart,
    deletePart
};

================
File: services/sceneService.js
================
const fs = require('fs').promises;
const path = require('path');

const dataPath = path.join(__dirname, '../data/scenes.json');

const getAllScenes = async () => {
    try {
        const data = await fs.readFile(dataPath, 'utf8');
        let scenes = JSON.parse(data);
        scenes = scenes.map(scene => ({
            ...scene,
            id: parseInt(scene.id)
        }));
        return scenes;
    } catch (error) {
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
};

const getSceneById = async (id) => {
    const scenes = await getAllScenes();
    return scenes.find(scene => scene.id === parseInt(id));
};

const getScenesByCharacterId = async (characterId) => {
    const scenes = await getAllScenes();
    return scenes.filter(scene => scene.character_id === parseInt(characterId));
};

const getNextId = (scenes) => {
    return scenes.length > 0 ? Math.max(...scenes.map(s => parseInt(s.id) || 0)) + 1 : 1;
};

const createScene = async (sceneData) => {
    const scenes = await getAllScenes();
    const newScene = {
        id: getNextId(scenes),
        character_id: parseInt(sceneData.character_id),
        scene_name: sceneData.scene_name,
        steps: sceneData.steps || []
    };
    scenes.push(newScene);
    await fs.writeFile(dataPath, JSON.stringify(scenes, null, 2));
    return newScene;
};

const updateScene = async (id, sceneData) => {
    const scenes = await getAllScenes();
    const index = scenes.findIndex(scene => scene.id === parseInt(id));
    if (index !== -1) {
        scenes[index] = {
            ...scenes[index],
            ...sceneData,
            id: parseInt(id),
            character_id: parseInt(sceneData.character_id),
            steps: sceneData.steps || scenes[index].steps
        };
        await fs.writeFile(dataPath, JSON.stringify(scenes, null, 2));
        return scenes[index];
    }
    return null; // Return null instead of throwing an error
};

const deleteScene = async (id) => {
    const scenes = await getAllScenes();
    const filteredScenes = scenes.filter(scene => scene.id !== parseInt(id));
    if (filteredScenes.length === scenes.length) {
        return false; // Indicate that no scene was deleted
    }
    await fs.writeFile(dataPath, JSON.stringify(filteredScenes, null, 2));
    return true; // Indicate successful deletion
};

module.exports = {
    getAllScenes,
    getSceneById,
    getScenesByCharacterId,
    createScene,
    updateScene,
    deleteScene
};

================
File: services/soundService.js
================
// File: services/soundService.js

const fs = require('fs').promises;
const path = require('path');

const dataPath = path.join(__dirname, '../data/sounds.json');

const getAllSounds = async () => {
    try {
        const data = await fs.readFile(dataPath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
};

const getSoundById = async (id) => {
    const sounds = await getAllSounds();
    return sounds.find(sound => sound.id === parseInt(id));
};

const getNextId = (sounds) => {
    return sounds.length > 0 ? Math.max(...sounds.map(s => s.id)) + 1 : 1;
};

const createSound = async (soundData) => {
    const sounds = await getAllSounds();
    const newSound = {
        id: getNextId(sounds),
        ...soundData
    };
    sounds.push(newSound);
    await fs.writeFile(dataPath, JSON.stringify(sounds, null, 2));
    return newSound;
};

const updateSound = async (id, soundData) => {
    const sounds = await getAllSounds();
    const index = sounds.findIndex(sound => sound.id === parseInt(id));
    if (index !== -1) {
        sounds[index] = { ...sounds[index], ...soundData, id: parseInt(id) };
        await fs.writeFile(dataPath, JSON.stringify(sounds, null, 2));
        return sounds[index];
    }
    throw new Error('Sound not found');
};

const deleteSound = async (id) => {
    const sounds = await getAllSounds();
    const filteredSounds = sounds.filter(sound => sound.id !== parseInt(id));
    if (filteredSounds.length === sounds.length) {
        throw new Error('Sound not found');
    }
    await fs.writeFile(dataPath, JSON.stringify(filteredSounds, null, 2));
};

module.exports = {
    getAllSounds,
    getSoundById,
    createSound,
    updateSound,
    deleteSound
};

================
File: views/part-forms/led.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="light">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="gpioPin">GPIO Pin:</label>
            <input type="number" id="gpioPin" name="gpioPin" value="<%= part.gpioPin || 26 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>
    <div id="lightTest">
        <h2>Test LED - fo shizzle</h2>
        <div>
            <label for="state">State:</label>
            <select id="state">
                <option value="on">On</option>
                <option value="off">Off</option>
            </select>
        </div>
        <div>
            <label for="duration">Duration (ms):</label>
            <input type="number" id="duration" value="1000" min="100" max="10000">
        </div>
        <button onclick="testPart()">Test Light</button>
    </div>
    <a href="/parts" class="button">Back to Parts</a>

    <script>
        function testPart() {
            const partData = {
                part_id: <%= part.id || 'null' %>,
                type: 'light',
                state: document.getElementById('state').value,
                duration: parseInt(document.getElementById('duration').value),
                gpioPin: parseInt(document.getElementById('gpioPin').value)
            };

            fetch('/parts/light/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(partData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Light test successful:', data.message);
                } else {
                    console.error('Light test failed:', data.message);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
            });
        }
    </script>
</body>
</html>

================
File: views/part-forms/light.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="light">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="gpioPin">GPIO Pin:</label>
            <input type="number" id="gpioPin" name="gpioPin" value="<%= part.gpioPin || 26 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>
    <div id="lightTest">
        <h2>Test Light</h2>
        <div>
            <label for="state">State:</label>
            <select id="state">
                <option value="on">On</option>
                <option value="off">Off</option>
            </select>
        </div>
        <div>
            <label for="duration">Duration (ms):</label>
            <input type="number" id="duration" value="1000" min="100" max="10000">
        </div>
        <button onclick="testPart()">Test Light</button>
    </div>
    <a href="/parts" class="button">Back to Parts</a>

    <script>
        function testPart() {
            const partData = {
                part_id: <%= part.id || 'null' %>,
                type: 'light',
                state: document.getElementById('state').value,
                duration: parseInt(document.getElementById('duration').value),
                gpioPin: parseInt(document.getElementById('gpioPin').value)
            };

            fetch('/parts/light/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(partData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Light test successful:', data.message);
                  //  alert('Light test successful: ' + data.message);
                } else {
                    console.error('Light test failed:', data.message);
                  //  alert('Light test failed: ' + data.message);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
                alert('An error occurred while testing the light');
            });
        }
    </script>
</body>
</html>

================
File: views/part-forms/linear-actuator.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="linear-actuator">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="directionPin">Direction GPIO Pin:</label>
            <input type="number" id="directionPin" name="directionPin" value="<%= part.directionPin || 18 %>" required>
        </div>
        <div>
            <label for="pwmPin">PWM Pin:</label>
            <input type="number" id="pwmPin" name="pwmPin" value="<%= part.pwmPin || 13 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>

    <div id="actuatorTest">
        <h2>Test Linear Actuator</h2>
        <div>
            <label for="direction">Direction:</label>
            <select id="direction">
                <option value="forward">Forward</option>
                <option value="backward">Backward</option>
            </select>
        </div>
        <div>
            <label for="speed">Speed:</label>
            <input type="range" id="speed" min="0" max="100" value="50">
            <span id="speedValue">50</span>
        </div>
        <div>
            <label for="duration">Duration (ms):</label>
            <input type="range" id="duration" min="100" max="5000" value="1000" step="100">
            <span id="durationValue">1000</span>
        </div>
        <button onclick="testPart()">Test Linear Actuator</button>
    </div>

    <a href="/parts" class="button">Back to Parts</a>

    <script>
        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speedValue').textContent = this.value;
        });
        document.getElementById('duration').addEventListener('input', function() {
            document.getElementById('durationValue').textContent = this.value;
        });

        function testPart() {
            const partData = {
                direction: document.getElementById('direction').value,
                speed: parseInt(document.getElementById('speed').value),
                duration: parseInt(document.getElementById('duration').value),
                directionPin: parseInt(document.getElementById('directionPin').value),
                pwmPin: parseInt(document.getElementById('pwmPin').value)
            };

            fetch('/parts/linear-actuator/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(partData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Linear actuator test successful:', data.message);
                } else {
                    console.error('Linear actuator test failed:', data.message);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
            });
        }
    </script>
</body>
</html>

================
File: views/part-forms/motor-control.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="motor">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="directionPin">Direction GPIO Pin:</label>
            <input type="number" id="directionPin" name="directionPin" value="<%= part.directionPin || 18 %>" required>
        </div>
        <div>
            <label for="pwmPin">PWM Pin:</label>
            <input type="number" id="pwmPin" name="pwmPin" value="<%= part.pwmPin || 13 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>

    <div id="motorTest">
        <h2>Test Motor</h2>
        <div>
            <label for="direction">Direction:</label>
            <select id="direction">
                <option value="forward">Forward</option>
                <option value="backward">Backward</option>
            </select>
        </div>
        <div>
            <label for="speed">Speed:</label>
            <input type="range" id="speed" min="0" max="100" value="50">
            <span id="speedValue">50</span>
        </div>
        <div>
            <label for="duration">Duration (ms):</label>
            <input type="range" id="duration" min="100" max="5000" value="1000" step="100">
            <span id="durationValue">1000</span>
        </div>
        <button onclick="testPart()">Test Motor</button>
        <button onclick="openOSTestForm()">OS Test</button>
    </div>

    <div id="osTestForm" style="display: none;">
        <h2>OS Test</h2>
        <select id="osTestPart">
            <!-- Options will be populated dynamically -->
        </select>
        <textarea id="osTestCommand" rows="4" cols="50"></textarea>
        <button onclick="runOSTest()">Run</button>
        <div id="osTestResult"></div>
    </div>

    <a href="/parts" class="button">Back to Parts</a>

    <script>
        // Update speed and duration values
        document.getElementById('speed').addEventListener('input', function() {
            document.getElementById('speedValue').textContent = this.value;
        });
        document.getElementById('duration').addEventListener('input', function() {
            document.getElementById('durationValue').textContent = this.value;
        });

        function testPart() {
            const partId = document.querySelector('input[name="id"]')?.value;
            const partData = {
                id: partId,
                type: 'motor',
                direction: document.getElementById('direction').value,
                speed: parseInt(document.getElementById('speed').value),
                duration: parseInt(document.getElementById('duration').value),
                directionPin: parseInt(document.getElementById('directionPin').value),
                pwmPin: parseInt(document.getElementById('pwmPin').value)
            };

            fetch('/parts/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(partData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Motor test successful');
                } else {
                    alert('Motor test failed: ' + data.message);
                }
            })
            .catch((error) => {
                console.error('Error:', error);
                alert('An error occurred while testing the motor. Check console for details.');
            });
        }

        function openOSTestForm() {
            document.getElementById('osTestForm').style.display = 'block';
            fetchAllParts();
        }

        function fetchAllParts() {
            fetch('/parts/all')
                .then(response => response.json())
                .then(parts => {
                    const select = document.getElementById('osTestPart');
                    select.innerHTML = '';
                    parts.forEach(part => {
                        const option = document.createElement('option');
                        option.value = part.id;
                        option.textContent = `${part.name} (${part.type})`;
                        select.appendChild(option);
                    });
                })
                .catch(error => console.error('Error fetching parts:', error));
        }

        function runOSTest() {
            const partId = document.getElementById('osTestPart').value;
            const command = document.getElementById('osTestCommand').value;

            fetch('/parts/os-test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ partId, command })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('osTestResult').textContent = data.output;
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('osTestResult').textContent = 'An error occurred during the OS test.';
            });
        }
    </script>
</body>
</html>

================
File: views/part-forms/motor.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="motor">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="directionPin">Direction GPIO Pin:</label>
            <input type="number" id="directionPin" name="directionPin" value="<%= part.directionPin || 18 %>" required>
        </div>
        <div>
            <label for="pwmPin">PWM Pin:</label>
            <input type="number" id="pwmPin" name="pwmPin" value="<%= part.pwmPin || 13 %>" required>
        </div>
        <button type="submit">Save Part</button>
    </form>

    <a href="/parts" class="button">Back to Parts</a>
</body>
</html>

================
File: views/part-forms/sensor.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&display=swap');

        .motion-detected {
            color: red;
            font-family: 'Creepster', cursive;
            font-size: 1.2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="sensor">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Sensor Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="sensorType">Type:</label>
            <select id="sensorType" name="sensorType" required>
                <option value="motion" <%= part.sensorType === 'motion' ? 'selected' : '' %>>Motion</option>
                <option value="sound" <%= part.sensorType === 'sound' ? 'selected' : '' %>>Sound</option>
            </select>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="gpioPin">GPIO Pin:</label>
            <input type="number" id="gpioPin" name="gpioPin" value="<%= part.gpioPin || '' %>" required>
        </div>
        <div>
            <label for="active">
                <input type="checkbox" id="active" name="active" <%= part.active ? 'checked' : '' %>>
                Active
            </label>
        </div>
        <button type="submit">Save Sensor</button>
    </form>

    <div id="testArea" style="margin-top: 20px;">
        <h2>Test Sensor</h2>
        <p id="statusText">Sensor status: Not testing</p>
        <button id="startTest">Start Test</button>
        <button id="stopTest" disabled>Stop Test</button>
        <div id="testResults" style="margin-top: 10px;"></div>
    </div>

    <a href="/parts" class="button">Back to Parts</a>

    <script>
        let eventSource;

        function updateSensorStatus(status) {
            const statusText = $('#statusText');
            statusText.text('Sensor status: ' + status);

            if (status === 'Motion Detected') {
                statusText.addClass('motion-detected');
            } else {
                statusText.removeClass('motion-detected');
            }
        }

        function startTest() {
            const sensorId = $('input[name="id"]').val();
            const gpioPin = $('#gpioPin').val();

            eventSource = new EventSource(`/parts/sensor/test-sensor?id=${sensorId}&gpioPin=${gpioPin}`);

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.status) {
                    updateSensorStatus(data.status);
                } else if (data.error) {
                    console.error('Error:', data.error);
                    updateSensorStatus('Error: ' + data.error);
                    stopTest();
                } else if (data.done) {
                    stopTest();
                }
            };

            eventSource.onerror = function(event) {
                console.error('EventSource failed:', event);
                stopTest();
            };

            $('#startTest').prop('disabled', true);
            $('#stopTest').prop('disabled', false);
        }

        function stopTest() {
            if (eventSource) {
                eventSource.close();
            }
            $('#startTest').prop('disabled', false);
            $('#stopTest').prop('disabled', true);
            updateSensorStatus('Not testing');
        }

        $('#startTest').click(startTest);
        $('#stopTest').click(stopTest);

        $('#sensorType').change(function() {
            if ($(this).val() === 'sound') {
                $('#gpioPin').prop('disabled', true);
            } else {
                $('#gpioPin').prop('disabled', false);
            }
        });

        // Trigger change event on page load
        $('#sensorType').change();
    </script>
</body>
</html>

================
File: views/part-forms/servo.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .channel-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .channel-button {
            padding: 10px;
            text-align: center;
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            cursor: pointer;
        }
        .channel-button.selected {
            background-color: #00ff00;
            color: #000000;
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <input type="hidden" name="type" value="servo">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="servoType">Servo Type:</label>
            <select id="servoType" name="servoType" required onchange="updateServoDescription(document.getElementById('testAngle').value)">
                <option value="DS3240MG" <%= (part.servoType === 'DS3240MG') ? 'selected' : '' %>>DS3240MG (40KG Digital RC Servo)</option>
                <option value="FS90R" <%= (part.servoType === 'FS90R') ? 'selected' : '' %>>FITEC FS90R (Continuous Rotation)</option>
                <option value="MG90S" <%= (part.servoType === 'MG90S') ? 'selected' : '' %>>MG90S Servo</option>
                <option value="BILDA" <%= (part.servoType === 'BILDA') ? 'selected' : '' %>>BILDA Dual Mode Servo</option>
            </select>
        </div>
        <div>
            <label for="channel">PCA9685 Channel:</label>
            <input type="number" id="channel" name="channel" value="<%= part.channel || 0 %>" min="0" max="15" required readonly>
        </div>
        <div>
            <label>Channel Position:</label>
            <div class="channel-grid">
                <% for (let i = 0; i < 16; i++) { %>
                    <div class="channel-button" data-channel="<%= i %>">
                        <%= i %> (<%= ['Top', 'Top', 'Top', 'Top', 'Upper Mid', 'Upper Mid', 'Upper Mid', 'Upper Mid', 'Lower Mid', 'Lower Mid', 'Lower Mid', 'Lower Mid', 'Bottom', 'Bottom', 'Bottom', 'Bottom'][i] %>)
                    </div>
                <% } %>
            </div>
        </div>
        <div>
            <label for="minPulse">Min Pulse (μs):</label>
            <input type="number" id="minPulse" name="minPulse" value="<%= part.minPulse || 500 %>" required>
        </div>
        <div>
            <label for="maxPulse">Max Pulse (μs):</label>
            <input type="number" id="maxPulse" name="maxPulse" value="<%= part.maxPulse || 2500 %>" required>
        </div>
        <div>
            <label for="defaultAngle">Default Angle:</label>
            <input type="number" id="defaultAngle" name="defaultAngle" value="<%= part.defaultAngle || 90 %>" min="0" max="180" required>
        </div>
        <button type="submit">Save Part</button>
    </form>
    <div id="servoTest">
        <h2>Test Servo</h2>
        <div>
            <label for="testAngle">Angle (0-180) / Speed for FS90R:</label>
            <input type="range" id="testAngle" min="0" max="180" value="90">
            <span id="angleValue">90</span>
        </div>
        <p id="servoDescription"></p>
        <button onclick="testServo()">Test Servo</button>
        <button onclick="stopServo()">Stop Test</button>
    </div>
    <a href="/parts" class="button">Back to Parts</a>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const channelButtons = document.querySelectorAll('.channel-button');
            const channelInput = document.getElementById('channel');

            channelButtons.forEach(button => {
                button.addEventListener('click', function() {
                    channelButtons.forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    channelInput.value = this.dataset.channel;
                });
            });

            // Set initial selected channel
            const initialChannel = parseInt(channelInput.value);
            channelButtons[initialChannel].classList.add('selected');

            // Initialize servo description
            updateServoDescription(document.getElementById('testAngle').value);
        });

        document.getElementById('testAngle').addEventListener('input', function() {
            const angle = parseInt(this.value);
            document.getElementById('angleValue').textContent = angle;
            updateServoDescription(angle);
        });

        function updateServoDescription(angle) {
            const servoType = document.getElementById('servoType').value;
            let description = '';
            if (servoType === 'FS90R') {
                if (angle === 90) description = 'Stopped';
                else if (angle < 90) description = `Clockwise (${100 - Math.round(angle / 90 * 100)}% speed)`;
                else description = `Counterclockwise (${Math.round((angle - 90) / 90 * 100)}% speed)`;
            } else {
                description = `Angle: ${angle}°`;
            }
            document.getElementById('servoDescription').textContent = description;
        }

        function testServo() {
            const angle = document.getElementById('testAngle').value;
            const channel = document.getElementById('channel').value;
            fetch('/parts/servo/test', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    angle: parseInt(angle),
                    channel: parseInt(channel),
                    servoType: document.getElementById('servoType').value,
                    minPulse: parseInt(document.getElementById('minPulse').value),
                    maxPulse: parseInt(document.getElementById('maxPulse').value)
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
//                    alert('Servo test successful');
						console.log('Servo Test Successful', data.message);
                } else {
                    alert('Servo test failed. Again. Of course you knew that already: ' + data.message);
						console.log('Servo Test FAAILURRREEE', data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred while testing the servo.damnit.');
            });
        }

        function stopServo() {
            const channel = document.getElementById('channel').value;
            fetch('/parts/servo/stop', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    channel: parseInt(channel),
                    servoType: document.getElementById('servoType').value
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Servo stopped successfully');
                } else {
                    alert('Failed to stop servo: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('An error occurred while stopping the servo');
            });
        }
    </script>
</body>
</html>

================
File: views/active-mode.ejs
================
<!-- File: views/active-mode.ejs -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Mode</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        #errorMessage {
            color: red;
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Active Mode</h1>
    
    <div class="character-section">
        <img id="characterImage" class="character-image" src="/images/placeholder.jpg" alt="Character Image">
        <div class="character-info">
            <label for="characterSelect">Character:</label>
            <select id="characterSelect">
                <option value="">Select a character</option>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>"><%= character.char_name %></option>
                <% }); %>
            </select>
            <div id="characterInfo"></div>
        </div>
    </div>

    <div class="scene-container">
        <div class="scene-box">
            <h2>Available Scenes</h2>
            <select id="availableScenes" multiple></select>
        </div>
        <div class="scene-controls">
            <button id="addScenes">&gt;&gt;</button>
            <button id="removeScenes">&lt;&lt;</button>
        </div>
        <div class="scene-box">
            <h2>ACTIVE Scenes</h2>
            <ul id="activatedScenes"></ul>
        </div>
    </div>

    <div class="monitoring-section">
        <h2>Monitoring: <span id="armStatus">DISARMED</span></h2>
        <button id="armButton">Arm</button>
        <button id="disarmButton" disabled>Disarm</button>
        <button id="stopAllSteps">Stop All Steps</button>
    </div>

    <div id="armedModeOutput" class="output-section">
        <h3>Armed Mode Output</h3>
    </div>

    <div class="monitoring-section">
        <h2>Camera Stream</h2>
        <img id="cameraStream" src="/stream" alt="Camera Stream">
        <audio id="audioStream" controls></audio>
        <div class="camera-controls">
            <button id="toggleNightMode">Toggle Night Mode</button>
            <label>
                <input type="checkbox" id="audioToggle" checked> Enable Audio
            </label>
            <label>
                Mic Volume: <input type="range" id="micVolume" min="0" max="2" step="0.1" value="1">
            </label>
            <select id="audioDevice">
                <!-- Options will be populated dynamically -->
            </select>
        </div>
        <div id="errorMessage"></div>
    </div>

    <a href="/" class="button">Back to Main Menu</a>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
    <script src="/scripts/active-mode.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            const toggleNightModeBtn = document.getElementById('toggleNightMode');
            const audioToggle = document.getElementById('audioToggle');
            const micVolumeSlider = document.getElementById('micVolume');
            const audioDeviceSelect = document.getElementById('audioDevice');
            const errorMessageDiv = document.getElementById('errorMessage');

            let audioWebSocket;

            function startAudioStream() {
                audioWebSocket = new WebSocket(`ws://${window.location.hostname}:${window.location.port}/audiostream`);
                audioWebSocket.binaryType = 'arraybuffer';
                audioWebSocket.onmessage = function(event) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioContext.decodeAudioData(event.data, function(buffer) {
                        const source = audioContext.createBufferSource();
                        source.buffer = buffer;
                        source.connect(audioContext.destination);
                        source.start(0);
                    });
                };
                audioWebSocket.onerror = function(error) {
                    console.error('WebSocket Error:', error);
                    errorMessageDiv.textContent = 'Error connecting to audio stream';
                };
            }

            toggleNightModeBtn.addEventListener('click', () => {
                fetch('/camera/toggle-night-mode', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        console.log('Night mode:', data.nightMode ? 'ON' : 'OFF');
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        errorMessageDiv.textContent = 'Error toggling night mode';
                    });
            });

            audioToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    startAudioStream();
                } else {
                    if (audioWebSocket) {
                        audioWebSocket.close();
                    }
                }
            });

            micVolumeSlider.addEventListener('input', (e) => {
                const volume = parseFloat(e.target.value);
                fetch('/audio/set-mic-volume', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ volume: volume }),
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Mic volume set to:', data.volume);
                })
                .catch(error => {
                    console.error('Error:', error);
                    errorMessageDiv.textContent = 'Error setting mic volume';
                });
            });

            // Populate audio devices
            fetch('/audio/devices')
                .then(response => response.json())
                .then(data => {
                    audioDeviceSelect.innerHTML = data.devices.map(device => 
                        `<option value="${device}">${device}</option>`
                    ).join('');
                })
                .catch(error => {
                    console.error('Error:', error);
                    errorMessageDiv.textContent = 'Error fetching audio devices';
                });

            audioDeviceSelect.addEventListener('change', (e) => {
                fetch('/audio/set-audio-device', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ device: e.target.value }),
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Audio device set to:', data.device);
                    if (audioWebSocket) {
                        audioWebSocket.close();
                    }
                    startAudioStream();
                })
                .catch(error => {
                    console.error('Error:', error);
                    errorMessageDiv.textContent = 'Error setting audio device';
                });
            });

            // Start audio stream initially if audio is enabled
            if (audioToggle.checked) {
                startAudioStream();
            }

            // Function to clear error messages after 5 seconds
            function clearErrorMessage() {
                setTimeout(() => {
                    errorMessageDiv.textContent = '';
                }, 5000);
            }

            // Add error handling for the video stream
            const cameraStream = document.getElementById('cameraStream');
            cameraStream.onerror = function() {
                errorMessageDiv.textContent = 'Error loading camera stream';
				clearErrorMessage();
            };

            // Restore previously removed functionality
            $('#characterSelect').change(fetchCharacterInfo);
            $('#addScenes').click(addScenes);
            $('#removeScenes').click(removeScenes);
            $('#activatedScenes').sortable().selectable();
            $('#armButton').click(armSystem);
            $('#disarmButton').click(disarmSystem);
            $('#stopAllSteps').click(stopAllSteps);

            // Load the first character by default
            loadFirstCharacter();

            function loadFirstCharacter() {
                const firstCharacter = $('#characterSelect option:first');
                if (firstCharacter.length > 0) {
                    $('#characterSelect').val(firstCharacter.val()).trigger('change');
                }
            }

            function fetchCharacterInfo() {
                const characterId = $(this).val();
                if (characterId) {
                    $.get(`/active-mode/character/${characterId}`, displayCharacterInfo)
                        .fail(handleCharacterInfoError);
                    fetchScenes(characterId);
                } else {
                    clearCharacterInfo();
                }
            }

            function displayCharacterInfo(character) {
                let infoHtml = `<h3>${character.char_name}</h3><p>${character.char_description}</p>`;
                $('#characterInfo').html(infoHtml);
                
                if (character.image) {
                    $('#characterImage').attr('src', `/images/characters/${character.image}`).attr('alt', character.char_name);
                } else {
                    $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
                }
            }

            function handleCharacterInfoError(jqXHR, textStatus, errorThrown) {
                console.error("Error fetching character info:", textStatus, errorThrown);
                $('#characterInfo').html('<p>Failed to load character information. Please try again.</p>');
                $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
            }

            function clearCharacterInfo() {
                $('#characterInfo').empty();
                $('#availableScenes').empty();
                $('#activatedScenes').empty();
                $('#characterImage').attr('src', '/images/placeholder.jpg').attr('alt', 'Placeholder Image');
            }

            function fetchScenes(characterId) {
                $.get(`/active-mode/character/${characterId}/scenes`, displayScenes)
                    .fail(handleSceneFetchError);
            }

            function displayScenes(scenes) {
                $('#availableScenes').empty();
                scenes.forEach(function(scene) {
                    $('#availableScenes').append(`<option value="${scene.id}">${scene.scene_name}</option>`);
                });
            }

            function handleSceneFetchError(jqXHR, textStatus, errorThrown) {
                console.error("Error fetching scenes:", textStatus, errorThrown);
                $('#availableScenes').html('<option>Failed to load scenes</option>');
            }

            function addScenes() {
                $('#availableScenes option:selected').each(function() {
                    const sceneId = $(this).val();
                    const sceneName = $(this).text();
                    $('#activatedScenes').append(`<li data-id="${sceneId}">${sceneName}</li>`);
                    $(this).remove();
                });
            }

            function removeScenes() {
                $('#activatedScenes li.ui-selected').each(function() {
                    const sceneId = $(this).data('id');
                    const sceneName = $(this).text();
                    $('#availableScenes').append(`<option value="${sceneId}">${sceneName}</option>`);
                    $(this).remove();
                });
            }

            function armSystem() {
                if ($('#activatedScenes li').length === 0) {
                    alert('Please select at least one scene to activate.');
                    return;
                }
                isArmed = true;
                $(this).prop('disabled', true);
                $('#disarmButton').prop('disabled', false);
                $('#armStatus').text('ARMED').removeClass('disarmed').addClass('armed');
                logArmedModeOutput('System armed. Starting Active Mode.');
                startActiveModeLoop();
            }

            function disarmSystem() {
                isArmed = false;
                $(this).prop('disabled', true);
                $('#armButton').prop('disabled', false);
                $('#armStatus').text('DISARMED').removeClass('armed').addClass('disarmed');
                logArmedModeOutput('System disarmed. Active Mode stopped.');
                stopAllSteps();
            }

            function stopAllSteps() {
                $.post('/scenes/stop-all')
                    .done(function(response) {
                        logArmedModeOutput('All steps stopped: ' + response.message);
                    })
                    .fail(function(xhr, status, error) {
                        console.error('Error stopping all steps:', error);
                        logArmedModeOutput('Error stopping all steps: ' + error);
                    });
            }

            function startActiveModeLoop() {
                const scenes = $('#activatedScenes li').map(function() {
                    return $(this).data('id');
                }).get();

                function runNextScene(index) {
                    if (!isArmed) return;
                    if (index >= scenes.length) {
                        index = 0; // Reset to the beginning of the list
                    }
                    const sceneId = scenes[index];
                    logArmedModeOutput(`Starting execution of scene ${sceneId}`);
                    runScene(sceneId).then(() => {
                        logArmedModeOutput(`Completed execution of scene ${sceneId}`);
                        setTimeout(() => runNextScene(index + 1), 5000); // 5 seconds between scenes
                    }).catch((error) => {
                        logArmedModeOutput(`Error executing scene ${sceneId}: ${error.message}`);
                        setTimeout(() => runNextScene(index + 1), 5000); // Continue to next scene even if there's an error
                    });
                }

                runNextScene(0);
            }

            function runScene(sceneId) {
                return new Promise((resolve, reject) => {
                    $.get(`/scenes/${sceneId}/play`)
                        .done(function(data) {
                            handleSceneExecutionUpdate(data);
                            resolve();
                        })
                        .fail(function(xhr, status, error) {
                            console.error('Error executing scene:', error);
                            reject(new Error(`Failed to execute scene ${sceneId}`));
                        });
                });
            }

            function handleSceneExecutionUpdate(data) {
                if (data.error) {
                    logArmedModeOutput(`Error: ${data.error}`);
                } else if (data.message) {
                    logArmedModeOutput(data.message);
                }
            }

            function logArmedModeOutput(message) {
                const timestamp = new Date().toLocaleTimeString();
                $('#armedModeOutput').append(`<p>[${timestamp}] ${message}</p>`);
                $('#armedModeOutput').scrollTop($('#armedModeOutput')[0].scrollHeight);
            }
        });
    </script>
</body>
</html>

================
File: views/character-form.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST" enctype="multipart/form-data">
        <% if (character.id) { %>
            <input type="hidden" name="id" value="<%= character.id %>">
        <% } %>
        <div>
            <label for="char_name">Name:</label>
            <input type="text" id="char_name" name="char_name" value="<%= character.char_name || '' %>" required>
        </div>
        <div>
            <label for="char_description">Description:</label>
            <textarea id="char_description" name="char_description" required><%= character.char_description || '' %></textarea>
        </div>
        <div>
            <label for="character_image">Character Image:</label>
            <input type="file" id="character_image" name="character_image" accept="image/*">
            <% if (character.image) { %>
                <img src="/images/characters/<%= character.image %>" alt="<%= character.char_name %>" style="max-width: 200px;">
            <% } %>
        </div>
        <div>
            <label>Parts:</label>
            <div id="parts-container">
                <div id="available-parts">
                    <h4>Available Parts:</h4>
                    <select id="available-parts-select" multiple>
                        <% parts.filter(part => !character.parts || !character.parts.includes(part.id)).forEach(function(part) { %>
                            <option value="<%= part.id %>"><%= part.name %> (<%= part.type %>)</option>
                        <% }); %>
                    </select>
                </div>
                <div>
                    <button type="button" onclick="addPart()">Add &gt;</button>
                    <button type="button" onclick="removePart()">&lt; Remove</button>
                </div>
                <div id="selected-parts">
                    <h4>Selected Parts:</h4>
                    <select id="selected-parts-select" name="parts" multiple>
                        <% if (character.parts) { %>
                            <% character.parts.forEach(function(partId) { %>
                                <% const part = parts.find(p => p.id === partId); %>
                                <% if (part) { %>
                                    <option value="<%= part.id %>"><%= part.name %> (<%= part.type %>)</option>
                                <% } %>
                            <% }); %>
                        <% } %>
                    </select>
                </div>
            </div>
        </div>
        <div>
            <label>Sounds:</label>
            <div id="sounds-container">
                <div id="available-sounds">
                    <h4>Available Sounds:</h4>
                    <select id="available-sounds-select" multiple>
                        <% sounds.filter(sound => !character.sounds || !character.sounds.includes(sound.id)).forEach(function(sound) { %>
                            <option value="<%= sound.id %>"><%= sound.name %></option>
                        <% }); %>
                    </select>
                </div>
                <div>
                    <button type="button" onclick="addSound()">Add &gt;</button>
                    <button type="button" onclick="removeSound()">&lt; Remove</button>
                </div>
                <div id="selected-sounds">
                    <h4>Selected Sounds:</h4>
                    <select id="selected-sounds-select" name="sounds" multiple>
                        <% if (character.sounds) { %>
                            <% character.sounds.forEach(function(soundId) { %>
                                <% const sound = sounds.find(s => s.id === soundId); %>
                                <% if (sound) { %>
                                    <option value="<%= sound.id %>"><%= sound.name %></option>
                                <% } %>
                            <% }); %>
                        <% } %>
                    </select>
                </div>
            </div>
        </div>
        <button type="submit">Save Character</button>
    </form>
    <a href="/characters" class="button">Back to Characters</a>

    <script>
        function addPart() {
            moveOptions('available-parts-select', 'selected-parts-select');
        }

        function removePart() {
            moveOptions('selected-parts-select', 'available-parts-select');
        }

        function addSound() {
            moveOptions('available-sounds-select', 'selected-sounds-select');
        }

        function removeSound() {
            moveOptions('selected-sounds-select', 'available-sounds-select');
        }

        function moveOptions(fromId, toId) {
            const fromSelect = document.getElementById(fromId);
            const toSelect = document.getElementById(toId);
            
            for (let option of Array.from(fromSelect.selectedOptions)) {
                toSelect.add(option);
                option.selected = false;
            }
            updateAvailableOptions();
        }

        function updateAvailableOptions() {
            const availableParts = document.getElementById('available-parts-select');
            const selectedParts = document.getElementById('selected-parts-select');
            const availableSounds = document.getElementById('available-sounds-select');
            const selectedSounds = document.getElementById('selected-sounds-select');

            for (let option of availableParts.options) {
                option.disabled = Array.from(selectedParts.options).some(o => o.value === option.value);
            }

            for (let option of availableSounds.options) {
                option.disabled = Array.from(selectedSounds.options).some(o => o.value === option.value);
            }
        }

        // Ensure all options are selected before form submission
        document.querySelector('form').onsubmit = function() {
            const selectedParts = document.getElementById('selected-parts-select');
            const selectedSounds = document.getElementById('selected-sounds-select');
            
            for (let option of selectedParts.options) {
                option.selected = true;
            }
            
            for (let option of selectedSounds.options) {
                option.selected = true;
            }
            
            return true;
        };

        // Initialize available options
        updateAvailableOptions();
    </script>
</body>
</html>

================
File: views/characters.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <h1><%= title %></h1>
    <a href="/characters/new" class="button">Add New Character</a>
    <table>
        <thead>
            <tr>
                <th>Image</th>
                <th>Name</th>
                <th>Description</th>
                <th>Parts</th>
                <th>Sounds</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <% characters.forEach(function(character) { %>
                <tr>
                    <td>
                        <% if (character.image) { %>
                            <img src="/images/characters/<%= character.image %>" alt="<%= character.char_name %>" style="max-width: 100px;">
                        <% } else { %>
                            No Image
                        <% } %>
                    </td>
                    <td><%= character.char_name %></td>
                    <td><%= character.char_description %></td>
                    <td>
                        <% character.parts.forEach(function(partId) { %>
                            <% const part = parts.find(p => p.id === partId); %>
                            <% if (part) { %>
                                <%= part.name %><br>
                            <% } %>
                        <% }); %>
                    </td>
                    <td>
                        <% character.sounds.forEach(function(soundId) { %>
                            <% const sound = sounds.find(s => s.id === soundId); %>
                            <% if (sound) { %>
                                <%= sound.name %><br>
                            <% } %>
                        <% }); %>
                    </td>
                    <td>
                        <a href="/characters/<%= character.id %>/edit" class="button">Edit</a>
                        <button onclick="deleteCharacter(<%= character.id %>)" class="button">Delete</button>
                    </td>
                </tr>
            <% }); %>
        </tbody>
    </table>
    <a href="/" class="button">Back to Main Menu</a>

    <script>
        function deleteCharacter(id) {
            if (confirm('Are you sure you want to delete this character?')) {
                $.post('/characters/' + id + '/delete')
                    .done(function() {
                        location.reload();
                    })
                    .fail(function(xhr, status, error) {
                        console.error('Error details:', xhr.responseText);
                        alert('Error deleting character: ' + xhr.status + ' ' + xhr.statusText);
                    });
            }
        }
    </script>
</body>
</html>

================
File: views/error.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <h1><%= title %></h1>
    <p><%= message %></p>
    <% if (error) { %>
        <pre><%= error.stack %></pre>
    <% } %>
    <a href="/" class="button">Back to Home</a>
</body>
</html>

================
File: views/index.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MonsterBox Control Panel</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Creepster&display=swap">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            font-family: 'Creepster', cursive;
            font-size: 3em;
            margin: 0;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        main {
            text-align: center;
            margin-bottom: 20px;
        }
        nav {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .button {
            display: inline-block;
            background-color: #003300;
            color: #00ff00;
            padding: 10px 15px;
            margin: 10px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            font-size: 1.2em;
            width: 200px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .button:hover {
            background-color: #004400;
            box-shadow: 0 0 10px #00ff00;
        }
        footer {
            margin-top: 20px;
            text-align: center;
            font-style: italic;
        }
    </style>
</head>
<body>
    <header>
        <h1>MonsterBox™</h1>
    </header>
    <main>
        <h2>Welcome to the MonsterBox Control Panel</h2>
        <p>Choose an option from the menu to get started.</p>
    </main>

    <nav>
        <a href="/scenes" class="button">Scenes</a>
        <a href="/characters" class="button">Characters</a>
        <a href="/parts" class="button">Parts</a>
        <a href="/sounds" class="button">Sounds</a>
        <a href="/active-mode" class="button">Active Mode</a>
    </nav>
    
    <footer>
        <p>An animatronic automation package by ARW 8.15.2024.</p>
    </footer>
</body>
</html>

================
File: views/os-test.ejs
================
<!-- File: views/os-test.ejs -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Test</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #000000;
            color: #00ff00;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        #osTestForm {
            background-color: #001100;
            margin-top: 20px;
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 5px;
        }
        #osTestResult {
            font-family: 'Courier New', Courier, monospace;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #00ff00;
            background-color: #000;
            color: #e0b0ff;
            white-space: pre-wrap;
            word-wrap: break-word;
            height: 200px;
            overflow-y: auto;
        }
        #flagInfo {
            background-color: #001800;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            border: 1px solid #00ff00;
        }
        label {
            display: block;
            margin-top: 10px;
            color: #00ff00;
        }
        select, textarea {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            background-color: #001100;
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        button {
            background-color: #003300;
            color: #00ff00;
            padding: 10px 15px;
            border: 1px solid #00ff00;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #004400;
            box-shadow: 0 0 10px #00ff00;
        }
        a.button {
            display: inline-block;
            background-color: #003300;
            color: #00ff00;
            padding: 10px 15px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            margin-top: 10px;
        }
        a.button:hover {
            background-color: #004400;
            text-decoration: none;
            box-shadow: 0 0 10px #00ff00;
        }
    </style>
</head>
<body>
    <h1>OS Test</h1>

    <div id="osTestResult"></div>

    <div id="osTestForm">
        <div>
            <label for="osTestPart">Select Part:</label>
            <select id="osTestPart" onchange="updateCommand()">
                <!-- Options will be populated dynamically -->
            </select>
        </div>
        <div id="flagInfo"></div>
        <div>
            <label for="osTestCommand">Command:</label>
            <textarea id="osTestCommand" rows="4" cols="50"></textarea>
        </div>
        <button onclick="runOSTest()">Run OS Test</button>
    </div>

    <a href="/parts" class="button">Back to Parts</a>

    <script>
        document.addEventListener('DOMContentLoaded', fetchAllParts);
        const commandHistory = {};
        let eventSource;

        function fetchAllParts() {
            fetch('/parts/all')
                .then(response => response.json())
                .then(parts => {
                    const select = document.getElementById('osTestPart');
                    select.innerHTML = '';
                    parts.forEach(part => {
                        const option = document.createElement('option');
                        option.value = JSON.stringify(part);
                        option.textContent = `${part.name} (${part.type})`;
                        select.appendChild(option);
                    });
                    updateCommand();
                })
                .catch(error => console.error('Error fetching parts:', error));
        }

        function updateCommand() {
            const partSelect = document.getElementById('osTestPart');
            const commandTextarea = document.getElementById('osTestCommand');
            const flagInfo = document.getElementById('flagInfo');
            
            if (partSelect.value) {
                const part = JSON.parse(partSelect.value);
                let command = `python3 ${part.type === 'linear-actuator' ? 'linear_actuator_control.py' : part.type + '_control.py'}`;
                let flagInfoText = '';
                
                switch(part.type) {
                    case 'motor':
                    case 'linear-actuator':
                        command += ` <direction> <speed> <duration> ${part.directionPin} ${part.pwmPin}`;
                        flagInfoText = `direction: forward, backward || speed: 0 - 100 || duration: time in milliseconds || directionPin: ${part.directionPin} (Direction GPIO Pin) || pwmPin: ${part.pwmPin} (PWM Pin) ||`;
                        break;
                    case 'led':
                    case 'light':
                        command += ` ${part.gpioPin} <state> <duration>`;
                        flagInfoText = `gpioPin: ${part.gpioPin} (GPIO Pin) || state: on, off || duration: time in milliseconds ||`;
                        break;
                    case 'servo':
                        command += ` ${part.gpioPin} <angle> <frequency> <duty_cycle> <duration>`;
                        flagInfoText = `gpioPin: ${part.gpioPin} (GPIO Pin) || angle: 0 - 180 || frequency: typically 50Hz || duty_cycle: typically 2.5 - 12.5 || duration: time in milliseconds ||`;
                        break;
                    case 'sensor':
                        command += ` ${part.gpioPin} <timeout>`;
                        flagInfoText = `gpioPin: ${part.gpioPin} (GPIO Pin) || timeout: time in seconds ||`;
                        break;
                }
                
                commandTextarea.value = commandHistory[part.id] || command;
                flagInfo.textContent = flagInfoText;
            } else {
                commandTextarea.value = '';
                flagInfo.textContent = '';
            }
        }

        function runOSTest() {
            const command = document.getElementById('osTestCommand').value;
            const part = JSON.parse(document.getElementById('osTestPart').value);

            // Save the command to history
            commandHistory[part.id] = command;

            if (eventSource) {
                eventSource.close();
            }

            const resultDiv = document.getElementById('osTestResult');
            const timestamp = new Date().toLocaleTimeString();
            resultDiv.textContent += `\n[${timestamp}] Running command: ${command}\n`;

            if (part.type === 'sensor') {
                eventSource = new EventSource(`/parts/os-test-stream?command=${encodeURIComponent(command)}`);
                
                eventSource.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    if (data.done) {
                        eventSource.close();
                    } else {
                        resultDiv.textContent += data.output;
                        resultDiv.scrollTop = resultDiv.scrollHeight;
                    }
                };

                eventSource.onerror = function(event) {
                    console.error('EventSource failed:', event);
                    eventSource.close();
                };
            } else {
                fetch('/parts/os-test', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ partId: part.id, command })
                })
                .then(response => response.json())
                .then(data => {
                    resultDiv.textContent += `${data.output}\n`;
                    resultDiv.scrollTop = resultDiv.scrollHeight;
                })
                .catch(error => {
                    console.error('Error:', error);
                    resultDiv.textContent += `An error occurred during the OS test.\n`;
                    resultDiv.scrollTop = resultDiv.scrollHeight;
                });
            }
        }
    </script>
</body>
</html>

================
File: views/part-form.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body>
    <h1><%= title %></h1>
    <form action="<%= action %>" method="POST">
        <% if (part.id) { %>
            <input type="hidden" name="id" value="<%= part.id %>">
        <% } %>
        <div>
            <label for="name">Part Name:</label>
            <input type="text" id="name" name="name" value="<%= part.name || '' %>" required>
        </div>
        <div>
            <label for="type">Type:</label>
            <select id="type" name="type" required onchange="toggleInputs()">
                <option value="motor" <%= part.type === 'motor' ? 'selected' : '' %>>Motor</option>
                <option value="light" <%= part.type === 'light' ? 'selected' : '' %>>Light</option>
                <option value="led" <%= part.type === 'led' ? 'selected' : '' %>>LED</option>
                <option value="servo" <%= part.type === 'servo' ? 'selected' : '' %>>Servo</option>
                <option value="sensor" <%= part.type === 'sensor' ? 'selected' : '' %>>Sensor</option>
            </select>
        </div>
        <div>
            <label for="characterId">Character:</label>
            <select id="characterId" name="characterId" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (part.characterId === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div id="motorInputs" style="display: none;">
            <div>
                <label for="directionPin">Direction Pin:</label>
                <input type="number" id="directionPin" name="directionPin" value="<%= part.directionPin || '' %>">
            </div>
            <div>
                <label for="pwmPin">PWM Pin:</label>
                <input type="number" id="pwmPin" name="pwmPin" value="<%= part.pwmPin || '' %>">
            </div>
        </div>
        <div id="singlePinInputs" style="display: none;">
            <div>
                <label for="pin">GPIO Pin:</label>
                <input type="number" id="pin" name="pin" value="<%= part.pin || '' %>">
            </div>
        </div>
        <div id="sensorInputs" style="display: none;">
            <div>
                <label for="sensorType">Sensor Type:</label>
                <select id="sensorType" name="sensorType">
                    <option value="motion" <%= part.sensorType === 'motion' ? 'selected' : '' %>>Motion</option>
                    <option value="sound" <%= part.sensorType === 'sound' ? 'selected' : '' %>>Sound</option>
                </select>
            </div>
        </div>
        <div id="ledInputs" style="display: none;">
            <div>
                <label for="ledPin">GPIO Pin:</label>
                <input type="number" id="ledPin" name="ledPin" value="<%= part.ledPin || '' %>" min="0" max="40">
            </div>
            <div>
                <label for="duration">Duration (ms):</label>
                <input type="number" id="duration" name="duration" value="<%= part.duration || '' %>" min="0">
            </div>
        </div>
        <button type="submit">Save Part</button>
        <button type="button" id="testPartButton" onclick="testPart()">Test Part</button>
    </form>
    <div id="testArea" style="display: none;">
        <h2>Test Results</h2>
        <p id="testStatus">Not testing</p>
    </div>
    <a href="/parts" class="button">Back to Parts</a>

    <script>
        function toggleInputs() {
            const type = document.getElementById('type').value;
            document.getElementById('motorInputs').style.display = type === 'motor' ? 'block' : 'none';
            document.getElementById('singlePinInputs').style.display = ['light', 'servo'].includes(type) ? 'block' : 'none';
            document.getElementById('sensorInputs').style.display = type === 'sensor' ? 'block' : 'none';
            document.getElementById('ledInputs').style.display = type === 'led' ? 'block' : 'none';
            document.getElementById('testArea').style.display = 'block';
        }

        // Call toggleInputs on page load to set initial state
        toggleInputs();

        function testPart() {
            const type = document.getElementById('type').value;
            const testStatus = document.getElementById('testStatus');
            testStatus.textContent = 'Testing...';

            let testData = { type: type };

            switch (type) {
                case 'motor':
                    testData.directionPin = document.getElementById('directionPin').value;
                    testData.pwmPin = document.getElementById('pwmPin').value;
                    testData.direction = 'forward';
                    testData.speed = 50;
                    testData.duration = 1000;
                    break;
                case 'light':
                case 'servo':
                    testData.pin = document.getElementById('pin').value;
                    testData.duration = 1000;
                    break;
                case 'led':
                    testData.ledPin = document.getElementById('ledPin').value;
                    testData.duration = document.getElementById('duration').value;
                    break;
                case 'sensor':
                    testData.pin = document.getElementById('pin').value;
                    testData.sensorType = document.getElementById('sensorType').value;
                    break;
            }

            axios.post('/parts/test', testData)
                .then(function (response) {
                    testStatus.textContent = 'Test completed: ' + response.data.message;
                })
                .catch(function (error) {
                    console.error('Error testing part:', error);
                    testStatus.textContent = 'Error testing part: ' + (error.response ? error.response.data : error.message);
                });
        }
    </script>
</body>
</html>

================
File: views/parts.ejs
================
<!-- File: views/parts.ejs -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        .button {
            display: inline-block;
            padding: 10px 20px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            font-size: 16px;
            border: none;
            cursor: pointer;
            width: 150px;
        }
        .button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    <div>
        <a href="/parts/new/motor" class="button">Add Motor</a>
        <a href="/parts/new/linear-actuator" class="button">Add Linear Actuator</a>
        <a href="/parts/new/light" class="button">Add Light</a>
        <a href="/parts/new/led" class="button">Add LED</a>
        <a href="/parts/new/servo" class="button">Add Servo</a>
        <a href="/parts/new/sensor" class="button">Add Sensor</a>
        <a href="/parts/os-test" class="button">OS Test</a>
    </div>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Character</th>
                <th>Details</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <% parts.forEach(function(part) { %>
                <tr>
                    <td><%= part.name %></td>
                    <td><%= part.type %></td>
                    <td><%= characters.find(c => c.id === parseInt(part.characterId))?.char_name || 'N/A' %></td>
                    <td>
                        <% if (part.type === 'motor' || part.type === 'linear-actuator') { %>
                            Dir Pin: <%= part.directionPin %>, PWM Pin: <%= part.pwmPin %>
                        <% } else if (part.type === 'light' || part.type === 'led') { %>
                            GPIO Pin: <%= part.gpioPin %>
                        <% } else if (part.type === 'servo') { %>
                            GPIO Pin: <%= part.gpioPin %>, Frequency: <%= part.pwmFrequency %>Hz, Duty Cycle: <%= part.dutyCycle %>%
                        <% } else if (part.type === 'sensor') { %>
                            Type: <%= part.sensorType %>, GPIO Pin: <%= part.gpioPin %>, Active: <%= part.active ? 'Yes' : 'No' %>
                        <% } %>
                    </td>
                    <td>
                        <a href="/parts/<%= part.id %>/edit" class="button">Edit</a>
                        <button onclick="deletePart(<%= part.id %>)" class="button">Delete</button>
                    </td>
                </tr>
            <% }); %>
        </tbody>
    </table>
    <a href="/" class="button">Back to Main Menu</a>

    <script>
        function deletePart(id) {
            if (confirm('Are you sure you want to delete this part?')) {
                $.post('/parts/' + id + '/delete')
                    .done(function() {
                        location.reload();
                    })
                    .fail(function(xhr, status, error) {
                        console.error('Error details:', xhr.responseText);
                        alert('Error deleting part: ' + xhr.status + ' ' + xhr.statusText);
                    });
            }
        }
    </script>
</body>
</html>

================
File: views/scene-form.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
</head>
<body>
    <h1><%= title %></h1>
    <form id="sceneForm" action="<%= action %>" method="POST">
        <input type="hidden" name="id" value="<%= scene.id %>">

        <div>
            <label for="character_id">Character:</label>
            <select id="character_id" name="character_id" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (scene.character_id === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>

        <div>
            <label for="scene_name">Scene Name:</label>
            <input type="text" id="scene_name" name="scene_name" value="<%= scene.scene_name || '' %>" required>
        </div>

        <h2>Steps</h2>
        <div id="steps" class="sortable">
            <% (scene.steps || []).forEach(function(step, index) { %>
                <div class="step" data-index="<%= index %>">
                    <h3>Step <%= index + 1 %>: <%= step.type.charAt(0).toUpperCase() + step.type.slice(1) %></h3>
                    <input type="hidden" name="steps[<%= index %>][type]" value="<%= step.type %>">
                    <input type="text" name="steps[<%= index %>][name]" value="<%= step.name %>" placeholder="Step Name" required>

                    <% if (step.type === 'sound') { %>
                        <select name="steps[<%= index %>][sound_id]" required>
                            <% sounds.forEach(function(sound) { %>
                                <option value="<%= sound.id %>" <%= (step.sound_id == sound.id) ? 'selected' : '' %>>
                                    <%= sound.name %>
                                </option>
                            <% }); %>
                        </select>
                        <label>
                            <input type="checkbox" name="steps[<%= index %>][concurrent]" <%= step.concurrent ? 'checked' : '' %>>
                            Play concurrently
                        </label>
                    <% } else if (['motor', 'linear-actuator', 'servo', 'led', 'light'].includes(step.type)) { %>
                        <select name="steps[<%= index %>][part_id]" required>
                            <% parts.filter(part => part.type === step.type).forEach(function(part) { %>
                                <option value="<%= part.id %>" <%= (step.part_id === part.id) ? 'selected' : '' %>>
                                    <%= part.name %>
                                </option>
                            <% }); %>
                        </select>
                        <input type="number" name="steps[<%= index %>][duration]" value="<%= step.duration || '' %>" placeholder="Duration (ms)" required>
                        
                        <% if (step.type === 'motor' || step.type === 'linear-actuator') { %>
                            <select name="steps[<%= index %>][direction]" required>
                                <option value="forward" <%= step.direction === 'forward' ? 'selected' : '' %>>Forward</option>
                                <option value="backward" <%= step.direction === 'backward' ? 'selected' : '' %>>Backward</option>
                            </select>
                            <input type="number" name="steps[<%= index %>][speed]" value="<%= step.speed || '' %>" placeholder="Speed (0-100)" min="0" max="100" required>
                        <% } else if (step.type === 'led' || step.type === 'light') { %>
                            <select name="steps[<%= index %>][state]" required>
                                <option value="on" <%= step.state === 'on' ? 'selected' : '' %>>On</option>
                                <option value="off" <%= step.state === 'off' ? 'selected' : '' %>>Off</option>
                            </select>
                            <% if (step.type === 'led') { %>
                                <input type="number" name="steps[<%= index %>][brightness]" value="<%= step.brightness || '' %>" placeholder="Brightness (0-100)" min="0" max="100" required>
                            <% } %>
                        <% } %>
                    <% } else if (step.type === 'sensor') { %>
                        <select name="steps[<%= index %>][part_id]" required>
                            <% parts.filter(part => part.type === 'sensor').forEach(function(part) { %>
                                <option value="<%= part.id %>" <%= (step.part_id === part.id) ? 'selected' : '' %>>
                                    <%= part.name %>
                                </option>
                            <% }); %>
                        </select>
                        <input type="number" name="steps[<%= index %>][timeout]" value="<%= step.timeout || 30 %>" placeholder="Timeout (seconds)" required>
                    <% } else if (step.type === 'pause') { %>
                        <input type="number" name="steps[<%= index %>][duration]" value="<%= step.duration || '' %>" placeholder="Duration (ms)" required>
                    <% } %>
                    <button type="button" onclick="removeStep(<%= index %>)">Remove Step</button>
                    <button type="button" onclick="copyStep(<%= index %>)">Copy Step</button>
                </div>
            <% }); %>
        </div>
        
        <button type="button" onclick="addStep('motor')">Add Motor</button>
        <button type="button" onclick="addStep('linear-actuator')">Add Linear Actuator</button>
        <button type="button" onclick="addStep('servo')">Add Servo</button>
        <button type="button" onclick="addStep('led')">Add LED</button>
        <button type="button" onclick="addStep('light')">Add Light</button>
        <button type="button" onclick="addStep('sensor')">Add Sensor</button>
        <button type="button" onclick="addStep('sound')">Add Sound</button>
        <button type="button" onclick="addStep('pause')">Add Pause</button>
        <button type="submit">Save Scene</button>
    </form>

    <a href="/scenes" class="button">Back to Scenes</a>

    <script>
        $(document).ready(function() {
            $('#character_id').change(function() {
                updatePartOptions();
            });

            $(".sortable").sortable({
                update: function(event, ui) {
                    updateStepNumbers();
                }
            });

            // Initial update of part options
            updatePartOptions();
        });

        function updatePartOptions() {
            const characterId = $('#character_id').val();
            $.ajax({
                url: '/characters/' + characterId + '/parts',
                method: 'GET',
                success: function(parts) {
                    window.availableParts = parts;
                    updateStepPartOptions();
                },
                error: function(error) {
                    console.error('Error fetching parts:', error);
                }
            });
        }

        function updateStepPartOptions() {
            $('.step').each(function() {
                const stepType = $(this).find('input[name$="[type]"]').val();
                const partSelect = $(this).find('select[name$="[part_id]"]');
                if (partSelect.length) {
                    const currentValue = partSelect.val();
                    partSelect.empty();
                    window.availableParts.filter(part => part.type === stepType).forEach(part => {
                        partSelect.append($('<option>', {
                            value: part.id,
                            text: part.name,
                            selected: part.id == currentValue
                        }));
                    });
                }
            });
        }

        function addStep(type) {
            const steps = document.getElementById('steps');
            const stepCount = steps.children.length;
            const newStep = document.createElement('div');
            newStep.className = 'step';
            newStep.dataset.index = stepCount;

            let stepContent = `
                <h3>Step ${stepCount + 1}: ${type.charAt(0).toUpperCase() + type.slice(1)}</h3>
                <input type="hidden" name="steps[${stepCount}][type]" value="${type}">
                <input type="text" name="steps[${stepCount}][name]" placeholder="Step Name" required>
            `;

            if (type === 'sound') {
                stepContent += `
                    <select name="steps[${stepCount}][sound_id]" required>
                        <% sounds.forEach(function(sound) { %>
                            <option value="<%= sound.id %>"><%= sound.name %></option>
                        <% }); %>
                    </select>
                    <label>
                        <input type="checkbox" name="steps[${stepCount}][concurrent]">
                        Play concurrently
                    </label>
                `;
            } else if (['motor', 'linear-actuator', 'servo', 'led', 'light'].includes(type)) {
                stepContent += `
                    <select name="steps[${stepCount}][part_id]" required>
                        ${getPartOptions(type)}
                    </select>
                    <input type="number" name="steps[${stepCount}][duration]" placeholder="Duration (ms)" required>
                `;
                if (type === 'motor' || type === 'linear-actuator') {
                    stepContent += `
                        <select name="steps[${stepCount}][direction]" required>
                            <option value="forward">Forward</option>
                            <option value="backward">Backward</option>
                        </select>
                        <input type="number" name="steps[${stepCount}][speed]" placeholder="Speed (0-100)" min="0" max="100" required>
                    `;
                } else if (type === 'led' || type === 'light') {
                    stepContent += `
                        <select name="steps[${stepCount}][state]" required>
                            <option value="on">On</option>
                            <option value="off">Off</option>
                        </select>
                    `;
                    if (type === 'led') {
                        stepContent += `
                            <input type="number" name="steps[${stepCount}][brightness]" placeholder="Brightness (0-100)" min="0" max="100" required>
                        `;
                    }
                }
            } else if (type === 'sensor') {
                stepContent += `
                    <select name="steps[${stepCount}][part_id]" required>
                        ${getPartOptions('sensor')}
                    </select>
                    <input type="number" name="steps[${stepCount}][timeout]" placeholder="Timeout (seconds)" value="30" required>
                `;
            } else if (type === 'pause') {
                stepContent += `
                    <input type="number" name="steps[${stepCount}][duration]" placeholder="Duration (ms)" required>
                `;
            }

            stepContent += `
                <button type="button" onclick="removeStep(${stepCount})">Remove Step</button>
                <button type="button" onclick="copyStep(${stepCount})">Copy Step</button>
            `;

            newStep.innerHTML = stepContent;
            steps.appendChild(newStep);
            updateStepNumbers();
        }

        function getPartOptions(type) {
            if (!window.availableParts) {
                return '<option value="">Please select a character first</option>';
            }
            return window.availableParts
                .filter(part => part.type === type)
                .map(part => `<option value="${part.id}">${part.name}</option>`)
                .join('');
        }

        function removeStep(index) {
            const steps = document.getElementById('steps');
            steps.removeChild(steps.children[index]);
            updateStepNumbers();
        }

        function copyStep(index) {
            const steps = document.getElementById('steps');
            const originalStep = steps.children[index];
            const newStep = originalStep.cloneNode(true);
            const newIndex = steps.children.length;

            // Update the step number and type
            const stepType = newStep.querySelector('input[name$="[type]"]').value;
            newStep.querySelector('h3').textContent = `Step ${newIndex + 1}: ${stepType.charAt(0).toUpperCase() + stepType.slice(1)}`;

            // Update the data-index attribute
            newStep.dataset.index = newIndex;

            // Update the name attribute of all inputs and selects
            newStep.querySelectorAll('input, select').forEach(element => {
                if (element.name) {
                    element.name = element.name.replace(`steps[${index}]`, `steps[${newIndex}]`);
                }
            });

            // Update the onclick attribute of the buttons
            newStep.querySelector('button[onclick^="removeStep"]').setAttribute('onclick', `removeStep(${newIndex})`);
            newStep.querySelector('button[onclick^="copyStep"]').setAttribute('onclick', `copyStep(${newIndex})`);

            // Append the new step to the steps container
            steps.appendChild(newStep);

            // Update the step name to indicate it's a copy
            const nameInput = newStep.querySelector('input[name$="[name]"]');
            nameInput.value = nameInput.value + ' (Copy)';

            updateStepNumbers();
        }

        function updateStepNumbers() {
            const steps = document.getElementById('steps').children;
            for (let i = 0; i < steps.length; i++) {
                const stepType = steps[i].querySelector('input[name$="[type]"]').value;
                steps[i].querySelector('h3').textContent = `Step ${i + 1}: ${stepType.charAt(0).toUpperCase() + stepType.slice(1)}`;
                steps[i].dataset.index = i;
                updateStepInputNames(steps[i], i);
            }
        }

        function updateStepInputNames(stepElement, newIndex) {
            const inputs = stepElement.querySelectorAll('input, select');
            inputs.forEach(input => {
                const name = input.getAttribute('name');
                if (name) {
                    input.setAttribute('name', name.replace(/steps\[\d+\]/, `steps[${newIndex}]`));
                }
            });
        }

        // Ensure all steps are included when submitting the form
        document.getElementById('sceneForm').onsubmit = function() {
            updateStepNumbers();
            return true;
        };
    </script>
</body>
</html>

================
File: views/scene-player.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        #log-box {
            border: 1px solid #00ff00;
            padding: 10px;
            height: 300px;
            overflow-y: scroll;
            background-color: #001100;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            margin-bottom: 20px;
        }
        #controls {
            margin-top: 20px;
        }
        #controls button {
            margin-right: 10px;
        }
        .step {
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #00ff00;
        }
        .current-step {
            background-color: #003300;
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    <h2><%= scene.scene_name %></h2>
    
    <div id="scene-overview">
        <h3>Scene Steps:</h3>
        <% scene.steps.forEach((step, index) => { %>
            <div class="step" id="step-<%= index %>">
                <strong>Step <%= index + 1 %>:</strong> <%= step.name %> (<%= step.type %>)
            </div>
        <% }); %>
    </div>
    
    <div id="log-box"></div>
    
    <div id="controls">
        <button id="backward-btn">Backward</button>
        <button id="run-btn">Run</button>
        <button id="forward-btn">Forward</button>
        <button id="stop-btn">Stop All Steps</button>
    </div>
    
    <a href="/scenes" class="button">Back to Scenes</a>

    <script>
        const sceneData = <%- JSON.stringify(scene) %>;
    </script>
    <script src="/scripts/scene-player.js"></script>
</body>
</html>

================
File: views/scenes.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <h1><%= title %></h1>
    <a href="/scenes/new" class="button">Add New Scene</a>
    <table>
        <thead>
            <tr>
                <th>Scene Name</th>
                <th>Character</th>
                <th>Steps</th>
                <th>Actions</th>
                <th>Operations</th>
            </tr>
        </thead>
        <tbody>
            <% scenes.forEach(function(scene) { %>
                <tr>
                    <td><%= scene.scene_name %></td>
                    <td><%= characters.find(c => c.id === scene.character_id)?.char_name || 'N/A' %></td>
                    <td><%= scene.steps ? scene.steps.length : 0 %></td>
                    <td>
                        <% if (scene.steps) { %>
                            <ul>
                                <% scene.steps.forEach(function(step) { %>
                                    <li><%= step.name %></li>
                                <% }); %>
                            </ul>
                        <% } %>
                    </td>
                    <td>
                        <a href="/scenes/<%= scene.id %>/edit" class="button edit-scene" data-id="<%= scene.id %>">Edit</a>
                        <button onclick="deleteScene('<%= scene.id %>')" class="button">Delete</button>
                        <a href="/scenes/<%= scene.id %>" class="button play-scene" data-id="<%= scene.id %>">Run</a>
                    </td>
                </tr>
            <% }); %>
        </tbody>
    </table>
    <a href="/" class="button">Back to Main Menu</a>

    <script>
        function deleteScene(id) {
            console.log('Attempting to delete scene:', id);
            if (confirm('Are you sure you want to delete this scene?')) {
                $.ajax({
                    url: '/scenes/' + id,
                    type: 'DELETE',
                    success: function(result) {
                        console.log('Scene deleted successfully');
                        location.reload();
                    },
                    error: function(xhr, status, error) {
                        console.error('Error deleting scene:', error);
                        console.error('Server response:', xhr.responseText);
                        alert('Error deleting scene: ' + error);
                    }
                });
            }
        }

        $(document).ready(function() {
            $('.edit-scene').on('click', function(e) {
                e.preventDefault();
                var id = $(this).data('id');
                var url = '/scenes/' + id + '/edit';
                console.log('Attempting to edit scene:', id);
                console.log('Edit URL:', url);
                window.location.href = url;
            });

            $('.play-scene').on('click', function(e) {
                e.preventDefault();
                var id = $(this).data('id');
                var url = '/scenes/' + id;
                console.log('Attempting to play scene:', id);
                console.log('Play URL:', url);
                window.location.href = url;
            });
        });
    </script>
</body>
</html>

================
File: views/sound-form.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
</head>
<body>
    <h1><%= title %></h1>
    <form id="sceneForm" action="<%= action %>" method="POST">
        <input type="hidden" name="id" value="<%= scene.id %>">
        
        <div>
            <label for="character_id">Character:</label>
            <select id="character_id" name="character_id" required>
                <% characters.forEach(function(character) { %>
                    <option value="<%= character.id %>" <%= (scene.character_id === character.id) ? 'selected' : '' %>>
                        <%= character.char_name %>
                    </option>
                <% }); %>
            </select>
        </div>
        <div>
            <label for="scene_name">Scene Name:</label>
            <input type="text" id="scene_name" name="scene_name" value="<%= scene.scene_name || '' %>" required>
        </div>

        <h2>Steps</h2>
        <div id="steps" class="sortable">
            <% (scene.steps || []).forEach(function(step, index) { %>
                <div class="step" data-index="<%= index %>">
                    <h3>Step <%= index + 1 %>: <%= step.type.charAt(0).toUpperCase() + step.type.slice(1) %></h3>
                    <input type="hidden" name="steps[<%= index %>][type]" value="<%= step.type %>">
                    <input type="text" name="steps[<%= index %>][name]" value="<%= step.name %>" placeholder="Step Name" required>
                    <% if (step.type === 'sound') { %>
                        <select name="steps[<%= index %>][sound_id]" required>
                            <% sounds.forEach(function(sound) { %>
                                <option value="<%= sound.id %>" <%= (step.sound_id == sound.id) ? 'selected' : '' %>><%= sound.name %></option>
                            <% }); %>
                        </select>
                    <% } else if (['motor', 'linear-actuator', 'servo', 'led', 'light'].includes(step.type)) { %>
                        <select name="steps[<%= index %>][part_id]" required>
                            <% parts.filter(part => part.type === step.type).forEach(function(part) { %>
                                <option value="<%= part.id %>" <%= (step.part_id === part.id) ? 'selected' : '' %>><%= part.name %></option>
                            <% }); %>
                        </select>
                        <input type="number" name="steps[<%= index %>][duration]" value="<%= step.duration || '' %>" placeholder="Duration (ms)" required>
                        <% if (step.type === 'motor' || step.type === 'linear-actuator') { %>
                            <select name="steps[<%= index %>][direction]" required>
                                <option value="forward" <%= step.direction === 'forward' ? 'selected' : '' %>>Forward</option>
                                <option value="backward" <%= step.direction === 'backward' ? 'selected' : '' %>>Backward</option>
                            </select>
                            <input type="number" name="steps[<%= index %>][speed]" value="<%= step.speed || '' %>" placeholder="Speed (0-100)" min="0" max="100" required>
                        <% } else if (step.type === 'led' || step.type === 'light') { %>
                            <select name="steps[<%= index %>][state]" required>
                                <option value="on" <%= step.state === 'on' ? 'selected' : '' %>>On</option>
                                <option value="off" <%= step.state === 'off' ? 'selected' : '' %>>Off</option>
                            </select>
                            <% if (step.type === 'led') { %>
                                <input type="number" name="steps[<%= index %>][brightness]" value="<%= step.brightness || '' %>" placeholder="Brightness (0-100)" min="0" max="100" required>
                            <% } %>
                        <% } %>
                    <% } else if (step.type === 'sensor') { %>
                        <select name="steps[<%= index %>][part_id]" required>
                            <% parts.filter(part => part.type === 'sensor').forEach(function(part) { %>
                                <option value="<%= part.id %>" <%= (step.part_id === part.id) ? 'selected' : '' %>><%= part.name %></option>
                            <% }); %>
                        </select>
                        <input type="number" name="steps[<%= index %>][timeout]" value="<%= step.timeout || 30 %>" placeholder="Timeout (seconds)" required>
                    <% } else if (step.type === 'pause') { %>
                        <input type="number" name="steps[<%= index %>][duration]" value="<%= step.duration || '' %>" placeholder="Duration (ms)" required>
                    <% } %>
                    <label>
                        <input type="checkbox" name="steps[<%= index %>][concurrent]" <%= step.concurrent ? 'checked' : '' %>>
                        Run Concurrently
                    </label>
                    <button type="button" onclick="removeStep(<%= index %>)">Remove Step</button>
                    <button type="button" onclick="copyStep(<%= index %>)">Copy Step</button>
                </div>
            <% }); %>
        </div>
        
        <button type="button" onclick="addStep('motor')">Add Motor</button>
        <button type="button" onclick="addStep('linear-actuator')">Add Linear Actuator</button>
        <button type="button" onclick="addStep('servo')">Add Servo</button>
        <button type="button" onclick="addStep('led')">Add LED</button>
        <button type="button" onclick="addStep('light')">Add Light</button>
        <button type="button" onclick="addStep('sensor')">Add Sensor</button>
        <button type="button" onclick="addStep('sound')">Add Sound</button>
        <button type="button" onclick="addStep('pause')">Add Pause</button>
        <button type="submit">Save Scene</button>
    </form>

    <a href="/scenes" class="button">Back to Scenes</a>

    <script>
        $(document).ready(function() {
            $('#character_id').change(function() {
                updatePartOptions();
            });

            $(".sortable").sortable({
                update: function(event, ui) {
                    updateStepNumbers();
                }
            });

            // Initial update of part options
            updatePartOptions();
        });

        function updatePartOptions() {
            const characterId = $('#character_id').val();
            $.ajax({
                url: '/characters/' + characterId + '/parts',
                method: 'GET',
                success: function(parts) {
                    window.availableParts = parts;
                    updateStepPartOptions();
                },
                error: function(error) {
                    console.error('Error fetching parts:', error);
                }
            });
        }

        function updateStepPartOptions() {
            $('.step').each(function() {
                const stepType = $(this).find('input[name$="[type]"]').val();
                const partSelect = $(this).find('select[name$="[part_id]"]');
                if (partSelect.length) {
                    const currentValue = partSelect.val();
                    partSelect.empty();
                    window.availableParts.filter(part => part.type === stepType).forEach(part => {
                        partSelect.append($('<option>', {
                            value: part.id,
                            text: part.name,
                            selected: part.id == currentValue
                        }));
                    });
                }
            });
        }

        function addStep(type) {
            const steps = document.getElementById('steps');
            const stepCount = steps.children.length;
            const newStep = document.createElement('div');
            newStep.className = 'step';
            newStep.dataset.index = stepCount;

            let stepContent = `
                <h3>Step ${stepCount + 1}: ${type.charAt(0).toUpperCase() + type.slice(1)}</h3>
                <input type="hidden" name="steps[${stepCount}][type]" value="${type}">
                <input type="text" name="steps[${stepCount}][name]" placeholder="Step Name" required>
            `;

            if (type === 'sound') {
                stepContent += `
                    <select name="steps[${stepCount}][sound_id]" required>
                        <% sounds.forEach(function(sound) { %>
                            <option value="<%= sound.id %>"><%= sound.name %></option>
                        <% }); %>
                    </select>
                `;
            } else if (['motor', 'linear-actuator', 'servo', 'led', 'light'].includes(type)) {
                stepContent += `
                    <select name="steps[${stepCount}][part_id]" required>
                        ${getPartOptions(type)}
                    </select>
                    <input type="number" name="steps[${stepCount}][duration]" placeholder="Duration (ms)" required>
                `;
                if (type === 'motor' || type === 'linear-actuator') {
                    stepContent += `
                        <select name="steps[${stepCount}][direction]" required>
                            <option value="forward">Forward</option>
                            <option value="backward">Backward</option>
                        </select>
                        <input type="number" name="steps[${stepCount}][speed]" placeholder="Speed (0-100)" min="0" max="100" required>
                    `;
                } else if (type === 'led' || type === 'light') {
                    stepContent += `
                        <select name="steps[${stepCount}][state]" required>
                            <option value="on">On</option>
                            <option value="off">Off</option>
                        </select>
                    `;
                    if (type === 'led') {
                        stepContent += `
                            <input type="number" name="steps[${stepCount}][brightness]" placeholder="Brightness (0-100)" min="0" max="100" required>
                        `;
                    }
                }
            } else if (type === 'sensor') {
                stepContent += `
                    <select name="steps[${stepCount}][part_id]" required>
                        ${getPartOptions('sensor')}
                    </select>
                    <input type="number" name="steps[${stepCount}][timeout]" placeholder="Timeout (seconds)" value="30" required>
                `;
            } else if (type === 'pause') {
                stepContent += `
                    <input type="number" name="steps[${stepCount}][duration]" placeholder="Duration (ms)" required>
                `;
            }

            stepContent += `
                <label>
                    <input type="checkbox" name="steps[${stepCount}][concurrent]">
                    Run Concurrently
                </label>
                <button type="button" onclick="removeStep(${stepCount})">Remove Step</button>
                <button type="button" onclick="copyStep(${stepCount})">Copy Step</button>
            `;

            newStep.innerHTML = stepContent;
            steps.appendChild(newStep);
            updateStepNumbers();
        }

        function getPartOptions(type) {
            if (!window.availableParts) {
                return '<option value="">Please select a character first</option>';
            }
            return window.availableParts
                .filter(part => part.type === type)
                .map(part => `<option value="${part.id}">${part.name}</option>`)
                .join('');
        }

        function removeStep(index) {
            const steps = document.getElementById('steps');
            steps.removeChild(steps.children[index]);
            updateStepNumbers();
        }

        function copyStep(index) {
            const steps = document.getElementById('steps');
            const originalStep = steps.children[index];
            const newStep = originalStep.cloneNode(true);
            const newIndex = steps.children.length;

            // Update the step number and type
            const stepType = newStep.querySelector('input[name$="[type]"]').value;
            newStep.querySelector('h3').textContent = `Step ${newIndex + 1}: ${stepType.charAt(0).toUpperCase() + stepType.slice(1)}`;

            // Update the data-index attribute
            newStep.dataset.index = newIndex;

            // Update the name attribute of all inputs and selects
            newStep.querySelectorAll('input, select').forEach(element => {
                if (element.name) {
                    element.name = element.name.replace(`steps[${index}]`, `steps[${newIndex}]`);
                }
            });

            // Update the onclick attribute of the buttons
            newStep.querySelector('button[onclick^="removeStep"]').setAttribute('onclick', `removeStep(${newIndex})`);
            newStep.querySelector('button[onclick^="copyStep"]').setAttribute('onclick', `copyStep(${newIndex})`);

            // Append the new step to the steps container
            steps.appendChild(newStep);

            // Update the step name to indicate it's a copy
            const nameInput = newStep.querySelector('input[name$="[name]"]');
            nameInput.value = nameInput.value + ' (Copy)';

            updateStepNumbers();
        }

        function updateStepNumbers() {
            const steps = document.getElementById('steps').children;
            for (let i = 0; i < steps.length; i++) {
                const stepType = steps[i].querySelector('input[name$="[type]"]').value;
                steps[i].querySelector('h3').textContent = `Step ${i + 1}: ${stepType.charAt(0).toUpperCase() + stepType.slice(1)}`;
                steps[i].dataset.index = i;
                updateStepInputNames(steps[i], i);
            }
        }

        function updateStepInputNames(stepElement, newIndex) {
            const inputs = stepElement.querySelectorAll('input, select');
            inputs.forEach(input => {
                const name = input.getAttribute('name');
                if (name) {
                    input.setAttribute('name', name.replace(/steps\[\d+\]/, `steps[${newIndex}]`));
                }
            });
        }

        // Ensure all steps are included when submitting the form
        document.getElementById('sceneForm').onsubmit = function() {
            updateStepNumbers();
            return true;
        };
    </script>
</body>
</html>

================
File: views/sounds.ejs
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <h1><%= title %></h1>
    <a href="/sounds/new" class="button">Add New Sound</a>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Filename</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <% sounds.forEach(function(sound) { %>
                <tr>
                    <td><%= sound.name %></td>
                    <td><%= sound.filename %></td>
                    <td>
                        <button onclick="playOnCharacter(<%= sound.id %>)">Play (on Character)</button>
                        <button onclick="playLocal('<%= sound.filename %>')">Play (local)</button>
                        <a href="/sounds/<%= sound.id %>/edit" class="button">Edit</a>
                        <button onclick="deleteSound(<%= sound.id %>)">Delete</button>
                    </td>
                </tr>
            <% }); %>
        </tbody>
    </table>
    <a href="/" class="button">Back to Main Menu</a>

    <div id="soundInfo"></div>
    <div id="errorInfo" style="color: red;"></div>

    <script>
        function playLocal(filename) {
            const audio = new Audio(`/sounds/${filename}`);
            audio.play().catch(error => {
                console.error('Error playing sound locally:', error);
                displayError('Error playing sound locally: ' + error.message);
            });
        }

        function playOnCharacter(soundId) {
            console.log('Attempting to play sound with ID:', soundId);
            fetch(`/sounds/${soundId}/play`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => { throw err; });
                }
                return response.json();
            })
            .then(data => {
                console.log('Server response:', data);
                const soundInfo = `
                    <h3>Sound Details:</h3>
                    <p>Message: ${data.message}</p>
                    <p>Python Output: ${data.pythonOutput}</p>
                    <p>Executed Command: ${data.command}</p>
                `;
                document.getElementById('soundInfo').innerHTML = soundInfo;
                document.getElementById('errorInfo').innerHTML = '';
            })
            .catch(error => {
                console.error('Error playing sound on character:', error);
                let errorMessage = 'Error playing sound on character: ';
                if (error.error) {
                    errorMessage += error.error;
                    if (error.details) errorMessage += ' - ' + error.details;
                    if (error.output) errorMessage += ' (Output: ' + error.output + ')';
                    if (error.errorOutput) errorMessage += ' (Error Output: ' + error.errorOutput + ')';
                    if (error.command) errorMessage += ' (Command: ' + error.command + ')';
                } else {
                    errorMessage += error.toString();
                }
                displayError(errorMessage);
            });
        }

        function deleteSound(id) {
            if (confirm('Are you sure you want to delete this sound?')) {
                fetch('/sounds/' + id + '/delete', { method: 'POST' })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => { throw err; });
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Delete sound response:', data);
                    location.reload();
                })
                .catch(error => {
                    console.error('Error deleting sound:', error);
                    let errorMessage = 'Error deleting sound: ';
                    if (error.error) {
                        errorMessage += error.error;
                        if (error.details) errorMessage += ' - ' + error.details;
                    } else {
                        errorMessage += error.toString();
                    }
                    displayError(errorMessage);
                });
            }
        }

        function displayError(message) {
            document.getElementById('errorInfo').innerHTML = message;
            document.getElementById('soundInfo').innerHTML = '';
        }
    </script>
</body>
</html>

================
File: .gitignore
================
repopack-output.txt
motor_control.log
*.log

================
File: app.js
================
// File: app.js
const express = require('express');
const path = require('path');
const http = require('http');
const app = express();
const server = http.createServer(app);
const port = 3000;
const camera = require('./scripts/camera');
const audio = require('./scripts/audio');

// Import routes
const ledRoutes = require('./routes/ledRoutes');
const lightRoutes = require('./routes/lightRoutes');
const servoRoutes = require('./routes/servoRoutes');
const sensorRoutes = require('./routes/sensorRoutes');
const partRoutes = require('./routes/partRoutes');
const sceneRoutes = require('./routes/sceneRoutes');
const characterRoutes = require('./routes/characterRoutes');
const soundRoutes = require('./routes/soundRoutes');
const linearActuatorRoutes = require('./routes/linearActuatorRoutes');
const activeModeRoutes = require('./routes/activeModeRoutes');

// Basic Express setup
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.set('view engine', 'ejs');
app.use(express.static('public'));
app.use('/scripts', express.static(path.join(__dirname, 'scripts')));

// Routes
app.use('/parts/led', ledRoutes);
app.use('/parts/light', lightRoutes);
app.use('/parts/servo', servoRoutes);
app.use('/parts/sensor', sensorRoutes);
app.use('/parts/linear-actuator', linearActuatorRoutes);
app.use('/parts', partRoutes);
app.use('/scenes', sceneRoutes);
app.use('/characters', characterRoutes);
app.use('/sounds', soundRoutes);
app.use('/active-mode', activeModeRoutes);

// Main menu route
app.get('/', (req, res) => {
    res.render('index', { title: 'MonsterBox Control Panel' });
});

// Camera routes
app.post('/camera/toggle-night-mode', (req, res) => {
    camera.toggleNightMode();
    res.json({ success: true, nightMode: camera.nightMode });
});

// Audio routes
app.post('/audio/set-mic-volume', (req, res) => {
    try {
        audio.setMicVolume(req.body.volume);
        res.json({ success: true, volume: req.body.volume });
    } catch (error) {
        console.error('Error setting mic volume:', error);
        res.status(500).json({ success: false, error: 'Failed to set mic volume' });
    }
});

app.post('/audio/set-audio-device', (req, res) => {
    try {
        audio.setAudioDevice(req.body.device);
        res.json({ success: true, device: req.body.device });
    } catch (error) {
        console.error('Error setting audio device:', error);
        res.status(500).json({ success: false, error: 'Failed to set audio device' });
    }
});

app.get('/audio/devices', (req, res) => {
    audio.getAudioDevices((devices) => {
        res.json({ devices: devices });
    });
});

// Proxy route for mjpeg-streamer
app.use('/stream', (req, res) => {
    const proxyRequest = http.request(
        {
            hostname: 'localhost',
            port: 8080,
            path: '/?action=stream',
            method: req.method,
            headers: req.headers
        },
        (proxyResponse) => {
            res.writeHead(proxyResponse.statusCode, proxyResponse.headers);
            proxyResponse.pipe(res);
        }
    );
    req.pipe(proxyRequest);

    proxyRequest.on('error', (error) => {
        console.error('Proxy request error:', error);
        res.status(500).send('Error connecting to camera stream');
    });
});

// Start the camera and audio streams
camera.startStream();
audio.startStream(server);

// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});

// Start the server
server.listen(port, () => {
    console.log(`MonsterBox server running at http://localhost:${port}`);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    // Optionally, you can choose to exit the process here
    // process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    // Optionally, you can choose to exit the process here
    // process.exit(1);
});

module.exports = app;

================
File: package.json
================
{
  "name": "monsterbox",
  "version": "1.0.0",
  "description": "A refactored scene builder application for managing scenes and steps.",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "test": "mocha --recursive || true"
  },
  "dependencies": {
    "body-parser": "^1.19.0",
    "ejs": "^3.1.10",
    "express": "^4.19.2",
    "hls.js": "^1.5.15",
    "i2c-bus": "^5.2.3",
    "multer": "^1.4.5-lts.1",
    "node-aplay": "^1.0.3",
    "node-mpg123": "^1.0.2-0023",
    "node-schedule": "^2.1.0",
    "onoff": "^6.0.3",
    "pca9685": "^5.0.0",
    "play-sound": "^1.1.6",
    "replit-auth": "^5.0.3",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "chai": "^4.5.0",
    "mocha": "^9.2.2",
    "supertest": "^6.1.6"
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/your-repo/monsterbox.git"
  },
  "keywords": [
    "scene",
    "builder",
    "express",
    "ejs",
    "nodejs"
  ],
  "author": "Your Name",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/your-repo/monsterbox/issues"
  },
  "homepage": "https://github.com/your-repo/monsterbox#readme"
}

================
File: README.md
================
Certainly! I'll update the README.md to include information about the hardware components. Here's the revised version:

```markdown
# MonsterBox

MonsterBox is an animatronic automation package designed to control and manage various components of interactive Halloween displays or haunted house attractions. It provides a web-based interface for creating, editing, and executing scenes that control different types of hardware components.

## Description

MonsterBox allows users to:
- Create and manage characters
- Add and configure various types of parts (motors, LEDs, lights, sensors, etc.)
- Design complex scenes with multiple steps
- Play sounds
- Execute scenes to control the animatronic components

The application is built with a Node.js backend using Express.js and EJS templates for the frontend. It's designed to run on a Raspberry Pi or similar device that can interface with GPIO pins to control physical hardware.

## Hardware Components

MonsterBox is designed to work with the following hardware:

1. **Raspberry Pi 4B**: The main controller running the MonsterBox software.
2. **Servos**: 
   - Standard servos (e.g., SG90, MG996R)
   - Continuous rotation servos
3. **Motors**:
   - DC motors with H-bridge drivers (e.g., L298N)
   - Stepper motors with appropriate drivers
4. **Linear Actuators**: 12V DC actuators for linear motion
5. **LEDs**: Both individual LEDs and LED strips (e.g., WS2812B)
6. **Lights**: Relay-controlled AC or DC lights
7. **Sensors**:
   - PIR motion sensors
   - Ultrasonic distance sensors (HC-SR04)
   - Sound sensors
8. **Audio**: 
   - USB audio adapter
   - Speakers or amplifier module

## Main Software Components

1. **Characters**: Represent the animatronic figures or props in your display.
2. **Parts**: Various types of controllable components (motors, LEDs, sensors, etc.) that can be attached to characters.
3. **Scenes**: Sequences of steps that define how parts should behave over time.
4. **Sounds**: Audio files that can be played as part of a scene.

## Project Structure

- `/routes`: Contains Express.js route handlers for different sections of the application.
- `/scripts`: Python scripts for controlling hardware components via GPIO.
- `/services`: JavaScript modules for data management and business logic.
- `/views`: EJS templates for rendering the web interface.
- `/public`: Static assets like CSS files.
- `/data`: JSON files for storing application data.

## Key Files

- `app.js`: The main Express.js application file.
- `package.json`: Defines project dependencies and scripts.
- `README.md`: This file, containing project documentation.

## Technology Stack

- Backend: Node.js with Express.js
- Frontend: EJS templates with custom CSS
- Database: JSON files (for simplicity and portability)
- Hardware Control: Python scripts using RPi.GPIO library

## Setup and Installation

1. Set up your Raspberry Pi 4B with the latest Raspberry Pi OS.
2. Install Node.js and npm on your Raspberry Pi.
3. Clone this repository to your Raspberry Pi.
4. Navigate to the project directory and run `npm install` to install dependencies.
5. Ensure Python 3 is installed and install the RPi.GPIO library: `pip3 install RPi.GPIO`.
6. Connect your hardware components to the appropriate GPIO pins on the Raspberry Pi.
7. Start the application by running `npm start`.

## Usage

1. Access the MonsterBox interface by opening a web browser and navigating to `http://<raspberry-pi-ip>:3000`.
2. Create characters to represent your animatronic figures.
3. Add parts to your characters, configuring them with the appropriate GPIO pins.
4. Create scenes by adding a series of steps that control your parts.
5. Use the scene player to test and run your scenes.

## Contributing

Contributions to MonsterBox are welcome! Please feel free to submit pull requests or create issues for bugs and feature requests.

## License

This project is licensed under the MIT License.

## Acknowledgments

Created by ARW (8.15.2024)

Special thanks to the Raspberry Pi Foundation and the open-source community for providing the tools and libraries that make this project possible.
```

This updated README now includes information about the specific hardware components that MonsterBox is designed to work with, as well as more detailed setup instructions. It provides a comprehensive overview of both the software and hardware aspects of the project.
