<!-- Previous content remains the same until the voice settings script -->

<script>
    // Voice configuration modal functionality
    document.addEventListener('DOMContentLoaded', async function() {
        const modal = document.getElementById('voiceModal');
        const configureBtn = document.getElementById('configureVoice');
        const closeBtn = document.getElementsByClassName('close')[0];
        let wavesurfer = null;
        let currentCharacterId = document.querySelector('input[name="id"]')?.value;

        // Load voice settings for the character
        async function loadVoiceSettings() {
            if (currentCharacterId) {
                try {
                    const response = await fetch(`/api/voice/settings/${currentCharacterId}`);
                    if (response.ok) {
                        const voiceSettings = await response.json();
                        if (voiceSettings) {
                            // Update UI with saved settings
                            document.getElementById('voiceSelect').value = voiceSettings.speaker_id;
                            document.getElementById('languageSelect').value = voiceSettings.settings.languageCode;
                            document.getElementById('styleSelect').value = voiceSettings.settings.style;
                            document.getElementById('pitch').value = voiceSettings.settings.pitch;
                            document.getElementById('pitchValue').textContent = voiceSettings.settings.pitch;
                            document.getElementById('speed').value = voiceSettings.settings.speed;
                            document.getElementById('speedValue').textContent = voiceSettings.settings.speed + 'x';
                            document.getElementById('volume').value = voiceSettings.settings.volume;
                            document.getElementById('volumeValue').textContent = voiceSettings.settings.volume + ' dB';
                            document.getElementById('sampleRate').value = voiceSettings.settings.sampleRate;
                            document.getElementById('bitRate').value = voiceSettings.settings.bitRate;
                            document.getElementById('outputFormat').value = voiceSettings.settings.outputFormat;
                        }
                    }
                } catch (error) {
                    console.error('Error loading voice settings:', error);
                }
            }
        }

        // Initialize WaveSurfer only after user interaction
        async function initWaveSurfer() {
            if (!wavesurfer) {
                wavesurfer = WaveSurfer.create({
                    container: '#waveform',
                    waveColor: '#4a9eff',
                    progressColor: '#1976d2',
                    height: 60,
                    responsive: true,
                    barWidth: 2,
                    barGap: 1
                });
            }
            return wavesurfer;
        }

        // Save voice settings
        async function saveVoiceSettings() {
            if (!currentCharacterId) return;

            const settings = {
                characterId: currentCharacterId,
                speaker_id: document.getElementById('voiceSelect').value,
                settings: {
                    languageCode: document.getElementById('languageSelect').value,
                    style: document.getElementById('styleSelect').value,
                    pitch: parseInt(document.getElementById('pitch').value),
                    speed: parseFloat(document.getElementById('speed').value),
                    volume: parseInt(document.getElementById('volume').value),
                    sampleRate: parseInt(document.getElementById('sampleRate').value),
                    bitRate: parseInt(document.getElementById('bitRate').value),
                    outputFormat: document.getElementById('outputFormat').value
                }
            };

            try {
                const response = await fetch('/api/voice/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });

                if (!response.ok) throw new Error('Failed to save voice settings');
                alert('Voice settings saved successfully');
            } catch (error) {
                console.error('Error saving voice settings:', error);
                alert('Error saving voice settings: ' + error.message);
            }
        }

        // Save to sounds library
        async function saveToSounds(audioUrl) {
            try {
                const text = document.getElementById('testText').value;
                const response = await fetch('/api/voice/save-to-sounds', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        audioUrl,
                        text,
                        characterId: currentCharacterId
                    })
                });

                if (!response.ok) throw new Error('Failed to save to sounds library');
                alert('Sound saved to library successfully');
            } catch (error) {
                console.error('Error saving to sounds:', error);
                alert('Error saving to sounds: ' + error.message);
            }
        }

        // Voice settings controls
        const updateValue = (elementId, value, suffix = '') => {
            const element = document.getElementById(elementId + 'Value');
            if (element) {
                element.textContent = value + suffix;
            }
        };

        ['pitch', 'speed', 'volume'].forEach(param => {
            const element = document.getElementById(param);
            if (element) {
                element.oninput = () => {
                    updateValue(param, element.value, 
                        param === 'speed' ? 'x' : 
                        param === 'volume' ? ' dB' : '');
                    // Keep preview button enabled
                    document.getElementById('previewPlay').disabled = false;
                };
            }
        });

        // Initialize voice selection
        try {
            const response = await fetch('/api/voice/available');
            const voices = await response.json();
            console.log('Available voices:', voices);
            
            const voiceSelect = document.getElementById('voiceSelect');
            if (voiceSelect) {
                voiceSelect.innerHTML = '<option value="">Select a voice</option>';
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.uuid;
                    option.textContent = `${voice.name} (${voice.uuid})`;
                    voiceSelect.appendChild(option);
                });
            }

            // Load voice settings after voices are loaded
            await loadVoiceSettings();
        } catch (error) {
            console.error('Error loading voices:', error);
        }

        // Modal controls
        if (configureBtn) {
            configureBtn.onclick = function() {
                if (modal) {
                    modal.style.display = 'block';
                }
            };
        }

        if (closeBtn) {
            closeBtn.onclick = function() {
                if (modal) {
                    modal.style.display = 'none';
                }
            };
        }

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        };

        let lastGeneratedAudioUrl = null;

        // Audio preview controls
        const previewPlayBtn = document.getElementById('previewPlay');
        if (previewPlayBtn) {
            previewPlayBtn.onclick = async function() {
                const voiceSelect = document.getElementById('voiceSelect');
                if (!voiceSelect || !voiceSelect.value) {
                    alert('Please select a voice first');
                    return;
                }

                const voiceId = voiceSelect.value;
                console.log('Selected voice ID:', voiceId);

                // Initialize WaveSurfer on first user interaction
                await initWaveSurfer();

                const testText = document.getElementById('testText');
                const settings = {
                    speaker_id: voiceId,
                    text: testText ? testText.value : 'Hello world',
                    modelId: 'vox_1_0', // Always use vox_1_0
                    pitch: parseInt(document.getElementById('pitch')?.value || 0),
                    speed: parseFloat(document.getElementById('speed')?.value || 1.0),
                    volume: parseInt(document.getElementById('volume')?.value || 0),
                    sampleRate: parseInt(document.getElementById('sampleRate')?.value || 44100),
                    bitRate: parseInt(document.getElementById('bitRate')?.value || 128),
                    outputFormat: document.getElementById('outputFormat')?.value || 'mp3',
                    languageCode: document.getElementById('languageSelect')?.value || 'en',
                    style: document.getElementById('styleSelect')?.value || 'neutral'
                };

                console.log('Sending speech generation request with settings:', settings);
                const loadingIndicator = document.getElementById('loadingIndicator');
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'block';
                }

                try {
                    const response = await fetch('/api/voice/generate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(settings)
                    });
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    console.log('Received response:', data);
                    lastGeneratedAudioUrl = data.url;
                    wavesurfer.load(data.url);
                    wavesurfer.on('ready', function() {
                        wavesurfer.play();
                    });
                } catch (error) {
                    console.error('Error generating speech:', error);
                    alert('Error generating speech preview: ' + error.message);
                } finally {
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                }
            };
        }

        const previewStopBtn = document.getElementById('previewStop');
        if (previewStopBtn) {
            previewStopBtn.onclick = function() {
                if (wavesurfer) {
                    wavesurfer.stop();
                }
            };
        }

        // Save voice settings button
        document.getElementById('saveVoiceSettings').onclick = saveVoiceSettings;

        // Save to sounds button
        document.getElementById('saveToSounds').onclick = function() {
            if (lastGeneratedAudioUrl) {
                saveToSounds(lastGeneratedAudioUrl);
            } else {
                alert('Please generate audio first');
            }
        };

        // Form submission handling
        const form = document.querySelector('form');
        if (form) {
            form.onsubmit = function() {
                const selectedParts = document.getElementById('selected-parts-select');
                const selectedSounds = document.getElementById('selected-sounds-select');
                
                if (selectedParts) {
                    for (let option of selectedParts.options) {
                        option.selected = true;
                    }
                }
                
                if (selectedSounds) {
                    for (let option of selectedSounds.options) {
                        option.selected = true;
                    }
                }
                
                return true;
            };
        }

        // Initialize available options
        updateAvailableOptions();
    });
</script>
</body>
</html>
  b